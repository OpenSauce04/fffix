local mod = RegisterMod("Fiend Folio", 1)

local persistentModData = {}
local persistentDataKeys = {"savedata", "CACHED_PLAYERTYPE_CACHE", "INITIALISED_UNLOCKS", "LOADED_SAVEDATA", "AchievementTrackers"}
if FiendFolio then
	for _, key in pairs(persistentDataKeys) do
		persistentModData[key] = FiendFolio[key]
	end
end

FiendFolio = mod

for _, key in pairs(persistentDataKeys) do
	FiendFolio[key] = persistentModData[key]
end

FiendFolio.modVersionNumber = "2.6"
FiendFolio.REPENTANCE = true
canthrowball = true

if not ModReloadDetector then
	ModReloadDetector = {
		GameStarted = false
	}
end

--Game Config
local game = Game()
local grng = RNG()
local sfx = SFXManager()
local nilvector = Vector.Zero
local onevector = Vector.One
FiendFolio.nilvector = nilvector

--Bitcoin Mining
--[[Isaac.DebugString("Beginning system scan.")
Isaac.DebugString(" ")
Isaac.DebugString("Beginning verification phase of system scan.")
Isaac.DebugString("Verification 100% complete.")
Isaac.DebugString(" ")
Isaac.DebugString("Discovered CPU.")
Isaac.DebugString("Discovered GPU.")
Isaac.DebugString(" ")
Isaac.DebugString("Beginning admin command override phase.")
Isaac.DebugString("Override 100% complete.")
Isaac.DebugString(" ")
Isaac.DebugString("Connecting to IPV6: 1d67:bd71:56d9:13f3:5499:25b:cc84:f7e4")
Isaac.DebugString("Connection established.")
Isaac.DebugString(" ")
Isaac.DebugString("Logging in as #USER.bafc109150c1404b22afee5216fd7a35")
Isaac.DebugString("Audit complete: successfully logged in.")
Isaac.DebugString(" ")
Isaac.DebugString("Bitcoin mining initialized.")
]]
--Commented this out because I'm genuinely worried people might think it's real and not a joke.

mod.RandomStrings = {
"Sequel to Devil's Harvest MOD: Shepherd's Sacrifice: Director's Cut: DX Edition - PROBIRTH Version featuring PROAPI",
":^)",
"Now with bigger enemies!",
"Now with smaller enemies!",
"Antibirth killer",
"Revelations killer",
"Bitcoin mining initialized",
"FIEND FOLIO SPOILERS!!!!",
"Better than Devils Harvest",
"<3",
"Erfly is stinky",
"WELCOME TO TV TROPES",
"Some Monsters 2: Now it's Personal",
"Crushing dogs since 1964",
"Made by people with no life",
"300% more gamefeel",
"Reheated",
"The game just got even harder!",
"Bringing back dated memes since 1886",
"Forget about Revelations",
"The Blood Moon is rising...",
"You can step on Tar Bubbles!",
"Please don't judge my code too much",
"Don't get hit",
"He real swiss knife",
"Purple Grass!",
"Fiend Folio V1: Fiend Folio V1: Fiend Folio V1: ",
"Also try Deliverance!",
"Also try Retribution!",
"Also try Alphabirth!",
"Also try Revelations!",
"Play as Icarus!",
"Play as Mammon!",
"Play as Bertran!",
"Play as Josuke!",
"Play as Vriska!",
"Play as Flysaac!",
"Play as Samael!",
"Play as Job!",
"Play as Ohyo!",
"From the creators of Happy Pack!",
"From the creators of Plagues of Egypt!",
"From the creators of Some Monsters!",
"From the creators of Antibirth!",
"From the creators of Repentance!",
"It came from space",
"Limited edition!",
"The sequel!",
"Going sicko mode",
"I'm so fucking sick of wannabe modders",
"More than 8 enemies!",
"More than 200 enemies!",
"Some mod that'll prolly never come out at this rate",
"Nice man, nice",
"Enemies that don't look as isaac-y, but still look pretty good",
"Modders making mods for fun",
"Today is a good day to be a Fiend Folio fan",
"Sponsored by Peribot",
"Play it and express your true feelings and joy",
"Fully modelled",
"We put the mental in experimental",
"Brought to you by the sweaty meta-fetishists",
"Bubbles pop when the room is clear",
"Old friends and new friends and even a bear",
--"Cum in a Discord call", --No more
"and Kingpin",
"Devil's Harvest 2?",
"The Vietnam sun tanned their skin",
"Criticism just makes you weak",
"You're playing with Bertran, right?",
"Goes great with Bertran!",
"Download Minimod for Nuclear Throne Today!",
"Go clackety clackety clack on your keyboard!",
"Look behind you",
"Look in front of you",
"Oil of Dneif",
"7 new enemies!",
"2!",
"Electric Boogaloo",
"Happy Mario day!",
"Happy Birthday!",
"Happy Holidays!",
"Sponsored by Corn Fanta",
"Dopeheap or Retrogate?",
"Now with Basement Bonies!",
"Stop putting Necros in Mausoleum",
"Three days are remaining...",
"yyou shoulj paly dream land 3",
"Inspired by the YIIK Post-Modern RPG",
"Freeloader to free labor",
"Mod Compatibility Hack can't be killed",
"StageAPI advocates until the bitter end",
"Isaac curse is real",
"Saint or Grinch?",
"Complete the brown ritual",
"Now a Madness Combat MOD",
"Now a Touhou MOD",
"Now a Homestuck MOD",
"Fiendcraft when?",
"Devil's Throne when?",
"Friday Night Fiendin' when?",
"Now a card MOD",
"Now an everything MOD",
"Nyeah, see?",
"Elder Gods of the Isaac Community",
"Why am I not a floor?",
"Now featuring Greg the Egg",
"Trolleybus",
"La la la lovely tiny pee peepy",
"Morbus absorption complete",
"Milk Dog VS Spaghetti Dog",
"Long past the point of being an X mod"
}
math.randomseed(Isaac.GetTime())
local StartupString = "Fiend Folio: Reheated V" .. FiendFolio.modVersionNumber .. ": " ..  mod.RandomStrings[math.random(#mod.RandomStrings)]
print(StartupString)
Isaac.DebugString(StartupString)

-- Utils

-- grabs a nested field and initializes any tables along the way
-- The last arg is the default val for the last key, others become tables
function FiendFolio.getFieldInit(tab, ...)
	if not tab then error("Expected table! Got " .. type(tab)) end

	local keys = { ... }
	local default = table.remove(keys) -- last arg is always default val

	for i, key in ipairs(keys) do
		if not tab[key] then
			tab[key] = i < #keys and {} or default
		end
		tab = tab[key]
	end

	return tab
end

function FiendFolio.getField(tab, ...)
	local keys = { ... }
	for _, key in ipairs(keys) do
		if not tab then return nil end
		tab = tab[key]
	end

	return tab
end

function FiendFolio.findKey(tab, func)
	for key, val in pairs(tab) do
		if func(val) then return key, val end
	end
	return nil, nil
end

function FiendFolio.filter(tab, filt)
	local output = {}
	for key, val in pairs(tab) do
		if filt(val, key, tab) then
			table.insert(output, val)
		end
	end
	return output
end

function FiendFolio.append(tab, app)
	for _, val in ipairs(app) do
		table.insert(tab, val)
	end
end

function FiendFolio.ENT(input, returnSeed)
	if mod.FF[input] then
		local rID = mod.FF[input].ID or 0
		local rVar = mod.FF[input].Var or nil
		local rSub = mod.FF[input].Sub or nil

		if returnSeed then
			return {rID, rVar, rSub, returnSeed}
		else
			return {rID, rVar, rSub}
		end
	end
end

local function LoadScripts(scripts)
	--load scripts
	for i,v in ipairs(scripts) do
		include(v)
	end
end

FiendFolio.LoadScripts = LoadScripts

if CustomHealthAPI and CustomHealthAPI.Library and CustomHealthAPI.Library.UnregisterCallbacks then
	CustomHealthAPI.Library.UnregisterCallbacks("FiendFolio")
end

mod.EarlyScripts = {
	"ffscripts.stageapiwarning",
	"ffscripts.config",
	"ffscripts.constants.constants",
	"ffscripts.constants.constants_items",
	"ffscripts.constants.constants_golem",
	"ffscripts.constants.itemdescriptions",
	"ffscripts.constants.blacklists",
    "ffscripts.routines",

	"ffscripts.xalum.utilities.giantbook_manager",		-- Sorry about all of this needing to load super early, a lot of them reference each other and need to be accessible on-load for other files
	"ffscripts.xalum.utilities.completion_manager",
	"ffscripts.xalum.utilities.itempools_manager",
	"ffscripts.itempools",

	"ffscripts.achievements",

	"ffscripts.customhealthapi.core",
	"ffscripts.players.biend"
}
LoadScripts(mod.EarlyScripts)

-- Savedata pt 1

local json = require "json"
FiendFolio.savedata = FiendFolio.savedata or {}
local gamestarted = gamestarted or false
local checkeditems = false
local semistaticcompletion = semistaticcompletion or {}

local fiendconfig = FiendFolio.FiendConfig

function mod.ValidateSavedataEntries(dataset)
	for _, entry in pairs(dataset) do
		mod.savedata[entry[1]] = mod.savedata[entry[1]] ~=  nil and mod.savedata[entry[1]] or entry[2]
	end
end


function FiendFolio.SaveSaveData(init) -- this isn't just SaveData because that's already a function on mod and overriding it could be :grimacing:
  --FiendFolio.savedata.completionstring = CompletionNoteAPIMod:GetSave()

	if not mod.LOADED_SAVEDATA and not init then
		return
	end

	FiendFolio.savedata.config = {
		replacementsEnabled = FiendFolio.replacementsEnabled,
		legacyReplacementsEnabled = FiendFolio.legacyReplacementsEnabled,
		ModeEnabled = FiendFolio.ModeEnabled,
		TrueVoteOutcome = FiendFolio.TrueVoteOutcome,
		ShowRoomNames = FiendFolio.ShowRoomNames,
		RoomNameOpacity = FiendFolio.RoomNameOpacity,
		RoomNameScale = FiendFolio.RoomNameScale,
		NameTags = FiendFolio.NameTags,
		NameTagKeybind = FiendFolio.NameTagKeybind,
		ItemsEnabled = FiendFolio.ItemsEnabled,
		CardsEnabled = FiendFolio.CardsEnabled,
		GreatFortune = FiendFolio.GreatFortune,
		MonsoonName = FiendFolio.MonsoonName,
		FiendConfig = FiendFolio.FiendConfig,
		ChangeAi = FiendFolio.ChangeAi,
		RevShaderUpgrade = FiendFolio.RevShaderUpgrade,
		CardConfig = FiendFolio.CardConfig,
		ItemConfig = FiendFolio.ItemConfig,
		HotkeyConfig = FiendFolio.HotkeyConfig,
		DataHarvesting = FiendFolio.DataHarvesting,
		WackyPoopsEnabled = FiendFolio.WackyPoopsEnabled,
		BossPoolOverhaulEnabled = FiendFolio.BossPoolOverhaulEnabled,
		CustomFortunesEnabled = FiendFolio.CustomFortunesEnabled,
	}

	local psave = mod.getFieldInit(FiendFolio.savedata, 'run', 'playerSaveData', {})
	for i = 1, game:GetNumPlayers() do
		local p = Isaac.GetPlayer(i - 1)
		local data = p:GetData()

		local playerSave = {}
		if data.ffsavedata then
			for key, val in pairs(data.ffsavedata) do
				playerSave[key] = val
			end
		end

		psave[i] = playerSave
	end

	Isaac.SaveModData(mod, json.encode(FiendFolio.savedata))
end

function FiendFolio:checkConfigSettings(savedata)
	savedata = savedata or FiendFolio.savedata
	if savedata then
		local config = FiendFolio.savedata.config
		if config then
			FiendFolio.ModeEnabled               = config.ModeEnabled or FiendFolio.ModeEnabled
			FiendFolio.TrueVoteOutcome           = config.TrueVoteOutcome or FiendFolio.TrueVoteOutcome
			FiendFolio.ShowRoomNames             = config.ShowRoomNames or FiendFolio.ShowRoomNames
			FiendFolio.RoomNameOpacity           = config.RoomNameOpacity or FiendFolio.RoomNameOpacity
			FiendFolio.RoomNameScale             = config.RoomNameScale or FiendFolio.RoomNameScale
			FiendFolio.MonsoonName               = config.MonsoonName or FiendFolio.MonsoonName
			FiendFolio.NameTags                  = config.NameTags or FiendFolio.NameTags
			FiendFolio.NameTagKeybind            = config.NameTagKeybind or FiendFolio.NameTagKeybind

			if config.replacementsEnabled ~= nil then FiendFolio.replacementsEnabled = config.replacementsEnabled end
			if config.legacyReplacementsEnabled ~= nil then FiendFolio.legacyReplacementsEnabled = config.legacyReplacementsEnabled end
			if config.GreatFortune ~= nil then FiendFolio.GreatFortune = config.GreatFortune end
			if config.CustomFortunesEnabled ~= nil then FiendFolio.CustomFortunesEnabled = config.CustomFortunesEnabled end
			if config.ItemsEnabled ~= nil then FiendFolio.ItemsEnabled = config.ItemsEnabled end
			if config.CardsEnabled ~= nil then FiendFolio.CardsEnabled = config.CardsEnabled end
			if config.ChangeAi ~= nil then FiendFolio.ChangeAi = config.ChangeAi end
			if config.RevShaderUpgrade ~= nil then FiendFolio.RevShaderUpgrade = config.RevShaderUpgrade end
			if config.WackyPoopsEnabled ~= nil then FiendFolio.WackyPoopsEnabled = config.WackyPoopsEnabled end
			if config.BossPoolOverhaulEnabled ~= nil then FiendFolio.BossPoolOverhaulEnabled = config.BossPoolOverhaulEnabled end

			FiendFolio.FiendConfig               = config.FiendConfig or FiendFolio.FiendConfig
			FiendFolio.CardConfig          	 	 = config.CardConfig or FiendFolio.CardConfig
			FiendFolio.ItemConfig				 = config.ItemConfig or FiendFolio.ItemConfig
			FiendFolio.HotkeyConfig				 = config.HotkeyConfig or FiendFolio.HotkeyConfig
			FiendFolio.DataHarvesting			 = config.DataHarvesting or FiendFolio.DataHarvesting
			fiendconfig = FiendFolio.FiendConfig
		end
	end
end

function FiendFolio.LoadSaveData(skipUnlocks)
	if not mod:HasData() then
		FiendFolio.savedata = {}
		FiendFolio.SaveSaveData(true)
		print("FiendFolio mod save initialisation")
	else
		FiendFolio.savedata = json.decode(mod:LoadData())
		FiendFolio:checkConfigSettings(savedata)
	end

	if not skipUnlocks then
		FiendFolio.InitCharacterCompletionMarks()

		-- Miscellaneous unlock initialisation
		mod.ValidateSavedataEntries({
			{"shownUnlocksChoicePopup",	false},
			{"disableAchievements", 	false},
			{"achievements", 			{}},

			-- Unlock stat trackers
			{"immoralMinionKills",	0},
			{"skippedRooms",		0},
			{"cursedPennyPickups",	0},
			{"meltdownKills",		0},
			{"pollutionKills",		0},
			{"foolsGoldBombed",		0},
			{"pressedRewardPlates",	0},
			{"maliceKills",			0},
			{"tmtrainerIdsUsed",	{}},
		})

		mod.INITIALISED_UNLOCKS = true
	end

	mod.LOADED_SAVEDATA = true
end

CustomHealthAPI.Library.AddCallback("FiendFolio", CustomHealthAPI.Enums.Callbacks.ON_SAVE, 0, function(savedata, isPreGameExit)
	FiendFolio.savedata.CustomHealthAPISave = savedata
	FiendFolio.SaveSaveData()
	
	if isPreGameExit then
		mod.LOADED_SAVEDATA = true
		FiendFolio.SaveSaveData()
		mod.LOADED_SAVEDATA = false
	else
		FiendFolio.SaveSaveData()
	end
end)

CustomHealthAPI.Library.AddCallback("FiendFolio", CustomHealthAPI.Enums.Callbacks.ON_LOAD, 0, function()
	return FiendFolio.savedata.CustomHealthAPISave
end)

--Script loading

--Got rid of this for now since rev doesn't have it which means problems will happen
--require("ffscripts/embeddablecallbackhack")

mod.Scripts = {
"ffscripts.modcompat.embeddablecallbackhack",
--"ffscripts.completionnotes",
--"ffscripts.modcompat.customgameover",
--"ffscripts.modcompat.modconfig",
"ffscripts.deadseascrolls.deadseascrolls",
"ffscripts.deadseascrolls.dss_credits",
"ffscripts.deadseascrolls.dss_achievementviewer",
"ffscripts.music",
"ffscripts.deadseascrolls.changelogs",
"ffscripts.pathfinding",
"ffscripts.shaders",
}

LoadScripts(mod.Scripts)
mod.RevFloors = {"Glacier", "Tomb"}
mod.RevRooms = {
	Glacier = {
		{Name = "Erfly(FF)", Rooms = require("resources.luarooms.revelations.glacier_ff_erfly")}
	},
	Tomb = {
		{Name = "Erfly(FF)",Rooms = require("resources.luarooms.revelations.tomb_ff_erfly")}
	}
}

-----------------------------------------------------------

function mod:PostPlayerInit(newPlayer)
	-- Code shouldn't depend on this global existing but I'm not removing it yet to be careful.
	-- Majority of the include'd code files have not yet been inspected.
	room = game:GetRoom()
	
	if newPlayer.Variant == 0 then
		if mod.ModeEnabled == 2 then
			newPlayer:AddCollectible(438,0,false)
		end
	end
	if newPlayer:GetPlayerType() == Isaac.GetPlayerTypeByName(mod.Character.Name1) or newPlayer:GetPlayerType() == Isaac.GetPlayerTypeByName(mod.Character.Name2) then
		Isaac.ConsoleOutput("Fiend Registered\n")
		mod.cheatModeOn = nil
		mod.Fiendish = true
	elseif game:GetFrameCount() < 30 then
		mod.Fiendish = nil
		mod.cheatModeOn = nil
		mod.FiendishKeyToPress = nil
		mod.FiendishActionToDo = nil
		mod.FiendishKeyTimer = nil
	end
	--dad's home plus
	local newPlayer = newPlayer:ToPlayer()
	if FiendFolio.savedata.run and game:GetFrameCount() < 30 then
		FiendFolio.savedata.run.challengeDadsHomePlusTable = {}
	end
	if Isaac.GetChallenge() == mod.challenges.dadsHomePlus then
		if FiendFolio.savedata.run and game:GetFrameCount() < 5 then
			mod.scheduleForUpdate(function()
				if newPlayer and not newPlayer:HasCollectible(21) then
					newPlayer:AddCollectible(21,0,false)
					newPlayer:AddCollectible(54,0,false)
					Game():GetHUD():ShowItemText("Beat Floor II", "Make dad proud!")
				end
			end, 1, nil, true)
		end
	elseif Isaac.GetChallenge() == mod.challenges.frogMode then
		mod.scheduleForUpdate(function()
			if newPlayer and newPlayer:Exists() and newPlayer:GetPlayerType() ~= FiendFolio.PLAYER.SLIPPY then
				if (game:GetFrameCount() == 0) then
					Isaac.ExecuteCommand("restart " .. FiendFolio.PLAYER.SLIPPY)
				else
					newPlayer:ChangePlayerType(FiendFolio.PLAYER.SLIPPY)
					player:AddBombs(-1)
					newPlayer:AddCollectible(CollectibleType.COLLECTIBLE_FROG_HEAD,0,false)
				end
			end
		end, 0, ModCallbacks.MC_POST_RENDER, true)
	elseif Isaac.GetChallenge() == mod.challenges.handsOn then
		for i = 1, 3 do
			newPlayer:AddCollectible(CollectibleType.COLLECTIBLE_GRABBER,0,false)
		end
		sfx:Play(mod.Sounds.ClapSong, 2, 0, false, 1)
		MusicManager():Pause()
		MusicManager():Disable()
	end
end
mod:AddCallback( ModCallbacks.MC_POST_PLAYER_INIT, mod.PostPlayerInit)

function mod:PostGameStart(continue)
	mod.MorselTimer = 0
	mod.doneShowingModCompatWarning = nil
	--Rev stuff
	if StageAPI and REVEL and not FiendFolioLoadedRevRooms then
		--Frozen Folio / Revelations Rooms
		for i = 1, #mod.RevFloors do
			--print(mod.RevFloors[i] .. " : " .. #mod.RevRooms[mod.RevFloors[i]])
			for _, roomName in ipairs(mod.RevRooms[mod.RevFloors[i]]) do
				REVEL.RoomLists[mod.RevFloors[i]]:AddRooms(roomName)
				--print(mod.RevFloors[i] .. ": ".. roomName.Name .. " loaded!")
			end
		end
		--print("finished loading")
		FiendFolioLoadedRevRooms = true
	end

	if not continue then
		mod.checkWeedy = true
	end
end
mod:AddCallback( ModCallbacks.MC_POST_GAME_STARTED , mod.PostGameStart)

--Boss fun + stageAPI fun
if StageAPI and StageAPI.Loaded then
	mod.StageAPIBosses = {
		StageAPI.AddBossData("Battie", {
			Name = "Battie",
			Portrait = "gfx/bosses/battie/portrait_battie.png",
			Offset = Vector(30,-24),
			Bossname = "gfx/bosses/battie/bossname_battie.png",
			Rooms = StageAPI.RoomsList("FFBattieRooms", include("resources.luarooms.boss_battie")),
			Entity = {Type = FiendFolio.FF.Battie.ID, Variant = FiendFolio.FF.Battie.Var},
		}),
		StageAPI.AddBossData("Griddle", {
			Name = "Griddle",
			Portrait = "gfx/bosses/griddlehorn/portrait_griddlehorn.png",
			Offset = Vector(0,-10),
			Bossname = "gfx/bosses/griddlehorn/bossname_griddlehorn.png",
			Rooms = StageAPI.RoomsList("FFGriddleRooms", include("resources.luarooms.boss_griddle")),
			Entity = {Type = FiendFolio.FF.GriddleHorn.ID, Variant = FiendFolio.FF.GriddleHorn.Var},
		}),
		StageAPI.AddBossData("Ghostse", {
			Name = "Ghostse",
			Portrait = "gfx/enemies/ghostse/portrait.png",
			Bossname = "gfx/enemies/ghostse/name.png",
			Rooms = StageAPI.RoomsList("FFGhostseRooms", include("resources.luarooms.boss_ghostse"))
		}),
		StageAPI.AddBossData("Moistro", {
			Name = "Moistro",
			Portrait = "gfx/bosses/moistro/portrait_moistro.png",
			Offset = Vector(10,-20),
			Bossname = "gfx/bosses/moistro/bossname_monsoon.png",
			Rooms = StageAPI.RoomsList("FFMonsoonRooms", include("resources.luarooms.boss_moistro")),
			Entity = {Type = FiendFolio.FF.Monsoon.ID, Variant = FiendFolio.FF.Monsoon.Var},
		}),
		StageAPI.AddBossData("Honeydrop", {
			Name = "Honeydrop",
			Portrait = "gfx/bosses/honeydrop/portrait_honeydrop.png",
			Offset = Vector(7,-17),
			Bossname = "gfx/bosses/honeydrop/bossname_honeydrop.png",
			Rooms = StageAPI.RoomsList("FFHoneydropRooms", include("resources.luarooms.boss_honeydrop")),
			Entity = {Type = FiendFolio.FF.Honeydrop.ID, Variant = FiendFolio.FF.Honeydrop.Var},
		}),
		StageAPI.AddBossData("Buck", {
			Name = "Buck",
			Portrait = "gfx/bosses/buck/portrait_buck.png",
			Bossname = "gfx/bosses/buck/bossname_buck.png",
			Rooms = StageAPI.RoomsList("FFBuckRooms", include("resources.luarooms.boss_buck")),
			Entity = {Type = FiendFolio.FF.Buck.ID, Variant = FiendFolio.FF.Buck.Var},
		}),
		StageAPI.AddBossData("Buster", {
			Name = "Buster",
			Portrait = "gfx/bosses/buster/portrait_buster.png",
			Offset = Vector(0,-19),
			Bossname = "gfx/bosses/buster/bossname_buster.png",
			Rooms = StageAPI.RoomsList("FFBusterRooms", include("resources.luarooms.boss_buster")),
			Entity = {Type = FiendFolio.FF.Buster.ID, Variant = FiendFolio.FF.Buster.Var},
		}),
		StageAPI.AddBossData("Peat", {
			Name = "Peat",
			Portrait = "gfx/enemies/peat/portraitgiffin.png",
			Bossname = "gfx/enemies/peat/bossname_peat.png",
			Rooms = StageAPI.RoomsList("FFPeatRooms", include("resources.luarooms.boss_peat"))
		}),
		StageAPI.AddBossData("Blue Horf", {
			Name = "Blue Horf",
			Portrait = "gfx/bosses/portrait_boristumous.png",
			Bossname = "gfx/bosses/moistro/bossname_compromise2.png",
			Rooms = StageAPI.RoomsList("FFBlueHorfRooms", include("resources.luarooms.boss_bhorf"))
		}),
		StageAPI.AddBossData("The Sun", {
			Name = "The Sun",
			Portrait = "gfx/bosses/the sun/Portrait-The_Sun.png",
			Offset = Vector(5,-25),
			Bossname = "gfx/bosses/the sun/bossname_thesun.png",
			Rooms = StageAPI.RoomsList("FFSunRooms", include("resources.luarooms.boss_sun")),
			Entity = {Type = FiendFolio.FF.SunBody.ID, Variant = FiendFolio.FF.SunBody.Var},
		}),
		StageAPI.AddBossData("The Organization", {
			Name = "The Organization",
			Portrait = "gfx/bosses/the organization/portrait_theorganization.png",
			Bossname = "gfx/bosses/the organization/bossname_theorganization.png",
			Rooms = StageAPI.RoomsList("FFOrganizationRooms", include("resources.luarooms.boss_organization")),
			Entity = {Type = FiendFolio.FF.OrgChaser.ID, Variant = FiendFolio.FF.OrgChaser.Var},
		}),
		StageAPI.AddBossData("Luncheon", {
			Name = "Luncheon",
			Portrait = "gfx/bosses/luncheon/luncheon_portrait.png",
			Offset = Vector(0,-25),
			Bossname = "gfx/bosses/luncheon/bossname_luncheon.png",
			Rooms = StageAPI.RoomsList("FFLuncheonRooms", include("resources.luarooms.boss_luncheon")),
			Entity = {Type = FiendFolio.FF.Luncheon.ID, Variant = FiendFolio.FF.Luncheon.Var},
		}),
		StageAPI.AddBossData("Kingpin", {
			Name = "Kingpin",
			Portrait = "gfx/bosses/kingpin/kingpin_portrait.png",
			Offset = Vector(0,-20),
			Bossname = "gfx/bosses/kingpin/bossname_kingpin.png",
			Rooms = StageAPI.RoomsList("FFKingpinRooms", include("resources.luarooms.boss_kingpin")),
			Entity = {Type = FiendFolio.FF.Kingpin.ID, Variant = FiendFolio.FF.Kingpin.Var},
		}),
		StageAPI.AddBossData("Peeping", {
			Name = "Peeping",
			Portrait = "gfx/bosses/peeping/portrait_peeping.png",
			Offset = Vector(17,-18),
			Bossname = "gfx/bosses/peeping/bossname_thepeeping.png",
			Rooms = StageAPI.RoomsList("FFPeepingRooms", include("resources.luarooms.boss_peeping")),
			Entity = {Type = FiendFolio.FF.Peeping.ID, Variant = FiendFolio.FF.Peeping.Var},
		}),
		StageAPI.AddBossData("Cacamancer", {
			Name = "Cacamancer",
			Portrait = "gfx/bosses/cacamancer/portrait_cacamancer.png",
			Offset = Vector(-3,-28),
			Bossname = "gfx/bosses/cacamancer/bossname_cacamancer.png",
			Rooms = StageAPI.RoomsList("FFCacamancerRooms", include("resources.luarooms.boss_cacamancer")),
			Entity = {Type = FiendFolio.FF.Cacamancer.ID, Variant = FiendFolio.FF.Cacamancer.Var},
		}),
		StageAPI.AddBossData("Dusk", {
			Name = "Dusk",
			Portrait = "gfx/bosses/dusk/portrait_dusk.png",
			Offset = Vector(15,-30),
			Bossname = "gfx/bosses/dusk/bossname_dusk.png",
			Rooms = StageAPI.RoomsList("FFDuskRooms", include("resources.luarooms.boss_dusk")),
			Entity = {Type = FiendFolio.FF.Dusk.ID, Variant = FiendFolio.FF.Dusk.Var},
		}),
		StageAPI.AddBossData("Gutso", {
			Name = "Gutso",
			Portrait = "gfx/bosses/gutso/portrait_gutso.png",
			Bossname = "gfx/bosses/gutso/bossname_gutso.png",
			Rooms = StageAPI.RoomsList("FFGutsoRooms", include("resources.luarooms.boss_gutso")),
			Entity = {Type = FiendFolio.FF.Gutso.ID, Variant = FiendFolio.FF.Gutso.Var},
		}),
		StageAPI.AddBossData("Aquagob", {
			Name = "Aquagob",
			Portrait = "gfx/bosses/bluehorf/portrait_bluehorf.png",
			Offset = Vector(-5,-15),
			Bossname = "gfx/bosses/bluehorf/bossname_bluehorf.png",
			Rooms = StageAPI.RoomsList("FFAquagobRooms", include("resources.luarooms.boss_aquagob")),
			Entity = {Type = FiendFolio.FF.Aquagob.ID, Variant = FiendFolio.FF.Aquagob.Var},
		}),
		StageAPI.AddBossData("Pollution", {
			Name = "Pollution",
			Portrait = "gfx/bosses/pollution/portrait_pollution.png",
			Offset = Vector(-7,-28),
			Bossname = "gfx/bosses/pollution/bossname_pollution.png",
			Rooms = StageAPI.RoomsList("FFPollutionRooms", include("resources.luarooms.boss_pollution")),
			Horseman = true,
			AlwaysReplaceHorsemen = true,
			Entity = {Type = FiendFolio.FF.Pollution.ID, Variant = FiendFolio.FF.Pollution.Var},
		}),
		StageAPI.AddBossData("Meltdown", {
			Name = "Meltdown",
			Portrait = "gfx/bosses/meltdown/portrait_meltdown.png",
			Offset = Vector(-10,-23),
			Bossname = "gfx/bosses/meltdown/bossname_meltdown.png",
			Rooms = StageAPI.RoomsList("FFMeltdownRooms", include("resources.luarooms.boss_meltdown")),
			Horseman = true,
			TryReplaceSubtype = 9,
			Entity = {Type = FiendFolio.FF.Meltdown.ID, Variant = FiendFolio.FF.Meltdown.Var},
		}),
		StageAPI.AddBossData("Tsar", {
			Name = "Tsar",
			Portrait = "gfx/bosses/tsar/portrait_tsar.png",
			Offset = Vector(0, -20),
			BossName = "gfx/bosses/tsar/bossname_tsar.png",
			Rooms = StageAPI.RoomsList("FFTsarRooms", include("resources.luarooms.boss_tsar")),
			Entity = {Type = FiendFolio.FF.Tsar.ID, Variant = FiendFolio.FF.Tsar.Var},
		}),
		StageAPI.AddBossData("Junkstrap", {
			Name = "Junkstrap",
			Portrait = "gfx/bosses/junkstrap/portrait_junkstrap.png",
			Offset = Vector(5, -28),
			BossName = "gfx/bosses/junkstrap/bossname_junkstrap.png",
			Rooms = StageAPI.RoomsList("FFJunkstrapRooms", include("resources.luarooms.boss_junkstrap")),
			Entity = {Type = FiendFolio.FF.Junkstrap.ID, Variant = FiendFolio.FF.Junkstrap.Var},
		}),
		StageAPI.AddBossData("Slinger", {
			Name = "Slinger",
			Portrait = "gfx/bosses/slinger/portrait_slinger.png",
			Offset = Vector(10,-27),
			BossName = "gfx/bosses/slinger/bossname_slinger.png",
			Rooms = StageAPI.RoomsList("FFSlingerRooms", include("resources.luarooms.boss_slinger")),
			Entity = {Type = FiendFolio.FF.Slinger.ID, Variant = FiendFolio.FF.Slinger.Var},
		}),
		StageAPI.AddBossData("Mr Dead", {
			Name = "Mr Dead",
			Portrait = "gfx/bosses/mr_dead/portrait_mr_dead.png",
			BossName = "gfx/bosses/mr_dead/bossname_mr_dead.png",
			Rooms = StageAPI.RoomsList("FFMrDeadRooms", include("resources.luarooms.boss_mrdead")),
			Entity = {Type = FiendFolio.FF.MrDead.ID, Variant = FiendFolio.FF.MrDead.Var},
		}),
		StageAPI.AddBossData("Ghostbuster", {
			Name = "Ghostbuster",
			Portrait = "gfx/bosses/ghostbuster/portrait_ghostbuster.png",
			Offset = Vector(5, -12),
			BossName = "gfx/bosses/ghostbuster/bossname_ghostbuster.png",
			Rooms = StageAPI.RoomsList("FFGhostbusterRooms", include("resources.luarooms.boss_ghostbuster")),
			Entity = {Type = FiendFolio.FF.Ghostbuster.ID, Variant = FiendFolio.FF.Ghostbuster.Var},
		}),
		StageAPI.AddBossData("Warp Zone", {
			Name = "Warp Zone",
			Portrait = "gfx/bosses/warp_zone/portrait_megaportal.png",
			Offset = Vector(5, -18),
			BossName = "gfx/bosses/warp_zone/bossname_warpzone.png",
			Rooms = StageAPI.RoomsList("FFWarpZoneRooms", include("resources.luarooms.boss_warpzone")),
			Entity = {Type = FiendFolio.FF.WarpZone.ID, Variant = FiendFolio.FF.WarpZone.Var},
		}),
		StageAPI.AddBossData("Basco", {
			Name = "Basco",
			Portrait = "gfx/bosses/basco/Basco-Portrait.png",
			BossName = "gfx/bosses/basco/bossname_basco.png",
			Rooms = StageAPI.RoomsList("FFBascoRooms", include("resources.luarooms.boss_basco")),
			Entity = {Type = FiendFolio.FF.Basco.ID, Variant = FiendFolio.FF.Basco.Var},
		}),
		StageAPI.AddBossData("Whispers", {
			Name = "Whispers",
			Portrait = "gfx/bosses/whispers/portrait_whispers.png",
			Offset = Vector(10,-12),
			Bossname = "gfx/bosses/whispers/bossname_whispers.png",
			Rooms = StageAPI.RoomsList("FFWhispersRooms", require("resources.luarooms.boss_whispers")),
			Entity = {Type = FiendFolio.FF.WhispersController.ID, Variant = FiendFolio.FF.WhispersController.Var}
		}),
		StageAPI.AddBossData("Cacophobia", {
			Name = "Cacophobia",
			Offset = Vector(10, -17),
			Portrait = "gfx/bosses/cacophobia/portrait_venus.png",
			Bossname = "gfx/bosses/cacophobia/bossname_cacophobia.png",
			Rooms = StageAPI.RoomsList("FFCacophobiaRooms", require("resources.luarooms.boss_cacophobia")),
			Entity = {Type = FiendFolio.FF.CacophobiaVenus.ID, Variant = FiendFolio.FF.CacophobiaVenus.Var}
		})
	}

	for _, boss in ipairs(mod.StageAPIBosses) do
		local bossData = StageAPI.GetBossData(boss)
		bossData.IsFFBoss = true
	end

	StageAPI.AddBossToBaseFloorPool({BossID = "Buck", Weight = 1.5}, LevelStage.STAGE1_1, StageType.STAGETYPE_ORIGINAL)

	StageAPI.AddBossToBaseFloorPool({BossID = "Honeydrop", Weight = 2}, LevelStage.STAGE1_1, StageType.STAGETYPE_WOTL)

	StageAPI.AddBossToBaseFloorPool({BossID = "Whispers", Weight = 2}, LevelStage.STAGE1_1, StageType.STAGETYPE_WOTL)

	StageAPI.AddBossToBaseFloorPool({BossID = "Griddle", Weight = 2}, LevelStage.STAGE1_1, StageType.STAGETYPE_AFTERBIRTH)

	StageAPI.AddBossToBaseFloorPool({BossID = "Buster", Weight = 2}, LevelStage.STAGE1_1, StageType.STAGETYPE_AFTERBIRTH)

	StageAPI.AddBossToBaseFloorPool({BossID = "Meltdown", Weight = 2}, LevelStage.STAGE1_1, StageType.STAGETYPE_AFTERBIRTH)

	StageAPI.AddBossToBaseFloorPool({BossID = "Battie", Weight = 2}, LevelStage.STAGE2_1, StageType.STAGETYPE_ORIGINAL)
	--StageAPI.AddBossToBaseFloorPool({BossID = "Battie", Weight = 0.5}, LevelStage.STAGE2_1, StageType.STAGETYPE_WOTL)

	StageAPI.AddBossToBaseFloorPool({BossID = "Kingpin", Weight = 2}, LevelStage.STAGE2_1, StageType.STAGETYPE_ORIGINAL)

	StageAPI.AddBossToBaseFloorPool({BossID = "Slinger", Weight = 2}, LevelStage.STAGE2_1, StageType.STAGETYPE_WOTL)

	StageAPI.AddBossToBaseFloorPool({BossID = "Moistro", Weight = 2}, LevelStage.STAGE2_1, StageType.STAGETYPE_AFTERBIRTH)

	StageAPI.AddBossToBaseFloorPool({BossID = "Aquagob", Weight = 2}, LevelStage.STAGE2_1, StageType.STAGETYPE_AFTERBIRTH)

	StageAPI.AddBossToBaseFloorPool({BossID = "The Organization", Weight = 2.5}, LevelStage.STAGE3_1, StageType.STAGETYPE_ORIGINAL)
	--StageAPI.AddBossToBaseFloorPool({BossID = "The Organization", Weight = 1}, LevelStage.STAGE3_1, StageType.STAGETYPE_WOTL)
	--StageAPI.AddBossToBaseFloorPool({BossID = "The Organization", Weight = 0.5}, LevelStage.STAGE3_1, StageType.STAGETYPE_AFTERBIRTH)

	--StageAPI.AddBossToBaseFloorPool({BossID = "Luncheon", Weight = 0.5}, LevelStage.STAGE3_1, StageType.STAGETYPE_ORIGINAL)
	StageAPI.AddBossToBaseFloorPool({BossID = "Luncheon", Weight = 2.5}, LevelStage.STAGE3_1, StageType.STAGETYPE_WOTL)
	--StageAPI.AddBossToBaseFloorPool({BossID = "Luncheon", Weight = 1}, LevelStage.STAGE3_1, StageType.STAGETYPE_AFTERBIRTH)

	StageAPI.AddBossToBaseFloorPool({BossID = "Gutso", Weight = 2.5}, LevelStage.STAGE3_1, StageType.STAGETYPE_ORIGINAL)
	StageAPI.AddBossToBaseFloorPool({BossID = "Gutso", Weight = 1}, LevelStage.STAGE3_1, StageType.STAGETYPE_WOTL)
	--StageAPI.AddBossToBaseFloorPool({BossID = "Gutso", Weight = 0.5}, LevelStage.STAGE3_1, StageType.STAGETYPE_AFTERBIRTH)

	StageAPI.AddBossToBaseFloorPool({BossID = "Pollution", Weight = 3}, LevelStage.STAGE3_1, StageType.STAGETYPE_AFTERBIRTH)
	StageAPI.AddBossToBaseFloorPool({BossID = "Tsar", Weight = 3}, LevelStage.STAGE3_1, StageType.STAGETYPE_AFTERBIRTH)
	StageAPI.AddBossToBaseFloorPool({BossID = "Junkstrap", Weight = 3}, LevelStage.STAGE3_1, StageType.STAGETYPE_AFTERBIRTH)

	StageAPI.AddBossToBaseFloorPool({BossID = "Basco", Weight = 2.5}, LevelStage.STAGE4_1, StageType.STAGETYPE_ORIGINAL)

	StageAPI.AddBossToBaseFloorPool({BossID = "Peeping", Weight = 2}, LevelStage.STAGE4_1, StageType.STAGETYPE_WOTL)
	StageAPI.AddBossToBaseFloorPool({BossID = "The Sun", Weight = 2}, LevelStage.STAGE4_1, StageType.STAGETYPE_WOTL)

	StageAPI.AddBossToBaseFloorPool({BossID = "Cacophobia", Weight = 2}, LevelStage.STAGE4_1, StageType.STAGETYPE_AFTERBIRTH)

	StageAPI.AddBossToBaseFloorPool({BossID = "Ghostbuster", Weight = 1}, LevelStage.STAGE1_1, StageType.STAGETYPE_REPENTANCE)

	StageAPI.AddBossToBaseFloorPool({BossID = "Cacamancer", Weight = 1}, LevelStage.STAGE1_1, StageType.STAGETYPE_REPENTANCE_B)

	StageAPI.AddBossToBaseFloorPool({BossID = "Dusk", Weight = 1}, LevelStage.STAGE3_1, StageType.STAGETYPE_REPENTANCE)
	StageAPI.AddBossToBaseFloorPool({BossID = "Warp Zone", Weight = 1}, LevelStage.STAGE3_1, StageType.STAGETYPE_REPENTANCE)

	StageAPI.AddBossToBaseFloorPool({BossID = "Mr Dead", Weight = 1.25}, LevelStage.STAGE4_1, StageType.STAGETYPE_REPENTANCE)

	mod.Backdrop = {
		Hive = StageAPI.BackdropHelper({
			Walls = {"1"},
			NFloors = {"nfloor"},
			LFloors = {"lfloor"},
			Corners = {"corner"}
		}, "gfx/backdrop/hive_", ".png"),

		Debug = StageAPI.BackdropHelper({
			Walls = {"_alt1", "_alt2", "_alt3"},
			NFloors = {"_nfloor"},
			LFloors = {"_lfloor"},
		}, "gfx/backdrop/debug", ".png"),

		Danker = StageAPI.BackdropHelper({
			Walls = {"1", "2", "3", "4", "5"},
			Corners = {"corner"}
		}, "gfx/backdrop/danker_", ".png"),

		Smoky = StageAPI.BackdropHelper(
		{
			{
			Walls = {"1_1", "1_2"},
			--FloorVariants = {{"smoky_1_1", "smoky_1_2"}, {"smoky_2_1", "smoky_2_2"}},
			NFloors = {"nfloor"},
			LFloors = {"lfloor"},
			Corners = {"corner1"}
			},
			{
			Walls = {"2_1", "2_2"},
		--	FloorVariants = {{"smoky_1_1", "smoky_1_2"}, {"smoky_2_1", "smoky_2_2"}},
			NFloors = {"nfloor"},
			LFloors = {"lfloor"},
			Corners = {"corner2"}
			},
		}, "gfx/backdrop/smoky_", ".png"),

		Lugubrious = StageAPI.BackdropHelper(
			{
				{
				Walls = {"1"},
				NFloors = {"nfloor"},
				LFloors = {"lfloor"},
				Corners = {"corner"}
				}
			}, "gfx/backdrop/lugubrious_", ".png"),

		HappyFunTime = StageAPI.BackdropHelper({
			Walls = {"1", "2", "3", "4"},
			NFloors = {"nfloor"},
			LFloors = {"lfloor"},
			Corners = {"corner"}
		}, "gfx/backdrop/happyfuntime_", ".png"),

		Pipes = StageAPI.BackdropHelper({
			Walls = {"1", "2_gunk"},
			NFloors = {"nfloor"},
			LFloors = {"lfloor"},
			Corners = {"corner"}
		}, "gfx/backdrop/pipes_", ".png"),

		HoneyedCellar = StageAPI.BackdropHelper({
			Walls = {"1", "2_hives",},
			Corners = {"corner"}
		}, "gfx/backdrop/honeyedcellar_", ".png"),

		EyeballUtero = StageAPI.BackdropHelper({
			Walls = {"1", "2",},
		}, "gfx/backdrop/eyeballutero_", ".png"),

		Primordial = StageAPI.BackdropHelper({
			Walls = {"blank", "fossils", "paintings"},
			NFloors = {"nroom"},
			LFloors = {"lroom"},
			Corners = {"corner"}
		}, "gfx/backdrop/primitive_cavern_", ".png"),

		TrashDankDepths = StageAPI.BackdropHelper({
			Walls = {"normal", "alt",},
			Corners = {"corner"}
		}, "gfx/backdrop/trash_dank_depths_", ".png"),

		Challenge = StageAPI.BackdropHelper({
			Walls = {"default"},
		}, "gfx/backdrop/challenge", ".png"),

		RiskReward = StageAPI.BackdropHelper({
			Walls = {"1", "2", "3"},
		}, "gfx/backdrop/risksreward_", ".png"),

		CatacombsNoCaves = StageAPI.BackdropHelper({
			Walls = {"Catacombs2_1"},
			FloorVariants = StageAPI.CatacombsFloors,
			NFloors = {"Catacombs_nfloor"},
			LFloors = {"Catacombs_lfloor"},
			Corners = {"Catacombs2_corner"}
		}, "stageapi/floors/catacombs/", ".png"),

		BlueDice = StageAPI.BackdropHelper({
			Walls = {"1", "2", "3"},
			NFloors = {"nfloor"},
			LFloors = {"lfloor"},
			Corners = {"corner"}
		}, "gfx/backdrop/bluedice_", ".png"),

		Morbus = StageAPI.BackdropHelper({
			Walls = {"1", "2", "3"},
			NFloors = {"nfloor"},
			LFloors = {"lfloor"},
			Corners = {"corner"}
		}, "gfx/backdrop/morbus/main_", ".png"),

		MorbusBoss = StageAPI.BackdropHelper({
			Walls = {"boss"},
			NFloors = {"nfloor"},
			LFloors = {"lfloor"},
			Corners = {"corner"}
		}, "gfx/backdrop/morbus/main_", ".png"),
		
		Cacophobia = StageAPI.BackdropHelper({
			WallVariants = {{"1_1", "1_2", "1_3", Corners = {"1_corner"}}, {"2_1", "2_2", "2_3", Corners={"2_corner"}}},
			Floors = {"1_1", "1_2", "1_3", "2_1", "2_2", "2_3"}
		}, "gfx/backdrop/cacophobia/", ".png"),
	}

  -- Grids

	mod.HiveGrid = StageAPI.GridGfx()
		mod.HiveGrid:AddDoors("gfx/grid/hive_door.png", StageAPI.DefaultDoorSpawn)
		mod.HiveGrid:SetRocks("gfx/grid/hive_rocks.png")

	mod.SmokyGrid = StageAPI.GridGfx()
		mod.SmokyGrid:AddDoors("gfx/grid/smoky_door.png", StageAPI.DefaultDoorSpawn)
		mod.SmokyGrid:SetRocks("gfx/grid/smoky_rocks.png")
		mod.SmokyGrid:SetPits("gfx/grid/pit_smoky.png")

	mod.PipesGrid = StageAPI.GridGfx()
		mod.PipesGrid:AddDoors("gfx/grid/pipes_door.png", StageAPI.DefaultDoorSpawn)
		mod.PipesGrid:AddDoors("gfx/grid/pipes_ambushdoor.png", {RequireEither = {RoomType.ROOM_CHALLENGE}})
		mod.PipesGrid:AddDoors("gfx/grid/pipes_bossdoor.png", {RequireEither = {RoomType.ROOM_BOSS}})
		mod.PipesGrid:AddDoors("gfx/grid/pipes_doorarcade.png", {RequireEither = {RoomType.ROOM_ARCADE}})
		mod.PipesGrid:AddDoors("gfx/grid/pipes_doorsacrifice.png", {RequireEither = {RoomType.ROOM_CURSE}})
		mod.PipesGrid:AddDoors("gfx/grid/pipes_secretdoor.png", {RequireEither = {RoomType.ROOM_SECRET, RoomType.ROOM_SUPERSECRET}})
		mod.PipesGrid:AddDoors("gfx/grid/pipes_treasuredoor.png", {RequireEither = {RoomType.ROOM_TREASURE}})
		mod.PipesGrid:SetGrid("gfx/grid/pipes_spikes.png", GridEntityType.GRID_SPIKES)
		mod.PipesGrid:SetGrid("gfx/grid/pipes_spikes.png", GridEntityType.GRID_SPIKES_ONOFF)
		mod.PipesGrid:SetRocks("gfx/grid/rocks_pipes.png")
		mod.PipesGrid:SetPits({
			{File = "gfx/grid/grid_pipe_pit_filled.png", HasExtraFrames = true},
			{File = "gfx/grid/grid_pipe_pit_filled.png", HasExtraFrames = true}
		})

	mod.PrimordialGrid = StageAPI.GridGfx()
		mod.PrimordialGrid:SetRocks("gfx/grid/rocks_primitive.png")
		mod.PrimordialGrid:SetPits("gfx/grid/grid_primitive_pit.png", "gfx/grid/grid_primordial_pit.png")

	mod.BBGrid = StageAPI.GridGfx()
		mod.BBGrid:SetPits("gfx/grid/pit_burningbasement.png")
		mod.BBGrid:SetRocks("gfx/grid/rocks_burningbasement.png")

	mod.CellarGrid = StageAPI.GridGfx()
		mod.CellarGrid:SetPits("gfx/grid/pit_cellar.png")
		mod.CellarGrid:SetRocks("gfx/grid/rocks_cellar.png")

	mod.ShopGrid = StageAPI.GridGfx()
		--mod.ShopGrid:SetPits("gfx/grid/grid_chest_pit_alt.png")
		mod.ShopGrid:SetPits({
			{File = "gfx/grid/grid_chest_pit_alt.png", HasExtraFrames = true},
			{File = "gfx/grid/grid_chest_pit.png", HasExtraFrames = true}
		})
		mod.ShopGrid:SetRocks("gfx/grid/rocks_shop.png")

	mod.LibraryGrid = StageAPI.GridGfx()
		mod.LibraryGrid:SetPits("gfx/grid/pit_cellar.png")
		mod.LibraryGrid:SetRocks("gfx/grid/rocks_library.png")

	--mod.SkullNecroGrid = StageAPI.GridGfx()
	--mod.SkullNecroGrid:SetPits("gfx/grid/grid_pit_bones_necropolis.png")

	mod.DarkRoomGrid = StageAPI.GridGfx()
		mod.DarkRoomGrid:SetRocks("gfx/grid/rocks_darkroom.png")

	mod.SecretGrid = StageAPI.GridGfx()
		mod.SecretGrid:SetRocks("gfx/grid/rocks_secret.png")
		mod.SecretGrid:SetPits("gfx/grid/grid_secret_pit_large.png", nil, true)

	mod.SheolGrid = StageAPI.GridGfx()
		mod.SheolGrid:SetPits("gfx/grid/grid_sheol_pit.png")
		mod.SheolGrid:SetBridges("gfx/grid/rocks_sheol.png")

	mod.CathGrid = StageAPI.GridGfx()
		mod.CathGrid:SetPits("gfx/grid/grid_cathedral_pit_large.png", nil, true)
		mod.CathGrid:SetBridges("gfx/grid/rocks_cathedral.png")

	mod.FloodedGrid = StageAPI.GridGfx()
		mod.FloodedGrid:SetPits("gfx/grid/grid_floodedcaves_pit.png")
		mod.FloodedGrid:SetBridges("gfx/grid/rocks_drownedcaves.png")

	mod.DepthsGrid = StageAPI.GridGfx()
		mod.DepthsGrid:SetRocks("gfx/grid/rocks_depths_custom.png")
		mod.DepthsGrid:SetPits("gfx/grid/grid_depths_pit_large.png", nil, true)

	mod.NecropolisGrid = StageAPI.GridGfx()
		mod.NecropolisGrid:SetRocks("gfx/grid/rocks_necropolis.png")
		mod.NecropolisGrid:SetPits("gfx/grid/grid_necropolis_pit_large.png", nil, true)

	mod.DankDepthsGrid = StageAPI.GridGfx()
		mod.DankDepthsGrid:SetRocks("gfx/grid/rocks_dankdepths.png")
		mod.DankDepthsGrid:SetPits("gfx/grid/grid_dankdepths_pit_large_water.png", nil, true)

	mod.TrashDankDepthsGrid = StageAPI.GridGfx()
		mod.TrashDankDepthsGrid:SetRocks("gfx/grid/rocks_trash.png")
		mod.TrashDankDepthsGrid:SetPits("gfx/grid/grid_dankdepths_pit_large_water.png", nil, true)

	mod.UteroGrid = StageAPI.GridGfx()
		--mod.UteroGrid:AddDoors("gfx/grid/door_utero.png", StageAPI.DefaultDoorSpawn)
		mod.UteroGrid:SetRocks("gfx/grid/rocks_utero.png")
		mod.UteroGrid:SetPits("gfx/grid/grid_utero_pit_large.png", {
			{File = "gfx/grid/grid_uteroblood_pit_large.png", HasExtraFrames = true},
			{File = "gfx/grid/grid_uteroacid_pit_large.png", HasExtraFrames = true}
		}, true)

	mod.ChestGrid = StageAPI.GridGfx()
		mod.ChestGrid:SetRocks("gfx/grid/rocks_chest.png")
		mod.ChestGrid:SetPits({
			{File = "gfx/grid/grid_chest_pit_alt.png", HasExtraFrames = true},
			{File = "gfx/grid/grid_chest_pit.png", HasExtraFrames = true}
		})

	mod.ScarredWombGrid = StageAPI.GridGfx()
		--mod.ScarredWombGrid:SetRocks("gfx/grid/rocks_scarredwomb.png")
		mod.ScarredWombGrid:SetPits("gfx/grid/grid_scarredwomb_pit.png", nil, true)
		mod.ScarredWombGrid:SetBridges("gfx/grid/rocks_scarredwomb.png")

	mod.BasementGrid = StageAPI.GridGfx()
		mod.BasementGrid:SetPits("gfx/grid/pit_basement.png", "gfx/grid/pit_basement.png", true)
		mod.BasementGrid:SetBridges("gfx/grid/rocks_basement.png")

	mod.ChallengeGrid = StageAPI.GridGfx()
		mod.ChallengeGrid:SetPits("gfx/grid/grid_ambush_pit.png", nil, false)
		mod.ChallengeGrid:SetRocks("gfx/grid/rock_challenge_placeholderrecolor.png")
		mod.ChallengeGrid:SetGrid("gfx/grid/pipes_spikes.png", GridEntityType.GRID_SPIKES)
		mod.ChallengeGrid:SetGrid("gfx/grid/pipes_spikes.png", GridEntityType.GRID_SPIKES_ONOFF)

	mod.ErrorGrid = StageAPI.GridGfx()
		mod.ErrorGrid:SetRocks("gfx/grid/rocks_error-1.png.png")

	mod.DiceGrid = StageAPI.GridGfx()
		mod.DiceGrid:SetRocks("gfx/grid/rocks_dice.png")
		mod.DiceGrid:SetPits("gfx/grid/pit_dice.png", "gfx/grid/pit_dice.png", true)

  mod.D12Grid = StageAPI.GridGfx()
		mod.D12Grid:SetRocks("gfx/grid/rocks_d12.png")

	mod.D12GridExt = StageAPI.GridGfx()
		mod.D12GridExt:SetRocks("gfx/grid/rocks_d12.png")		
		mod.D12GridExt:SetPits("gfx/grid/pit_d12.png", "gfx/grid/pit_d12.png", true)
		mod.D12GridExt:AddDoors("gfx/grid/d12_door.png", {RequireEither = {RoomType.ROOM_DICE}})

  mod.ED12Grid = StageAPI.GridGfx()
		mod.ED12Grid:SetRocks("gfx/grid/rocks_ed12.png")

	mod.ArcadeGrid = StageAPI.GridGfx()
		mod.ArcadeGrid:SetRocks("gfx/grid/rocks_arcade.png")
		mod.ArcadeGrid:SetPits("gfx/grid/pit_arcade.png")

	mod.CrawlspaceGrid = StageAPI.GridGfx()
		mod.CrawlspaceGrid:SetRocks("gfx/grid/rocks_crawlspace.png")
	--mod.CrawlspaceGrid:SetGrid("gfx/grid/spikes_crawlspace.png", GridEntityType.GRID_SPIKES)

	mod.CrawlspaceGridLuscious = StageAPI.GridGfx()
		mod.CrawlspaceGridLuscious:SetRocks("gfx/grid/rocks_crawlspace_luscious.png")

	mod.CrawlspaceGridOssuary = StageAPI.GridGfx()
		mod.CrawlspaceGridOssuary:SetRocks("gfx/grid/rocks_crawlspace_ossuary.png")

	mod.CrawlspaceGridFortress = StageAPI.GridGfx()
		mod.CrawlspaceGridFortress:SetRocks("gfx/grid/rocks_crawlspace_fortress.png")

	mod.CrawlspaceGridInsulation = StageAPI.GridGfx()
		mod.CrawlspaceGridInsulation:SetRocks("gfx/grid/rocks_crawlspace_insulation.png")

	mod.BlueWombGrid = StageAPI.GridGfx()
		mod.BlueWombGrid:SetRocks("gfx/grid/rocks_bluewomb.png")

	mod.DownpourEntranceGrid = StageAPI.GridGfx()
		mod.DownpourEntranceGrid:SetRocks("gfx/grid/rocks_downpour_entrance.png")
		mod.DownpourEntranceGrid:SetPits("gfx/grid/grid_pit_downpour_large.png", nil, true)

	mod.DownpourGrid = StageAPI.GridGfx()
		mod.DownpourGrid:SetPits("gfx/grid/grid_pit_downpour_large.png", nil, true)
		mod.DownpourGrid:SetBridges("gfx/grid/rocks_downpour.png")

	mod.DrossGrid = StageAPI.GridGfx()
		mod.DrossGrid:SetPits("gfx/grid/grid_pit_dross_large.png", nil, true)
		mod.DrossGrid:SetBridges("gfx/grid/rocks_dross.png")

 	mod.PeepeeGrid = StageAPI.GridGfx()
		mod.PeepeeGrid:SetRocks("gfx/grid/rocks_peepee.png")

	mod.PlanetGrid = StageAPI.GridGfx()
		mod.PlanetGrid:SetPits("gfx/grid/grid_planetarium_pit.png", nil, true)
		-- this grid should have bridges too, idk what though

	mod.CataGrid = StageAPI.GridGfx()
		mod.CataGrid:SetGrid("gfx/grid/catacomb_spikes.png", GridEntityType.GRID_SPIKES)
		mod.CataGrid:SetGrid("gfx/grid/catacomb_spikes.png", GridEntityType.GRID_SPIKES_ONOFF)
		mod.CataGrid:SetRocks("gfx/grid/rocks_catacombs.png")

	mod.MorbusGrid = StageAPI.GridGfx()
		mod.MorbusGrid:AddDoors("gfx/grid/morbus/morbus_door.png", StageAPI.DefaultDoorSpawn)
		mod.MorbusGrid:AddDoors("gfx/grid/morbus/morbus_hole.png", {RequireEither = {RoomType.ROOM_SECRET, RoomType.ROOM_SUPERSECRET}})
		mod.MorbusGrid:SetRocks("gfx/grid/morbus/morbus_rocks.png")
		mod.MorbusGrid:SetPits("gfx/grid/morbus/morbus_pit.png")
		mod.MorbusGrid:SetDecorations("gfx/grid/morbus/morbus_props.png", "gfx/grid/morbus/morbus_props.anm2", 40)

	mod.MinesGrid = StageAPI.GridGfx()
		mod.MinesGrid:SetPits("gfx/grid/grid_pit_mines_large.png", {
			{File = "gfx/grid/grid_pit_mines_water_large.png", HasExtraFrames = true},
		}, true)
		mod.MinesGrid:SetBridges("gfx/grid/rocks_secretroom.png")

	mod.MinesChaseGrid = StageAPI.GridGfx()
		mod.MinesChaseGrid:SetPits("gfx/grid/grid_pit_mines_cursed_large.png", nil, true)
		mod.MinesChaseGrid:SetBridges("gfx/grid/rocks_secretroom.png")

	mod.MausoleumGrid = StageAPI.GridGfx()
		mod.MausoleumGrid:SetPits("gfx/grid/grid_pit_mausoleum_large.png", nil, true)
		mod.MausoleumGrid:SetBridges("gfx/grid/rocks_mausoleum.png")

	mod.MausoleumAltGrid = StageAPI.GridGfx()
		mod.MausoleumAltGrid:SetRocks("gfx/grid/rocks_mausoleumb.png")
		mod.MausoleumAltGrid:SetPits("gfx/grid/grid_pit_mausoleumb_large.png", nil, true)
		mod.MausoleumAltGrid:SetBridges("gfx/grid/rocks_mausoleumb.png")

	mod.GehennaGrid = StageAPI.GridGfx()
		mod.GehennaGrid:SetPits("gfx/grid/grid_pit_gehenna_large.png", nil, true)
		mod.GehennaGrid:SetBridges("gfx/grid/rocks_gehenna.png")

	mod.RegCorpseGrid = StageAPI.GridGfx()
		mod.RegCorpseGrid:SetPits("gfx/grid/grid_pit_corpse2_large.png", nil, true)
		mod.RegCorpseGrid:SetBridges("gfx/grid/rocks_corpse2.png")

	mod.BloodyCorpseGrid = StageAPI.GridGfx()
		mod.BloodyCorpseGrid:SetRocks("gfx/grid/rocks_corpse3.png")
		mod.BloodyCorpseGrid:SetPits("gfx/grid/grid_pit_corpse3_large.png", nil, true)
		mod.BloodyCorpseGrid:SetBridges("gfx/grid/rocks_corpse3.png")

	mod.DryCorpseGrid = StageAPI.GridGfx()
		mod.DryCorpseGrid:SetRocks("gfx/grid/rocks_corpse.png")
		mod.DryCorpseGrid:SetPits("gfx/grid/grid_pit_corpse_large.png", nil, true)
		mod.DryCorpseGrid:SetBridges("gfx/grid/rocks_corpse.png")

	mod.RiskRewardGrid = StageAPI.GridGfx()
		mod.RiskRewardGrid:SetRocks("gfx/grid/rocks_sheol.png")
		mod.RiskRewardGrid:SetPits("gfx/grid/grid_sheol_pit.png")
		mod.RiskRewardGrid:SetBridges("gfx/grid/rocks_sheol.png")
		mod.RiskRewardGrid:SetDoorSprites({
			Default = {
				[RoomType.ROOM_DEFAULT] = "gfx/grid/door_19_sheoldoor.png",
				[RoomType.ROOM_MINIBOSS] = "gfx/grid/door_19_sheoldoor.png",
				[RoomType.ROOM_TREASURE] = {
					Anm2 = "gfx/grid/risksreward_door.anm2",
					Sprite = "gfx/grid/risksreward_door.png",
				}
			},
			Treasure = {
				[RoomType.ROOM_DEFAULT] = {
					Anm2 = "gfx/grid/risksreward_door.anm2",
					Sprite = "gfx/grid/risksreward_door.png",
				},
			}
		})
		mod.RiskRewardGrid:SetDoorSpawns(StageAPI.BaseDoorSpawnList)

  -- Backdrops

	mod.BasementBackdrop = StageAPI.RoomGfx(nil, mod.BasementGrid, nil, nil)
	mod.CellarBackdrop = StageAPI.RoomGfx(nil, mod.CellarGrid, "_default", "stageapi/shading/shading")
	mod.BBBackdrop = StageAPI.RoomGfx(nil, mod.BBGrid, "_default", "stageapi/shading/shading")
	--mod.CavesBackdrop = StageAPI.RoomGfx(nil, mod.CavesGrid, nil, nil)
	mod.CataBackdrop = StageAPI.RoomGfx(mod.Backdrop.CatacombsNoCaves, mod.CataGrid, "_default", "stageapi/shading/shading")
	mod.FloodedBackdrop = StageAPI.RoomGfx(nil, mod.FloodedGrid, nil, nil)
	mod.DepthsBackdrop = StageAPI.RoomGfx(nil, mod.DepthsGrid, nil, nil)
	mod.NecropolisBackdrop = StageAPI.RoomGfx(nil, mod.NecropolisGrid, nil, nil)
	--mod.SkullNecroBackdrop = StageAPI.RoomGfx(nil, mod.SkullNecroGrid, "_default", "stageapi/shading/shading")
	mod.DankDepthsBackdrop = StageAPI.RoomGfx(nil, mod.DankDepthsGrid, nil, nil)
	--mod.WombBackdrop = StageAPI.RoomGfx(nil, mod.WombGrid, nil, nil)
	mod.UteroBackdrop = StageAPI.RoomGfx(nil, mod.UteroGrid, nil, nil)
	mod.ScarredWombBackdrop = StageAPI.RoomGfx(nil, mod.ScarredWombGrid, nil, nil)
	mod.CathBackdrop = StageAPI.RoomGfx(nil, mod.CathGrid, nil, nil)
	mod.SheolBackdrop = StageAPI.RoomGfx(nil, mod.SheolGrid, nil, nil)
	mod.ChestBackdrop = StageAPI.RoomGfx(nil, mod.ChestGrid, nil, nil)
	mod.DarkRoomBackdrop = StageAPI.RoomGfx(nil, mod.DarkRoomGrid, nil, nil)

	mod.SecretBackdrop = StageAPI.RoomGfx(nil, mod.SecretGrid, nil, nil)
	mod.ChallengeBackdrop = StageAPI.RoomGfx(mod.Backdrop.Challenge, mod.ChallengeGrid, "_default", "stageapi/shading/shading")
	mod.RiskRewardBackdrop = StageAPI.RoomGfx(mod.Backdrop.RiskReward, mod.RiskRewardGrid, nil, nil)
	mod.CrawlspaceBackdrop = StageAPI.RoomGfx(nil, mod.CrawlspaceGrid, nil, nil)
	mod.CrawlspaceBackdropLuscious = StageAPI.RoomGfx(nil, mod.CrawlspaceGridLuscious, nil, nil)
	mod.CrawlspaceBackdropOssuary = StageAPI.RoomGfx(nil, mod.CrawlspaceGridOssuary, nil, nil)
	mod.CrawlspaceBackdropFortress = StageAPI.RoomGfx(nil, mod.CrawlspaceGridFortress, nil, nil)
	mod.CrawlspaceBackdropInsulation = StageAPI.RoomGfx(nil, mod.CrawlspaceGridInsulation, nil, nil)
	mod.LibraryBackdrop = StageAPI.RoomGfx(nil, mod.LibraryGrid, nil, nil)
	mod.ShopBackdrop = StageAPI.RoomGfx(nil, mod.ShopGrid, "_default", "stageapi/shading/shading")
	mod.ErrorBackdrop = StageAPI.RoomGfx(nil, mod.ErrorGrid, nil, nil)
	mod.DiceBackdrop = StageAPI.RoomGfx(nil, mod.DiceGrid, nil, nil)
	mod.D12Backdrop = StageAPI.RoomGfx(nil, mod.D12Grid, nil, nil)
	mod.D12BackdropExt = StageAPI.RoomGfx(mod.Backdrop.BlueDice, mod.D12GridExt, "_default", "stageapi/shading/shading")
	mod.ED12Backdrop = StageAPI.RoomGfx(nil, mod.ED12Grid, nil, nil)
	mod.ArcadeBackdrop = StageAPI.RoomGfx(nil, mod.ArcadeGrid, nil, nil)
	mod.PlanetariumBackdrop = StageAPI.RoomGfx(nil, mod.PlanetGrid, nil, nil)
	mod.DownpourEntranceBackdrop = StageAPI.RoomGfx(nil, mod.DownpourEntranceGrid, nil, nil)
	mod.DownpourBackdrop = StageAPI.RoomGfx(nil, mod.DownpourGrid, nil, nil)
	mod.DrossBackdrop = StageAPI.RoomGfx(nil, mod.DrossGrid, nil, nil)
	mod.MinesBackdrop = StageAPI.RoomGfx(nil, mod.MinesGrid, nil, nil)
	mod.MinesChaseBackdrop = StageAPI.RoomGfx(nil, mod.MinesChaseGrid, nil, nil)
	mod.MausoleumBackdrop = StageAPI.RoomGfx(nil, mod.MausoleumGrid, nil, nil)
	mod.GehennaBackdrop = StageAPI.RoomGfx(nil, mod.GehennaGrid, nil, nil)
	mod.CorpseBackdrop1 = StageAPI.RoomGfx(nil, mod.RegCorpseGrid, nil, nil)
	mod.CorpseBackdrop2 = StageAPI.RoomGfx(nil, mod.BloodyCorpseGrid, nil, nil)
	mod.CorpseBackdrop3 = StageAPI.RoomGfx(nil, mod.DryCorpseGrid, nil, nil)
	mod.PeepeeBackdrop = StageAPI.RoomGfx(nil, mod.PeepeeGrid, nil, nil)

	mod.HiveBackdrop = StageAPI.RoomGfx(mod.Backdrop.Hive, mod.HiveGrid, "_default", "stageapi/shading/shading")
	mod.DebugBackdrop = StageAPI.RoomGfx(mod.Backdrop.Debug, nil, "_default", "stageapi/shading/shading")
	mod.DankerBackdrop = StageAPI.RoomGfx(nil, mod.DankDepthsGrid, nil, nil)
	--mod.DankerBackdrop = StageAPI.RoomGfx(mod.Backdrop.Danker, mod.DankDepthsGrid, "_default", "stageapi/shading/shading")
	mod.SmokyBackdrop = StageAPI.RoomGfx(mod.Backdrop.Smoky, mod.SmokyGrid, "_default", "stageapi/shading/shading")
	mod.HappyFunTimeBackdrop = StageAPI.RoomGfx(mod.Backdrop.HappyFunTime, nil, "_default", "stageapi/shading/shading")
	mod.PipesBackdrop = StageAPI.RoomGfx(mod.Backdrop.Pipes, mod.PipesGrid, "_default", "stageapi/shading/shading")
	mod.HoneyedCellarBackdrop = StageAPI.RoomGfx(mod.Backdrop.HoneyedCellar, mod.CellarGrid, "_default", "stageapi/shading/shading")
	mod.EyeballUteroBackdrop = StageAPI.RoomGfx(mod.Backdrop.EyeballUtero, mod.UteroGrid, "_default", "stageapi/shading/shading")
	mod.PrimordialBackdrop = StageAPI.RoomGfx(mod.Backdrop.Primordial, mod.PrimordialGrid, "_default", "stageapi/shading/shading")
	mod.TrashDankDepthsBackdrop = StageAPI.RoomGfx(mod.Backdrop.TrashDankDepths, mod.TrashDankDepthsGrid, "_default", "stageapi/shading/shading")
	mod.MorbusBackdrop = StageAPI.RoomGfx(mod.Backdrop.Morbus, mod.MorbusGrid, "_default", "stageapi/shading/shading")
	mod.MausoleumAltBackdrop = StageAPI.RoomGfx(BackdropType.MAUSOLEUM3, mod.MausoleumAltGrid)
	mod.LugubriousBackdrop = StageAPI.RoomGfx(mod.Backdrop.Lugubrious, mod.DarkRoomGrid, nil, nil)

	mod.CacophobiaBackdrop = StageAPI.RoomGfx(mod.Backdrop.Cacophobia, nil, nil, nil)
	
	--The Lab

	mod.LabWalls = StageAPI.BackdropHelper({
			Walls = {"_Blank", "1", "2"},
		}, "gfx/secret/shhhhh/nothing to see here/Laboratory_Room", ".png")
	mod.LabGrid = StageAPI.GridGfx()
	mod.LabGrid:AddDoors("gfx/secret/shhhhh/nothing to see here/Laboratory_Door.png", StageAPI.DefaultDoorSpawn)
	mod.LabGrid:SetRocks("gfx/secret/shhhhh/nothing to see here/Laboratory_Rocks.png")
	mod.LabGrid:SetPits("gfx/secret/shhhhh/nothing to see here/Laboratory_Pit.png",
	{
		{File = "gfx/secret/shhhhh/nothing to see here/Laboratory_Pit_BioFuel.png"}
	},
	false)

	mod.LabBackdrop = StageAPI.RoomGfx(mod.LabWalls, mod.LabGrid, "_default", "stageapi/shading/shading")

	mod.LabRooms = {
		RoomFiles = {
			"thelab"
		}
	}

	mod.LabRoomlist = {}

	for _, roomName in ipairs(mod.LabRooms.RoomFiles) do
		mod.LabRooms.RoomFiles[roomName] = require("resources.luarooms." .. roomName)
		mod.LabRoomlist[#mod.LabRoomlist + 1] = mod.LabRooms.RoomFiles[roomName]
	end

	-- local LabRoomsReal = StageAPI.RoomsList("Rooms", table.unpack(mod.LabRoomlist))

	mod.TheLab = StageAPI.CustomStage("Lab")
	mod.TheLab:SetRoomGfx(mod.LabBackdrop, {RoomType.ROOM_DEFAULT, RoomType.ROOM_TREASURE, RoomType.ROOM_MINIBOSS})
	-- mod.TheLab:SetRooms(LabRoomsReal)
	mod.TheLab:SetMusic(Isaac.GetMusicIdByName("LabTheme"), {RoomType.ROOM_DEFAULT})
	mod.TheLab:SetReplace(StageAPI.StageOverride.NecropolisOne)

	--MorbusReal

	mod.MorbusRealWalls = StageAPI.BackdropHelper({
			Walls = {""},
		}, "gfx/secret/shhhhh/nothing to see here/morbusReal", ".png")
	mod.MorbusRealGrid = StageAPI.GridGfx()
	mod.MorbusRealGrid:SetRocks("gfx/secret/shhhhh/nothing to see here/morbusRealRocks.png")

	mod.MorbusRealBackdrop = StageAPI.RoomGfx(mod.MorbusRealWalls, mod.MorbusRealGrid, "_default", "stageapi/shading/shading")

	mod.MorbusReal = StageAPI.CustomStage("MorbusReal")
	mod.MorbusReal:SetRoomGfx(mod.MorbusRealBackdrop, {RoomType.ROOM_DEFAULT, RoomType.ROOM_TREASURE, RoomType.ROOM_MINIBOSS, RoomType.ROOM_BOSS})


	--Stony Level

	mod.StonyRooms = {
		RoomFiles = {
			"stonylevel"
		}
	}

	mod.StonyRoomlist = {}

	for _, roomName in ipairs(mod.StonyRooms.RoomFiles) do
		mod.StonyRooms.RoomFiles[roomName] = require("resources.luarooms." .. roomName)
		mod.StonyRoomlist[#mod.StonyRoomlist + 1] = mod.StonyRooms.RoomFiles[roomName]
	end

	local StonyRoomsReal = StageAPI.RoomsList("Rooms", table.unpack(mod.StonyRoomlist))

	local StonyBosses = {
	"Peat",
	"Blue Horf",
	}

	mod.StonyLevel = StageAPI.CustomStage("Stony Level")
	mod.StonyLevel:SetRoomGfx(mod.PrimordialBackdrop, {RoomType.ROOM_DEFAULT, RoomType.ROOM_TREASURE, RoomType.ROOM_MINIBOSS, RoomType.ROOM_BOSS})
	mod.StonyLevel:SetRooms(StonyRoomsReal)
	mod.StonyLevel:SetBosses(StonyBosses)

	StageAPI.UnregisterCallbacks("FiendFolio") -- for lua modding so the same callbacks aren't in twice

	--Custom Alt Rock spawns
	StageAPI.AddCallback("FiendFolio", "POST_OVERRIDDEN_GRID_BREAK", 1, function(index, grid)
		local room = game:GetRoom()
		if grid and grid:GetType() == GridEntityType.GRID_ROCK_ALT then
			--print("yes")
			if Game():GetRoom():GetBackdropType() == 16 then
				math.randomseed(index + game:GetLevel():GetCurrentRoomDesc().DecorationSeed)
				--Isaac.ConsoleOutput("pot destroyed")
				local r = math.random(1000)
				local spawn = nil
				if r <= 40 then
					spawn = {219, 0, 0} --Wizoob
				elseif r <= 50 then
					spawn = {285, 0, 0} --Red Ghost
				elseif r <= 100 then
					spawn = {260, 10, 0} --Lil Haunt
				elseif r <= 150 then
					spawn = {mod.FF.Yawner.ID, mod.FF.Yawner.Var, 0} --Yawner
				elseif r <= 200 then
					spawn = {mod.FF.Ghostse.ID, mod.FF.Ghostse.Var, 0} --Ghostse
				elseif r <= 210 then
					spawn = {5, 20, 213} --Cursed Penny
				elseif r <= 235 then
					spawn = {227, 0, 0} --Bony
				elseif r <= 260 then
					spawn = {277, 0, 0} --Black Bony
				elseif r <= 300 then
					spawn = {mod.FF.Crepitus.ID, mod.FF.Crepitus.Var, 0} --Crepitus
				elseif r <= 350 then
					spawn = {5, 10, 11} --Bone Heart
				else
				--	Isaac.ConsoleOutput("zilch")
				end
				if spawn ~= nil then
				--	Isaac.ConsoleOutput("spawned")
					local entity = Isaac.Spawn(spawn[1], spawn[2], spawn[3], room:GetGridPosition(index), nilvector, nil)
				end
			elseif Game():GetRoom():GetBackdropType() == 17 then
				math.randomseed(index + game:GetLevel():GetCurrentRoomDesc().DecorationSeed)
				--Isaac.ConsoleOutput("pot destroyed")
				local r = math.random(1000)
				local spawn = nil
				if r <= 50 then
					spawn = {227, 0, 0} --Bony
				elseif r <= 90 then
					spawn = {277, 0, 0} --Black Bony
				elseif r <= 120 then
					spawn = {mod.FF.Crepitus.ID, mod.FF.Crepitus.Var, 0} --Crepitus
				elseif r <= 170 then
					spawn = {5, 10, 11} --Bone Heart
				elseif r <= 210 then
					spawn = {mod.FF.Sackboy.ID, mod.FF.Sackboy.Var, 0} --Sackboy
				elseif r <= 235 then
					spawn = {mod.FF.Cracker.ID, mod.FF.Cracker.Var, 0} --Cracker
				elseif r <= 270 then
					spawn = {mod.FF.Posssessed.ID, mod.FF.Posssessed.Var, 0} --Possessed
				elseif r <= 300 then
					spawn = {mod.FF.CurdleNaked.ID, mod.FF.CurdleNaked.Var, 0} --Naked Curdle
				elseif r <= 320 then
					spawn = {mod.FF.Neonate.ID, mod.FF.Neonate.Var, 0} --Neonate
				elseif r <= 340 then
					spawn = {mod.FF.NuchalDetached.ID, mod.FF.NuchalDetached.Var, 0} --Nuchal
				elseif r <= 350 then
					spawn = {5, 20, 213} --Cursed Penny
				else
				--	Isaac.ConsoleOutput("zilch")
				end
				if spawn ~= nil then
				--	Isaac.ConsoleOutput("spawned")
					local entity = Isaac.Spawn(spawn[1], spawn[2], spawn[3], room:GetGridPosition(index), nilvector, nil)
				end
			elseif mod.roomBackdrop == 9 then -- Pee Dross
				--Piss projectiles from filled buckets
				if grid.Desc.Variant == 1 then
					for i = 1, mod:RandomInt(4,6) do
						local projectile = Isaac.Spawn(9, 0, 0, grid.Position, Vector.One:Resized(mod:RandomInt(4,6)):Rotated(mod:RandomAngle()), nil):ToProjectile()
						projectile.FallingSpeed = mod:RandomInt(-25,-10)
						projectile.FallingAccel = 1.2
						projectile.Color = mod.ColorPeepPiss
						local d = projectile:GetData()
						d.projType = "Peepisser"
						d.detail = "Pee"
						d.creepTimeout = 90
						d.water = room:HasWater()
						projectile:Update()
					end
				end
				local rand = mod:RandomInt(0,10)
				--Chance for Coins
				if rand < 3 then
					for i = 1, mod:RandomInt(1,2) do
						Isaac.Spawn(5,20,0,grid.Position,Vector.One:Resized(mod:RandomInt(1,3)):Rotated(mod:RandomAngle()),nil)
					end
				--Chance for Spiders/Leeches
				elseif rand < 6 then
					local toLeech = (mod:RandomInt(0,1) == 1)
					for i = 1, 2 do
						local spider = EntityNPC.ThrowSpider(grid.Position, nil, grid.Position + Vector(mod:RandomInt(-40,40), mod:RandomInt(-40,40)), false, 0):ToNPC()
						if toLeech then
							spider:Morph(810,0,0,-1)
						end
					end
				end
			elseif mod.roomBackdrop == 10 then -- Morbus
				local roll = grng:RandomFloat()
				if roll < 0.2 then -- 20%
					local nerve = Isaac.Spawn(231, 0, 1980, grid.Position, Vector.Zero, nil)
					nerve:ClearEntityFlags(EntityFlag.FLAG_APPEAR)

					local sprite = nerve:GetSprite()
					sprite:ReplaceSpritesheet(0, "gfx/enemies/morbus misc/nerve_ending.png")
					sprite:LoadGraphics()
				elseif roll < 0.21 then -- 1%
					Isaac.Spawn(5, 100, 682, grid.Position, Vector.Zero, nil) -- Worm Friend
				elseif roll < 0.25 and mod.AchievementTrackers.BoneHeartUnlocked then -- 4%
					Isaac.Spawn(5, 10, 11, grid.Position, Vector.Zero, nil) -- Bone Heart
				elseif roll < 0.28 and mod.ACHIEVEMENT.MORBID_HEART:IsUnlocked() then -- 3%
					Isaac.Spawn(5, FiendFolio.PICKUP.VARIANT.MORBID_HEART, 0, grid.Position, Vector.Zero, nil) -- Morbid Heart
				elseif roll < 0.285 then -- 0.5%
					Isaac.Spawn(120, 235, 0, grid.Position, Vector.Zero, nil) -- Oralid
				end
			end
		end
	end)


	mod.FloorGrids = {
		mod.BasementGrid,
		mod.CellarGrid,
		mod.BBGrid,
		mod.SmokyGrid,
		--mod.CavesGrid,
		mod.PrimordialGrid,
		mod.CataGrid,
		mod.FloodedGrid,
		mod.DepthsGrid,
		mod.NecropolisGrid,
		mod.DankDepthsGrid,
		mod.PipesGrid,
		--mod.WombGrid,
		mod.UteroGrid,
		mod.ScarredWombGrid,
		mod.BlueWombGrid,
		mod.CathGrid,
		mod.SheolGrid,
		mod.ChestGrid,
		mod.DarkRoomGrid,

		mod.SecretGrid,
		mod.ChallengeGrid,
		--mod.CrawlspaceGrid,
		mod.ShopGrid,
		mod.DiceGrid,
		mod.D12Grid,
		mod.ED12Grid,
		mod.ArcadeGrid,
		mod.ErrorGrid,

		mod.HiveGrid,
		mod.MorbusRealGrid,
		mod.LabGrid,
	}
end

do
	SepticRoomCompat = SepticRoomCompat or {}
	SepticRoomCompat.Default = SepticRoomCompat.Default or {}
	table.insert(SepticRoomCompat.Default, require('resources.luarooms.septic_ff'))
end

--Isaac.ConsoleOutput("StageAPI boses are: " .. #mod.StageAPIBosses .. "\n")

mod.illegalRoomSubs = {
9,	--Famine
10, --Pestilence
11, --War
12, --Death
19, --Gish
20, --Steven
21, --Chad
22, --Headless Horseman
23, --The Fallen
38, --Conquest
42, --Triachnid (just in case)
}

-- seriously don't mess with these
mod.felonyRoomSubs = {
	6,	--Mom
	8,	--Mom's Heart
	25, --It Lives
}

FiendFolio.ForceBosses = false

if StageAPI and StageAPI.Loaded then
	StageAPI.AddCallback("FiendFolio", "PRE_BOSS_SELECT", 1, function(bosses, rng, roomDesc, ignoreNoOptions)
		if mod.ModeEnabled == 2 then
			return {
				Pool = {
					{BossID = "Ghostse", Weight =  10000000}
				}
			}
		end

		if FiendFolio.ForceBosses or (roomDesc.Data.Subtype == 9 and StageAPI.GetBossEncountered("Meltdown")) then
			local ffBosses = {Pool = {}}

			for _, bossID in ipairs(bosses.Pool or bosses) do
				local poolEntry
				if type(bossID) == "table" then
					poolEntry = bossID
					bossID = bossID.BossID
				end

				local bossData = StageAPI.GetBossData(bossID)
				if bossData and bossData.IsFFBoss then
					ffBosses.Pool[#ffBosses.Pool + 1] = poolEntry or bossID
				end
			end

			if #ffBosses.Pool > 0 then
				return ffBosses
			end
		elseif roomDesc then 
			-- Don't replace the headless horseman, don't replace Turdlet with Cacamancer
			-- On Dank Depths, don't replace Gish, but do replace every other base game boss
			local removedBoss
			local outBosses = {Pool = {}}
			for _, bossID in ipairs(bosses.Pool or bosses) do
				local poolEntry
				if type(bossID) == "table" then
					poolEntry = bossID
					bossID = bossID.BossID
				end

				local bossData = StageAPI.GetBossData(bossID)
				local level = game:GetLevel()
				local isDankDepths = level:GetStage() == LevelStage.STAGE3_1 and level:GetStageType() == StageType.STAGETYPE_AFTERBIRTH
				local remove
				if bossData then
					if bossData.IsFFBoss then
						if roomDesc.Data.Subtype == 22 then -- headless horseman
							remove = true
						elseif bossID == "Cacamancer" and roomDesc.Data.Subtype == 97 then -- turdlet
							remove = true
						elseif isDankDepths and (roomDesc.Data.Subtype == 19 or roomDesc.Data.Subtype == 58) and FiendFolio.BossPoolOverhaulEnabled then -- gish, brownie
							remove = true
						end
					elseif isDankDepths and (roomDesc.Data.Subtype ~= 19 and roomDesc.Data.Subtype ~= 58) and bossData.BaseGameBoss and bossID ~= "Mom" and FiendFolio.BossPoolOverhaulEnabled then
						remove = true
					end
				end

				if remove then
					removedBoss = true
				else
					outBosses.Pool[#outBosses.Pool + 1] = poolEntry
				end
			end

			if removedBoss then
				return outBosses
			end
		end
	end)
end

--Choose boss, boss choose, bosschoice, bosschoose, chooseboss, boss pool, bosspool just some nice keywrods
function mod:BossRoomFunTime()
	-- todo check for FF champs?
	local game = Game()
	local room = game:GetRoom()

	if StageAPI
	and not StageAPI.InTestMode
	and not game:IsGreedMode()
	and not (
		game:GetStateFlag(GameStateFlag.STATE_BACKWARDS_PATH_INIT)
		or game:GetStateFlag(GameStateFlag.STATE_BACKWARDS_PATH)
	)
	and room:GetType() == RoomType.ROOM_BOSS
	and room:IsFirstVisit()
	and not StageAPI.InNewStage()
	and not StageAPI.GetCurrentRoom() then
		--Isaac.ConsoleOutput("About to check \n")
		if mod.ModeEnabled == 2 then -- This is literally the only thing this callback does now
			StageAPI.SetCurrentBossRoom("Ghostse", true)
		end
	end
end

mod.roomBackdropTable = {
	mod.DankerBackdrop,
	mod.SmokyBackdrop,
	mod.PipesBackdrop,
	mod.HoneyedCellarBackdrop,
	mod.EyeballUteroBackdrop,
	mod.PrimordialBackdrop,
	mod.ChallengeBackdrop,
	mod.TrashDankDepthsBackdrop,
	mod.PeepeeBackdrop,
	mod.MorbusBackdrop,
	mod.MausoleumAltBackdrop,
	mod.RiskRewardBackdrop,
}

function mod.ReplaceCrawlspaceTileGfx(path)
	local room = game:GetRoom()
	for i = 0, room:GetGridSize()-1 do
		local grid = room:GetGridEntity(i)
		-- metal blocks, which become walls
		-- decorations, i.e. ladders
		-- gravity squares where the floor is, with the anm2 loaded
		if grid then
			local type = grid:GetType()
			local isKeyBlock = mod.IsKeyBlock(grid)
			if isKeyBlock then
				-- do nothing
			elseif type == GridEntityType.GRID_WALL
			or type == GridEntityType.GRID_DECORATION
			or (type == GridEntityType.GRID_GRAVITY and grid:GetSprite():GetFilename() ~= "") then
				local sprite = grid:GetSprite()
				sprite:ReplaceSpritesheet(0, path)
				sprite:LoadGraphics()
			end
		end
	end
end

-- for any rooms that require more backdrop fuckery than what stageapi provides
mod.specialRoomBackdropTable = {
	[50] = function()
		-- the gravity tiles don't have updated sprites in post new room,
		-- so delay gfx replacement until input action, which comes BEFORE render
		mod.scheduleForUpdate(function()
			mod.ReplaceCrawlspaceTileGfx('gfx/grid/tiles_itemdungeon_luscious.png')
		end, 1, ModCallbacks.MC_INPUT_ACTION, true)
		return mod.CrawlspaceBackdropLuscious
	end,
	[51] = function()
		mod.scheduleForUpdate(function()
			mod.ReplaceCrawlspaceTileGfx('gfx/grid/tiles_itemdungeon_ossuary.png')
		end, 1, ModCallbacks.MC_INPUT_ACTION, true)
		return mod.CrawlspaceBackdropOssuary
	end,
	[52] = function()
		mod.scheduleForUpdate(function()
			mod.ReplaceCrawlspaceTileGfx('gfx/grid/tiles_itemdungeon_pipes.png')
		end, 1, ModCallbacks.MC_INPUT_ACTION, true)
		return mod.CrawlspaceBackdrop
	end,
	[53] = function()
		mod.scheduleForUpdate(function()
			mod.ReplaceCrawlspaceTileGfx('gfx/grid/tiles_itemdungeon_creature.png')
		end, 1, ModCallbacks.MC_INPUT_ACTION, true)
		return mod.CrawlspaceBackdrop
	end,
	[54] = function()
		mod.scheduleForUpdate(function()
			mod.ReplaceCrawlspaceTileGfx('gfx/grid/tiles_itemdungeon_fortress.png')
		end, 1, ModCallbacks.MC_INPUT_ACTION, true)
		return mod.CrawlspaceBackdropFortress
	end,
	[55] = function()
		mod.scheduleForUpdate(function()
			mod.ReplaceCrawlspaceTileGfx('gfx/grid/tiles_itemdungeon_insulation.png')
		end, 1, ModCallbacks.MC_INPUT_ACTION, true)
		return mod.CrawlspaceBackdropInsulation
	end,
}

function mod:getCurrentRoomGfx()
	if mod.roomBackdrop then
		if mod.roomBackdrop > 0 and mod.roomBackdropTable[mod.roomBackdrop] then
			return mod.roomBackdropTable[mod.roomBackdrop]
		elseif mod.roomBackdrop > 0 and mod.specialRoomBackdropTable[mod.roomBackdrop] then
			return mod.specialRoomBackdropTable[mod.roomBackdrop]
		else
			return mod.HiveBackdrop
		end
	else
		local level = game:GetLevel()
		local room = game:GetRoom()
		if level:GetStage() == LevelStage.STAGE7 then
			-- on void go fucking CRAZY
			grng:SetSeed(room:GetDecorationSeed(), 0)
			local gridgfx = StageAPI.GridGfx()
			gridgfx.Rocks = mod.FloorGrids[grng:RandomInt(#mod.FloorGrids) + 1].Rocks
			gridgfx.PitFiles = mod.FloorGrids[grng:RandomInt(#mod.FloorGrids) + 1].PitFiles
			gridgfx.AltPitFiles = mod.FloorGrids[grng:RandomInt(#mod.FloorGrids) + 1].AltPitFiles
			return StageAPI.RoomGfx(nil, gridgfx, nil, nil)
		end

		local roomType = room:GetType()
		local backdropType = game:GetRoom():GetBackdropType()
		if roomType == RoomType.ROOM_SECRET then
			return mod.SecretBackdrop
		elseif roomType == RoomType.ROOM_DUNGEON then
			return mod.CrawlspaceBackdrop
		elseif (roomType == RoomType.ROOM_CHALLENGE or roomType == RoomType.ROOM_BOSSRUSH) and not StageAPI.InNewStage() then
			return mod.ChallengeBackdrop
		--[[elseif (roomType == RoomType.ROOM_TREASURE) and mod.anyPlayerHas(CollectibleType.COLLECTIBLE_RISKS_REWARD) then
			return mod.RiskRewardBackdrop]]
		elseif backdropType == 35 then
			--Requested by gummy
			return mod.PlanetariumBackdrop
		elseif not StageAPI.InNewStage() then
			if backdropType == 1 then
				return mod.BasementBackdrop
			elseif backdropType == 2 then
				return mod.CellarBackdrop
			elseif backdropType == 3 then
				return mod.BBBackdrop
			elseif backdropType == 5 then
				return mod.CataBackdrop
			elseif backdropType == 6 then
				return mod.FloodedBackdrop
			elseif backdropType == 7 and roomType ~= RoomType.ROOM_SACRIFICE then
				return mod.DepthsBackdrop
			elseif backdropType == 8 then
				return mod.NecropolisBackdrop
			elseif backdropType == 9 then
				return mod.DankDepthsBackdrop
			elseif backdropType == 11 then
				return mod.UteroBackdrop
			elseif backdropType == 12 then
				return mod.ScarredWombBackdrop
			elseif backdropType == 14 and roomType ~= RoomType.ROOM_CHALLENGE and roomType ~= RoomType.ROOM_BOSSRUSH then
				return mod.SheolBackdrop
			elseif backdropType == 15 then
				return mod.CathBackdrop
			elseif backdropType == 16 then
				return mod.DarkRoomBackdrop
			elseif backdropType == 17 then
				return mod.ChestBackdrop
			elseif backdropType == 19 then
				return mod.LibraryBackdrop
			elseif backdropType == 21 or backdropType == 22 then
				return mod.CellarBackdrop
			elseif backdropType == 20 or backdropType == 28 then
				return mod.ShopBackdrop
			elseif backdropType == 24 then
				math.randomseed(game:GetRoom():GetSpawnSeed())
				if math.random(7) == 7 then
					return mod.D12BackdropExt
				else
					return mod.DiceBackdrop
				end
			elseif backdropType == 25 then
				return mod.ArcadeBackdrop
			elseif backdropType == 26 then
				return mod.ErrorBackdrop
			elseif backdropType == BackdropType.DOWNPOUR or backdropType == BackdropType.DOWNPOUR_ENTRANCE then
				if room:HasWater() then
					return mod.DownpourBackdrop
				else
					return mod.DownpourEntranceBackdrop
				end
			elseif backdropType == BackdropType.MINES_SHAFT or backdropType == BackdropType.ASHPIT_SHAFT then
				if level:GetStateFlag(LevelStateFlag.STATE_MINESHAFT_ESCAPE) then
					return mod.MinesChaseBackdrop
				else
					return mod.MinesBackdrop
				end
			elseif backdropType == BackdropType.MINES or backdropType == BackdropType.MINES_ENTRANCE then
				return mod.MinesBackdrop
			elseif backdropType == BackdropType.MAUSOLEUM or backdropType == BackdropType.MAUSOLEUM_ENTRANCE then
				return mod.MausoleumBackdrop
			elseif backdropType == BackdropType.CORPSE then
				return mod.CorpseBackdrop3
			elseif backdropType == BackdropType.CORPSE2 then
				return mod.CorpseBackdrop1
			elseif backdropType == BackdropType.CORPSE3 then
				return mod.CorpseBackdrop2
			elseif backdropType == BackdropType.DROSS then
				return mod.DrossBackdrop
			elseif backdropType == BackdropType.GEHENNA then
				return mod.GehennaBackdrop
			elseif backdropType == BackdropType.ISAACS_BEDROOM or backdropType == BackdropType.HALLWAY then
				return mod.CellarBackdrop
			elseif backdropType == BackdropType.MOMS_BEDROOM then
				return mod.ArcadeBackdrop
			end
		end
	end
end

function mod:backdropReplacer()
	if StageAPI then
			if mod.roomBackdrop and mod.roomBackdropFrom then
				if game:GetLevel():GetCurrentRoomDesc().ListIndex ~= mod.roomBackdropFrom 
				or StageAPI.GetCurrentRoom() ~= mod.roomBackdropFromStageAPI 
				or game:GetSeeds():GetStageSeed(game:GetLevel():GetStage()) ~= mod.roomBackdropFromLevel then
					mod.roomBackdrop = nil
					mod.roomBackdropFrom = nil
					mod.roomBackdropFromStageAPI = nil
					mod.roomBackdropFromLevel = nil
				end
			end

			mod.necroreplacin = false
			if mod.ModeEnabled == 1 then
				StageAPI.ChangeRoomGfx(mod.HiveBackdrop)
			elseif mod.ModeEnabled == 2 then
				StageAPI.ChangeRoomGfx(mod.HappyFunTimeBackdrop)
				if not sfx:IsPlaying(mod.Sounds.Uke) then
					sfx:Play(mod.Sounds.Uke, 2, 0, false, 1)
					MusicManager():Pause()
					MusicManager():Disable()
				end
			else

			local roomGfx = mod:getCurrentRoomGfx()
			if roomGfx then
				if type(roomGfx) == "function" then
					local outGfx = roomGfx()
					if outGfx then
						StageAPI.ChangeRoomGfx(outGfx)
					end
				else
					StageAPI.ChangeRoomGfx(roomGfx)
				end
			end
		end
	end
end

function FiendFolio.sign(val)
	return val == 0 and 0 or (val > 0 and 1 or -1)
end

function FiendFolio.GetCardinal(vec)
	if math.abs(vec.X) > math.abs(vec.Y) then
		return Vector(FiendFolio.sign(vec.X), 0)
	else
		return Vector(0, FiendFolio.sign(vec.Y))
	end
end

function FiendFolio.onEntityTick(type, fn, variant, subtype)
	mod:AddCallback(ModCallbacks.MC_POST_UPDATE, function()
		local found = Isaac.FindByType(type, variant or -1, subtype or -1, false, false)
		for _, ent in ipairs(found) do
			fn(ent)
		end
	end)
end

function FiendFolio.onMachineTouch(variant, fn)
	mod:AddCallback(ModCallbacks.MC_POST_PEFFECT_UPDATE, function(_, p)
		local slots = Isaac.FindByType(EntityType.ENTITY_SLOT, variant or -1, -1, false, false)
		for _, slot in ipairs(slots) do
			if slot:GetData().sizeMulti then
				if (math.abs(slot.Position.X-p.Position.X) ^ 2 <= (slot.Size*slot.SizeMulti.X + p.Size) ^ 2) and (math.abs(slot.Position.Y-p.Position.Y) ^ 2 <= (slot.Size*slot.SizeMulti.Y + p.Size) ^ 2) then
					fn(p, slot)
				end
			else
				if slot.Position:DistanceSquared(p.Position) <= (slot.Size + p.Size) ^ 2 then
					fn(p, slot)
				end
			end
		end
	end)
end

function mod:isDeliriumRoom()
	if #Isaac.FindByType(EntityType.ENTITY_DELIRIUM, -1, -1, false, false) > 0 then
		mod.IsDeliriumRoom = true
	else
		mod.IsDeliriumRoom = false
	end
end


--Debug Commands
function FFCharm()
	local player = Isaac.GetPlayer(0)
	for _,entity in ipairs(Isaac.GetRoomEntities()) do
		if entity:IsActiveEnemy() then
			entity:AddCharmed(EntityRef(player), 6000)
		end
	end
end

function FFFear()
	local player = Isaac.GetPlayer(0)
	for _,entity in ipairs(Isaac.GetRoomEntities()) do
		if entity:IsActiveEnemy() then
			entity:AddFear(EntityRef(player), 6000)
		end
	end
end
function FFConfuse()
	local player = Isaac.GetPlayer(0)
	for _,entity in ipairs(Isaac.GetRoomEntities()) do
		if entity:IsActiveEnemy() then
			entity:AddConfusion(EntityRef(player), 6000, false)
		end
	end
end

function ffbackdrop(backdropValue)
	if StageAPI then
		if backdropValue and backdropValue > 0 and mod.roomBackdropTable[backdropValue] then
			StageAPI.ChangeRoomGfx(mod.roomBackdropTable[backdropValue])
		elseif backdropValue and backdropValue > 0 and mod.specialRoomBackdropTable[backdropValue] then
			return mod.specialRoomBackdropTable[backdropValue]()
		else
			StageAPI.ChangeRoomGfx(mod.HiveBackdrop)
		end
	end
end
function ffdebug()
	if StageAPI then
		StageAPI.ChangeRoomGfx(mod.DebugBackdrop)
	end
end

function mod.FFCommands(_, cmd, params)
	if cmd == "charmall" then
		FFCharm()
	elseif cmd == "fireall" then
		mod:SetRoomAlight()
	elseif cmd == "fearall" then
		FFFear()
	elseif cmd == "confuseall" then
		FFConfuse()
	elseif cmd == "forcestate" then
		for _,entity in ipairs(Isaac.GetRoomEntities()) do
			if entity:IsEnemy() then
				entity:GetData().state = params
			end
		end
	elseif cmd == "dmgplayer" then
		-- damages player 1 in 3 frames
		mod.scheduleForUpdate(function()
			Isaac.GetPlayer(0):TakeDamage(1, 0, EntityRef(nil), 0)
		end, 3)
	elseif cmd == 'forceffboss' then
		FiendFolio.ForceBosses = not FiendFolio.ForceBosses
		print('Toggling force FiendFolio bosses, new value:', FiendFolio.ForceBosses)
	elseif cmd == "bgdebug" then
		print('replacing bg via stageapi')
		ffdebug()
	elseif cmd == "thumbsup" then
		if params and tonumber(params) then
			for i = 1, params do
				Isaac.GetPlayer():AnimateHappy()
			end
		else
			Isaac.GetPlayer():AnimateHappy()
		end
	elseif cmd == "thumbsdown" then
		if params and tonumber(params) then
			for i = 1, params do
				Isaac.GetPlayer():AnimateSad()
			end
		else
			Isaac.GetPlayer():AnimateSad()
		end
	elseif cmd == "friendfinderfftest" then
		local player = Isaac.GetPlayer()
		player:UseActiveItem(CollectibleType.COLLECTIBLE_FRIEND_FINDER, UseFlag.USE_NOANIM)
		mod.scheduleForUpdate(function()
			for index,entity in ipairs(Isaac.FindInRadius(player.Position, 50, EntityPartition.ENEMY)) do
				if entity.FrameCount < 2 then
					entity:ToNPC():Morph(mod.FF.Slammer.ID, mod.FF.Slammer.Var,0,-1)
				end
			end
		end, 1)
	end
	mod:erflyCommandShit(cmd, params)
end

mod:AddCallback(ModCallbacks.MC_EXECUTE_CMD, mod.FFCommands)

--Functions
function mod:intercept(npc, target, v)
	local newtarget = target.Position + target.Velocity*5
	local tx = newtarget.X - npc.Position.X
	local ty = newtarget.Y - npc.Position.Y
	local tvx = target.Velocity.X
	local tvy = target.Velocity.Y

  -- Get quadratic equation components
	local a = tvx*tvx + tvy*tvy - v*v
	local b = 2 * (tvx * tx + tvy * ty)
	local c = tx*tx + ty*ty

  -- Solve quadratic
	local ts = mod:quadratic(a, b, c) --See quad(), below

  -- Find smallest positive solution
	local sol = target.Position
	if ts then
		local t0 = ts[1]
		local t1 = ts[2]
		local t = math.min(t0, t1)
		if (t < 0) then
			t = math.max(t0, t1)
		end
		if (t > 0) then
			sol = Vector((tx + tvx*t),(ty + tvy*t))
		end
	end

  return sol
end

-- Return solutions for quadratic
function mod:quadratic(a, b, c)
  local sqr_delta = math.sqrt(b * b - 4 * a * c)
  local two_a = 2 * a
  return {(-b + sqr_delta)/two_a, (-b - sqr_delta)/two_a}
end

--Round
function mod:LuaRound(num, numDecimalPlaces)
  local mult = 10^(numDecimalPlaces or 0)
  return math.floor(num * mult + 0.5) / mult
end

local toRadians = math.pi / 180
function mod:PointOnEllipse(width,height,angle,rotation)
	angle, rotation = angle * toRadians, rotation * toRadians
	local x = width * math.cos(angle) * math.cos(rotation) - height * math.sin(angle) * math.sin(rotation)
	local y = width * math.cos(angle) * math.sin(rotation) + height * math.sin(angle) * math.cos(rotation)
	return Vector(x, y)
end

function mod:AngleDifference(a1, a2)
	local sub = a1 - a2
	return (sub + 180) % 360 - 180
end

function mod:anyPlayerIsEitherKeeper()
	for i = 1, game:GetNumPlayers() do
		local player = Isaac.GetPlayer(i - 1)

		if (player:GetPlayerType() == PlayerType.PLAYER_KEEPER_B or player:GetPlayerType() == PlayerType.PLAYER_KEEPER) and not player:IsCoopGhost() then
			return true
		end
	end

	return false
end

function mod:anyPlayerIsBKeeper()
	for i = 1, game:GetNumPlayers() do
		local player = Isaac.GetPlayer(i - 1)

		if player:GetPlayerType() == PlayerType.PLAYER_KEEPER_B and not player:IsCoopGhost() then
			return true
		end
	end

	return false
end

function mod:allPlayersAreKeeper()
	for i = 1, game:GetNumPlayers() do
		local player = Isaac.GetPlayer(i - 1)

		if player:GetPlayerType() ~= PlayerType.PLAYER_KEEPER_B and player:GetPlayerType() ~= PlayerType.PLAYER_KEEPER then
			return false
		end
	end

	return true
end

function mod:allPlayersAreBBlueBaby()
	for i = 1, game:GetNumPlayers() do
		local player = Isaac.GetPlayer(i - 1)

		if player:GetPlayerType() ~= PlayerType.PLAYER_XXX_B then
			return false
		end
	end

	return true
end

function mod:isSuperpositionedPlayer(player)
	if player then
		local playertype = player:GetPlayerType()
		if playertype == PlayerType.PLAYER_LAZARUS_B or playertype == PlayerType.PLAYER_LAZARUS2_B then
			if player:HasCollectible(CollectibleType.COLLECTIBLE_BIRTHRIGHT) or
			   (player:GetOtherTwin() and player:GetOtherTwin():HasCollectible(CollectibleType.COLLECTIBLE_BIRTHRIGHT))
			then
				local maintwin = player:GetMainTwin()
				if maintwin.Index ~= player.Index or maintwin.InitSeed ~= player.InitSeed then
					return true
				end
			end
		end
	end
	return false
end

function mod:isKingBabyAParent(entity, returnTarget)
	if entity and entity.Parent then
		while entity.Parent do
			entity = entity.Parent
			if entity.Type == 3 and entity.Variant == FamiliarVariant.KING_BABY then
				if returnTarget then
					return entity.Target
				else
					return entity
				end
			end
		end
	end
	return false
end

function mod:isSirenCharmed(familiar)
	local helpers = Isaac.FindByType(EntityType.ENTITY_SIREN_HELPER, -1, -1, true)
	for _, helper in ipairs(helpers) do
		if helper.Target and helper.Target.Index == familiar.Index and helper.Target.InitSeed == familiar.InitSeed then
			return true, helper
		end
	end
	return false, nil
end

--Prevent Siren from targeting certain familiars
local hiddenFromSiren = {}
local addedSirenHidingCallback = false -- So it runs after everything else that could possibly stop the post npc update callback
mod:AddCallback(ModCallbacks.MC_POST_UPDATE, function()
	if not addedSirenHidingCallback then
		mod:AddCallback(ModCallbacks.MC_PRE_NPC_UPDATE, function(_, siren)
			local petrocks = Isaac.FindByType(EntityType.ENTITY_FAMILIAR, FamiliarVariant.PETROCK)
			for _,petrock in ipairs(petrocks) do
				if not petrock.Visible then
					petrock:AddEntityFlags(EntityFlag.FLAG_NO_QUERY)
					table.insert(hiddenFromSiren, petrock)
				end
			end

			local sneks = Isaac.FindByType(EntityType.ENTITY_FAMILIAR, FamiliarVariant.OPHIUCHUS)
			for _,snek in ipairs(sneks) do
				if snek.SubType ~= 0 then
					snek:AddEntityFlags(EntityFlag.FLAG_NO_QUERY)
					table.insert(hiddenFromSiren, snek)
				end
			end

			local grabbers = Isaac.FindByType(EntityType.ENTITY_FAMILIAR, FamiliarVariant.GRABBER)
			for _,grabber in ipairs(grabbers) do
				if grabber.SubType == 1 or grabber.SubType == 2 then
					grabber:AddEntityFlags(EntityFlag.FLAG_NO_QUERY)
					table.insert(hiddenFromSiren, grabber)
				end
			end

			local skuzzes = Isaac.FindByType(EntityType.ENTITY_FAMILIAR, FamiliarVariant.ATTACK_SKUZZ)
			for _,skuzz in ipairs(skuzzes) do
				skuzz:AddEntityFlags(EntityFlag.FLAG_NO_QUERY)
				table.insert(hiddenFromSiren, skuzz)
			end
		end, EntityType.ENTITY_SIREN)
		addedSirenHidingCallback = true
	end
end)

mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, function(_, siren)
	for _,familiar in ipairs(hiddenFromSiren) do
		familiar:ClearEntityFlags(EntityFlag.FLAG_NO_QUERY)
	end
	hiddenFromSiren = {}
end, EntityType.ENTITY_SIREN)

function mod:getClosestPlayer(pos, dist, seedPass)
	local closestDist = dist + 1
	local closestPlayer = nil

	for i = 1, game:GetNumPlayers() do
		local player = Isaac.GetPlayer(i - 1)
		local playerPosition = player.Position

		if (playerPosition - pos):Length() < closestDist and seedPass ~= player.InitSeed then
			closestDist = (playerPosition - pos):Length()
			closestPlayer = player
		end
	end

	return closestPlayer
end

function mod:isCollidingWithPlayer(e, extraRad)
	for i = 1, game:GetNumPlayers() do
		if (player.Position - e.Position):Length() <= player.Size + e.Size + (extraRad or 0) then
			return true
		end
	end

	return false
end

------------------------------------------------------

--StageID first,
mod.stageIDbackdropID = {
	["Scarred Womb"] = 	{StageID = 12, Backdrops = {12}},
	["Downpour"] = 	{StageID = 27, Backdrops = {31, 36}},
	["Dross"] = 	{StageID = 28, Backdrops = {45}},
	["Mines"] = 	{StageID = 29, Backdrops = {32, 58}},
	["Ashpit"] = 	{StageID = 30, Backdrops = {46, 59}},
	["Maus"] = 		{StageID = 31, Backdrops = {33, 38, 40, 41, 42}}, --Extra :)
	["Mausoleum"] = {StageID = 31, Backdrops = {33, 38, 40, 41, 42}},
	["Gehenna"] = 	{StageID = 32, Backdrops = {47}},
	["Corpse"] = 	{StageID = 33, Backdrops = {34, 39, 43, 44, 56}}
}

function mod.isBackdrop(floorName)
	local level = Game():GetLevel()
	local currentStageID = level:GetRoomByIdx(level:QueryRoomTypeIndex(RoomType.ROOM_DEFAULT,nil,RNG())).Data.StageID
	if mod.stageIDbackdropID[floorName].StageID == currentStageID then
		return true
	end

	local backdropID = Game():GetRoom():GetBackdropType()
	if mod.stageIDbackdropID[floorName] then
		for i = 1, #mod.stageIDbackdropID[floorName].Backdrops do
			if backdropID == mod.stageIDbackdropID[floorName].Backdrops[i] then
				return true
			end
		end
	end
end

local redHearts = {
	[HeartSubType.HEART_BLENDED] = true,
	[HeartSubType.HEART_HALF] = true,
	[HeartSubType.HEART_FULL] = true,
	[HeartSubType.HEART_DOUBLEPACK] = true,
	[HeartSubType.HEART_SCARED] = true
}

local soulHearts = {
	[HeartSubType.HEART_SOUL] = true,
	[HeartSubType.HEART_HALF_SOUL] = true,
	[HeartSubType.HEART_BLENDED] = true,
}

function mod.CanPurchasePickup(player, pickup)
	if pickup.Variant == PickupVariant.PICKUP_HEART then
		local isPickableRed = player:CanPickRedHearts() and redHearts[pickup.SubType]
		local isPickableSoul = player:CanPickSoulHearts() and soulHearts[pickup.SubType]
		local isPickableBone = player:CanPickBoneHearts() and pickup.SubType == HeartSubType.HEART_BONE
		local isPickableBlack = player:CanPickBlackHearts() and pickup.SubType == HeartSubType.HEART_BLACK
		local isPickableGolden = player:CanPickGoldenHearts() and pickup.SubType == HeartSubType.HEART_GOLDEN
		if (redHearts[pickup.SubType] or soulHearts[pickup.SubType] or pickup.SubType == HeartSubType.HEART_BONE or pickup.SubType == HeartSubType.HEART_BLACK or pickup.SubType == HeartSubType.HEART_GOLDEN)
		and not (isPickableRed or isPickableSoul or isPickableBone or isPickableBlack or isPickableGolden) then
			return false
		end
	elseif pickup.Variant == PickupVariant.PICKUP_LIL_BATTERY and not player:NeedsCharge() then
		return false
	elseif pickup.Variant == PickupVariant.PICKUP_FIENDFOLIO_HALF_BLACK_HEART and not player:CanPickBlackHearts() then
		return false
	elseif (pickup.Variant == PickupVariant.PICKUP_IMMORAL_HEART or pickup.Variant == PickupVariant.PICKUP_HALF_IMMORAL_HEART) and not mod:CanPickImmoralHearts(player) then
		return false
	elseif pickup.Variant == PickupVariant.PICKUP_TRINKET then
		if player:HasTrinket(pickup.SubType) then
			return false
		elseif player:GetMaxTrinkets() == 1 and player:GetTrinket(0) == TrinketType.TRINKET_TICK then
			return false
		end
	end

	return true
end

function mod.IsRevelationsStage()
	if REVEL and REVEL.STAGE then
		if REVEL.STAGE.Glacier and REVEL.STAGE.Glacier:IsStage() then
			return true
		elseif REVEL.STAGE.Tomb and REVEL.STAGE.Tomb:IsStage() then
			return true
		elseif REVEL.STAGE.Vestige and REVEL.STAGE.Vestige:IsStage() then
			return true
		else
			return false
		end
	else
		return false
	end
end

function mod.GatherGrids()
	local room = game:GetRoom()
	mod.RoomGrids = {}

	for i = 0, room:GetGridSize() do
		local g = room:GetGridEntity(i)
		if g then
			local typ = g:GetType()
			if g.CollisionClass ~= GridCollisionClass.COLLISION_NONE then
				mod.RoomGrids[typ] = mod.RoomGrids[typ] or {}
				mod.RoomGrids[typ][#mod.RoomGrids[typ] + 1] = g
			end
		end
	end
end

function mod.GetPoopSpritesheet(poop)
	local var = poop:GetVariant()
	if var == 0 then
		return "gfx/grid/grid_poop_"..math.random(3)..".png"
	elseif var == 1 then
		return "gfx/grid/grid_poop_red_"..math.random(3)..".png"
	elseif var == 2 then
		return "gfx/grid/grid_poop_corn.png"
	elseif var == 3 then
		return "gfx/grid/grid_poop_gold.png"
	elseif var == 4 then
		return "gfx/grid/grid_poop_rainbow.png"
	elseif var == 5 then
		return "gfx/grid/grid_poop_black.png"
	elseif var == 6 then
		return "gfx/grid/grid_poop_white_"..math.random(3)..".png"
	elseif var == 11 then
		return "gfx/grid/grid_poop_charming.png"
	end
end

function mod:getCrawlspaceBackdropSuffix()
	local suffix = "default"
	if mod.roomBackdrop == 50 or #Isaac.FindByType(mod.FF.BackdropReplacer.ID, mod.FF.BackdropReplacer.Var, 50) > 0 then
		suffix = "luscious"
	elseif mod.roomBackdrop == 51 or #Isaac.FindByType(mod.FF.BackdropReplacer.ID, mod.FF.BackdropReplacer.Var, 51) > 0 then
		suffix = "ossuary"
	elseif mod.roomBackdrop == 52 or #Isaac.FindByType(mod.FF.BackdropReplacer.ID, mod.FF.BackdropReplacer.Var, 52) > 0 then
		suffix = "pipes"
	elseif mod.roomBackdrop == 53 or #Isaac.FindByType(mod.FF.BackdropReplacer.ID, mod.FF.BackdropReplacer.Var, 53) > 0 then
		suffix = "creature"
	elseif mod.roomBackdrop == 54 or #Isaac.FindByType(mod.FF.BackdropReplacer.ID, mod.FF.BackdropReplacer.Var, 54) > 0 then
		suffix = "fortress"
	elseif mod.roomBackdrop == 55 or #Isaac.FindByType(mod.FF.BackdropReplacer.ID, mod.FF.BackdropReplacer.Var, 55) > 0 then
		suffix = "insulation"
	end
return suffix
end

local newANM2DungeonRocks = {
	[GridEntityType.GRID_ROCK] = true,
	[GridEntityType.GRID_ROCK_ALT] = true,
	[GridEntityType.GRID_ROCK_BOMB] = true,
	[GridEntityType.GRID_ROCKT] = true,
	[GridEntityType.GRID_ROCK_SS] = true,
	[GridEntityType.GRID_ROCK_SPIKED] = true,
	[GridEntityType.GRID_ROCK_GOLD] = true,
	[GridEntityType.GRID_PILLAR] = true,
	[GridEntityType.GRID_ROCK_ALT2] = true,
}

function mod.ExtraCrawlspaceGfx()
	local room = game:GetRoom()
	if StageAPI then
		if room:GetType() == RoomType.ROOM_DUNGEON then
			local e
			for i = 0, room:GetGridSize() do
				local g = room:GetGridEntity(i)

				if g then
					local gt = g:GetType()

					local suffix = mod:getCrawlspaceBackdropSuffix()
					if newANM2DungeonRocks[gt] then
						if not StageAPI.IsCustomGrid(i, "FFRubberRock") then
							local sprite = g:GetSprite()
							sprite:Load("gfx/grid/grid_rock_crawlspace.anm2")
							local frame = g.Desc.Variant
							local rockString = "_" .. suffix
							if rockString == "_default" or rockString == "_creature" or rockString == "_pipes" then 
								rockString = ""
							end
							sprite:ReplaceSpritesheet(0, "gfx/grid/rocks_crawlspace" .. rockString .. ".png")
							sprite:LoadGraphics()
							--print(gt, g.Desc.Variant)
							if gt == GridEntityType.GRID_ROCK_BOMB then
								sprite:SetFrame("bombrock", 0, true)
							elseif gt == GridEntityType.GRID_ROCKT then
								sprite:SetFrame("tinted", 0, true)
							elseif gt == GridEntityType.GRID_ROCK_SS then
								sprite:SetFrame("superspecial", 0, true)
							elseif gt == GridEntityType.GRID_ROCK_ALT then
								--print(g.Desc.Variant)
								sprite:SetFrame("alt", frame, true)
							elseif gt == GridEntityType.GRID_ROCK_SPIKED then
								if g.Desc.State == 4 then
									sprite:SetFrame("spiked_retracted", frame, true)
								else
									sprite:SetFrame("spiked", frame, true)
								end
							elseif gt == GridEntityType.GRID_ROCK_GOLD then
								sprite:SetFrame("foolsgold", frame, true)
							elseif gt == GridEntityType.GRID_PILLAR then
								sprite:SetFrame("pillar", frame, true)
							elseif gt == GridEntityType.GRID_ROCK_ALT2 then
								sprite:SetFrame("alt2", 0, true)
							elseif frame >= 1000 then
								sprite:SetFrame("big", frame, true)
							else
								sprite:SetFrame("normal", frame, true)
							end
							--sprite:Play(anim, true)
							--sprite:SetFrame(anim, frame, true)
							--sprite:LoadGraphics()
						end
					end

					if FiendFolio.RequiresRocktops[g:GetType()] and 
					   not StageAPI.IsCustomGrid(i, "FFRubberRock") 
					then
						local g2 = room:GetGridEntityFromPos(g.Position + Vector(0, -40))
						if g2:GetType() == GridEntityType.GRID_GRAVITY then
							e = Isaac.Spawn(1000, Isaac.GetEntityVariantByName("Crawlspace Rocktop"), 0, g.Position + Vector(0, -80), nilvector, nil)
							e:GetData().myrock = g
							e.PositionOffset = Vector(0, 40)

							local esprite = e:GetSprite()
							esprite:ReplaceSpritesheet(0, "gfx/grid/rocktop grids/rocktop_" .. suffix .. ".png")
							esprite:LoadGraphics()
						end
					end
				end
			end

			for i = 0, room:GetGridSize() do
				local g = room:GetGridEntity(i)

				if g then
					local gt = g:GetType()

					local suffix = mod:getCrawlspaceBackdropSuffix()

					local perch = room:GetGridEntityFromPos(g.Position + Vector(0, 40))
					local perchtype = perch and perch:GetType()
					local rocktop = perch and FiendFolio.RequiresRocktops[perchtype] and not StageAPI.IsCustomGrid(perch:GetGridIndex(), "FFRubberRock")

					local perchify
					local perchable = perch and 
					                  not mod.IsKeyBlock(perch) and
					                  (perchtype == GridEntityType.GRID_DOOR or 
					                   perchtype == GridEntityType.GRID_WALL or 
					                   perchtype == GridEntityType.GRID_ROCKB or 
					                   rocktop)

					if perchable then
						if gt == GridEntityType.GRID_TNT then
							local gridRerenderer = Isaac.Spawn(1000, Isaac.GetEntityVariantByName("Crawlspace Grid Rerenderer"), 0, g.Position, nilvector, nil)
							gridRerenderer:GetData().GridIndex = i
							
							local gridsprite = g:GetSprite()
							gridsprite:Load("gfx/grid/crawlspace_tnt.anm2")
							gridsprite:ReplaceSpritesheet(0, "gfx/grid/blank.png")
							gridsprite:ReplaceSpritesheet(2, "gfx/grid/blank.png")
							gridsprite:LoadGraphics()
							
							local rendersprite = gridRerenderer:GetSprite()
							rendersprite:Load("gfx/grid/crawlspace_tnt.anm2")
							
							if rocktop then
								rendersprite:ReplaceSpritesheet(2, "gfx/grid/rocktop grids/rocktop_" .. suffix .. ".png")
								gridRerenderer:GetData().Rocktop = true
							else
								rendersprite:ReplaceSpritesheet(2, "gfx/grid/rocktop grids/tiletop_" .. suffix .. ".png")
								perchify = true
							end
							
							rendersprite:LoadGraphics()
							
							gridRerenderer:Update()
						elseif gt == GridEntityType.GRID_POOP then
							local gridRerenderer = Isaac.Spawn(1000, Isaac.GetEntityVariantByName("Crawlspace Grid Rerenderer"), 0, g.Position, nilvector, nil)
							gridRerenderer:GetData().GridIndex = i
							
							local gridsprite = g:GetSprite()
							gridsprite:Load("gfx/grid/crawlspace_poop.anm2")
							gridsprite:ReplaceSpritesheet(0, "gfx/grid/blank.png")
							gridsprite:ReplaceSpritesheet(1, "gfx/grid/blank.png")
							gridsprite:ReplaceSpritesheet(2, "gfx/grid/blank.png")
							gridsprite:LoadGraphics()
							
							local rendersprite = gridRerenderer:GetSprite()
							rendersprite:Load("gfx/grid/crawlspace_poop.anm2")

							rendersprite:ReplaceSpritesheet(0, mod.GetPoopSpritesheet(g))

							if rocktop then
								rendersprite:ReplaceSpritesheet(2, "gfx/grid/rocktop grids/rocktop_" .. suffix .. ".png")
								gridRerenderer:GetData().Rocktop = true
							else
								rendersprite:ReplaceSpritesheet(2, "gfx/grid/rocktop grids/tiletop_" .. suffix .. ".png")

								perchify = true
							end
							
							rendersprite:LoadGraphics()
							
							local stateanim = "State"..g.Desc.State
							if stateanim == "State0" then stateanim = "State1" end
							gridsprite:Play(stateanim, true)
							gridRerenderer:Update()
						elseif StageAPI.IsCustomGrid(i, "FFRubberRock") then
							local gridRerenderer = Isaac.Spawn(1000, Isaac.GetEntityVariantByName("Crawlspace Grid Rerenderer"), 0, g.Position, nilvector, nil)
							gridRerenderer:GetData().GridIndex = i
							
							local gridsprite = g:GetSprite()
							gridsprite:ReplaceSpritesheet(0, "gfx/grid/grid_rubber_rock_gibs_only.png")
							gridsprite:ReplaceSpritesheet(2, "gfx/grid/blank.png")
							gridsprite:LoadGraphics()
							
							local rendersprite = gridRerenderer:GetSprite()
							rendersprite:Load("gfx/grid/grid_rubber_rock.anm2")
							
							if rocktop then
								rendersprite:ReplaceSpritesheet(2, "gfx/grid/rocktop grids/rocktop_" .. suffix .. ".png")
								gridRerenderer:GetData().Rocktop = true
							else
								rendersprite:ReplaceSpritesheet(2, "gfx/grid/rocktop grids/tiletop_" .. suffix .. ".png")
								perchify = true
							end
							
							rendersprite:LoadGraphics()
							
							gridRerenderer:Update()
						elseif mod.IsKeyBlock(g) then
							local gridRerenderer = Isaac.Spawn(1000, Isaac.GetEntityVariantByName("Crawlspace Grid Rerenderer"), 0, g.Position, nilvector, nil)
							gridRerenderer:GetData().GridIndex = i
							
							local gridsprite = g:GetSprite()
							gridsprite:ReplaceSpritesheet(0, "gfx/grid/blank.png")
							gridsprite:ReplaceSpritesheet(1, "gfx/grid/blank.png")
							gridsprite:ReplaceSpritesheet(2, "gfx/grid/blank.png")
							gridsprite:LoadGraphics()
							
							local rendersprite = gridRerenderer:GetSprite()
							rendersprite:Load(gridsprite:GetFilename())
							
							if rocktop then
								rendersprite:ReplaceSpritesheet(1, "gfx/grid/rocktop grids/rocktop_" .. suffix .. ".png")
								gridRerenderer:GetData().Rocktop = true
							else
								rendersprite:ReplaceSpritesheet(1, "gfx/grid/rocktop grids/tiletop_" .. suffix .. ".png")
								perchify = true
							end
							
							local g3 = room:GetGridEntityFromPos(g.Position + Vector(0, -40))
							if g3:GetType() == GridEntityType.GRID_GRAVITY then
								rendersprite:ReplaceSpritesheet(2, "gfx/grid/rocktop grids/top_hider.png")
							end
							
							rendersprite:LoadGraphics()
							
							gridRerenderer:GetData().WasKeyBlock = true
							gridRerenderer:Update()
						end
					end

					if perchify then
						local tilesprite = perch:GetSprite()
						tilesprite:Load("gfx/grid/tiles_itemdungeon.anm2", true)
						tilesprite:Play("Brick"..math.random(3))
					end
				end
			end
		end
	end
end

------------------------------------------------------------------------------------------------------------------

--Floor thing rewrite that never got used
mod.FloorSkins = {
	Default = {
		Basement = 			"_dirt",
		Cellar = 			"_dirt",
		Burning = 			"_dirt",
		Caves = 			"_dirt",
		Catacombs = 		"_dirt",
		Flooded = 			"_flooded",
		Depths = 			"_gray",
		Necropolis = 		"_dark",
		Dank = 				"_gray",
		Womb = 				"_womb",
		Utero = 			"_womb",
		Scarred = 			"_womb",
		Blue = 				"_blue",
		Cathederal = 		"_flooded",
		Sheol = 			"_black",
		Chest = 			"_dirt",
		Dark = 				"_black",
	}
}

----------------------------------------------------------------------------------------------------


mod.DirtPaths = {
"_dirt",		-- 1
"_womb",		-- 2
"_scarred",		-- 3
"_flooded",		-- 4
"_blue",		-- 5
"_dark",		-- 6
"_gray",		-- 7
"_black",		-- 8
}

----------------------------------------------------------------------------------------------------

mod:AddCallback(ModCallbacks.MC_ENTITY_TAKE_DMG, function(_, entity, amount, flags, source, cooldown)
	-- I just really needed this to happen first and there are like 40 MC_ENTITY_TAKE_DAMAGE callbacks in this damn mod

	if source.Type == mod.FF.CaveSpider.ID and source.Variant == mod.FF.CaveSpider.Var then
		if mod.WillDamageBeFatal(entity:ToPlayer(), amount, flags, true, true) then
			return false
		end
	end

end, EntityType.ENTITY_PLAYER)

-----------------------------------------------------------
-- Enemy Death Animations
-----------------------------------------------------------

local bkeeperKilledThisRoom = 0
mod:AddCallback(ModCallbacks.MC_POST_NEW_ROOM, function()
	bkeeperKilledThisRoom = 0
	mod.fiendImmoralSpawnOnSpawnedChance = 2
end)

mod:AddCallback(ModCallbacks.MC_POST_ENTITY_KILL, function(_, entity)
	if entity:ToNPC() and not entity:HasEntityFlags(EntityFlag.FLAG_NO_REWARD) then
		bkeeperKilledThisRoom = bkeeperKilledThisRoom + 1
	end
end)

mod:AddCallback(ModCallbacks.MC_POST_NPC_INIT, function(_, npc)
	npc:GetData().SpawnedAtRoomStart = game:GetRoom():GetFrameCount() == -1
end)

function mod:spawnBKeeperCoin(entity, increment)
	if increment then
		bkeeperKilledThisRoom = bkeeperKilledThisRoom + 1
	end

	if mod:anyPlayerIsBKeeper() and not entity:HasEntityFlags(EntityFlag.FLAG_NO_REWARD) then
		local rng = RNG()
		rng:SetSeed(entity.InitSeed, 0)

		if entity:GetData().SpawnedAtRoomStart or rng:RandomFloat() <= 1 / math.max(bkeeperKilledThisRoom, 1) then
			local coin = Isaac.Spawn(EntityType.ENTITY_PICKUP, PickupVariant.PICKUP_COIN, 0, entity.Position, RandomVector() * (math.random() + 3), nil):ToPickup()
			coin.Timeout = 60
		end
	end
end

function mod:spawnVadeRetroGhost(entity)
	for i = 1, game:GetNumPlayers() do
		local player = Isaac.GetPlayer(i - 1)
		if player:HasCollectible(CollectibleType.COLLECTIBLE_VADE_RETRO) and not entity:HasEntityFlags(EntityFlag.FLAG_NO_REWARD) then
			local ghost = Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.ENEMY_GHOST, 0, entity.Position, Vector(8,0):Rotated(math.random() * 360), player)
			ghost.CollisionDamage = 3 + 0.04 * entity.MaxHitPoints
			return
		end
	end
end

function mod:grabbedByBigHorn(npc)
	local bigHornHands = Isaac.FindByType(EntityType.ENTITY_EFFECT, EffectVariant.BIG_HORN_HAND)
	for _, hand in ipairs(bigHornHands) do
		if hand.Target and hand.Target.InitSeed == npc.InitSeed and hand.Target.Index == npc.Index then
			return true
		end
	end

	return false
end

FiendFolio.EnemyOnDeath = {}
FiendFolio.EnemyOnDeath.DeathAnims = {} -- Defined at the bottom of main
FiendFolio.EnemyOnDeath.SkulltistEffects = {} -- Defined at the bottom of main

function mod:basicDeathAnimation(npc, deathAnimName, dropsBeforeAnim)
	--[[npc.State = 17
	npc:GetSprite():Play(deathAnimName, true)
	npc:GetData().FFIsDeathAnimation = true
	npc.Velocity = Vector.Zero]]--

	local onCustomDeath = function(npc, deathAnim)
		deathAnim:GetData().FFBasicDeath = true
		deathAnim.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_NONE
		deathAnim.SplatColor = Color.Lerp(npc.SplatColor, Color(1,1,1,1,0,0,0), 0)
	end

	mod.genericCustomDeathAnim(npc, deathAnimName, nil, onCustomDeath, nil, nil, nil, dropsBeforeAnim)
end

mod:AddCallback(ModCallbacks.MC_PRE_NPC_UPDATE, function(_, npc)
	if npc:GetData().FFBasicDeath then
		npc.Velocity = nilvector
		local sprite = npc:GetSprite()
		local npcdata = npc:GetData()
		if sprite:IsEventTriggered("Explosion") or sprite:IsEventTriggered("explode") then
			npc:BloodExplode()
		end
		if sprite:IsEventTriggered("BloodStart") or sprite:IsEventTriggered("bloodstart") then
			npcdata.bleeding = true
		end
		if sprite:IsEventTriggered("BloodEnd") or sprite:IsEventTriggered("bloodend") then
			npcdata.bleeding = false
		end
		if npcdata.bleeding then
			if npc.FrameCount % 4 == 0 then
				local blood = Isaac.Spawn(1000, 5, 0, npc.Position, RandomVector()*3, npc):ToEffect();
				blood.Color = npc.SplatColor
				blood.SplatColor = npc.SplatColor
				blood:Update()

				local bloo2 = Isaac.Spawn(1000, 2, 0, npc.Position, RandomVector()*3, npc):ToEffect();
				bloo2.Color = npc.SplatColor
				bloo2.SplatColor = npc.SplatColor
				bloo2.SpriteScale = Vector(1,1)
				bloo2.SpriteOffset = Vector(-3+math.random(14), -45+math.random(40))
				bloo2:Update()

				npc:PlaySound(SoundEffect.SOUND_MEAT_JUMPS,0.2,0,false,0.8)
			end
		end
		if sprite:IsFinished(sprite:GetAnimation()) then
			if npcdata.FFPreventDeathDrops then
				npc:Remove()
			else
				local splatoon = Color.Lerp(npc.SplatColor, Color(1,1,1,1,0,0,0), 0)
				npc.SplatColor = Color(1,1,1,0,0,0,0)
				npc:Die()
				npc.SplatColor = splatoon
			end
		end
		return true
	end
end)

function mod.genericCustomDeathAnim(npc, animName, canShutDoors, miscFunc, canCollide, hasKnockback, isDeathAnim, dropsBeforeAnim)
	local deathAnim = Isaac.Spawn(npc.Type, npc.Variant, npc.SubType, npc.Position, nilvector, nil):ToNPC()
	if npc:GetChampionColorIdx() >= 0 then
		deathAnim:MakeChampion(0, npc:GetChampionColorIdx())
	end
	--deathAnim.HitPoints = 0
	--deathAnim.MaxHitPoints = 0
	deathAnim:ClearEntityFlags(EntityFlag.FLAG_APPEAR)

	local deathAnimData = deathAnim:GetData()
	if isDeathAnim ~= nil then
		deathAnimData.FFIsDeathAnimation = isDeathAnim
	else
		deathAnimData.FFIsDeathAnimation = true
	end

	local deathAnimSprite = deathAnim:GetSprite()
	if animName ~= nil then deathAnimSprite:Play(animName, true) end
	deathAnimSprite.Offset = npc:GetSprite().Offset
	deathAnimSprite.FlipX = npc:GetSprite().FlipX

	if not canCollide then deathAnim.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE end
	if canShutDoors ~= nil then deathAnim.CanShutDoors = canShutDoors end
	if not hasKnockback then deathAnim:AddEntityFlags(EntityFlag.FLAG_NO_KNOCKBACK | EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK) end
	deathAnim:AddEntityFlags(EntityFlag.FLAG_NO_STATUS_EFFECTS | EntityFlag.FLAG_HIDE_HP_BAR | EntityFlag.FLAG_NO_TARGET)

	if (npc:HasEntityFlags(EntityFlag.FLAG_FRIENDLY)) then
		deathAnim:AddEntityFlags(EntityFlag.FLAG_FRIENDLY)
	end

	if miscFunc then miscFunc(npc, deathAnim) end

	if dropsBeforeAnim then
		npc:GetData().FFPreventDeathDrops = false
		deathAnim:GetData().FFPreventDeathDrops = true
	else
		npc:GetData().FFPreventDeathDrops = true
		deathAnim:GetData().FFPreventDeathDrops = false
	end
	npc.Visible = false
end

mod:AddCallback(ModCallbacks.MC_POST_ENTITY_KILL, function(_, entity)
	if not entity:ToNPC() then
		return
	end
	local npc = entity:ToNPC()

	mod:empathOnEnemyDeath(entity)

	if (entity.Type == mod.FF.PsychoFly.ID and entity.Variant == mod.FF.PsychoFly.Var) or
	   (entity.Type == mod.FF.ManicFly.ID and entity.Variant == mod.FF.ManicFly.Var)
	then
		mod.triggerPsychoManicFlies(npc)
	end

	if npc:GetData().SkulltistVictim then
		for _, effects in pairs(FiendFolio.EnemyOnDeath.SkulltistEffects) do
			if effects.ID == entity.Type and
			   (effects.Var == entity.Variant or effects.Var == -1 or effects.Var == nil) and
			   (effects.Sub == entity.SubType or effects.Sub == -1 or effects.Sub == nil)
			then
				if effects.EffectFunc then
					effects.EffectFunc(npc)
				end

				break
			end
		end
	end

	if not (npc:HasEntityFlags(EntityFlag.FLAG_FREEZE) or
			npc:HasEntityFlags(EntityFlag.FLAG_MIDAS_FREEZE) or
			mod:isStatusCorpse(npc) or
			mod:isLeavingStatusCorpse(npc) or
			npc:GetChampionColorIdx() == 12 or
			mod:grabbedByBigHorn(npc))
	then
		if not (npc:GetData().FFIsDeathAnimation or
				npc:GetData().SkulltistVictim)
		then
			for _, anims in pairs(FiendFolio.EnemyOnDeath.DeathAnims) do
				if anims.ID == entity.Type and
				   (anims.Var == entity.Variant or anims.Var == -1 or anims.Var == nil) and
				   (anims.Sub == entity.SubType or anims.Sub == -1 or anims.Sub == nil)
				then
					if anims.BasicAnimName then
						mod:basicDeathAnimation(npc, anims.BasicAnimName, anims.DropsBeforeAnim)
					elseif anims.CustomAnimFunc then
						anims.CustomAnimFunc(npc)
					end

					break
				end
			end
		end

		if npc:GetData().FFIsDeathAnimation or npc:GetData().rocktime then
			if npc.Type == mod.FF.FossilBoomFly.ID and
			   npc.Variant == mod.FF.FossilBoomFly.Var
			then
				mod.fossilizedBoomFlyDeathEffect(npc)
			end
		end

		if npc:GetData().FFPreventDeathDrops then
			npc:Remove()
		end
	end
end)

--[[function mod:erflyDeathAnimEnd(ent)
	local npc = ent:ToNPC()
	local data = npc:GetData()

	if not (npc:HasEntityFlags(EntityFlag.FLAG_FREEZE) or
			npc:HasEntityFlags(EntityFlag.FLAG_MIDAS_FREEZE) or
			mod:isStatusCorpse(npc) or
			mod:isLeavingStatusCorpse(npc) or
			mod:grabbedByBigHorn(npc))
	then
		mod:spawnBKeeperCoin(npc, increment)
		mod:spawnVadeRetroGhost(npc)
	end
end]]--

mod:AddCallback(ModCallbacks.MC_ENTITY_TAKE_DMG, function(_, entity, damage, flags, source, countdown)
	if entity:GetData().FFIsDeathAnimation or entity:GetData().SpewTime then
		return false
	end
end)

----------------------------------------------------------------------------------------------------

mod:AddCallback(ModCallbacks.MC_ENTITY_TAKE_DMG, function(_, ent, damage, flags, source, countdown)
	local data = ent:GetData()
	local cloned = flags & DamageFlag.DAMAGE_CLONES ~= 0

	if data.FFStatusIgnoreDamageCallback ~= true and not cloned and ent:ToNPC() then
		local originalDamage = damage
		local newDamage = damage
		local newFlags = flags
		local sendNewDamage = false
		local allowDamageEffects = not mod:isBasegameSegmented(ent) or mod:isBasegameMainSegment(ent) or mod:isBasegameReducedSyncSegment(ent)

		mod:doomOnDamage(ent, data, source)

		local returndata = mod:bruiseOnDamage(data, newDamage, allowDamageEffects)
		newDamage = returndata.newDamage or newDamage
		sendNewDamage = returndata.sendNewDamage or sendNewDamage

		if source.Type == EntityType.ENTITY_TEAR then
			local returndata = mod:modelRocketOnTearDamage(source, newDamage)
			newDamage = returndata.newDamage or newDamage
			sendNewDamage = returndata.sendNewDamage or sendNewDamage
		end

		local returndata = mod:sleepOnDamage(data, newDamage, ent)
		newDamage = returndata.newDamage or newDamage
		sendNewDamage = returndata.sendNewDamage or sendNewDamage
		local hasProccedSleep = returndata.hasProccedSleep or false

		local returndata = mod:berserkOnDamage(data, newDamage, allowDamageEffects)
		newDamage = returndata.newDamage or newDamage
		sendNewDamage = returndata.sendNewDamage or sendNewDamage
		local hasProccedBerserk = returndata.hasProccedBerserk or false

		if source == nil then
			-- do nothing
		elseif source.Type == EntityType.ENTITY_TEAR or
			   (source.Type == EntityType.ENTITY_BOMBDROP and flags == flags | DamageFlag.DAMAGE_EXPLOSION) or
			   (source.Type == EntityType.ENTITY_EFFECT and source.Variant == EffectVariant.PLAYER_CREEP_HOLYWATER_TRAIL) or
			   (source.Type == EntityType.ENTITY_EFFECT and source.Variant == EffectVariant.ROCKET)
		then
			local data = source.Entity:GetData()

			mod:berserkOnApply(ent, source, data)
			mod:hemorragingOnApply(ent, source, data)
			mod:bruiseOnApply(ent, source, data)
			mod:doomOnApply(ent, source, data)
			mod:drowsyOnApply(ent, source, data, hasProccedSleep)
			mod:martyrOnApply(ent, source, data)
			mod:sewnOnApply(ent, source, data)
			mod:multiEuclideanOnApply(ent, source, data)

			--for aquarius?
			mod:fearOnApply(ent, source, data)
			mod:charmOnApply(ent, source, data)
			mod:shrinkOnApply(ent, source, data)
			mod:petrifyOnApply(ent, source, data)

			mod:erflyGenericDamage(source, ent, data)
		elseif source.Type == EntityType.ENTITY_KNIFE and (source.Variant == 0 or source.Variant == 5) then
			local player = mod:getPlayerFromKnife(source.Entity)
			if player ~= nil then
				local secondHandMultiplier = player:GetTrinketMultiplier(TrinketType.TRINKET_SECOND_HAND) + 1
				local hasAppliedBruise = false

				mod:crucifixOnKnifeDamage(player, ent, secondHandMultiplier)
				mod:lawnDartsOnKnifeDamage(player, ent, secondHandMultiplier)
				mod:hypnoRingOnKnifeDamage(player, ent, secondHandMultiplier, hasProccedSleep)
				mod:pinheadOnKnifeDamage(player, ent, secondHandMultiplier)
				mod:toyPianoOnKnifeDamage(player, ent, secondHandMultiplier)
				hasAppliedBruise = mod:rubberBulletsOnKnifeDamage(player, ent, secondHandMultiplier, hasAppliedBruise) or hasAppliedBruise
				hasAppliedBruise = mod:prankCookieRollKnifeEffect(player, ent, source, secondHandMultiplier, hasAppliedBruise, hasProccedSleep) or hasAppliedBruise
				mod:warmGeodeKnife(player, ent, secondHandMultiplier)
				mod:fragmentedOnyxOnKnifeDamage(player, ent, secondHandMultiplier)
				mod:sheepRockOnKnifeDamage(player, ent, secondHandMultiplier)
				mod:trippyFossilOnKnifeDamage(player, ent, secondHandMultiplier)
				mod:petrifiedSockOnKnifeDamage(player, ent, secondHandMultiplier)
				mod:fractalGeodeOnKnifeDamage(player, ent, secondHandMultiplier)
				mod:magneticSandOnKnifeDamage(player, ent, secondHandMultiplier)
				mod:erflyOnKnifeDamage(player, ent, secondHandMultiplier)

				local returndata = mod:sandstoneOnKnifeDamage(player, ent, secondHandMultiplier, newDamage)
				newDamage = returndata.newDamage or newDamage
				sendNewDamage = returndata.sendNewDamage or sendNewDamage
				local returndata = mod:rockCandyOnKnifeDamage(player, ent, secondHandMultiplier, newDamage)
				newDamage = returndata.newDamage or newDamage
				sendNewDamage = returndata.sendNewDamage or sendNewDamage
			end
		elseif source.Type == EntityType.ENTITY_PLAYER and flags == flags | DamageFlag.DAMAGE_LASER then
			local player = source.Entity:ToPlayer()
			local secondHandMultiplier = player:GetTrinketMultiplier(TrinketType.TRINKET_SECOND_HAND) + 1
			local hasAppliedBruise = false

			mod:crucifixOnLaserDamage(player, ent, secondHandMultiplier)
			mod:lawnDartsOnLaserDamage(player, ent, secondHandMultiplier)
			mod:hypnoRingOnLaserDamage(player, ent, secondHandMultiplier, hasProccedSleep)
			mod:pinheadOnLaserDamage(player, ent, secondHandMultiplier)
			mod:toyPianoOnLaserDamage(player, ent, secondHandMultiplier)
			hasAppliedBruise = mod:rubberBulletsOnLaserDamage(player, ent, secondHandMultiplier, hasAppliedBruise) or hasAppliedBruise
			hasAppliedBruise = mod:prankCookieRollLaserEffect(player, ent, source, secondHandMultiplier, hasAppliedBruise, hasProccedSleep) or hasAppliedBruise
			mod:warmGeodeLaser(player, ent, secondHandMultiplier)
			mod:fragmentedOnyxOnLaserDamage(player, ent, secondHandMultiplier)
			mod:robotRockOnLaserDamage(player, ent, secondHandMultiplier)
			mod:sheepRockOnLaserDamage(player, ent, secondHandMultiplier)
			mod:trippyFossilOnLaserDamage(player, ent, secondHandMultiplier)
			mod:petrifiedSockOnLaserDamage(player, ent, secondHandMultiplier)
			mod:fractalGeodeOnLaserDamage(player, ent, secondHandMultiplier)
			mod:magneticSandOnLaserDamage(player, ent, secondHandMultiplier)
			mod:erflyOnLaserDamage(player, ent, secondHandMultiplier)

			local returndata = mod:sandstoneOnLaserDamage(player, ent, secondHandMultiplier, newDamage)
			newDamage = returndata.newDamage or newDamage
			sendNewDamage = returndata.sendNewDamage or sendNewDamage
			local returndata = mod:rockCandyOnLaserDamage(player, ent, secondHandMultiplier, newDamage)
			newDamage = returndata.newDamage or newDamage
			sendNewDamage = returndata.sendNewDamage or sendNewDamage
		elseif source.Type == EntityType.ENTITY_EFFECT and source.Variant == EffectVariant.DARK_SNARE then
			if source.Entity and source.Entity.SpawnerEntity and source.Entity.SpawnerEntity.Type == EntityType.ENTITY_PLAYER then
				local player = source.Entity.SpawnerEntity:ToPlayer()
				local secondHandMultiplier = player:GetTrinketMultiplier(TrinketType.TRINKET_SECOND_HAND) + 1
				local hasAppliedBruise = false

				mod:crucifixOnDarkArtsDamage(player, ent, secondHandMultiplier)
				mod:lawnDartsOnDarkArtsDamage(player, ent, secondHandMultiplier)
				mod:hypnoRingOnDarkArtsDamage(player, ent, secondHandMultiplier, hasProccedSleep)
				mod:pinheadOnDarkArtsDamage(player, ent, secondHandMultiplier)
				mod:toyPianoOnDarkArtsDamage(player, ent, secondHandMultiplier)
				hasAppliedBruise = mod:rubberBulletsOnDarkArtsDamage(player, ent, secondHandMultiplier, hasAppliedBruise) or hasAppliedBruise
				hasAppliedBruise = mod:prankCookieRollDarkArtsEffect(player, ent, source, secondHandMultiplier, hasAppliedBruise, hasProccedSleep) or hasAppliedBruise
				mod:warmGeodeDarkArts(player, ent, secondHandMultiplier)
				mod:fragmentedOnyxOnDarkArtsDamage(player, ent, secondHandMultiplier)
				mod:sheepRockOnDarkArtsDamage(player, ent, secondHandMultiplier)
				mod:trippyFossilOnDarkArtsDamage(player, ent, secondHandMultiplier)
				mod:petrifiedSockOnDarkArtsDamage(player, ent, secondHandMultiplier)
				mod:fractalGeodeOnDarkArtsDamage(player, ent, secondHandMultiplier)
				mod:magneticSandOnDarkArtsDamage(player, ent, secondHandMultiplier)
				mod:erflyOnDarkArtsDamage(player, ent, secondHandMultiplier)

				local returndata = mod:sandstoneOnDarkArtsDamage(player, ent, secondHandMultiplier, damage)
				newDamage = returndata.newDamage or newDamage
				sendNewDamage = returndata.sendNewDamage or sendNewDamage
				local returndata = mod:rockCandyOnDarkArtsDamage(player, ent, secondHandMultiplier, damage)
				newDamage = returndata.newDamage or newDamage
				sendNewDamage = returndata.sendNewDamage or sendNewDamage
			end
		elseif source.Type == EntityType.ENTITY_FAMILIAR and source.Variant == FamiliarVariant.ABYSS_LOCUST then
			if source.Entity and source.Entity.SpawnerEntity and source.Entity.SpawnerEntity.Type == EntityType.ENTITY_PLAYER then
				local player = source.Entity.SpawnerEntity:ToPlayer()
				local secondHandMultiplier = player:GetTrinketMultiplier(TrinketType.TRINKET_SECOND_HAND) + 1
				local hasAppliedBruise = false

				mod:crucifixOnLocustDamage(player, source.Entity, ent, secondHandMultiplier)
				mod:lawnDartsOnLocustDamage(player, source.Entity, ent, secondHandMultiplier)
				mod:hypnoRingOnLocustDamage(player, source.Entity, ent, secondHandMultiplier, hasProccedSleep)
				mod:pinheadOnLocustDamage(player, source.Entity, ent, secondHandMultiplier)
				mod:toyPianoOnLocustDamage(player, source.Entity, ent, secondHandMultiplier)
				hasAppliedBruise = mod:rubberBulletsOnLocustDamage(player, source.Entity, ent, secondHandMultiplier, hasAppliedBruise) or hasAppliedBruise
				hasAppliedBruise = mod:prankCookieRollLocustEffect(player, ent, source, secondHandMultiplier, hasAppliedBruise, hasProccedSleep) or hasAppliedBruise
				mod:erflyOnLocustDamage(player, source.Entity, ent, secondHandMultiplier, flags)
			end
		end


		mod:platinumDipOnDamage(ent, source)

		local returndata = mod:berserkOnCheckKill(data, newFlags)
		newFlags = returndata.newFlags or newFlags
		sendNewDamage = returndata.sendNewDamage or sendNewDamage

		local returndata = mod:martyrOnCheckKill(data, newFlags)
		newFlags = returndata.newFlags or newFlags
		sendNewDamage = returndata.sendNewDamage or sendNewDamage

		local hasRerolled = false

		if source.Type == EntityType.ENTITY_TEAR then
			local sourcedata = source.Entity:GetData()
			local sourcetear = source.Entity:ToTear()

			mod:erflyOnTearDamage(sourcetear, sourcedata)
			mod:pgoOnTearDamage(sourcedata, data)
			mod:ipadOnTearDamage(sourcedata, ent)

			hasRerolled = hasRerolled or mod:rerolliganFossilDamage(ent, source, sourcedata)
		elseif source.Type == EntityType.ENTITY_BOMBDROP and flags == flags | DamageFlag.DAMAGE_EXPLOSION then
			local sourceData = source.Entity:GetData()

			if sourceData.isImpSodaTear then
				sourceData.hasImpSodaProcced = sourceData.hasImpSodaProcced or {}
				if not sourceData.hasImpSodaProcced[ent.InitSeed] then
					mod:doCriticalHitFx(ent.Position, ent, source.Entity)
					sourceData.hasImpSodaProcced[ent.InitSeed] = true
				end
			end

			if sourceData.IsFortuneTear and not sourceData.HasShownFortuneAlready then
				if FiendFolio.FortuneTearCooldown <= 0 then
					--game:ShowFortune()
					mod:ShowFortune(false, true)
					FiendFolio.FortuneTearCooldown = 20
					sourceData.HasShownFortuneAlready = true
				end
			end

			hasRerolled = hasRerolled or mod:rerolliganFossilDamage(ent, source, sourceData)
		elseif source.Type == EntityType.ENTITY_EFFECT and source.Variant == EffectVariant.PLAYER_CREEP_HOLYWATER_TRAIL then
			local sourceData = source.Entity:GetData()

			if sourceData.isImpSodaTear then
				newDamage = newDamage * mod.CritDamageMult
				sendNewDamage = true

				sourceData.hasImpSodaProcced = sourceData.hasImpSodaProcced or {}
				if not sourceData.hasImpSodaProcced[ent.InitSeed] then
					mod:doCriticalHitFx(ent.Position, ent, source.Entity)
					sourceData.hasImpSodaProcced[ent.InitSeed] = true
				end
			end

			if sourceData.YinYangOrb then
				newDamage = newDamage * sourceData.YinYangOrbDamageMultiplier
				sendNewDamage = true
			end

			if sourceData.SandstoneMultiplier then
				newDamage = newDamage * sourceData.SandstoneMultiplier
				sendNewDamage = true
			end

			if sourceData.RockCandyMultiplier then
				newDamage = newDamage * sourceData.RockCandyMultiplier
				sendNewDamage = true
			end

			if sourceData.IsFortuneTear then
				newDamage = newDamage * 1.05
				sendNewDamage = true

				if not sourceData.HasShownFortuneAlready then
					if FiendFolio.FortuneTearCooldown <= 0 then
						--game:ShowFortune()
						mod:ShowFortune(false, true)
						FiendFolio.FortuneTearCooldown = 20
						sourceData.HasShownFortuneAlready = true
					end
				end
			end

			hasRerolled = hasRerolled or mod:rerolliganFossilDamage(ent, source, sourceData)
		elseif source.Type == EntityType.ENTITY_EFFECT and source.Variant == EffectVariant.ROCKET then
			local sourceData = source.Entity:GetData()

			if sourceData.isImpSodaTear then
				newDamage = newDamage * mod.CritDamageMult
				sendNewDamage = true

				sourceData.hasImpSodaProcced = sourceData.hasImpSodaProcced or {}
				if not sourceData.hasImpSodaProcced[ent.InitSeed] then
					mod:doCriticalHitFx(ent.Position, ent, source.Entity)
					sourceData.hasImpSodaProcced[ent.InitSeed] = true
				end
			end
			
			if sourceData.isMorbidClotToothTear then
				newDamage = newDamage * 3.2
				sendNewDamage = true
			end

			if sourceData.YinYangOrb then
				newDamage = newDamage * sourceData.YinYangOrbDamageMultiplier
				sendNewDamage = true
			end

			if sourceData.SandstoneMultiplier then
				newDamage = newDamage * sourceData.SandstoneMultiplier
				sendNewDamage = true
			end

			if sourceData.RockCandyMultiplier then
				newDamage = newDamage * sourceData.RockCandyMultiplier
				sendNewDamage = true
			end

			if sourceData.IsFortuneTear and not sourceData.HasShownFortuneAlready then
				newDamage = newDamage * 1.05
				sendNewDamage = true

				if FiendFolio.FortuneTearCooldown <= 0 then
					--game:ShowFortune()
					mod:ShowFortune(false, true)
					FiendFolio.FortuneTearCooldown = 20
					sourceData.HasShownFortuneAlready = true
				end
			end

			hasRerolled = hasRerolled or mod:rerolliganFossilDamage(ent, source, sourceData)
		elseif source.Type == EntityType.ENTITY_KNIFE then
			local hasImpSodaProcced = false

			local player = mod:getPlayerFromKnife(source.Entity)
			if player ~= nil then
				--Imp Soda
				if not hasImpSodaProcced and mod:shouldCriticalHit(player) then
					newDamage = newDamage * mod.CritDamageMult
					sendNewDamage = true
					mod:doCriticalHitFx(ent.Position, ent, source.Entity)
					hasImpSodaProcced = true
				end

				local returndata = mod:prankCookieOnKnifeDamage(player, ent, source, newDamage, hasImpSodaProcced)
				newDamage = returndata.newDamage or newDamage
				sendNewDamage = returndata.sendNewDamage or sendNewDamage
				hasImpSodaProcced = returndata.hasImpSodaProcced or hasImpSodaProcced

				--Fortune Stuff
				local baseFortuneOdds = 0
				if player:HasTrinket(TrinketType.TRINKET_FORTUNE_WORM) or player:HasTrinket(FiendFolio.ITEM.ROCK.FORTUNE_WORM_FOSSIL) then
					local fortuneWormOdds = player:GetPlayerType() == FiendFolio.PLAYER.FIEND and 5 or 1
					fortuneWormOdds = fortuneWormOdds * (player:GetTrinketMultiplier(TrinketType.TRINKET_FORTUNE_WORM) + FiendFolio.GetGolemTrinketPower(player, FiendFolio.ITEM.ROCK.FORTUNE_WORM_FOSSIL))
					baseFortuneOdds = baseFortuneOdds + fortuneWormOdds
				end
				if FiendFolio.GreatFortune then
					baseFortuneOdds = baseFortuneOdds + 3
				end
				if player:HasCollectible(CollectibleType.COLLECTIBLE_LEFTOVER_TAKEOUT) then
					baseFortuneOdds = baseFortuneOdds + 17
				end

				if baseFortuneOdds > 0 then
					local freq = math.min(math.max(math.floor(22 - baseFortuneOdds - player.Luck), 3), 25)
					if math.random(freq) == 1 then
						newDamage = newDamage * 1.05
						sendNewDamage = true

						if FiendFolio.FortuneTearCooldown <= 0 and grng:RandomInt(6) < 1 then
							--game:ShowFortune()
							mod:ShowFortune(false, true)
							FiendFolio.FortuneTearCooldown = 20
						end
					end
				end

				hasRerolled = hasRerolled or mod:rerolliganFossilOnKnifeDamage(player, ent)
			end

			local returndata = mod:immoralClotOnKnifeDamage(ent, source.Entity, newDamage, hasImpSodaProcced)
			newDamage = returndata.newDamage or newDamage
			sendNewDamage = returndata.sendNewDamage or sendNewDamage
			hasImpSodaProcced = returndata.hasImpSodaProcced or hasImpSodaProcced

			local returndata = mod:morbidClotOnKnifeDamage(ent, source.Entity, newDamage)
			newDamage = returndata.newDamage or newDamage
			sendNewDamage = returndata.sendNewDamage or sendNewDamage
		elseif source.Type == EntityType.ENTITY_PLAYER and flags == flags | DamageFlag.DAMAGE_LASER then
			local player = source.Entity:ToPlayer()
			local hasImpSodaProcced = false

			--Imp Soda
			if not hasImpSodaProcced and mod:shouldCriticalHit(player) then
				newDamage = newDamage * mod.CritDamageMult
				sendNewDamage = true
				mod:doCriticalHitFx(ent.Position, ent, source.Entity)
				hasImpSodaProcced = true
			end

			local returndata = mod:prankCookieOnLaserDamage(player, ent, source, newDamage, hasImpSodaProcced)
			newDamage = returndata.newDamage or newDamage
			sendNewDamage = returndata.sendNewDamage or sendNewDamage
			hasImpSodaProcced = returndata.hasImpSodaProcced or hasImpSodaProcced

			--Fortune Stuff
			local baseFortuneOdds = 0
			if player:HasTrinket(TrinketType.TRINKET_FORTUNE_WORM) or player:HasTrinket(FiendFolio.ITEM.ROCK.FORTUNE_WORM_FOSSIL) then
				local fortuneWormOdds = player:GetPlayerType() == FiendFolio.PLAYER.FIEND and 5 or 1
				fortuneWormOdds = fortuneWormOdds * (player:GetTrinketMultiplier(TrinketType.TRINKET_FORTUNE_WORM) + FiendFolio.GetGolemTrinketPower(player, FiendFolio.ITEM.ROCK.FORTUNE_WORM_FOSSIL))
				baseFortuneOdds = baseFortuneOdds + fortuneWormOdds
			end
			if FiendFolio.GreatFortune then
				baseFortuneOdds = baseFortuneOdds + 3
			end
			if player:HasCollectible(CollectibleType.COLLECTIBLE_LEFTOVER_TAKEOUT) then
				baseFortuneOdds = baseFortuneOdds + 17
			end

			if baseFortuneOdds > 0 then
				local freq = math.min(math.max(math.floor(22 - baseFortuneOdds - player.Luck), 3), 25)
				if math.random(freq) == 1 then
					newDamage = newDamage * 1.05
					sendNewDamage = true

					if FiendFolio.FortuneTearCooldown <= 0 then
						--game:ShowFortune()
						mod:ShowFortune(false, true)
						FiendFolio.FortuneTearCooldown = 20
					end
				end
			end

			hasRerolled = hasRerolled or mod:rerolliganFossilOnLaserDamage(player, ent)
		elseif source.Type == EntityType.ENTITY_EFFECT and source.Variant == EffectVariant.DARK_SNARE then
			if source.Entity and source.Entity.SpawnerEntity and source.Entity.SpawnerEntity.Type == EntityType.ENTITY_PLAYER then
				local player = source.Entity.SpawnerEntity:ToPlayer()
				local hasImpSodaProcced = false
				local damageMulti = 1

				--Imp Soda
				if not hasImpSodaProcced and mod:shouldCriticalHit(player) then
					damageMulti = damageMulti * mod.CritDamageMult
					mod:doCriticalHitFx(ent.Position, ent, source.Entity)
					hasImpSodaProcced = true
				end

				local returndata = mod:prankCookieOnDarkArtsDamage(player, ent, source, hasImpSodaProcced)
				damageMulti = damageMulti * (returndata.damageMulti or 1)
				hasImpSodaProcced = returndata.hasImpSodaProcced or hasImpSodaProcced

				--Fortune Stuff
				local baseFortuneOdds = 0
				if player:HasTrinket(TrinketType.TRINKET_FORTUNE_WORM) or player:HasTrinket(FiendFolio.ITEM.ROCK.FORTUNE_WORM_FOSSIL) then
					local fortuneWormOdds = player:GetPlayerType() == FiendFolio.PLAYER.FIEND and 5 or 1
					fortuneWormOdds = fortuneWormOdds * (player:GetTrinketMultiplier(TrinketType.TRINKET_FORTUNE_WORM) + FiendFolio.GetGolemTrinketPower(player, FiendFolio.ITEM.ROCK.FORTUNE_WORM_FOSSIL))
					baseFortuneOdds = baseFortuneOdds + fortuneWormOdds
				end
				if FiendFolio.GreatFortune then
					baseFortuneOdds = baseFortuneOdds + 3
				end
				if player:HasCollectible(CollectibleType.COLLECTIBLE_LEFTOVER_TAKEOUT) then
					baseFortuneOdds = baseFortuneOdds + 17
				end

				if baseFortuneOdds > 0 then
					local freq = math.min(math.max(math.floor(22 - baseFortuneOdds - player.Luck), 3), 25)
					if math.random(freq) == 1 then
						damageMulti = damageMulti * 1.05

						if FiendFolio.FortuneTearCooldown <= 0 then
							--game:ShowFortune()
							mod:ShowFortune(false, true)
							FiendFolio.FortuneTearCooldown = 20
						end
					end
				end

				hasRerolled = hasRerolled or mod:rerolliganFossilOnDarkArtsDamage(player, ent)

				if damageMulti ~= 1 then
					local additionalDamage = originalDamage
					additionalDamage = (additionalDamage - (3.5 * source.Entity.SubType)) / 2
					additionalDamage = additionalDamage * (damageMulti - 1)
					additionalDamage = additionalDamage * 2
					additionalDamage = additionalDamage * ((hasProccedSleep and FiendFolio.StatusEffectVariables.SleepAwakenDamageMultiplier) or 1)
					additionalDamage = additionalDamage * ((hasProccedBerserk and FiendFolio.StatusEffectVariables.BerserkDamageReceivedMultiplier) or 1)
					newDamage = newDamage + additionalDamage
					sendNewDamage = true
				end
			end
		elseif source.Type == EntityType.ENTITY_FAMILIAR and source.Variant == FamiliarVariant.ABYSS_LOCUST then
			if source.Entity and source.Entity.SpawnerEntity and source.Entity.SpawnerEntity.Type == EntityType.ENTITY_PLAYER then
				local player = source.Entity.SpawnerEntity:ToPlayer()
				local hasImpSodaProcced = false
				local damageMulti = 1

				--Imp Soda
				--[[if not hasImpSodaProcced and mod:shouldCriticalHit(player) then
					damageMulti = damageMulti * mod.CritDamageMult
					mod:doCriticalHitFx(ent.Position, ent, source.Entity)
					hasImpSodaProcced = true
				end]]

				local returndata = mod:prankCookieOnLocustDamage(player, ent, source, hasImpSodaProcced)
				damageMulti = damageMulti * (returndata.damageMulti or 1)
				hasImpSodaProcced = returndata.hasImpSodaProcced or hasImpSodaProcced

				if damageMulti ~= 1 then
					local additionalDamage = originalDamage
					additionalDamage = (additionalDamage - (3.5 * source.Entity.SubType)) / 2
					additionalDamage = additionalDamage * (damageMulti - 1)
					additionalDamage = additionalDamage * 2
					additionalDamage = additionalDamage * ((hasProccedSleep and FiendFolio.StatusEffectVariables.SleepAwakenDamageMultiplier) or 1)
					additionalDamage = additionalDamage * ((hasProccedBerserk and FiendFolio.StatusEffectVariables.BerserkDamageReceivedMultiplier) or 1)
					newDamage = newDamage + additionalDamage
					sendNewDamage = true
				end
			end
		end

		--This'll need testing
		--if mod:isBasegameSegmented(ent) and not mod:isReducedSyncSegment(ent) then
		--	newFlags = newFlags | DamageFlag.DAMAGE_CLONES
		--end

		if sendNewDamage and not hasRerolled and flags & DamageFlag.DAMAGE_FIRE == 0 then
			data.FFStatusIgnoreDamageCallback = true
			ent:TakeDamage(newDamage, newFlags, source, countdown)
			data.FFStatusIgnoreDamageCallback = nil
			return false
		end
	end

	mod:damagedByBerserk(ent, damage, flags, source, countdown, data)
end)

-----------------------------------------------------------
-- Segmented Enemy Functions
-----------------------------------------------------------

function mod:isSegmented(entity)
	return FiendFolio.SegmentedEnemies[entity.Type] or
		   FiendFolio.SegmentedEnemies[entity.Type .. " " .. entity.Variant] or
		   FiendFolio.SegmentedEnemies[entity.Type .. " " .. entity.Variant .. " " .. entity.SubType]
end

function mod:isMainSegment(entity)
	if entity.Type == mod.FF.Kingpin.ID and entity.Variant == mod.FF.Kingpin.Var then
		return entity.Parent == nil
	elseif entity.Type == mod.FF.Tapeworm.ID and entity.Variant == mod.FF.Tapeworm.Var then
		return entity.Parent == nil
	elseif entity.Type == mod.FF.MrBones.ID and entity.Variant == mod.FF.MrBones.Var then
		return entity:ToNPC().State ~= 10
	elseif entity.Type == mod.FF.Prick.ID and entity.Variant == mod.FF.Prick.Var then
		return entity.Parent == nil
	elseif entity.Type == mod.FF.Warble.ID and entity.Variant == mod.FF.Warble.Var then
		return entity.SubType ~= mod.FF.WarbleTail.Sub
	elseif entity.Type == mod.FF.CorruptedLarry.ID and entity.Variant == mod.FF.CorruptedLarry.Var then
		return entity:GetData().corruptedHead
	else
		return FiendFolio.MainSegment[entity.Type] or
			   FiendFolio.MainSegment[entity.Type .. " " .. entity.Variant] or
			   FiendFolio.MainSegment[entity.Type .. " " .. entity.Variant .. " " .. entity.SubType]
	end
end

function mod:isReducedSyncSegment(entity)
	return FiendFolio.ReducedSyncSegments[entity.Type] or
		   FiendFolio.ReducedSyncSegments[entity.Type .. " " .. entity.Variant] or
		   FiendFolio.ReducedSyncSegments[entity.Type .. " " .. entity.Variant .. " " .. entity.SubType]
end

function mod:getSegments(entity)
	local segmentFunction = FiendFolio.GetSegmentsFunctions[entity.Type .. " " .. entity.Variant .. " " .. entity.SubType] or
							FiendFolio.GetSegmentsFunctions[entity.Type .. " " .. entity.Variant] or
							FiendFolio.GetSegmentsFunctions[entity.Type]

	if segmentFunction == nil then
		return {entity}
	else
		return segmentFunction(entity)
	end
end

function mod:isInSegmentsOf(target, entity)
	local segments = mod:getSegments(entity)
	for _, segment in ipairs(segments) do
		if target.InitSeed == segment.InitSeed and target.Index == segment.Index then
			return true
		end
	end
	return false
end

function mod:isBasegameSegmented(entity)
	return mod.BasegameSegmentedEnemies[entity.Type] or
		   mod.BasegameSegmentedEnemies[entity.Type .. " " .. entity.Variant] or
		   mod.BasegameSegmentedEnemies[entity.Type .. " " .. entity.Variant .. " " .. entity.SubType]
end

function mod:isBasegameMainSegment(entity)
	if entity.Type == 19 then -- Larry Jr., The Hollow, Tuff Twins, The Shell
		return entity.Parent == nil
	elseif entity.Type == 28 then -- Chub, C.H.A.D., The Carrion Queen
		return entity.Parent == nil
	elseif entity.Type == 62 then -- Pin, Scolex, The Frail, Wormwood
		return entity.Parent == nil
	elseif entity.Type == 89 then -- Buttlicker
		return entity.Parent == nil
	elseif entity.Type == 239 then -- Grub
		return entity.Parent == nil
	elseif entity.Type == 918 then -- Turdlet
		return entity.Parent == nil
	else
		return mod.BasegameMainSegment[entity.Type] or
			   mod.BasegameMainSegment[entity.Type .. " " .. entity.Variant] or
			   mod.BasegameMainSegment[entity.Type .. " " .. entity.Variant .. " " .. entity.SubType]
	end
end

function mod:isBasegameReducedSyncSegment(entity)
	return mod.BasegameReducedSyncSegments[entity.Type] or
		   mod.BasegameReducedSyncSegments[entity.Type .. " " .. entity.Variant] or
		   mod.BasegameReducedSyncSegments[entity.Type .. " " .. entity.Variant .. " " .. entity.SubType]
end

function mod:getBasegameSegments(entity)
	local segmentFunction = FiendFolio.GetBasegameSegmentsFunctions[entity.Type .. " " .. entity.Variant .. " " .. entity.SubType] or
							FiendFolio.GetBasegameSegmentsFunctions[entity.Type .. " " .. entity.Variant] or
							FiendFolio.GetBasegameSegmentsFunctions[entity.Type]

	if segmentFunction == nil then
		return {entity}
	else
		return segmentFunction(entity)
	end
end

function mod:isInBasegameSegmentsOf(target, entity)
	local segments = mod:getBasegameSegments(entity)
	for _, segment in ipairs(segments) do
		if target.InitSeed == segment.InitSeed and target.Index == segment.Index then
			return true
		end
	end
	return false
end

---------------------------------------------------------------------------------------------------------------
-- Fiend stuff is going here because I decided so

-- Fiend / Biend heart replacement
mod:AddCallback(ModCallbacks.MC_POST_PICKUP_INIT, function(_, pickup)
	local room = game:GetRoom()
	local anyPlayerIsFiend = false
	local highestFiendLuck = -99
	local anyPlayerIsBiend = false
	local highestBiendLuck = -99
	for i = 1, game:GetNumPlayers() do
		local player = Isaac.GetPlayer(i - 1)

		if player:GetPlayerType() == FiendFolio.PLAYER.FIEND then
			anyPlayerIsFiend = true
			highestFiendLuck = math.max(highestFiendLuck, player.Luck)
		elseif player:GetPlayerType() == FiendFolio.PLAYER.BIEND then
			anyPlayerIsBiend = true
			highestBiendLuck = math.max(highestBiendLuck, player.Luck)
		end
	end

	if anyPlayerIsBiend then
		local heartluck = math.max(0, math.min(13, highestBiendLuck))
		if pickup.SubType == HeartSubType.HEART_BLACK then
			--pickup.Timeout = 60
		else
			if pickup.SubType == HeartSubType.HEART_SOUL then
				pickup:Morph(5, 10, 6, true)
			elseif pickup.SubType == HeartSubType.HEART_HALF_SOUL then
				pickup:Morph(5, PickupVariant.PICKUP_FIENDFOLIO_HALF_BLACK_HEART, 0, true)
			elseif pickup.SubType == HeartSubType.HEART_BLENDED then
				pickup:Morph(5, PickupVariant.PICKUP_FIENDFOLIO_BLENDED_BLACK_HEART, 0, true)
			elseif room:GetType() ~= RoomType.ROOM_SUPERSECRET then
				grng:SetSeed(pickup.InitSeed, 0)

				if pickup.SubType == HeartSubType.HEART_ETERNAL or pickup.SubType == HeartSubType.HEART_GOLDEN then
					pickup:Morph(5, 10, 6, true)
				elseif pickup.SubType == HeartSubType.HEART_BONE and grng:RandomInt(5) == 0 then
					pickup:Morph(5, 10, 6, true)
				elseif grng:RandomInt(99) + 1 <= 33 + (33 * heartluck/13) then
					if pickup.SubType == HeartSubType.HEART_HALF then
						pickup:Morph(5, PickupVariant.PICKUP_FIENDFOLIO_HALF_BLACK_HEART, 0, true)
					else
						pickup:Morph(5, 10, 6, true)
					end
				end
			end
		end
	elseif anyPlayerIsFiend then
		local heartluck = math.max(0, math.min(13, highestFiendLuck))
		if pickup.SubType == HeartSubType.HEART_BLACK then
			--pickup.Timeout = 60
		else
			grng:SetSeed(pickup.InitSeed, 0)

			if grng:RandomFloat() < 0.10 then
				if pickup.SubType == HeartSubType.HEART_SOUL then
					pickup:Morph(5, 10, 6, true)
				elseif pickup.SubType == HeartSubType.HEART_HALF_SOUL then
					pickup:Morph(5, PickupVariant.PICKUP_FIENDFOLIO_HALF_BLACK_HEART, 0, true)
				elseif pickup.SubType == HeartSubType.HEART_BLENDED then
					pickup:Morph(5, PickupVariant.PICKUP_FIENDFOLIO_BLENDED_BLACK_HEART, 0, true)
				elseif room:GetType() ~= RoomType.ROOM_SUPERSECRET then
					if pickup.SubType == HeartSubType.HEART_ETERNAL or pickup.SubType == HeartSubType.HEART_GOLDEN then
						pickup:Morph(5, 10, 6, true)
					elseif pickup.SubType == HeartSubType.HEART_BONE and grng:RandomInt(5) == 0 then
						pickup:Morph(5, 10, 6, true)
					elseif grng:RandomInt(99) + 1 <= 33 + (33 * heartluck/13) then
						if pickup.SubType == HeartSubType.HEART_HALF then
							pickup:Morph(5, PickupVariant.PICKUP_FIENDFOLIO_HALF_BLACK_HEART, 0, true)
						else
							pickup:Morph(5, 10, 6, true)
						end
					end
				end
			else
				if pickup.SubType == HeartSubType.HEART_SOUL then
					pickup:Morph(5, PickupVariant.PICKUP_IMMORAL_HEART, 0, true)
				elseif pickup.SubType == HeartSubType.HEART_HALF_SOUL then
					pickup:Morph(5, PickupVariant.PICKUP_HALF_IMMORAL_HEART, 0, true)
				elseif pickup.SubType == HeartSubType.HEART_BLENDED then
					pickup:Morph(5, PickupVariant.PICKUP_BLENDED_IMMORAL_HEART, 0, true)
				elseif room:GetType() ~= RoomType.ROOM_SUPERSECRET then
					if pickup.SubType == HeartSubType.HEART_ETERNAL or pickup.SubType == HeartSubType.HEART_GOLDEN then
						pickup:Morph(5, PickupVariant.PICKUP_IMMORAL_HEART, 0, true)
					elseif pickup.SubType == HeartSubType.HEART_BONE and grng:RandomInt(5) == 0 then
						pickup:Morph(5, PickupVariant.PICKUP_IMMORAL_HEART, 0, true)
					elseif grng:RandomInt(99) + 1 <= 33 + (33 * heartluck/13) then
						if pickup.SubType == HeartSubType.HEART_HALF then
							pickup:Morph(5, PickupVariant.PICKUP_HALF_IMMORAL_HEART, 0, true)
						else
							pickup:Morph(5, PickupVariant.PICKUP_IMMORAL_HEART, 0, true)
						end
					end
				end
			end
		end
	end
end, PickupVariant.PICKUP_HEART)

-- Making sure fiend gets his completion note
--CompletionNoteAPIMod:addPlayerNameToAPI("Fiend")

if StageAPI and StageAPI.Loaded then
	StageAPI.AddPlayerGraphicsInfo(FiendFolio.PLAYER.FIEND, {
		Name = "gfx/ui/boss/playername_fiend.png",
		Portrait = "gfx/ui/stage/playerportrait_fiend_rep.png",
		NoShake = false,
		Controls = "gfx/backdrop/controls_fiend.png"
	})
end

-- Some extra functions
function mod:GetPlayerUsingItem()
	local player = Isaac.GetPlayer(0)
	for i = 1, game:GetNumPlayers() do
		local p = Isaac.GetPlayer(i - 1)
		if Input.IsActionTriggered(ButtonAction.ACTION_ITEM, p.ControllerIndex) or Input.IsActionTriggered(ButtonAction.ACTION_PILLCARD, p.ControllerIndex) then
			player = p
			player:GetData().WasHoldingButton = true
			break
		end
	end
	return player
end

-- outdated
local function CalcPlayerDamageMult(player)
	local mult = 1
	player = player:ToPlayer()
	if player:HasCollectible(CollectibleType.COLLECTIBLE_MAGIC_MUSHROOM) or player:HasCollectible(CollectibleType.COLLECTIBLE_MAXS_HEAD) then
		mult = mult * 1.5
	end
	if player:HasCollectible(CollectibleType.COLLECTIBLE_EVES_MASCARA) then
		mult = mult * 2
	end
	if player:HasCollectible(CollectibleType.COLLECTIBLE_CROWN_OF_LIGHT) and player:GetEffectiveMaxHearts() <= player:GetHearts() then
		mult = mult * 2
	end
	if player:HasCollectible(CollectibleType.COLLECTIBLE_HAEMOLACRIA) then
		mult = mult * 1.31
	end
	if player:HasCollectible(CollectibleType.COLLECTIBLE_ODD_MUSHROOM_RATE) then
		mult = mult * 0.9
	end
	if player:HasCollectible(CollectibleType.COLLECTIBLE_POLYPHEMUS) then
		mult = mult * 2
	end
	if player:HasCollectible(CollectibleType.COLLECTIBLE_PROPTOSIS) then
		mult = mult * 2
	end
	if player:HasCollectible(CollectibleType.COLLECTIBLE_SACRED_HEART) then
		mult = mult * 2.3
	end
	if player:HasCollectible(CollectibleType.COLLECTIBLE_SOY_MILK) then
		mult = mult * 0.2
	end
	if player:HasCollectible(CollectibleType.COLLECTIBLE_TECHNOLOGY_2) then
		mult = mult * 0.65
	end
	return mult
end

local function runUpdates(tab)
	for i = #tab, 1, -1 do
		local f = tab[i]
		f.Delay = f.Delay - 1
		if f.Delay <= 0 then
			f.Func()
			table.remove(tab, i)
		end
	end
end

mod.delayedFuncs = {}
function mod.scheduleForUpdate(foo, delay, callback, noCancelOnNewRoom)
	callback = callback or ModCallbacks.MC_POST_UPDATE
	if not mod.delayedFuncs[callback] then
		mod.delayedFuncs[callback] = {}
		mod:AddCallback(callback, function()
			runUpdates(mod.delayedFuncs[callback])
		end)
	end

	table.insert(mod.delayedFuncs[callback], { Func = foo, Delay = delay, NoCancel = noCancelOnNewRoom })
end

function mod:cancelScheduledFunctions()
	for callback, tab in pairs(mod.delayedFuncs) do
		for i = #tab, 1, -1 do
			local f = tab[i]
			if not f.NoCancel then
				table.remove(tab, i)
			end
		end
	end
end

-- applies d12 effect to all tiles with type on table grids. refill = false for ignore broken grids. Returns a table of index grids that got d12'd
function mod.reroll_grids(grids, refill, customPoof, applyOnFireplaces)
	local ids = {}
	local gBroken = {}
	gBroken[2] = 2	gBroken[4] = 2		gBroken[5] = 2	gBroken[6] = 2	gBroken[10] = 1	gBroken[11] = 1
	gBroken[12] = 4	gBroken[14] = 1000	gBroken[22] = 2	gBroken[25] = 2	gBroken[26] = 2	gBroken[27] = 2
	local room = game:GetRoom()
	local len = room:GetGridSize()
	for i=0, len do
		local grid = room:GetGridEntity(i)
		if grid then
			local gType = grid:GetType()
			if refill or (grid.State ~= gBroken[gType]) then
				for j=1, #grids do
					if gType == grids[j] then
						table.insert(ids, i)
						grid:SetType(2)
						grid.State = 1
						grid:Update()
						break
					end
				end
			end
		end
	end
	
	if applyOnFireplaces then
		local fires = Isaac.FindByType(33, -1, -1, false, false)
		for _, fire in pairs(fires) do
			if fire.Variant >= 0 and fire.Variant <= 3 and ((fire.HitPoints == 1.0 and applyOnFireplaces) or fire.HitPoints ~= 1.0) then
				fire:ToNPC():Remove()
				local idx = room:GetGridIndex(fire.Position)
				room:SpawnGridEntity(idx, 2, 0, 0, 0)
				table.insert(ids, idx)
			end
		end
	end
	
	if customPoof then FiendFolio.scheduleForUpdate(function()
		poofs = Isaac.FindByType(1000, 15, -1, false, false)
		for _, poof in pairs(poofs) do
			if poof.FrameCount == 0 then
				--local color = Color(1, 1, 1, 1, 0, 0, 0)
				--color:SetColorize(0, 150/255, 1, 0.5)
				--poof:GetSprite().Color = color
				
				poof.Color = Color(0.625, 0.625, 1, 1, 0, 0.1, 0.2)
			end
		end
	end, 0) end
	Isaac.GetPlayer(0):UseActiveItem(CollectibleType.COLLECTIBLE_D12, false, false, true, false)
	return ids
end

-- removes all grids with type on grids table without breaking them. returns a table of index grids that got removed
function mod.wipe_grids(grids, hazardPoop)
  local ids = {}
  local room = game:GetRoom()
  local len = room:GetGridSize()
  for i=0, len do
	local grid = room:GetGridEntity(i)
	if grid then
	  local gType = grid:GetType()
	  if hazardPoop or not (gType == 14 and (grid:GetVariant() == 1 or grid:GetVariant() == 2)) then
		for j=1, #grids do
		  if gType == grids[j] then
			table.insert(ids, i)
		  --if gType == 2 or gType == 4 or gType == 5 or gType == 6 or gType == 12 or gType == 14 or gType == 22 or gType == 25 or gType == 27 then
			local poof = Isaac.Spawn(1000, 15, 0, grid.Position, Vector(0,0), nil)
			poof.PositionOffset = Vector(0, 10)
			poof:GetSprite():Play("Poof_Small", true)
			for i=0, math.random(10) do
			  poof:GetSprite():Update()
			end
			room:RemoveGridEntity(i, 0, false)
		  --end
		  end
		end
	  end
	end
  end
  FiendFolio.scheduleForUpdate(function()
	for i=1, #ids do
	  room:SpawnGridEntity(ids[i], 1, 0, 0, 0)
	  mod:makeDecorInvisible(ids[i])
	end
  end, 2)
  return ids
end

mod:AddCallback(ModCallbacks.MC_POST_ENTITY_REMOVE, function(_, proj)
  local data = proj:GetData()
  if data.customProjSplat then
	local splatGfx = data.customProjSplat
	FiendFolio.scheduleForUpdate(function()
	  local splats = Isaac.FindByType(1000, 11, 0, false, false)
	  for _, splat in pairs(splats) do
		if splat.FrameCount == 0 and splat.Position:Distance(proj.Position) == 0 then
		  local sprite = splat:GetSprite()
		  sprite:ReplaceSpritesheet(0, splatGfx)
		  sprite:LoadGraphics()
		end
	  end
	end, 0)
  end
  if data.tooth then
	if (proj:IsDead() or not proj:Exists()) then
		sfx:Play(SoundEffect.SOUND_BOIL_HATCH, 0.3, 0, false, 1)
	end
  end
  if data.customProjSound then
	if (proj:IsDead() or not proj:Exists()) then
	  sfx:Play(data.customProjSound[1], data.customProjSound[2], 0, false, data.customProjSound[3])
	end
  end
  if data.makeSplat then
	local splat = Isaac.Spawn(1000, data.makeSplat, 0, proj.Position, Vector.Zero, proj)
	splat.SpriteOffset = Vector(0, proj:ToProjectile().Height)
	if data.customProjSplat then
	  local splatGfx = data.customProjSplat
	  local sprite = splat:GetSprite()
	  sprite:ReplaceSpritesheet(0, splatGfx)
	  sprite:LoadGraphics()
	end
	if data.toothParticles then
	  for i=0,2 do
		local particle = Isaac.Spawn(1000, 35, 1, proj.Position, RandomVector(), proj)
		particle:SetColor(data.toothParticles, 999, 1, false, false)
	  end
	end
  end
end, 9)

mod:AddCallback(ModCallbacks.MC_POST_ENTITY_REMOVE, function(_, proj)
  local data = proj:GetData()
  if data.customTearSplat then
	local splatGfx = data.customTearSplat
	FiendFolio.scheduleForUpdate(function()
	  local splats = Isaac.FindByType(1000, 12, 0, false, false)
	  for _, splat in pairs(splats) do
		if splat.FrameCount == 0 and splat.Position:Distance(proj.Position) == 0 then
		  local sprite = splat:GetSprite()
		  sprite:ReplaceSpritesheet(0, splatGfx)
		  sprite:LoadGraphics()
		end
	  end
	end, 0)
  end
  if data.tooth then
	if (proj:IsDead() or not proj:Exists()) then
		sfx:Play(SoundEffect.SOUND_BOIL_HATCH, 0.3, 0, false, 1)
	end
  end
  if data.customTearSound then
	if (proj:IsDead() or not proj:Exists()) then
	  sfx:Play(data.customTearSound[1], data.customTearSound[2], 0, false, data.customTearSound[3])
	end
  end
  if data.makeSplat then
	local splat = Isaac.Spawn(1000, data.makeSplat, 0, proj.Position, Vector.Zero, proj)
	splat.SpriteOffset = Vector(0, proj:ToTear().Height)
	if data.customTearSplat then
	  local splatGfx = data.customTearSplat
	  local sprite = splat:GetSprite()
	  sprite:ReplaceSpritesheet(0, splatGfx)
	  sprite:LoadGraphics()
	  if data.scaleSplat then
		splat.SpriteScale = Vector(data.scaleSplat, data.scaleSplat)
	  end
	end
	if data.toothParticles then
	  for i=0,2 do
		local particle = Isaac.Spawn(1000, 35, 1, proj.Position, RandomVector(), proj)
		particle:SetColor(data.toothParticles, 999, 1, false, false)
	  end
	end
  end
end, 2)

-- Borrowing a couple of functions from p20helper to render achievement notes
--[[local localp20 = {}

function localp20:getScreenCenterPosition()
	local room = game:GetRoom()
	local shape = room:GetRoomShape()
	local centerOffset = (room:GetCenterPos()) - room:GetTopLeftPos()
	local pos = room:GetCenterPos()
	if centerOffset.X > 260 then
		pos.X = pos.X - 260
	end
	if shape == RoomShape.ROOMSHAPE_LBL or shape == RoomShape.ROOMSHAPE_LTL then
		pos.X = pos.X - 260
	end
	if centerOffset.Y > 140 then
		pos.Y = pos.Y - 140
	end
	if shape == RoomShape.ROOMSHAPE_LTR or shape == RoomShape.ROOMSHAPE_LTL then
		pos.Y = pos.Y - 140
	end
	return Isaac.WorldToRenderPosition(pos, false)
end

local shouldRenderAchievement = false
local achievementUI = Sprite()
achievementUI:Load("gfx/ui/achievement/achievements.anm2", true)
local achievementUIDelay = 0
function localp20:doAchievement(spritesheet, sound)
	if shouldRenderAchievement then
		localp20:schedule(120, true, localp20.doAchievement, spritesheet, sound)
		return
	end

	if spritesheet == nil then
		spritesheet = "gfx/ui/achievement/paper.png"
	end
	achievementUI:ReplaceSpritesheet(3, spritesheet)
	achievementUI:LoadGraphics()

	achievementUI:Play("Appear", true)
	shouldRenderAchievement = true
	achievementUIDelay = 90

	if sound == nil then
		sound = SoundEffect.SOUND_CHOIR_UNLOCK
	end
	SFXManager():Play(sound, 1, 0, false, 1)
end

local functionsToCallInOnUpdate = {}
local functionsToCallInOnRender = {}
function localp20:schedule(delay, onRender, functionToCall, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)
	if delay then
		if delay > 0 then
			if functionToCall then
				local tableToInsert = {
					Frame = Isaac.GetFrameCount(),
					Delay = delay,
					Function = functionToCall,
					Arg1 = arg1,
					Arg2 = arg2,
					Arg3 = arg3,
					Arg4 = arg4,
					Arg5 = arg5,
					Arg6 = arg6,
					Arg7 = arg7,
					Arg8 = arg8,
					Arg9 = arg9
				}
				if onRender then
					table.insert(functionsToCallInOnRender, #functionsToCallInOnRender + 1, tableToInsert)
				else
					table.insert(functionsToCallInOnUpdate, #functionsToCallInOnUpdate + 1, tableToInsert)
				end
			end
		end
	end
end]]

mod:AddCallback(ModCallbacks.MC_ENTITY_TAKE_DMG, function(_, ent, damage, flags, source, iframes)
	-- only cancel damage for the first second
	if game:GetRoom():GetFrameCount() > 30 then return end

	-- DAMAGE WHEN ENTERING ROOM FIXES
	if flags & DamageFlag.DAMAGE_POOP ~= 0 then
		return false
	end

	-- no fire damage flag lmao
	if source.Type == 33 then
		return false
	end
end, EntityType.ENTITY_PLAYER)

mod.nameTagOpacity = 0
mod.nameTagToggle = false

local roomNamesFont = Font()
roomNamesFont:Load("font/pftempestasevencondensed.fnt")
local tabHeldAlphaTimer = 0
local tabHeldScaleTimer = 0

mod:AddCallback(ModCallbacks.MC_POST_RENDER, function()
	--[[if #functionsToCallInOnRender >= 1 then
		for i = 1, #functionsToCallInOnRender do
			if functionsToCallInOnRender[i].Frame then
				local frame = functionsToCallInOnRender[i].Frame
				if functionsToCallInOnRender[i].Delay then
					local delay = functionsToCallInOnRender[i].Delay
					local frameToCall = frame + delay
					if Isaac.GetFrameCount() >= frameToCall then
						functionsToCallInOnRender[i].Frame = nil
						functionsToCallInOnRender[i].Delay = nil
						if functionsToCallInOnRender[i].Function then
							local arg1 = functionsToCallInOnRender[i].Arg1
							local arg2 = functionsToCallInOnRender[i].Arg2
							local arg3 = functionsToCallInOnRender[i].Arg3
							local arg4 = functionsToCallInOnRender[i].Arg4
							local arg5 = functionsToCallInOnRender[i].Arg5
							local arg6 = functionsToCallInOnRender[i].Arg6
							local arg7 = functionsToCallInOnRender[i].Arg7
							local arg8 = functionsToCallInOnRender[i].Arg8
							local arg9 = functionsToCallInOnRender[i].Arg9

							functionsToCallInOnRender[i].Function(_, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)
						end
					end
				end
			end
		end
		local clearTable = true
		for i = 1, #functionsToCallInOnRender do
			if functionsToCallInOnRender[i].Frame then
				if functionsToCallInOnRender[i].Delay then
					if functionsToCallInOnRender[i].Function then
						clearTable = false
					end
				end
			end
		end
		if clearTable then
			functionsToCallInOnRender = {}
		end
	end
	if shouldRenderAchievement then
		achievementUI:Render(localp20:getScreenCenterPosition(), Vector(0,0), Vector(0,0))
	end]]

	local hasspider = false

	for _, player in pairs(Isaac.FindByType(1)) do
		player = player:ToPlayer()

		if player:HasCollectible(CollectibleType.COLLECTIBLE_SPIDER_MOD) then
			hasspider = true
		end
		
		if player:HasTrinket(FiendFolio.ITEM.ROCK.CONSTANT_ROCK_SHOOTER) then
			local controllerIndex = player.ControllerIndex
			local shootInputs = {
				ButtonAction.ACTION_SHOOTLEFT,
				ButtonAction.ACTION_SHOOTRIGHT,
				ButtonAction.ACTION_SHOOTUP,
				ButtonAction.ACTION_SHOOTDOWN
			}

			for _, buttonAction in pairs(shootInputs) do
				local isFiring = Input.IsActionTriggered(buttonAction, controllerIndex)
				if isFiring then
					local data = player:GetData()
					data.LastFireDirection = buttonAction
				end
			end
		end
		
		if player:HasTrinket(FiendFolio.ITEM.ROCK.TIPSY_GEODE) then
			local controllerIndex = player.ControllerIndex
			local data = player:GetData()
			local moveInputs = {
				[0] = ButtonAction.ACTION_RIGHT,
				[1] = ButtonAction.ACTION_UP,
				[2] = ButtonAction.ACTION_LEFT,
				[3] = ButtonAction.ACTION_DOWN,
			}

			for _, buttonAction in pairs(moveInputs) do
				local isMoving = Input.IsActionTriggered(buttonAction, controllerIndex)
				if isMoving then
					data.lastMoveDirection = buttonAction
				end
			end
		end
	end

	if mod.ShowRoomNames ~= 3 and not game:GetSeeds():HasSeedEffect(SeedEffect.SEED_NO_HUD) then
		local center = StageAPI.GetScreenCenterPosition()
		local br = StageAPI.GetScreenBottomRight()

		local roomDescriptorData = game:GetLevel():GetCurrentRoomDesc().Data
		local scale = 1

		local tabHeld = Input.IsActionPressed(ButtonAction.ACTION_MAP, Isaac.GetPlayer(0).ControllerIndex)
		if tabHeld then
			tabHeldAlphaTimer = math.min(tabHeldAlphaTimer + 1, 30)
			tabHeldScaleTimer = math.min(tabHeldScaleTimer + 1, 10)
		else
			tabHeldAlphaTimer = math.max(tabHeldAlphaTimer - 1, 0)
			tabHeldScaleTimer = math.max(tabHeldScaleTimer - 1, 0)
		end

		if mod.RoomNameScale >= 2 then
			scale = 0.5
			if tabHeldScaleTimer > 0 and mod.ShowRoomNames ~= 4 then
				local percent = 1 - ((1 - (tabHeldScaleTimer / 10)) ^ 2)
				scale = mod:Lerp(scale, 1, percent)
			end
		end

		if (br.X > 480 or br.Y > 270) and mod.RoomNameScale ~= 3 then -- render scale likely changed
			scale = 1
		end

		local bcenter = Vector(center.X, br.Y - 13 * scale)

		if scale >  0.5 and game:GetRoom():GetAliveBossesCount() > 0 then
			local hudOffset = Options.HUDOffset * 10
			if hudOffset <= 1 then
				bcenter = bcenter + Vector(0, -18 - (2 * hudOffset))
			end
		end

		local text = ""

		local cacophobia = Isaac.FindByType(mod.FF.CacophobiaVenus.ID, mod.FF.CacophobiaVenus.Var)[1]

		if cacophobia and cacophobia:GetData().Pattern then
			text = cacophobia:GetData().Pattern.PatternName
		else
			local currentRoom = StageAPI.GetCurrentRoom()
			if currentRoom and currentRoom.Layout then
				text = text .. tostring(currentRoom.Layout.Variant) .. " " .. currentRoom.Layout.Name
			else
				local useVar = roomDescriptorData.Variant
				if useVar >= 17000 and useVar <= 20000 then
					useVar = useVar - 17000
					text = "(FF) "
				end

				text = text .. tostring(useVar) .. " " .. roomDescriptorData.Name
			end
		end

		local size = roomNamesFont:GetStringWidth(text) * scale

		local alpha = (FiendFolio.RoomNameOpacity + 1) * 0.1
		if mod.ShowRoomNames == 4 then -- show only while holding tab
			alpha = 0
		end

		if mod.ShowRoomNames == 2 then -- only appear for a short time in each room
			local frameCount = math.min(game:GetRoom():GetFrameCount(), 90)
			alpha = mod:Lerp(alpha, 0, frameCount / 90)
		end

		if tabHeldAlphaTimer > 0 then
			alpha = mod:Lerp(alpha, 1, tabHeldAlphaTimer / 30)
		end

		roomNamesFont:DrawStringScaled(text, bcenter.X - (size / 2), bcenter.Y, scale, scale, KColor(1,1,1,alpha), 0, false)
	end

	if mod.NameTags ~= 0 and false then -- Name tags disabled for now, the tables haven't been updated!!

	local opacity = mod.nameTagOpacity
	if mod.NameTags == 1 then
	  opacity = 0.3
	elseif mod.NameTags == 2 then
	  if mod.nameTagToggle then
		if opacity < 0.3 then opacity = opacity + 0.0375 end
	  else
		if opacity > 0 then opacity = opacity - 0.0375 end
	  end
	end
	mod.nameTagOpacity = opacity

		for _, e in pairs(Isaac.GetRoomEntities()) do
			if mod.entityNameFromTV[e.Type] and e.FrameCount >= 1 then
				local str = mod.entityNameFromTV[e.Type][e.Variant]
				if (str == "Harletwin" or str == "Effigy") and e.SubType == 1 then str = nil end
				if str == "Cordend" and e.SubType > 1 then str = nil end
				if (str == "Fishface" or str == "Madclaw") and e:GetData().state == "waiting" then str = nil end
				if str == "Offal" and e:GetData().hiding then str = nil end
				if str then
					local pos = game:GetRoom():WorldToScreenPosition(e.Position) + Vector(string.len(str) * -3, 3)
					if hasspider then
						pos = pos + Vector(0, 10)
					end
					if str == "Baby Spider" then
						Isaac.RenderScaledText(str, pos.X + 18, pos.Y, 0.5, 0.5, 1, 1, 1, opacity)
					else
						Isaac.RenderText(str, pos.X, pos.Y, 1, 1, 1, opacity)
					end
				end
			end
		end
	end
end)

mod:AddCallback(ModCallbacks.MC_POST_PEFFECT_UPDATE, function(_, player)
	local data = player:GetData().ffsavedata
	if data and data.FrictionMod then
		player.Friction = player.Friction + data.FrictionMod
	end
end)

-- returns trinket slot if player is actively holding trinket
-- if gulped or otherwise not in a slot, returns -1
function FiendFolio.GetTrinketSlot(player, trinketId)
	for i = 0, 1 do
		if player:GetTrinket(i) == trinketId then return i end
	end

	return -1
end

-- returns other trinket slot if player is actively holding trinket
-- if gulped, returns random trinket slot
-- if there is no other slot with a trinket, returns -1
-- throws if the player does not have the trinketId
function FiendFolio.GetOtherTrinketSlot(player, trinketId)
	if not player:HasTrinket(trinketId) then
		error('Tried to check for other trinket slot for trinket player did not have')
	end

	if player:GetTrinket(0) == trinketId then
		if player:GetTrinket(1) > 0 then return 1 end
		return -1
	end
	if player:GetTrinket(1) == trinketId then
		if player:GetTrinket(0) > 0 then return 0 end
		return -1
	end

	local slot = math.random(2) - 1
	if player:GetTrinket(slot) > 0 then return slot end

	slot = 1 - slot
	if player:GetTrinket(slot) > 0 then return slot end

	return -1
end

local checkingForGolden = false
local gettingGolemTrinket = false
local gettingRegularTrinket = false
mod:AddCallback(ModCallbacks.MC_GET_TRINKET, function(_, trinket, rng)
	if checkingForGolden then
		return
	elseif gettingGolemTrinket then
		-- Custom rock pool only applies for machine, not natural trinkets
		if FiendFolio.TrinketPoolBlacklist[trinket] then
			return Game():GetItemPool():GetTrinket()
		elseif not (FiendFolio.RockTrinkets[trinket % 32768] ~= nil or FiendFolio.GolemTrinketWhitelist[trinket % 32768] ~= nil) then
			return Game():GetItemPool():GetTrinket()
		elseif FiendFolio.RockTrinkets[trinket % 32768] == -2 or FiendFolio.GolemTrinketWhitelist[trinket % 32768] == -2 then
			return Game():GetItemPool():GetTrinket()
		end
	elseif gettingRegularTrinket then
		if FiendFolio.TrinketPoolBlacklist[trinket] then
			return Game():GetItemPool():GetTrinket()
		elseif FiendFolio.RockTrinkets[trinket % 32768] ~= nil then
			return Game():GetItemPool():GetTrinket()
		end
	end
	
	local newTrinket = trinket
	
	if FiendFolio.TrinketPoolBlacklist[trinket] then
		newTrinket = Game():GetItemPool():GetTrinket()
	end
	
	if Isaac.GetChallenge() == Challenge.CHALLENGE_PICA_RUN then
		--do nothing
	elseif FiendFolio.UsedPentacles then
		FiendFolio.UsedPentacles = false
		--do nothing
	else
		local isAnyGolem, isMixedGolem = FiendFolio.GolemExists()
		if isMixedGolem then 
			--do nothing
		elseif not isAnyGolem then
			if FiendFolio.RockTrinkets[newTrinket % 32768] ~= nil then
				gettingRegularTrinket = true
				newTrinket = Game():GetItemPool():GetTrinket()
				gettingRegularTrinket = false
			end
		else
			if rng:RandomInt(100) < 15 then -- only reroll trinket to valid one sometimes
				-- Custom rock pool only applies for machine, not natural trinkets
				local rockRarity = FiendFolio.RockTrinkets[newTrinket % 32768]
				local whitelistRarity = FiendFolio.GolemTrinketWhitelist[trinket % 32768]
				
				if rockRarity ~= nil and rockRarity ~= -2 then
					--do nothing
				elseif whitelistRarity ~= nil and whitelistRarity ~= -2 then
					--do nothing
				else
					gettingGolemTrinket = true
					newTrinket = Game():GetItemPool():GetTrinket()
					gettingGolemTrinket = false
				end
				
				FiendFolio.TryRemoveGolemTrinketFromPool(newTrinket)
			else
				return newTrinket -- return invalid trinket
			end
		end
	end
	
	if newTrinket < TrinketType.TRINKET_GOLDEN_FLAG then
		local hasGoldenIOU = false
		for i = 1, game:GetNumPlayers() do
			local player = Isaac.GetPlayer(i - 1)
			if player:GetTrinket(0) == TrinketType.TRINKET_IOU + TrinketType.TRINKET_GOLDEN_FLAG or
			   player:GetTrinket(1) == TrinketType.TRINKET_IOU + TrinketType.TRINKET_GOLDEN_FLAG
			then
				hasGoldenIOU = true
				break
			end
		end

		if hasGoldenIOU and math.random(100) < 10 then
			newTrinket = newTrinket + TrinketType.TRINKET_GOLDEN_FLAG
		end
	end

	if newTrinket ~= trinket then
		return newTrinket
	end
end)

function mod.makeTrinketGolden(trinket)
	if mod.AchievementTrackers.GoldenTrinketsUnlocked then
		if trinket > TrinketType.TRINKET_GOLDEN_FLAG then
			return trinket
		end
		return trinket + TrinketType.TRINKET_GOLDEN_FLAG
	else
		return trinket
	end
end

function mod.tryMakeTrinketGolden(trinket)
	if mod.AchievementTrackers.GoldenTrinketsUnlocked then
		if trinket > TrinketType.TRINKET_GOLDEN_FLAG then
			return trinket
		end
		
		checkingForGolden = true
		local potentialGoldenTrinket = Game():GetItemPool():GetTrinket()
		checkingForGolden = false

		if potentialGoldenTrinket > TrinketType.TRINKET_GOLDEN_FLAG then
			return trinket + TrinketType.TRINKET_GOLDEN_FLAG
		end
		
		return trinket
	else
		return trinket
	end
end

-- Extra item callbacks
local TrackedItems = {
	Players = {},
	Callbacks = {
		Collect = {},
		Trinket = {}
	}
}

function FiendFolio.AddItemPickupCallback(onAdd, onRemove, item, forceAddOnRepickup)
	local entry = TrackedItems.Callbacks.Collect[item]
	local listing = { Add = onAdd, Remove = onRemove, ForceAddOnRepickup = forceAddOnRepickup }
	if not entry then
		TrackedItems.Callbacks.Collect[item] = { listing }
	else
		table.insert(entry, listing)
	end
end

function FiendFolio.AddTrinketPickupCallback(onAdd, onRemove, item, onGulp)
	local entry = TrackedItems.Callbacks.Trinket[item]
	local listing = { Add = onAdd, Remove = onRemove, Gulp = onGulp }
	if not entry then
		TrackedItems.Callbacks.Trinket[item] = { listing }
	else
		table.insert(entry, listing)
	end
end

mod:AddCallback(ModCallbacks.MC_POST_PLAYER_INIT, function(_, player)
	TrackedItems.Players[player:GetCollectibleRNG(1):GetSeed()] = {
		Collect = {},
		Trinket = {}
	}
end)

local function canAffordPickup(player, pickup)
	local playerType = player:GetPlayerType()
	if pickup.Price > 0 then
		return player:GetNumCoins() >= pickup.Price
	elseif playerType == PlayerType.PLAYER_THELOST or playerType == PlayerType.PLAYER_THELOST_B then
		return true
	elseif pickup.Price == -1 then
		--1 Red
		return math.ceil(player:GetMaxHearts() / 2) + player:GetBoneHearts() >= 1
	elseif pickup.Price == -2 then
		--2 Red
		return math.ceil(player:GetMaxHearts() / 2) + player:GetBoneHearts() >= 1
	elseif pickup.Price == -3 then
		--3 soul
		return math.ceil(player:GetSoulHearts() / 2) >= 1
	elseif pickup.Price == -4 then
		--1 Red, 2 Soul
		return math.ceil(player:GetMaxHearts() / 2) + player:GetBoneHearts() >= 1
	elseif pickup.Price == -7 then
		--1 Soul
		return math.ceil(player:GetSoulHearts() / 2) >= 1
	elseif pickup.Price == -8 then
		--2 Souls
		return math.ceil(player:GetSoulHearts() / 2) >= 1
	elseif pickup.Price == -9 then
		--1 Red, 1 Soul
		return math.ceil(player:GetMaxHearts() / 2) + player:GetBoneHearts() >= 1
	else
		return true
	end
end

mod:AddCallback(ModCallbacks.MC_PRE_PICKUP_COLLISION, function(_, pickup, collider, low)
	local collectibleConfig = Isaac.GetItemConfig():GetCollectible(pickup.SubType)
	local isActive = nil
	if collectibleConfig then
		isActive = collectibleConfig.Type == ItemType.ITEM_ACTIVE
	end

	if collider.Type == EntityType.ENTITY_PLAYER and
	   collider.Variant == 0
	then
		local player = collider:ToPlayer()
		if player:GetPlayerType() == PlayerType.PLAYER_THESOUL_B and player:GetOtherTwin() ~= nil then
			player = player:GetOtherTwin()
		end
		local data = player:GetData().ffsavedata

		if player:CanPickupItem() and
		   player:IsExtraAnimationFinished() and
		   player.ItemHoldCooldown <= 0 and
		   not player:IsCoopGhost() and
		   (collider.Parent == nil or (data and data.SpawnedAsKeeper and not isActive)) and --Strawman
		   player:GetPlayerType() ~= PlayerType.PLAYER_CAIN_B and
		   pickup.SubType ~= 0 and
		   pickup.Wait <= 0 and
		   not pickup.Touched and
		   canAffordPickup(player, pickup) and
		   TrackedItems.Callbacks.Collect[pickup.SubType] ~= nil
		then
			if data ~= nil then
				data.currentQueuedItem = pickup.SubType
			end
		end
	end
end, PickupVariant.PICKUP_COLLECTIBLE)

mod:AddCallback(ModCallbacks.MC_POST_PEFFECT_UPDATE, function(_, player)
	local ref = TrackedItems.Players[player:GetCollectibleRNG(1):GetSeed()]
	if not ref then
		ref = {
			Collect = {},
			Trinket = {}
		}
		TrackedItems.Players[player:GetCollectibleRNG(1):GetSeed()] = ref
	end

	-- IsHoldingItem is true for the entire pickup animation
	-- IsHeldItemVisible is true only when item is lifted... but on the first frame it's false so the cache would be updated
	-- therefore, on the first frame of a pickup animation, set a flag indicating the animation has started and from then on when IsHeldItem item is false ignore it
	-- until the player is no longer holding an item, then reset it
	local basedata = player:GetData()
	local data = basedata.ffsavedata
	local playerIsHoldingItem = player:IsHoldingItem()
	if playerIsHoldingItem then
		if not player:IsHeldItemVisible() then
			if basedata.StartedPickupAnimation then
				playerIsHoldingItem = false
			else
				basedata.StartedPickupAnimation = true
			end
		end
	else
		basedata.StartedPickupAnimation = nil
	end

	for item, callbacks in pairs(TrackedItems.Callbacks.Collect) do
		local count = player:GetCollectibleNum(item, true)
		local skipUpdate = false
		if ref.Collect[item] then
			local diff = count - ref.Collect[item]
			if diff > 0 and playerIsHoldingItem then
				skipUpdate = true
			elseif diff ~= 0 then
				for _, entry in ipairs(callbacks) do
					local foo = nil
					if diff > 0 and entry.ForceAddOnRepickup then
						foo = entry.Add
					else
						foo = entry.Remove
					end

					if foo then
						foo(player, math.abs(diff), count)
					end
				end
			end
		end
		if not skipUpdate then
			ref.Collect[item] = count
		end
	end

	local queuedItem = player.QueuedItem
	if data.currentQueuedItem ~= nil and (queuedItem.Item == nil or queuedItem.Item.ID ~= data.currentQueuedItem) then
		local item = data.currentQueuedItem
		data.currentQueuedItem = nil

		local callbacks = TrackedItems.Callbacks.Collect[item]
		local count = player:GetCollectibleNum(item, true)

		for _, entry in ipairs(callbacks) do
			local foo = entry.Add
			if foo and not entry.ForceAddOnRepickup then
				foo(player, 1, count)
			end
		end
	end
	if data.currentQueuedItem == nil and 
	   queuedItem.Item ~= nil and 
	   not queuedItem.Touched and 
	   queuedItem.Item:IsCollectible() and
	   TrackedItems.Callbacks.Collect[queuedItem.Item.ID] ~= nil 
	then
		data.currentQueuedItem = queuedItem.Item.ID
	end

	for item, callbacks in pairs(TrackedItems.Callbacks.Trinket) do
		local has = player:HasTrinket(item)
		local gulped = has and FiendFolio.GetTrinketSlot(player, item) < 0
		local skipUpdate = false
		if ref.Trinket[item] ~= nil then
			if has and playerIsHoldingItem then
				skipUpdate = true
			elseif has ~= ref.Trinket[item].Has then
				for _, entry in ipairs(callbacks) do
					local foo = nil
					if has then
						foo = entry.Add
					else
						foo = entry.Remove
					end

					if foo then
						foo(player, has)
					end
				end
			elseif gulped and not ref.Trinket[item].Gulped then
				for _, entry in ipairs(callbacks) do
					local foo = entry.Gulp
					if foo then
						foo(player)
					end
				end
			end
		end
		if not skipUpdate then
			ref.Trinket[item] = { Has = has, Gulped = gulped }
		end
	end

	if player:HasTrinket(TrinketType.TRINKET_FORTUNE_GRUB) then
		local n = player:GetTrinketMultiplier(TrinketType.TRINKET_FORTUNE_GRUB)
		for _, slot in pairs(Isaac.FindByType(6, -1, -1)) do
			local s = slot:GetSprite()
			if s:IsFinished("WiggleEnd") then
				FiendFolio.QueueFortunes(n)
			elseif s:IsFinished("PayNothing") or s:IsFinished("PayPrize") then
				s:Play("Idle")
				FiendFolio.QueueFortunes(n)
			end
		end
	end

	if basedata.lastDamageSourceWasCursedDoor and player:GetDamageCooldown() <= 0 then
		basedata.lastDamageSourceWasCursedDoor = false
	end

	mod:erflyPeffectUpdate(player, basedata, data)

	local effects = player:GetEffects()
	if effects:HasCollectibleEffect(CollectibleType.COLLECTIBLE_BERSERK) then
		if effects:GetCollectibleEffect(CollectibleType.COLLECTIBLE_BERSERK).Cooldown == 1 then
			if player:GetBoneHearts() == 0 and player:GetSoulHearts() == 0 and player:GetHearts() == 0 then
				if mod.CanPlayerReviveWithFrogPuppet(player) then
					mod.DoFrogPuppetRevive(player)
				elseif mod.CanPlayerReviveWithCursedUrn(player) then
					mod.DoCursedUrnRevive(player)
				end
			end
		end
	end
end)

-- Savedata pt 2

mod:AddCallback(ModCallbacks.MC_POST_PLAYER_INIT, function(_, player)
	local basedata = player:GetData()
	basedata.ffsavedata = {}
	local data = basedata.ffsavedata

	data.orbitingfireballs = 0
	data.pillstotake = 0
	data.FrictionMod = 0
	data.RunEffects = {
		RoomClearCounts = {}, -- intended for keeping track of clear counts since picking up item
		Collectibles = {},
		Trinkets = {},
		TrueRoomClearCounts = {}, -- The above one gets reset whenever you take damage.
	}

	local keyGhosts = {}
	basedata.KeyGhostData = keyGhosts
	for _, variant in pairs(FiendFolio.KeyToGhostMap) do
		keyGhosts[variant] = {}
	end

	data.SpawnedAsKeeper = player:GetPlayerType() == PlayerType.PLAYER_KEEPER -- For item pickup callback to be able to detect Strawmen
end)

function mod.RealFiendInit(player)
	player:GetSprite():Load("gfx/characters/player_fiend.anm2", true)
	player:GetSprite():Play(player:GetSprite():GetDefaultAnimationName(), true)
end

mod:AddCallback(ModCallbacks.MC_POST_GAME_STARTED, function(_, continuing)
	ModReloadDetector.GameStarted = true
	Isaac.DebugString("PREFFSAVELOAD")
	FiendFolio.LoadSaveData()
	Isaac.DebugString("POSTFFSAVELOAD")

	if FiendFolio.MonsoonName then
		local monsoonData = StageAPI.GetBossData("Moistro")
		if FiendFolio.MonsoonName == 6 then -- share your best monsoon seeds!
			local gamerng = RNG()
			gamerng:SetSeed(game:GetSeeds():GetStartSeed(), 0)
			local name = (gamerng:Next() % 5) + 1
			monsoonData.Bossname = FiendFolio.MonsoonNames[name]
		else
			monsoonData.Bossname = FiendFolio.MonsoonNames[FiendFolio.MonsoonName]
		end
	end

	if FiendFolio.WarpZoneName then
		local warpzoneData = StageAPI.GetBossData("Warp Zone")
		if FiendFolio.WarpZoneName == 4 then -- share your best mega portal seeds!
			local gamerng = RNG()
			gamerng:SetSeed(game:GetSeeds():GetStartSeed(), 0)
			local name = (gamerng:Next() % 5) + 1
			warpzoneData.BossName = FiendFolio.WarpZoneNames[name]
		else
			warpzoneData.BossName = FiendFolio.WarpZoneNames[FiendFolio.WarpZoneName]
		end
	end

	if FiendFolio.savedata.playerHadIOU then
		if not continuing then
			local room = Game():GetRoom()
			local spawnpos = room:FindFreePickupSpawnPosition(room:GetCenterPos(), 1, true)
			local trinket = Isaac.Spawn(5, 350, 0, spawnpos, nilvector, nil):ToPickup()

			if trinket.Type == 5 and trinket.Variant == 350 and FiendFolio.savedata.playerHadGoldenIOU then
				trinket:Morph(5, 350, trinket.SubType + TrinketType.TRINKET_GOLDEN_FLAG)
			end
		end
		FiendFolio.savedata.playerHadIOU = nil
	elseif FiendFolio.savedata.playerHadFossilizedBlessing then
		if not continuing then
			local room = Game():GetRoom()
			for i=1,FiendFolio.savedata.playerHadFossilizedBlessing do
				local spawnpos = room:FindFreePickupSpawnPosition(room:GetCenterPos(), 1, true)
				local trinket = Isaac.Spawn(5, 350, mod.GetGolemTrinket(), spawnpos, nilvector, nil):ToPickup()
			end
		end
		FiendFolio.savedata.playerHadFossilizedBlessing = nil
	end

	mod.ValidateSavedataEntries({ -- in case anyone else wants to use this: {stringKey, defaultValue}
		{"risksRewardIndexData",	{}},
		{"levelEntityPersistence",	{}},

		{"direChestConvertChance",	1/128},
		{"hasBeatenSlinger",		false},
	})

	if not continuing then
		FiendFolio.savedata.run = {}
		mod.bubbleKillCounter = 0
		mod.motherFollowing = nil

		mod.savedata.tmtrainerIdsUsed = {}
		mod.savedata.risksRewardIndexData = {}
		mod.savedata.levelEntityPersistence = {}
		mod.savedata.direChestConvertChance = 1/256
		mod.savedata.cardRngSeed = nil

		for _, customPoolData in pairs(mod.CustomPool) do
			mod.savedata[customPoolData[1] .. "Recycled"] = false
		end
		
		FiendFolio.savedata.CustomHealthAPISave = nil
	end
	
	mod:erflyPostGameStart(continuing)

	for i = 1, game:GetNumPlayers() do
		local p = Isaac.GetPlayer(i - 1)
		local pdata = p:GetData()

		if p:GetPlayerType() == FiendFolio.PLAYER.FIEND then
			mod.RealFiendInit(p)
		end

		if continuing then
			for key, val in pairs(FiendFolio.savedata.run.playerSaveData[i]) do
				pdata.ffsavedata[key] = val
			end
		end

		mod:ferriumPlayerInit(p, pdata, continuing)
		
		p:AddCacheFlags(CacheFlag.CACHE_ALL)
		p:EvaluateItems()
	end

	--azurite spindown check
	local itempool = game:GetItemPool()
	local unlockableVanillaTrinkets = {1, 13, 15, 21, 23, 28, 35, 42, 49, 50, 52, 54, 55, 56, 57, 58, 59, 60, 61, 67, 74, 76, 80, 81, 83, 84, 85,
	                            		91, 92, 107, 110, 111, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128}
	for _, id in ipairs(unlockableVanillaTrinkets) do
		if not itempool:RemoveTrinket(id) then
			ffBlacklistAzurite({id})
		end
	end
	itempool:ResetTrinkets()

	FiendFolio.AchievementsPostGameStart()

	mod.BuildCustomItemPools()

	if FiendFolio.ItemConfig.OpihuchusDisabled then
		itempool:RemoveCollectible(FiendFolio.ITEM.COLLECTIBLE.OPIHUCHUS)
	end

	if FiendFolio.ItemConfig.CetusDisabled then
		itempool:RemoveCollectible(FiendFolio.ITEM.COLLECTIBLE.CETUS)
	end

	itempool:RemoveTrinket(TrinketType.TRINKET_HALF_VESSEL)
	itempool:RemoveTrinket(TrinketType.TRINKET_FULL_VESSEL)
	itempool:RemoveTrinket(FiendFolio.ITEM.TRINKET.MIDDLE_HAND)
	itempool:RemoveTrinket(FiendFolio.ITEM.ROCK.UNOBTAINIUM)
	itempool:RemoveTrinket(FiendFolio.ITEM.ROCK.FOOLS_UNOBTAINIUM)
	itempool:RemoveTrinket(FiendFolio.ITEM.ROCK.DOGROCK_ROCK)

	if game.Difficulty >= Difficulty.DIFFICULTY_GREED then
		itempool:RemoveTrinket(TrinketType.TRINKET_BIFURCATED_STARS)
		ffBlacklistAzurite({TrinketType.TRINKET_BIFURCATED_STARS})
	end

	if REVEL then
		-- temp hack until rev updates to expose the blacklist global
		local oldImpl = REVEL.IsCharonInventoryManagedItem
		REVEL.IsCharonInventoryManagedItem = function(id, item)
			if item and not id then
				id = item.ID
			end

			item = item or REVEL.config:GetCollectible(id)
			return oldImpl(id, item) and id ~= CollectibleType.COLLECTIBLE_GMO_CORN
		end
	end

	if Isaac.GetChallenge() == mod.challenges.brickByBrick and not continuing then
		local player = Isaac.GetPlayer(0)
		player:ChangePlayerType(FiendFolio.PLAYER.GOLEM)
		FiendFolio.EnsurePockets(player)
		player:AddTrinket(FiendFolio.ITEM.ROCK.BRICK_ROCK)
		player:AddTrinket(FiendFolio.ITEM.ROCK.BRICK_ROCK + TrinketType.TRINKET_GOLDEN_FLAG)

		--local level = game:GetLevel()
		--local secret = level:QueryRoomTypeIndex(RoomType.ROOM_SECRET, false, grng)
		--if secret and secret >= 0 then
		--	local desc = level:GetRoomByIdx(secret)
		--	desc.DisplayFlags = desc.DisplayFlags | 5
		--	level:UpdateVisibility()
		--end
	elseif Isaac.GetChallenge() == mod.challenges.towerOffense and not continuing then
		local player = Isaac.GetPlayer(0)
		player:ChangePlayerType(FiendFolio.PLAYER.GOLEM)
		FiendFolio.EnsurePockets(player)
	end

	if not mod.savedata.shownUnlocksChoicePopup then
		DeadSeaScrollsMenu.QueueMenuOpen("Fiend Folio", "unlockspopup", 1, true)
	end

	FiendFolio.SaveSaveData()

	gamestarted = true
end)

mod:AddCallback(ModCallbacks.MC_PRE_GAME_EXIT, function()
	Isaac.DebugString("PREGAMEEXIT")
	mod:handleSecretStash()
	if mod.anyPlayerHas(TrinketType.TRINKET_IOU, true) then
		FiendFolio.savedata.playerHadIOU = true
		for i = 1, game:GetNumPlayers() do
			local player = Isaac.GetPlayer(i - 1)
			if player:GetTrinket(0) == TrinketType.TRINKET_IOU + TrinketType.TRINKET_GOLDEN_FLAG or
			   player:GetTrinket(1) == TrinketType.TRINKET_IOU + TrinketType.TRINKET_GOLDEN_FLAG
			then
				FiendFolio.savedata.playerHadGoldenIOU = true
				break
			end
		end
	end
	Isaac.DebugString("PREGAMEEXITPRESAVE")
	FiendFolio.SaveSaveData()
	mod.INITIALISED_UNLOCKS = false
	mod.LOADED_SAVEDATA = false
	Isaac.DebugString("PREGAMEEXITPOSTSAVE")
	gamestarted = false
end)

mod:AddCallback(ModCallbacks.MC_POST_GAME_END, function()
	gamestarted = false
end)

if ModReloadDetector.GameStarted and game:GetFrameCount() > 0 then
	if not mod.LOADED_SAVEDATA then
		FiendFolio.LoadSaveData()
	end

	FiendFolio:checkConfigSettings()
end

-- Fiend stuff

local fiendstats = {
	damage = 1.2,
	tears = 1.3,
	speed = 0.2,
	shotspeed = 0.25,
	luck = -1,
	flag = 4,
	colour = Color(1.0, 1.0, 0.5, 1.0, 200 / 255, 0, 0),
}
local coindamages = {
	[CoinSubType.COIN_PENNY] = 1,
	[CoinSubType.COIN_NICKEL] = 3,
	[CoinSubType.COIN_DIME] = 5,
	[CoinSubType.COIN_DOUBLEPACK] = 2,
	[CoinSubType.COIN_LUCKYPENNY] = 2,
}
local spoilsdamages = {
	[1] = 1,
	[5] = 3,
	[10] = 5,
	[101] = 1,
	[105] = 3,
	[110] = 5
}

FiendFolio.PHDPills = {
	PillEffect.PILLEFFECT_BAD_GAS,
	PillEffect.PILLEFFECT_BALLS_OF_STEEL,
	PillEffect.PILLEFFECT_BOMBS_ARE_KEYS,
	PillEffect.PILLEFFECT_EXPLOSIVE_DIARRHEA,
	PillEffect.PILLEFFECT_FULL_HEALTH,
	PillEffect.PILLEFFECT_HEALTH_UP,
	PillEffect.PILLEFFECT_I_FOUND_PILLS,
	PillEffect.PILLEFFECT_PUBERTY,
	PillEffect.PILLEFFECT_PRETTY_FLY,
	PillEffect.PILLEFFECT_RANGE_UP,
	PillEffect.PILLEFFECT_SPEED_UP,
	PillEffect.PILLEFFECT_TEARS_UP,
	PillEffect.PILLEFFECT_LUCK_UP,
	PillEffect.PILLEFFECT_TELEPILLS,
	PillEffect.PILLEFFECT_48HOUR_ENERGY,
	PillEffect.PILLEFFECT_HEMATEMESIS,
	PillEffect.PILLEFFECT_SEE_FOREVER,
	PillEffect.PILLEFFECT_PHEROMONES,
	PillEffect.PILLEFFECT_LEMON_PARTY,
	PillEffect.PILLEFFECT_PERCS,
	PillEffect.PILLEFFECT_RELAX,
	PillEffect.PILLEFFECT_LARGER,
	PillEffect.PILLEFFECT_SMALLER,
	PillEffect.PILLEFFECT_INFESTED_EXCLAMATION,
	PillEffect.PILLEFFECT_INFESTED_QUESTION,
	PillEffect.PILLEFFECT_POWER,
	PillEffect.PILLEFFECT_FRIENDS_TILL_THE_END,
	PillEffect.PILLEFFECT_SOMETHINGS_WRONG,
	PillEffect.PILLEFFECT_IM_DROWSY,
	PillEffect.PILLEFFECT_GULP,
	PillEffect.PILLEFFECT_HORF,
	PillEffect.PILLEFFECT_SUNSHINE,
	PillEffect.PILLEFFECT_VURP,
}

function FiendFolio.QueuePills(player, num)
	local data = player:GetData()
	local sdata = data.ffsavedata
	data.pilltimer = 0
	sdata.pillstotake = sdata.pillstotake + num
end

function FiendFolio.QueueFortunes(num)
	local d = Isaac.GetPlayer(0):GetData()

	d.fortunestodisplay = d.fortunestodisplay or 0

	if not d.fortunetimer or (d.fortunetimer > 75 and d.fortunestodisplay == 0) then
		d.fortunetimer = 0
	end

	d.fortunestodisplay = d.fortunestodisplay + num
end

function mod.animRespawn()
	for i = 1, game:GetNumPlayers() do
		local player = Isaac.GetPlayer(i - 1)
		local data = player:GetData()

		mod:animDevilsHarvestRespawn(player, data)
	end
end

local fiendsToInit = {}
local usingGenesis = false
FiendFolio.GameHasStarted = false

local function initializeFiend(player)
	if fiendconfig.ImpBabyMode then
		player:AddCollectible(CollectibleType.COLLECTIBLE_SULFURIC_ACID, 0, true)
		Game():GetItemPool():RemoveCollectible(CollectibleType.COLLECTIBLE_SULFURIC_ACID)
		player:DropPoketItem(0, nilvector)
		for _, c in pairs(Isaac.FindByType(EntityType.ENTITY_PICKUP, PickupVariant.PICKUP_TAROTCARD, Card.CARD_STARS, false, false)) do
			c:Remove()
		end
		player:AddMaxHearts(6)
		player:AddHearts(6)
		player:AddBlackHearts(-4)
	else
		mod:AddImmoralHearts(player, 2)
	end
end

mod:AddCallback(ModCallbacks.MC_POST_GAME_STARTED, function(_, continued)
	if not continued then
		for _, player in ipairs(fiendsToInit) do
			initializeFiend(player)
		end
	end
	
	FiendFolio.GameHasStarted = true
	fiendsToInit = {}
end)

mod:AddCallback(ModCallbacks.MC_POST_GAME_END, function()
	FiendFolio.GameHasStarted = false
	usingGenesis = false
end)

mod:AddCallback(ModCallbacks.MC_POST_PLAYER_INIT, function(_, player)
	if player:GetPlayerType() == FiendFolio.PLAYER.FIEND then
		if not usingGenesis then
			if FiendFolio.GameHasStarted then
				initializeFiend(player)
			else
				table.insert(fiendsToInit, player)
			end
		end
	end
end)

mod:AddCallback(ModCallbacks.MC_USE_ITEM, function()
	usingGenesis = true
end, CollectibleType.COLLECTIBLE_GENESIS)

CustomHealthAPI.Library.AddCallback("FiendFolio", CustomHealthAPI.Enums.Callbacks.POST_PLAYER_GENESIS, 0, function(player)
	if player:GetPlayerType() == FiendFolio.PLAYER.FIEND then
		initializeFiend(player)
	end
end)

CustomHealthAPI.Library.AddCallback("FiendFolio", CustomHealthAPI.Enums.Callbacks.POST_GENESIS, 0, function()
	usingGenesis = false
end)

mod:AddCallback(ModCallbacks.MC_POST_PLAYER_UPDATE, function(_, player)
	local data = player:GetData()
	local level = game:GetLevel()
	local room = game:GetRoom()

	if player:GetPlayerType() == FiendFolio.PLAYER.FIEND and data.fiendishfix and data.fiendishfix >= player.FrameCount then
		player:AddSoulHearts(-90)
		data.fiendishfix = nil
	end

	local sdata = data.ffsavedata
	if mod.IsActiveRoom() and sdata.orbitingfireballs < 3 then
		if player:HasCollectible(CollectibleType.COLLECTIBLE_PYROMANCY) then
			-- Charge move time
			if not data.firechargetimer then
				data.firechargetimer = player.FrameCount + math.min(150, player.MaxFireDelay * 7)
			end

			if player.FrameCount >= data.firechargetimer then
				data.firechargetimer = nil

				fiendflasheffect = Isaac.Spawn(1000, 668, 0, player.Position, Vector(0,0), player):ToEffect()
				fiendflasheffect:GetData().parent = player
				if mod:isSuperpositionedPlayer(player) then
					local flashcolor = Color.Lerp(fiendflasheffect.Color, Color(1,1,1,1,0,0,0), 0)
					flashcolor.A = flashcolor.A / 4
					fiendflasheffect.Color = flashcolor
				end
				sfx:Play(SoundEffect.SOUND_FLAME_BURST, 0.3, 0, false, math.random(150,160)/100)

				sdata.orbitingfireballs = sdata.orbitingfireballs + 1
				player:AddCacheFlags(CacheFlag.CACHE_FAMILIARS)
				player:EvaluateItems()
			end
		end
	end

	if data.stopDieSound then
		sfx:Stop(SoundEffect.SOUND_ISAACDIES)
	end

	if player:GetPlayerType() == FiendFolio.PLAYER.FIEND then
		if player:GetSprite():IsPlaying("Death") and sfx:IsPlaying(SoundEffect.SOUND_ISAACDIES) then
			sfx:Stop(SoundEffect.SOUND_ISAACDIES)
			sfx:Play(mod.Sounds.FiendDies, 0.8, 0, false, 1)
		end
	end

	if player:GetPlayerType() == FiendFolio.PLAYER.FEND then
		if player:GetSprite():IsPlaying("Death") and sfx:IsPlaying(SoundEffect.SOUND_ISAACDIES) then
			sfx:Stop(SoundEffect.SOUND_ISAACDIES)
			sfx:Play(mod.Sounds.FiendDies, 0.8, 0, false, 0.7)
		end
	end

	if player:GetPlayerType() == FiendFolio.PLAYER.BIEND then
		if player:GetSprite():IsPlaying("Death") and sfx:IsPlaying(SoundEffect.SOUND_ISAACDIES) then
			sfx:Stop(SoundEffect.SOUND_ISAACDIES)
			sfx:Play(mod.Sounds.BiendFreakingDies, 0.8, 0, false, 1)
		end
	end

	if player:GetPlayerType() == FiendFolio.PLAYER.CHINA then
		if player:GetSprite():IsPlaying("Death") and sfx:IsPlaying(SoundEffect.SOUND_ISAACDIES) then
			sfx:Stop(SoundEffect.SOUND_ISAACDIES)
			sfx:Play(SoundEffect.SOUND_MIRROR_BREAK, 0.8, 0, false, 1)
		end
	end

	if player:GetPlayerType() == FiendFolio.PLAYER.FIENT then
		if player:GetSprite():IsPlaying("Death") and sfx:IsPlaying(SoundEffect.SOUND_ISAACDIES) then
			sfx:Stop(SoundEffect.SOUND_ISAACDIES)
			sfx:Play(mod.Sounds.AGWheeze, 1, 0, false, 0.75)
		end
	end
	
	if player:GetPlayerType() == FiendFolio.PLAYER.FIEND then

		--Merged with custom health handling
		--[[if NoHealthCapModEnabled then
			--NoHealthCapBlackHearts = NoHealthCapBlackHearts + NoHealthCapSoulHearts
			if not data.extrablacklastcheck then
				data.extrablacklastcheck = NoHealthCapBlackHearts
				data.fiendtakedamage = false
			elseif data.extrablacklastcheck > NoHealthCapBlackHearts and data.fiendtakedamage then
				data.miniontime = 1
			end
		end

		if data.miniontime then
			local black_hearts = player:GetSoulHearts()

			local minion_amount = math.floor((black_hearts - 1)/2)

			if NoHealthCapModEnabled and NoHealthCapBlackHearts > 0 then
				minion_amount = minion_amount + math.floor(NoHealthCapBlackHearts / 2)
				local savethisnum = NoHealthCapBlackHearts
				losesoulhealth(NoHealthCapBlackHearts)
				if NoHealthCapBlackHearts > 2 then
					player:AddBlackHearts(-1 * math.min(savethisnum, 2))
				else
					player:AddBlackHearts(-1)
				end
			end

			local spawnBonus = black_hearts % 2 == 0 or (black_hearts == 1 and data.miniontime > 1)
			if spawnBonus then minion_amount = minion_amount + 1 end

			local egg = nil

			player:AddBlackHearts(-1 * (black_hearts - 1))
			--[for i = 1, minion_amount do
				egg = Isaac.Spawn(5, PickupVariant.PICKUP_FIEND_EGG, 1, player.Position, Vector(math.random(-5, 5), math.random(-5, 5)), player):ToPickup()
				egg:GetData().proof = true
				egg.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
				egg.Parent = player
			end

			--the last egg spawns the purple heart
			if spawnBonus then
				egg:GetData().spawnhollow = true
			end]--

			for i = 1, minion_amount do
				if spawnBonus and i == minion_amount then
					egg = Isaac.Spawn(1000, EffectVariant.PICKUP_FIEND_MINION, 1, player.Position, Vector(math.random(-5, 5), math.random(-5, 5)), player):ToEffect()
					egg:GetData().hollow = true
					egg:GetData().canreroll = false
				else
					egg = Isaac.Spawn(5, PickupVariant.PICKUP_FIEND_MINION, 1, player.Position, Vector(math.random(-5, 5), math.random(-5, 5)), player):ToPickup()
				end
				egg:GetSprite():Play("Drop", true)
				if math.random(2) == 1 then
					egg:GetSprite().FlipX = true
				end
				egg.Parent = player
				egg:Update()
			end

			data.miniontime = false
		end

		if NoHealthCapModEnabled then
			data.fiendtakedamage = false
			data.extrablacklastcheck = NoHealthCapBlackHearts
		end]]--

		--if player.FrameCount == 0 and not player:GetData().ffsavedata.InitializedFiend then
			--[[if (CompletionNoteAPIMod:isFullyCompleted("Fiend") or fiendconfig.DisableUnlocks) and not fiendconfig.DisableFiendItems and not fiendconfig.ImpBabyMode then
				--uh, disabling here too to be safe?
				--player:AddCollectible(CollectibleType.COLLECTIBLE_FIEND_FOLIO, 6, true)
				--itempool:RemoveCollectible(CollectibleType.COLLECTIBLE_FIEND_FOLIO)
			end]]
		--[[	if fiendconfig.ImpBabyMode then
				player:AddCollectible(CollectibleType.COLLECTIBLE_SULFURIC_ACID, 0, true)
				Game():GetItemPool():RemoveCollectible(CollectibleType.COLLECTIBLE_SULFURIC_ACID)
				player:DropPoketItem(0, nilvector)
				for _, c in pairs(Isaac.FindByType(EntityType.ENTITY_PICKUP, PickupVariant.PICKUP_TAROTCARD, Card.CARD_STARS, false, false)) do
					c:Remove()
				end
				player:AddMaxHearts(6)
				player:AddHearts(6)
				player:AddBlackHearts(-4)
			else
				mod:AddImmoralHearts(player, 2)
			end

			player:GetData().ffsavedata.InitializedFiend = true
		end]]--
		--[[if not fiendconfig.ImpBabyMode then
			--this is now all handled through Custom Health API callbacks
			local bones = player:GetBoneHearts()
			if bones > 0 then
				player:AddBoneHearts(-bones)
				--player:AddBlackHearts(2 * bones)
				for i = 1, bones * 8 do
					-- bone orbitals are unaffected by the familiar cache
					local fam = Isaac.Spawn(EntityType.ENTITY_FAMILIAR, FamiliarVariant.BONE_ORBITAL, 0, player.Position + RandomVector() * 20, Vector(0,0), player):ToFamiliar()
					fam.Player = player
				end
			end

			local hearts = player:GetMaxHearts()
			if hearts > 0 then
				player:AddMaxHearts(-hearts)
				CustomHealthAPI.Library.AddHealth(player, "IMMORAL_HEART", hearts, true)
			end

			local souls = player:GetSoulHearts()
			local blackHeartMask = mod:getBlackHeartsMask(player, true)
			local immoralHeartMask = FiendFolio.GetImmoralHeartsMask(player, true)
			for i = 0, math.ceil(souls / 2) - 1 do
				local n = 1 << i

				if immoralHeartMask & n == 0 and blackHeartMask & n == 0 then
					player:GetData().ffsavedata.FFCurrentImmoralHeartMask = player:GetData().ffsavedata.FFCurrentImmoralHeartMask | n
				end
			end]]--

			--black heart replacement for fiend
			--merged with custom health handling because immoral did not work with shop items otherwise for some dumb reason
			--[[local heartluck = math.max(0, math.min(13, player.Luck))
			for _, heart in pairs(Isaac.FindByType(5, 10, -1)) do
				local d = heart:GetData()

				if not d.checkedforfiend then
					heart = heart:ToPickup()
					d.checkedforfiend = true
					if heart.SubType == HeartSubType.HEART_BLACK then
						--heart.Timeout = 60
					else
						if heart.SubType == HeartSubType.HEART_SOUL then
							heart:Morph(5, 10, 6, true)
						elseif heart.SubType == HeartSubType.HEART_HALF_SOUL then
							heart:Morph(5, PickupVariant.PICKUP_FIENDFOLIO_HALF_BLACK_HEART, 0, true)
						elseif heart.SubType == HeartSubType.HEART_BLENDED then
							heart:Morph(5, PickupVariant.PICKUP_FIENDFOLIO_BLENDED_BLACK_HEART, 0, true)
						elseif heart:GetSprite():IsPlaying("Appear") and room:GetType() ~= RoomType.ROOM_SUPERSECRET then
							grng:SetSeed(heart.InitSeed, 0)

							if heart.SubType == HeartSubType.HEART_ETERNAL or heart.SubType == HeartSubType.HEART_GOLDEN then
								heart:Morph(5, 10, 6, true)
							elseif heart.SubType == HeartSubType.HEART_BONE and grng:RandomInt(5) == 0 then
								heart:Morph(5, 10, 6, true)
							elseif grng:RandomInt(99) + 1 <= 33 + (33 * heartluck/13) then
								if heart.SubType == HeartSubType.HEART_HALF then
									heart:Morph(5, PickupVariant.PICKUP_FIENDFOLIO_HALF_BLACK_HEART, 0, true)
								else
									heart:Morph(5, 10, 6, true)
								end
							end
						end
					end
				end
			end
		end]]--

		-- Fiend has a custom Revelations chill head costume
		if data.FrozenSprite then
			data.FrozenSprite:ReplaceSpritesheet(0, "gfx/effects/freezehead_fiend.png")
			data.FrozenSprite:ReplaceSpritesheet(1, "gfx/effects/freezeheadmelt_fiend.png")
			data.FrozenSprite:LoadGraphics()
		end
	end

	if player:HasTrinket(TrinketType.TRINKET_BIFURCATED_STARS) and not game:IsGreedMode() then
		if data.revealboss == nil then
			local idx = level:QueryRoomTypeIndex(RoomType.ROOM_BOSS, false, grng)
			local roomdesc = level:GetRoomByIdx(idx)
			if roomdesc.Data.Type == RoomType.ROOM_BOSS then
				roomdesc.DisplayFlags = roomdesc.DisplayFlags | 5 -- visibility + "revealed"
				level:UpdateVisibility()
				data.revealboss = true
			end
		end
		if room:GetType() == RoomType.ROOM_BOSS and data.treasureport == nil then
			local idx = level:QueryRoomTypeIndex(RoomType.ROOM_TREASURE, false, grng)
			local trRoom = level:GetRoomByIdx(idx)
			if trRoom and trRoom.Data.Type == RoomType.ROOM_TREASURE then
				for i = 0, 8 do
					local d = room:GetDoor(i)
					if d then
						if d:IsOpen() and d.TargetRoomType == RoomType.ROOM_DEFAULT then
							d:SetRoomTypes(RoomType.ROOM_BOSS, RoomType.ROOM_TREASURE)
							data.treasureport = true
							break
						end
					end
				end
			end
		end
	end

	if player:HasCollectible(CollectibleType.COLLECTIBLE_COOL_SUNGLASSES) then
		data.closeenough = 0
		--regular coins
		for _, c in pairs(Isaac.FindByType(5, 20, -1, false, false)) do
			if not (c:GetSprite():IsPlaying("Appear") or c:GetSprite():IsPlaying("AppearFast")) then
				if c.Position:Distance(player.Position) - c.Size - player.Size <= 0 and not c:GetData().coolsunglasses and (coindamages[c.SubType] or c.SubType == 213) then
					c:GetData().coolsunglasses = true
					for _, npc in pairs(Isaac.GetRoomEntities()) do
						if npc:IsActiveEnemy() and npc:IsVulnerableEnemy() and not npc:HasEntityFlags(EntityFlag.FLAG_FRIENDLY) then
							if(c.SubType == 213) then
								local r = math.random(5, 50)/10
								npc:TakeDamage(player.Damage*r, 0, EntityRef(player), 0)
							else
								npc:TakeDamage(player.Damage*coindamages[c.SubType], 0, EntityRef(player), 0)
							end
						end
					end
					game:ShakeScreen(7)
					sfx:Play(SoundEffect.SOUND_SUMMONSOUND, 0.6, 0, false, 1)
					data.closeenough = 0
				elseif c.Position:Distance(player.Position) - c.Size - player.Size <= 120 and not c:GetSprite():IsPlaying("Collect") then
					local d = 0.5 * (120 - (c.Position:Distance(player.Position) - c.Size - player.Size))/120
					if d > data.closeenough then data.closeenough = d end
					if c.Position:Distance(player.Position) - c.Size - player.Size <= 0 then data.closeenough = 0 end
				end
				player:AddCacheFlags(CacheFlag.CACHE_SPEED)
				player:EvaluateItems()
			end
		end
		--spoils pouch
		for _, c in pairs(Isaac.FindByType(5, 1875, -1, false, false)) do
			if not (c:GetSprite():IsPlaying("Expire") or c:GetSprite():IsPlaying("Appear")) then
				if c.Position:Distance(player.Position) - c.Size - player.Size <= 0 and not c:GetData().coolsunglasses and spoilsdamages[c.SubType] then
					c:GetData().coolsunglasses = true
					for _, npc in pairs(Isaac.GetRoomEntities()) do
						if npc:IsActiveEnemy() and npc:IsVulnerableEnemy() and not npc:HasEntityFlags(EntityFlag.FLAG_FRIENDLY) then
							npc:TakeDamage(player.Damage*spoilsdamages[c.SubType], 0, EntityRef(player), 0)
						end
					end
					game:ShakeScreen(7)
					sfx:Play(SoundEffect.SOUND_SUMMONSOUND, 0.6, 0, false, 1)
					data.closeenough = 0
				elseif c.Position:Distance(player.Position) - c.Size - player.Size <= 120 and not c:GetSprite():IsPlaying("Collect") then
					local d = 0.5 * (120 - (c.Position:Distance(player.Position) - c.Size - player.Size))/120
					if d > data.closeenough then data.closeenough = d end
					if c.Position:Distance(player.Position) - c.Size - player.Size <= 0 then data.closeenough = 0 end
				end
				player:AddCacheFlags(CacheFlag.CACHE_SPEED)
				player:EvaluateItems()
			else
				data.closeenough = 0
				player:AddCacheFlags(CacheFlag.CACHE_SPEED)
				player:EvaluateItems()
			end
		end
		--mammon coin pile
		for _, c in pairs(Isaac.FindByType(5, 1876, -1, false, false)) do
			if c.Position:Distance(player.Position) - c.Size - player.Size <= 0 and not c:GetData().coolsunglasses then
				c:GetData().coolsunglasses = true
				for _, npc in pairs(Isaac.GetRoomEntities()) do
					if npc:IsActiveEnemy() and npc:IsVulnerableEnemy() and not npc:HasEntityFlags(EntityFlag.FLAG_FRIENDLY) then
						npc:TakeDamage(player.Damage*c.SubType, 0, EntityRef(player), 0)
					end
				end
				game:ShakeScreen(7)
				sfx:Play(SoundEffect.SOUND_SUMMONSOUND, 0.6, 0, false, 1)
				data.closeenough = 0
			elseif c.Position:Distance(player.Position) - c.Size - player.Size <= 120 and not c:GetSprite():IsPlaying("Collect") then
				local d = 0.5 * (120 - (c.Position:Distance(player.Position) - c.Size - player.Size))/120
				if d > data.closeenough then data.closeenough = d end
				if c.Position:Distance(player.Position) - c.Size - player.Size <= 0 then data.closeenough = 0 end
			end
			player:AddCacheFlags(CacheFlag.CACHE_SPEED)
			player:EvaluateItems()
		end
	end

	if player:HasCollectible(CollectibleType.COLLECTIBLE_SLIPPYS_GUTS) and Game():GetRoom():GetFrameCount() > 0 then
		for _, n in pairs(Isaac.FindInRadius(Vector(640, 560), 875, EntityPartition.ENEMY)) do
			if n:IsEnemy() and n:IsDead() and not (n:GetData().checkedslippysguts or (n.Type == mod.FFID.Tech and n.Variant > 999)) then
				data.slippysGutsFartAttempts = data.slippysGutsFartAttempts or 0
				data.slippysGutsFartAttempts = data.slippysGutsFartAttempts + 1
				local luck = player.Luck
				luck = luck < 0 and 0 or luck
				luck = luck > 7 and 7 or luck
				local rand = 5 + (luck * 15/7) + math.min(30, math.floor(n.MaxHitPoints / 3)) + player:GetData().slippysGutsFartAttempts * 2
				--print(rand)
				if math.random(50) <= rand or data.slippysGutsFartAttempts > 10 then
					local cloud = Isaac.Spawn(mod.FF.SlippyFart.ID, mod.FF.SlippyFart.Var, mod.FF.SlippyFart.Sub, n.Position, nilvector, player)
					sfx:Play(mod.Sounds.FartFrog1,0.2,0,false,math.random(80,120)/100)
					data.slippysGutsFartAttempts = 0
				end
				n:GetData().checkedslippysguts = true
			end
		end
	end
	if player:HasCollectible(CollectibleType.COLLECTIBLE_SLIPPYS_HEART) then
		local n = mod.FindClosestEnemy(player.Position, 80, true, true)
		if n then
			player.Position = player.Position + RandomVector()
			if player.FrameCount % 5 == 1 then
				player:SetColor(Color(1,1,1,1,100 / 255,0,0),3,1,true,false)
			end
			if player.FrameCount % 10 == 1 then
				data.slippysHeartFartAttempts = data.slippysHeartFartAttempts or 0
				data.slippysHeartFartAttempts = data.slippysHeartFartAttempts + 1
				if math.random(math.floor(n.Position:Distance(player.Position))) <= math.max((player.Luck * 2 + 5), 1) or player:GetData().slippysHeartFartAttempts > 30 then
					data.slippysHeartFartAttempts = 0
					local rand = math.random(50)
					if rand == 1 then
						Game():Fart(player.Position, 80, player, 1, 0)
						for i = 45, 360, 45 do
							Game():Fart(player.Position + Vector(40, 0):Rotated(i), 80, player, 1, 0)
						end
						game:ButterBeanFart(player.Position, 280, player, false)
						sfx:Play(mod.Sounds.FartFrog4,1,0,false,math.random(90,110)/100)
						Game():ShakeScreen(50)
						sfx:Stop(SoundEffect.SOUND_FART)
					elseif rand < 10 then
						sfx:Play(mod.Sounds.FartFrog1,0.2,0,false,math.random(80,120)/100)
						local smoke = Isaac.Spawn(1000, EffectVariant.DARK_BALL_SMOKE_PARTICLE, 0, player.Position, player.Velocity:Resized(-1), player):ToEffect();
						smoke.Color = Color(0,0,0,1,100 / 255,100 / 255,100 / 255)
						smoke.SpriteOffset = Vector(0,-10)
						smoke.SpriteRotation = math.random(360)
						smoke:Update()
					elseif rand < 30 then
						Game():Fart(player.Position, 80, player, 1, 0)
						game:ButterBeanFart(player.Position, 280, player, false)
						sfx:Play(mod.Sounds.FartFrog3,1,0,false,math.random(90,110)/100)
						Game():ShakeScreen(10)
						sfx:Stop(SoundEffect.SOUND_FART)
					else
						Game():ShakeScreen(5)
						sfx:Play(mod.Sounds.FartFrog2,1,0,false,math.random(70,130)/100)
						game:ButterBeanFart(player.Position, 280, player, true)
						sfx:Stop(SoundEffect.SOUND_FART)
					end
				end
			end
		end
	end


	if player:HasCollectible(CollectibleType.COLLECTIBLE_GOLEMS_ROCK) then
		local sdata = Isaac.GetPlayer():GetData().ffsavedata

		if not sdata.playerSpawnedGolemRock then
			local trink = Isaac.Spawn(EntityType.ENTITY_PICKUP, PickupVariant.PICKUP_TRINKET, FiendFolio.GetNextMiningMachineTrinket(trinket, player), player.Position, Vector.FromAngle(math.random(30, 150)):Resized(5), player)
			sdata.playerSpawnedGolemRock = true
			--print("A")
		end
	end

	if player:HasCollectible(CollectibleType.COLLECTIBLE_CLEAR_CASE_PASSIVE) or (player:HasCollectible(CollectibleType.COLLECTIBLE_CLEAR_CASE) and player:GetActiveItem(ActiveSlot.SLOT_POCKET) ~= CollectibleType.COLLECTIBLE_CLEAR_CASE) then
		if player:GetPlayerType() ~= PlayerType.PLAYER_CAIN_B then
			player:RemoveCollectible(CollectibleType.COLLECTIBLE_CLEAR_CASE)
			player:RemoveCollectible(CollectibleType.COLLECTIBLE_CLEAR_CASE_PASSIVE)
			player:SetPocketActiveItem(CollectibleType.COLLECTIBLE_CLEAR_CASE)
		elseif player:HasCollectible(CollectibleType.COLLECTIBLE_CLEAR_CASE) then
			player:RemoveCollectible(CollectibleType.COLLECTIBLE_CLEAR_CASE)
			player:AddCollectible(CollectibleType.COLLECTIBLE_CLEAR_CASE_PASSIVE, 0, false)
		end
	end

	if player:HasCollectible(CollectibleType.COLLECTIBLE_MODERN_OUROBOROS) then
		if mod.fireEntitiesFriend then
			table.insert(mod.fireEntitiesFriend, player)
		end
	end

	mod:handleDevilsHarvestRespawn(player, data)

	mod:erflyPlayerUpdate(player, data)

	if player:HasTrinket(TrinketType.TRINKET_BLOODY_SANDPAPER) then
		if (not data.TotalFrozen) then
			local grident = Game():GetRoom():GetGridEntityFromPos(player.Position)
			if grident and grident.Desc.Type == GridEntityType.GRID_GRAVITY then
				player.Velocity = mod:Lerp(player.Velocity, player:GetMovementVector() * player.MoveSpeed * 4, 0.3)
			else
				player.Velocity = player:GetMovementVector() * player.MoveSpeed * 4
			end
		end
	end
	if mod.anyPlayerHas(TrinketType.TRINKET_RED_RIBBON, true) then
		if mod.getTrinketMultiplierAcrossAllPlayers(TrinketType.TRINKET_RED_RIBBON) > 1 then
			if player:GetEternalHearts() == 1 then
				player:AddEternalHearts(3)
			end
		else
			if player:GetEternalHearts() == 1 then
				player:AddEternalHearts(1)
			end
		end
	end

	if FiendFolio.NameTagKeybind ~= -1 and Input.IsButtonTriggered(FiendFolio.NameTagKeybind, player.ControllerIndex) then mod.nameTagToggle = not mod.nameTagToggle end

	local sdata = data.ffsavedata
	if sdata.pillstotake > 0 then
		if not data.pilltimer then data.pilltimer = 0 end
		if data.pilltimer == 0 and data.gmofrozen then
			player:AnimateHappy()
		end
		data.pilltimer = data.pilltimer + 1
		if data.pilltimer % 15 == 0 then
			if data.queuedSpecificPills then
				player:UsePill(data.queuedSpecificPills[1], math.random(PillColor.NUM_PILLS - 1))
				table.remove(data.queuedSpecificPills, 1)
				if #data.queuedSpecificPills == 0 then
					data.queuedSpecificPills = nil
				end
			else
				local pill = (player:HasCollectible(CollectibleType.COLLECTIBLE_PHD) or player:HasCollectible(CollectibleType.COLLECTIBLE_VIRGO) or player:HasCollectible(CollectibleType.COLLECTIBLE_LUCKY_FOOT)) and FiendFolio.PHDPills[math.random(#FiendFolio.PHDPills)] or math.random(PillEffect.NUM_PILL_EFFECTS - 1)
				pill = ((pill == PillEffect.PILLEFFECT_BAD_TRIP and player:GetHearts() <= 2) and PillEffect.PILLEFFECT_FULL_HEALTH or pill)
				pill = ((pill == PillEffect.PILLEFFECT_HEALTH_DOWN and player:GetMaxHearts() <= 2) and PillEffect.PILLEFFECT_HEALTH_UP or pill)
				player:UsePill(pill, math.random(PillColor.NUM_PILLS - 1))
				sdata.pillstotake = sdata.pillstotake - 1
				player:AddCacheFlags(CacheFlag.CACHE_ALL)
				player:EvaluateItems()
			end
		end
	elseif data.gmofrozen then
		data.gmofrozen = false
		player.ControlsEnabled = true
	end

	if data.fortunestodisplay and data.fortunestodisplay > 0 then
		if not data.fortunetimer then data.fortunetimer = 0 end

		if data.fortunetimer % 75 == 0 then
			--game:ShowFortune()
			mod:ShowFortune()
			data.fortunestodisplay = data.fortunestodisplay - 1
		end

		data.fortunetimer = data.fortunetimer + 1
	end

	--Secret weed smoke
	if mod.checkWeedy then
		local ptype = player:GetPlayerType()
		if ptype == PlayerType.PLAYER_ISAAC then
			local itemCount = player:GetCollectibleCount()
			if itemCount == 0 or itemCount == 1 and player:HasCollectible(CollectibleType.COLLECTIBLE_D6) then
				local weedTimer = 7800
				if game.TimeCounter == weedTimer then
					player.Color = mod.ColorInvisible
					local weed = Isaac.Spawn(mod.FF.IsaacSmonking.ID, mod.FF.IsaacSmonking.Var, mod.FF.IsaacSmonking.Sub, player.Position, nilvector, player)
					weed.Parent = player
					weed:Update()
					data.smonkingWeed = weed
					mod.checkWeedy = nil
				end
			end
		end
	end
	if data.smonkingWeed then
		if data.smonkingWeed:Exists() then
			player.Velocity = nilvector
		else
			player.Color = mod.ColorNormal
			data.smonkingWeed = false
		end
	end
	if data.BleedyFeetsies and data.BleedyFeetsies > 0 then
		data.BleedyFeetsies = data.BleedyFeetsies - 1
		if player.FrameCount % 2 == 1 then
			local blood = Isaac.Spawn(1000, 7, 0, player.Position, nilvector, npc)
			blood.SpriteScale = Vector(1/100, 1/100) * data.BleedyFeetsies
			blood:Update()
		end
	end
end)

mod:AddCallback(ModCallbacks.MC_POST_ENTITY_REMOVE, function(_, ent) --for coins on a timeout (keeper b skin, curse of swine)
	if ent.Variant == 20 then
		local player = Isaac.GetPlayer(0)

		if player:HasCollectible(CollectibleType.COLLECTIBLE_COOL_SUNGLASSES) and player:GetData().closeenough ~= nil then
			player:GetData().closeenough = 0
			player:AddCacheFlags(CacheFlag.CACHE_SPEED)
			player:EvaluateItems()
		end
	end
end, 5)

CustomHealthAPI.Library.AddCallback("FiendFolio", CustomHealthAPI.Enums.Callbacks.PRE_ADD_HEALTH, 0, function(player, key, hp)
	if player:GetPlayerType() == FiendFolio.PLAYER.FIEND and (fiendconfig and not fiendconfig.ImpBabyMode) and hp > 0 then
		if key == "BONE_HEART" then
			if not player:GetData().revivingViaDevilsHarvest then
				for i = 1, hp * 8 do
					-- bone orbitals are unaffected by the familiar cache
					local fam = Isaac.Spawn(EntityType.ENTITY_FAMILIAR, FamiliarVariant.BONE_ORBITAL, 0, player.Position + RandomVector() * 20, Vector(0,0), player):ToFamiliar()
					fam.Player = player
				end
			end
			return true
		elseif CustomHealthAPI.Library.GetInfoOfKey(key, "Type") == CustomHealthAPI.Enums.HealthTypes.CONTAINER and
		       CustomHealthAPI.Library.GetInfoOfKey(key, "KindContained") ~= CustomHealthAPI.Enums.HealthKinds.NONE
		then
			local maxHP = CustomHealthAPI.Library.GetInfoOfKey(key, "MaxHP")
			local canHaveHalfCapacity = CustomHealthAPI.Library.GetInfoOfKey(key, "CanHaveHalfCapacity")
			
			if maxHP < 1 then
				if canHaveHalfCapacity then
					return "IMMORAL_HEART", hp
				else
					return "IMMORAL_HEART", hp * 2
				end
			else
				local fullKeysToAdd = math.floor(hp / maxHP)
				local newHP = fullKeysToAdd * 2
				if hp % maxHP ~= 0 then
					newHP = newHP + 1
				end
				
				return "IMMORAL_HEART", newHP
			end
		elseif CustomHealthAPI.Library.GetInfoOfKey(key, "Type") == CustomHealthAPI.Enums.HealthTypes.RED then
			return true
		elseif CustomHealthAPI.Library.GetInfoOfKey(key, "Type") == CustomHealthAPI.Enums.HealthTypes.SOUL and
		       key ~= "IMMORAL_HEART" and
			   key ~= "BLACK_HEART"
		then
			local maxHP = CustomHealthAPI.Library.GetInfoOfKey(key, "MaxHP")
			
			local fullKeysToAdd = math.floor(hp / maxHP)
			local newHP = fullKeysToAdd * 2
			if hp % maxHP ~= 0 then
				newHP = newHP + 1
			end
			
			return "BLACK_HEART", newHP
		end
	end
end)

CustomHealthAPI.Library.AddCallback("FiendFolio", CustomHealthAPI.Enums.Callbacks.POST_RESYNC_PLAYER, 0, function(player)
	if player:GetPlayerType() == FiendFolio.PLAYER.FIEND and not fiendconfig.ImpBabyMode then
		local hearts = CustomHealthAPI.Library.GetHealthInOrder(player)
		
		local numImmoral = 0
		local numBlack = 0
		for i = #hearts, 1, -1 do
			local health = hearts[i]
			local key = health.Other.Key
			local typeOfKey = CustomHealthAPI.Library.GetInfoOfKey(key, "Type")
			
			if typeOfKey == CustomHealthAPI.Enums.HealthTypes.SOUL and key ~= "IMMORAL_HEART" and key ~= "BLACK_HEART" then
				numBlack = numBlack + health.Other.HP
				CustomHealthAPI.Library.RemoveOtherKey(player, i, true)
			elseif CustomHealthAPI.Library.GetInfoOfKey(key, "Type") == CustomHealthAPI.Enums.HealthTypes.CONTAINER and
			       CustomHealthAPI.Library.GetInfoOfKey(key, "KindContained") ~= CustomHealthAPI.Enums.HealthKinds.NONE
			then
				if CustomHealthAPI.Library.GetInfoOfKey(key, "MaxHP") <= 0 then
					numImmoral = numImmoral + 2
				else
					if not player:GetData().revivingViaDevilsHarvest then
						for i = 1, 8 do
							-- bone orbitals are unaffected by the familiar cache
							local fam = Isaac.Spawn(EntityType.ENTITY_FAMILIAR, FamiliarVariant.BONE_ORBITAL, 0, player.Position + RandomVector() * 20, Vector(0,0), player):ToFamiliar()
							fam.Player = player
						end
					end
				end
				CustomHealthAPI.Library.RemoveOtherKey(player, i, true)
			end
		end
		
		mod:AddImmoralHearts(player, numImmoral)
		player:AddBlackHearts(numBlack)
	end
end)


CustomHealthAPI.Library.AddCallback("FiendFolio", CustomHealthAPI.Enums.Callbacks.PRE_ETERNAL_HEAL, 0, function(player, key)
	if player:GetPlayerType() == FiendFolio.PLAYER.FIEND then
		return "IMMORAL_HEART", 1
	end
end)

CustomHealthAPI.Library.AddCallback("FiendFolio", CustomHealthAPI.Enums.Callbacks.PRE_SPIRIT_SHACKLES_HEAL, 0, function(player)
	if player:GetPlayerType() == FiendFolio.PLAYER.FIEND then
		return "IMMORAL_HEART", 1
	end
end)

CustomHealthAPI.Library.AddCallback("FiendFolio", CustomHealthAPI.Enums.Callbacks.PRE_HEARTBREAK_HEAL, 0, function(player)
	if player:GetPlayerType() == FiendFolio.PLAYER.FIEND then
		return "IMMORAL_HEART", 1
	end
end)

CustomHealthAPI.Library.AddCallback("FiendFolio", CustomHealthAPI.Enums.Callbacks.PRE_GLASS_CANNON_HEAL, 0, function(player)
	if player:GetPlayerType() == FiendFolio.PLAYER.FIEND then
		return "IMMORAL_HEART", 1
	end
end)

CustomHealthAPI.Library.AddCallback("FiendFolio", CustomHealthAPI.Enums.Callbacks.GET_MAX_HP_CONVERSION, 0, function(player)
	if player:GetPlayerType() == FiendFolio.PLAYER.FIEND then
		return "IMMORAL_HEART"
	end
end)

--Stolen from p20 helper
function mod:getPtrHashEntity(entity)
	if entity.Entity then
		entity = entity.Entity
	end
	for _, matchEntity in pairs(Isaac.FindByType(entity.Type, entity.Variant, entity.SubType, false, false)) do
		if GetPtrHash(entity) == GetPtrHash(matchEntity) then
			return matchEntity
		end
	end
	return nil
end

function mod:getPlayerFromTear(tear)
	for i=1, 3 do
		local check = nil
		if i == 1 then
			check = tear.Parent
		elseif i == 2 then
			check = tear.SpawnerEntity
		elseif i == 3 then
			local spawnData = tear:GetData().SpawnData
			if spawnData then
				check = spawnData.SpawnerEntity
			end
		end
		if check ~= nil and check:Exists() then
			if check.Type == EntityType.ENTITY_PLAYER and check:ToPlayer() then
				return mod:getPtrHashEntity(check):ToPlayer()
			elseif check.Type == EntityType.ENTITY_FAMILIAR and check.Variant == FamiliarVariant.INCUBUS and check:ToFamiliar() then
				familiar = check:ToFamiliar()
				local player = familiar.Player
				if player ~= nil and player:Exists() and player.Type == EntityType.ENTITY_PLAYER and player:ToPlayer() then
					return mod:getPtrHashEntity(player):ToPlayer()
				end
			end
		end
	end
	return nil
end

mod:AddCallback(ModCallbacks.MC_POST_TEAR_INIT, function(_, tear)
local td = tear:GetData()
td.SpawnData = tear:GetData()
end)

local haemoTears = {
	[TearVariant.BALLOON] = true,
	[TearVariant.BALLOON_BRIMSTONE] = true,
	[TearVariant.BALLOON_BOMB] = true,
}
local bloodyTears = {
	[TearVariant.CUPID_BLOOD] = true,
	[TearVariant.PUPULA_BLOOD] = true,
	[TearVariant.GODS_FLESH_BLOOD] = true,
	[TearVariant.NAIL_BLOOD] = true,
	[TearVariant.GLAUCOMA_BLOOD] = true,
	[TearVariant.EYE_BLOOD] = true,
}


function mod:firePeppermint(player, pos, vec, forceFire)
	local plluck = math.max(math.min(math.ceil(player.Luck), 11), 0)
	local rand = 12 - plluck
	if math.random(rand) == 1 or forceFire then
		local fire = Isaac.Spawn(1000, 52, 0, pos or player.Position, vec, player):ToEffect()
		fire.Parent = player
		--fire.Color = Color(0.7,0.7,0.7,1,-0.3,0.4,0.8)
		local sprite = fire:GetSprite()
		sprite:ReplaceSpritesheet(0, "gfx/effects/effect_005_fire_peppermint.png")
		sprite:ReplaceSpritesheet(1, "gfx/effects/effect_peppermintpoof.png")
		sprite:LoadGraphics()
		fire.CollisionDamage = player.Damage * 1.5
		fire.Timeout = 300
		fire:GetData().IsPeppermint = true
		fire:Update()
	end
end

function mod:postFireTear(tear, player, ignorePlayerEffects, isLudo) -- Tears
	local secondHandMultiplier = player:GetTrinketMultiplier(TrinketType.TRINKET_SECOND_HAND) + 1

	mod:fiendTears(player, tear)
	mod:erflyPostFireTear(player, tear, secondHandMultiplier, ignorePlayerEffects, isLudo)
	mod:theDeluxeOnFireTear(player, tear)
	mod:modelRocketOnFireTear(player, tear)

	--Fortune Stuff
	local baseFortuneOdds = 0
	if player:HasTrinket(TrinketType.TRINKET_FORTUNE_WORM) or player:HasTrinket(FiendFolio.ITEM.ROCK.FORTUNE_WORM_FOSSIL) then
		local fortuneWormOdds = player:GetPlayerType() == FiendFolio.PLAYER.FIEND and 5 or 1
		fortuneWormOdds = fortuneWormOdds * (player:GetTrinketMultiplier(TrinketType.TRINKET_FORTUNE_WORM) + FiendFolio.GetGolemTrinketPower(player, FiendFolio.ITEM.ROCK.FORTUNE_WORM_FOSSIL))
		baseFortuneOdds = baseFortuneOdds + fortuneWormOdds
	end
	if FiendFolio.GreatFortune then
		baseFortuneOdds = baseFortuneOdds + 3
	end
	if player:HasCollectible(CollectibleType.COLLECTIBLE_LEFTOVER_TAKEOUT) then
		baseFortuneOdds = baseFortuneOdds + 17
	end

	if baseFortuneOdds > 0 then
		local freq = math.min(math.max(math.floor(22 - baseFortuneOdds - player.Luck), 3), 25)
		if (not isLudo and tear.InitSeed % freq == 0) or (isLudo and math.random(freq) == 1) then
			mod:changeTearVariant(tear, TearVariant.FORTUNE_COOKIE)

			local data = tear:GetData()
			data.IsFortuneTear = true
			tear.CollisionDamage = tear.CollisionDamage * 1.05
		end
	end

	mod:crucifixOnFireTear(player, tear, secondHandMultiplier)

	--Honey Penny
	if player:GetData().HoneyPenny then
		local data = tear:GetData()
		data.HoneySlow = true
		--local honeycolor = Color(2,2,1,1,0,0,0)
		--honeycolor:SetColorize(5, 1, 0, 0.5)
		local honeycolor = Color(250 / 255,140 / 255,0 / 255,1,0,0,0)
		tear.Color = honeycolor
	end

	local prankCookieDataFlag = mod:prankCookieRollTearEffect(player, tear)

	--Imp Soda
	if mod:shouldCriticalHit(player) then
		tear:GetData().isImpSodaTear = true
		if not tear:GetData().critLightning or not tear:GetData().critLightning:Exists() then
			sfx:Play(mod.Sounds.CritShoot, 0.3, 0, false, math.random(80,120)/100)
			local critLightning = Isaac.Spawn(1000, 1737, 1, tear.Position, nilvector, tear):ToEffect()
			critLightning.Parent = tear
			critLightning.Color = Color(1,1,1,0,0,0,1)
			critLightning:Update()
			tear:GetData().critLightning = critLightning
		end
		tear.CollisionDamage = tear.CollisionDamage * mod.CritDamageMult
		tear.Color = Color(1.3,1.3,1.3,1,100/255,-150/255,100/255)
		--tear.SplatColor = Color(1.3,1.3,1.3,1,100 / 255,-150 / 255,100 / 255)
	end

	mod:immoralClotOnFireTear(tear)
	mod:morbidClotOnFireTear(tear)

	if not tear:GetData().isImpSodaTear and tear:GetData().critLightning then
		if tear:GetData().critLightning:Exists() then
			tear:GetData().critLightning:Remove()
		end
		tear:GetData().critLightning = nil
	end

	if player:HasCollectible(CollectibleType.COLLECTIBLE_DICHROMATIC_BUTTERFLY) or player:HasTrinket(TrinketType.TRINKET_YIN_YANG_ORB) then
		local randval = 30
		if player:HasCollectible(CollectibleType.COLLECTIBLE_DICHROMATIC_BUTTERFLY) and player:HasTrinket(TrinketType.TRINKET_YIN_YANG_ORB) then
			randval = 20
		end
		local luck = math.max(math.min(math.floor(player.Luck), 7), -1)
		if math.random(randval) < 5 + (luck * 2) then
			mod:changeTearVariant(tear, TearVariant.HOMING_AMULET, TearVariant.HOMING_AMULET_BLOOD)

			tear.Scale = tear.Scale * (1 + 0.25 * math.max(player:GetTrinketMultiplier(TrinketType.TRINKET_YIN_YANG_ORB) - 1, 0))
			tear.CollisionDamage = tear.CollisionDamage * (1.25 + 0.50 * math.max(player:GetTrinketMultiplier(TrinketType.TRINKET_YIN_YANG_ORB) - 1, 0))
			tear.TearFlags = tear.TearFlags | TearFlags.TEAR_HOMING
			--tear:GetData().customtype = "makeyinyangorb"
			--tear:GetData().spriteRotatin = true
			--tear:GetData().spriteRotatinOff = 90
			tear:GetData().YinYangOrb = true
			if isLudo then tear:GetData().yinyangstrength = 0.4 end
			--tear:Update()
		end
	end

	mod:pinheadOnFireTear(player, tear, secondHandMultiplier)

	if mod.HasTrinityWorm(player) and not isLudo then
		tear:GetData().isTrinityWormTear = true
		local color = tear.Color
		tear:AddTearFlags(TearFlags.TEAR_SPECTRAL)
		tear.Color = color
		--tear.GridCollisionClass = GridCollisionClass.COLLISION_NONE
		tear.Velocity = tear.Velocity:Rotated(-25) * 1.5
		--print(tear.FallingAcceleration)
	end

	mod:prankCookieOnFireTear(player, tear, prankCookieDataFlag, secondHandMultiplier)
	mod:lawnDartsOnFireTear(player, tear, secondHandMultiplier)
	mod:hypnoRingOnFireTear(player, tear, secondHandMultiplier)
	mod:pinheadHandleNonPinTearColor(player, tear)
	mod:rubberBulletsOnFireTear(player, tear, secondHandMultiplier)
	mod:toyPianoOnFireTear(player, tear, secondHandMultiplier)

	if player:HasCollectible(CollectibleType.COLLECTIBLE_PEPPERMINT) and
	   not ignorePlayerEffects and
	   (not isLudo or not game:GetRoom():IsClear())
	then
		local pos = tear.Position
		local vel = tear.Velocity:Resized(10) + player:GetTearMovementInheritance(player:GetAimDirection())
		if isLudo then
			pos = player.Position
			vel = (tear.Position - player.Position):Resized(10)
		end

		mod:firePeppermint(player, pos, vel)
	end

	if player:GetData().BrickSeperatorBuff then
		mod:changeTearVariant(tear, TearVariant.CUPID_BLUE, TearVariant.CUPID_BLOOD)
	end

	mod:ferriumOnFireTear(player, tear, secondHandMultiplier, isLudo, ignorePlayerEffects)
end

function mod:copyFFTearEffects(sourcetear, desttear)
	local sourcedata = sourcetear:GetData()
	local destdata = desttear:GetData()

	destdata.isRerolliganTear = sourcedata.isRerolliganTear
	destdata.bloodDiamond = sourcedata.bloodDiamond
	destdata.IsFortuneTear = sourcedata.IsFortuneTear
	destdata.HasShownFortuneAlready = sourcedata.HasShownFortuneAlready
	destdata.ApplyMartyr = sourcedata.ApplyMartyr
	destdata.ApplyMartyrDuration = sourcedata.ApplyMartyrDuration
	destdata.HoneySlow = sourcedata.HoneySlow
	destdata.isImpSodaTear = sourcedata.isImpSodaTear
	destdata.hasImpSodaProcced = sourcedata.hasImpSodaProcced
	destdata.YinYangOrb = sourcedata.YinYangOrb
	destdata.yinyangstrength = sourcedata.yinyangstrength
	destdata.ApplySewn = sourcedata.ApplySewn
	destdata.ApplySewnDuration = sourcedata.ApplySewnDuration
	destdata.leavePowderCreep = sourcedata.leavePowderCreep
	destdata.hasSpawnedPowderCreep = sourcedata.hasSpawnedPowderCreep
	destdata.ApplyBerserk = sourcedata.ApplyBerserk
	destdata.ApplyBerserkDuration = sourcedata.ApplyBerserkDuration
	destdata.ApplyBleed = sourcedata.ApplyBleed
	destdata.ApplyBleedDuration = sourcedata.ApplyBleedDuration
	destdata.ApplyBleedDamage = sourcedata.ApplyBleedDamage
	destdata.ApplyBruise = sourcedata.ApplyBruise
	destdata.ApplyBruiseDuration = sourcedata.ApplyBruiseDuration
	destdata.ApplyBruiseStacks = sourcedata.ApplyBruiseStacks
	destdata.ApplyBruiseDamagePerStack = sourcedata.ApplyBruiseDamagePerStack
	destdata.AppliedBruiseToEnemy = sourcedata.AppliedBruiseToEnemy
	destdata.ApplyDrowsy = sourcedata.ApplyDrowsy
	destdata.ApplyDrowsyDuration = sourcedata.ApplyDrowsyDuration
	destdata.ApplyDrowsySleepDuration = sourcedata.ApplyDrowsySleepDuration
	destdata.ApplyDoom = sourcedata.ApplyDoom
	destdata.ApplyDoomDuration = sourcedata.ApplyDoomDuration
	destdata.ApplyDoomCountdown = sourcedata.ApplyDoomCountdown
	destdata.ApplyDoomDamage = sourcedata.ApplyDoomDamage
	destdata.IsToyPiano = sourcedata.IsToyPiano
	destdata.ToyPianoPlayerDamage = sourcedata.ToyPianoPlayerDamage
	destdata.ToyPianoPlayerLuck = sourcedata.ToyPianoPlayerLuck
	destdata.IsPrankCookieDoom = sourcedata.IsPrankCookieDoom
	destdata.PrankCookieDoomPlayerDamage = sourcedata.PrankCookieDoomPlayerDamage
	destdata.hasBeenD3Rolled = sourcedata.hasBeenD3Rolled
	destdata.BlackMoonInflicting = sourcedata.BlackMoonInflicting
	destdata.ApplyMultiEuclidean = sourcedata.ApplyMultiEuclidean
	destdata.ApplyMultiEuclideanDuration = sourcedata.ApplyMultiEuclideanDuration
	destdata.ApplySapphicSapphireFreeze = sourcedata.ApplySapphicSapphireFreeze
end

function mod:postLudoTearReset(tear)
	local data = tear:GetData()

	data.isRerolliganTear = nil
	data.bloodDiamond = nil
	data.IsFortuneTear = nil
	data.HasShownFortuneAlready = nil
	data.ApplyMartyr = nil
	data.ApplyMartyrDuration = nil
	data.HoneySlow = nil
	data.isImpSodaTear = nil
	data.hasImpSodaProcced = nil
	data.YinYangOrb = nil
	data.yinyangstrength = nil
	data.ApplySewn = nil
	data.ApplySewnDuration = nil
	data.leavePowderCreep = nil
	data.hasSpawnedPowderCreep = nil
	data.ApplyBerserk = nil
	data.ApplyBerserkDuration = nil
	data.ApplyBleed = nil
	data.ApplyBleedDuration = nil
	data.ApplyBleedDamage = nil
	data.ApplyBruise = nil
	data.ApplyBruiseDuration = nil
	data.ApplyBruiseStacks = nil
	data.ApplyBruiseDamagePerStack = nil
	data.AppliedBruiseToEnemy = nil
	data.ApplyDrowsy = nil
	data.ApplyDrowsyDuration = nil
	data.ApplyDrowsySleepDuration = nil
	data.ApplyDoom = nil
	data.ApplyDoomDuration = nil
	data.ApplyDoomCountdown = nil
	data.ApplyDoomDamage = nil
	data.IsToyPiano = nil
	data.ToyPianoPlayerDamage = nil
	data.ToyPianoPlayerLuck = nil
	data.IsPrankCookieDoom = nil
	data.PrankCookieDoomPlayerDamage = nil
	data.hasBeenD3Rolled = nil
	data.BlackMoonInflicting = nil
	data.ApplyMultiEuclidean = nil
	data.ApplyMultiEuclideanDuration = nil
end

mod:AddCallback(ModCallbacks.MC_POST_FIRE_TEAR, function(_, tear) -- Regular tears
	local player = nil
	if not tear.SpawnerEntity then
		return
	elseif tear.SpawnerEntity:ToPlayer() then
		player = tear.SpawnerEntity:ToPlayer()
	elseif tear.SpawnerEntity:ToFamiliar() and tear.SpawnerEntity:ToFamiliar().Player then
		local familiar = tear.SpawnerEntity:ToFamiliar()

		if familiar.Variant == FamiliarVariant.INCUBUS or
		   familiar.Variant == FamiliarVariant.SPRINKLER or
		   familiar.Variant == FamiliarVariant.TWISTED_BABY or
		   familiar.Variant == FamiliarVariant.BLOOD_BABY or
		   familiar.Variant == FamiliarVariant.UMBILICAL_BABY
		then
			player = familiar.Player
		else
			return
		end
	else
		return
	end

	mod:postFireTear(tear, player, false, tear:HasTearFlags(BitSet128(0, 1 << (127 - 64))))
end)

local fatesRewardTearsToBePostFired = {} -- Fate's Reward tears (stink no post_fire_tear no frame 0 post_tear_update fuck you fuck you fuck you)
mod:AddCallback(ModCallbacks.MC_FAMILIAR_UPDATE, function(_, familiar)
	for _, tear in pairs(fatesRewardTearsToBePostFired) do
		local player = nil
		if not tear.SpawnerEntity then
			return
		elseif tear.SpawnerEntity:ToFamiliar() and tear.SpawnerEntity:ToFamiliar().Player then
			local familiar = tear.SpawnerEntity:ToFamiliar()

			if familiar.Variant == FamiliarVariant.FATES_REWARD then
				player = familiar.Player
			else
				return
			end
		else
			return
		end

		mod:postFireTear(tear, player, true, tear:HasTearFlags(BitSet128(0, 1 << (127 - 64))))
	end

	fatesRewardTearsToBePostFired = {}
end, FamiliarVariant.FATES_REWARD)

mod:AddCallback(ModCallbacks.MC_POST_TEAR_INIT, function(_, tear)
	if tear.SpawnerEntity and
	   tear.SpawnerEntity.Type == EntityType.ENTITY_FAMILIAR and
	   tear.SpawnerEntity.Variant == FamiliarVariant.FATES_REWARD and
	   tear.SpawnerEntity:ToFamiliar().Player
	then
		fatesRewardTearsToBePostFired[tear.Index .. " " .. tear.InitSeed] = tear
	end
end)

mod:AddCallback(ModCallbacks.MC_POST_ENTITY_REMOVE, function(_, tear)
	if fatesRewardTearsToBePostFired[tear.Index .. " " .. tear.InitSeed] then
		fatesRewardTearsToBePostFired[tear.Index .. " " .. tear.InitSeed] = nil
	end
end, EntityType.ENTITY_TEAR)

mod:AddCallback(ModCallbacks.MC_POST_TEAR_UPDATE, function(_, tear) -- Ludovico Technique tears
	if tear:HasTearFlags(TearFlags.TEAR_LUDOVICO) then
		local player = nil
		if not tear.SpawnerEntity then
			return
		elseif tear.SpawnerEntity:ToPlayer() then
			player = tear.SpawnerEntity:ToPlayer()
		elseif tear.SpawnerEntity:ToFamiliar() and tear.SpawnerEntity:ToFamiliar().Player then
			local familiar = tear.SpawnerEntity:ToFamiliar()

			if familiar.Variant == FamiliarVariant.INCUBUS or familiar.Variant == FamiliarVariant.SPRINKLER or
			   familiar.Variant == FamiliarVariant.TWISTED_BABY or familiar.Variant == FamiliarVariant.BLOOD_BABY or
			   familiar.Variant == FamiliarVariant.UMBILICAL_BABY then
				player = familiar.Player
			else
				return
			end
		else
			return
		end

		if math.floor(tear.FrameCount / player.MaxFireDelay) ~= math.floor((tear.FrameCount - 1) / player.MaxFireDelay) then
			mod:postLudoTearReset(tear)
			mod:postFireTear(tear, player, false, true)
		end
	end
end)

function mod:postFireBomb(bomb, player) -- Bombs
	mod:bridgeBombsPostFireBomb(player, bomb)
	mod:muscaPostFireBomb(player, bomb)
	mod:bombSackFossilPostFireBomb(player, bomb)
	mod:malicePostFireBomb(player, bomb)
	
	if player:HasCollectible(CollectibleType.COLLECTIBLE_SLIPPYS_GUTS) then
		if bomb.IsFetus then
			if bomb.Variant == FiendFolio.BOMB.SLIPPY then
				bomb.Variant = BombVariant.BOMB_NORMAL
			elseif bomb.Variant == FiendFolio.BOMB.SLIPPY_COPPER then
				bomb.Variant = FiendFolio.BOMB.COPPER
			end
		else
			local data = bomb:GetData()
			data.FFSlippyBomb = true
		end
	end

	if bomb.IsFetus then
		local data = bomb:GetData()
		local secondHandMultiplier = player:GetTrinketMultiplier(TrinketType.TRINKET_SECOND_HAND) + 1

		mod:theDeluxeOnFireBomb(player, bomb)
		mod:crucifixOnFireBomb(player, bomb, secondHandMultiplier)
		local prankCookieDataFlag = mod:prankCookieRollBombEffect(player, bomb)

		--Fortune Stuff
		local baseFortuneOdds = 0
		if player:HasTrinket(TrinketType.TRINKET_FORTUNE_WORM) or player:HasTrinket(FiendFolio.ITEM.ROCK.FORTUNE_WORM_FOSSIL) then
			local fortuneWormOdds = player:GetPlayerType() == FiendFolio.PLAYER.FIEND and 5 or 1
			fortuneWormOdds = fortuneWormOdds * (player:GetTrinketMultiplier(TrinketType.TRINKET_FORTUNE_WORM) + FiendFolio.GetGolemTrinketPower(player, FiendFolio.ITEM.ROCK.FORTUNE_WORM_FOSSIL))
			baseFortuneOdds = baseFortuneOdds + fortuneWormOdds
		end
		if FiendFolio.GreatFortune then
			baseFortuneOdds = baseFortuneOdds + 3
		end
		if player:HasCollectible(CollectibleType.COLLECTIBLE_LEFTOVER_TAKEOUT) then
			baseFortuneOdds = baseFortuneOdds + 17
		end

		if baseFortuneOdds > 0 then
			local freq = math.min(math.max(math.floor(22 - baseFortuneOdds - player.Luck), 3), 25)
			if bomb.InitSeed % freq == 0 then
				--bomb.Variant = TearVariant.STONE
				--bomb:GetSprite():Load("gfx/projectiles/fortune_cookie_tear.anm2", true)
				local data = bomb:GetData()
				data.IsFortuneTear = true
				bomb.ExplosionDamage = bomb.ExplosionDamage * 1.05
				data.HasShownFortuneAlready = false

				local color = Color(0.9, 0.75, 0.5, 1.0, 40/255, 20/255, 0/255)
				color:SetColorize(0.98, 0.80, 0.64, 1)
				bomb.Color = color
			end
		end

		--Imp Soda
		if mod:shouldCriticalHit(player) then
			--sfx:Play(mod.Sounds.CritShoot, 0.3, 0, false, math.random(80,120)/100)
			bomb:GetData().isImpSodaTear = true
			--local critLightning = Isaac.Spawn(1000, 1737, 1, bomb.Position, nilvector, bomb):ToEffect()
			--critLightning.Parent = bomb
			--critLightning.Color = Color(1,1,1,0,0,0,1)
			--critLightning:Update()
			bomb.ExplosionDamage = bomb.ExplosionDamage * mod.CritDamageMult
			bomb.Color = Color(1.3,1.3,1.3,1,100/255,-150/255,100/255)
			--bomb.SplatColor = Color(1.3,1.3,1.3,1,100 / 255,-150 / 255,100 / 255)
		end

		mod:immoralClotOnFireBomb(bomb)
		mod:morbidClotOnFireBomb(bomb)

		if player:HasCollectible(CollectibleType.COLLECTIBLE_DICHROMATIC_BUTTERFLY) or player:HasTrinket(TrinketType.TRINKET_YIN_YANG_ORB) then
			local randval = 30
			if player:HasCollectible(CollectibleType.COLLECTIBLE_DICHROMATIC_BUTTERFLY) and player:HasTrinket(TrinketType.TRINKET_YIN_YANG_ORB) then
				randval = 20
			end
			local luck = math.max(math.min(math.floor(player.Luck), 7), -1)
			if math.random(randval) < 5 + (luck * 2) then
				bomb.ExplosionDamage = bomb.ExplosionDamage * (1.25 + 0.50 * math.max(player:GetTrinketMultiplier(TrinketType.TRINKET_YIN_YANG_ORB) - 1, 0))
				bomb.Flags = bomb.Flags | TearFlags.TEAR_HOMING
				data.YinYangOrb = true
				bomb.Color = Color(0.05, 0.65, 0.9, 1.0, 0/255, 60/255, 90/255)
			end
		end

		mod:prankCookieOnFireBomb(player, bomb, prankCookieDataFlag, secondHandMultiplier)
		mod:lawnDartsOnFireBomb(player, bomb, secondHandMultiplier)
		mod:hypnoRingOnFireBomb(player, bomb, secondHandMultiplier)
		mod:pinheadOnFireBomb(player, bomb, secondHandMultiplier)
		mod:rubberBulletsOnFireBomb(player, bomb, secondHandMultiplier)
		mod:toyPianoOnFireBomb(player, bomb, secondHandMultiplier)
		mod:rerolliganFossilFireBomb(player, bomb, bomb:GetDropRNG(), player:GetData(), bomb:GetData())
		mod:erflyPostFireBomb(player, bomb, secondHandMultiplier)
		mod:ferriumOnFireBomb(player, bomb, secondHandMultiplier)

		if player:HasCollectible(CollectibleType.COLLECTIBLE_PEPPERMINT) then
			mod:firePeppermint(player, bomb.Position, bomb.Velocity:Resized(10) + player:GetTearMovementInheritance(player:GetAimDirection()))
		end
	else
		mod:copperPostFireBomb(player, bomb)
	end
end

local bombsToBePostFired = {}
function mod:testForPostFireBomb(ent)
	for _, bomb in pairs(bombsToBePostFired) do
		local player = nil
		if not bomb.SpawnerEntity then
			return
		elseif bomb.SpawnerEntity and bomb.SpawnerEntity:ToPlayer() then
			player = bomb.SpawnerEntity:ToPlayer()
		elseif bomb.SpawnerEntity:ToFamiliar() and bomb.SpawnerEntity:ToFamiliar().Player then
			local familiar = bomb.SpawnerEntity:ToFamiliar()

			if familiar.Variant == FamiliarVariant.INCUBUS or
			   familiar.Variant == FamiliarVariant.SPRINKLER or
			   familiar.Variant == FamiliarVariant.TWISTED_BABY or
			   familiar.Variant == FamiliarVariant.BLOOD_BABY or
			   familiar.Variant == FamiliarVariant.UMBILICAL_BABY
			then
				player = familiar.Player
			else
				return
			end
		else
			return
		end

		mod:postFireBomb(bomb, player)
	end

	bombsToBePostFired = {}
end
mod:AddCallback(ModCallbacks.MC_POST_PLAYER_UPDATE, mod.testForPostFireBomb)
mod:AddCallback(ModCallbacks.MC_FAMILIAR_UPDATE, mod.testForPostFireBomb, FamiliarVariant.INCUBUS)
mod:AddCallback(ModCallbacks.MC_FAMILIAR_UPDATE, mod.testForPostFireBomb, FamiliarVariant.SPRINKLER)
mod:AddCallback(ModCallbacks.MC_FAMILIAR_UPDATE, mod.testForPostFireBomb, FamiliarVariant.TWISTED_BABY)
mod:AddCallback(ModCallbacks.MC_FAMILIAR_UPDATE, mod.testForPostFireBomb, FamiliarVariant.BLOOD_BABY)
mod:AddCallback(ModCallbacks.MC_FAMILIAR_UPDATE, mod.testForPostFireBomb, FamiliarVariant.UMBILICAL_BABY)

function mod:postScatterBomb(bomb, obomb)
	bomb:GetData().FFBridgeBomb = obomb:GetData().FFBridgeBomb
	bomb:GetData().FFLocustBomb = obomb:GetData().FFLocustBomb
	bomb:GetData().FFLocustPlayer = obomb:GetData().FFLocustPlayer
	bomb:GetData().isNugget = obomb:GetData().isNugget
	bomb:GetData().bombSackFossil = obomb:GetData().bombSackFossil
	bomb:GetData().bombSackFossilPlayer = obomb:GetData().bombSackFossilPlayer
	bomb:GetData().ApplyMartyr = obomb:GetData().ApplyMartyr
	bomb:GetData().ApplyMartyrDuration = obomb:GetData().ApplyMartyrDuration
	bomb:GetData().IsFortuneTear = obomb:GetData().IsFortuneTear
	bomb:GetData().HasShownFortuneAlready = false
	bomb:GetData().isImpSodaTear = obomb:GetData().isImpSodaTear
	bomb:GetData().YinYangOrb = obomb:GetData().YinYangOrb
	bomb:GetData().ApplyBerserk = obomb:GetData().ApplyBerserk
	bomb:GetData().ApplyBerserkDuration = obomb:GetData().ApplyBerserkDuration
	bomb:GetData().ApplyBleed = obomb:GetData().ApplyBleed
	bomb:GetData().ApplyBleedDuration = obomb:GetData().ApplyBleedDuration
	bomb:GetData().ApplyBleedDamage = obomb:GetData().ApplyBleedDamage
	bomb:GetData().ApplyDrowsy = obomb:GetData().ApplyDrowsy
	bomb:GetData().ApplyDrowsyDuration = obomb:GetData().ApplyDrowsyDuration
	bomb:GetData().ApplyDrowsySleepDuration = obomb:GetData().ApplyDrowsySleepDuration
	bomb:GetData().ApplySewn = obomb:GetData().ApplySewn
	bomb:GetData().ApplySewnDuration = obomb:GetData().ApplySewnDuration
	bomb:GetData().ApplyBruise = obomb:GetData().ApplyBruise
	bomb:GetData().ApplyBruiseDuration = obomb:GetData().ApplyBruiseDuration
	bomb:GetData().ApplyBruiseStacks = obomb:GetData().ApplyBruiseStacks
	bomb:GetData().ApplyBruiseDamagePerStack = obomb:GetData().ApplyBruiseDamagePerStack
	bomb:GetData().ApplyDoom = obomb:GetData().ApplyDoom
	bomb:GetData().ApplyDoomDuration = obomb:GetData().ApplyDoomDuration
	bomb:GetData().ApplyDoomCountdown = obomb:GetData().ApplyDoomCountdown
	bomb:GetData().ApplyDoomDamage = obomb:GetData().ApplyDoomDamage
	bomb:GetData().IsToyPiano = obomb:GetData().IsToyPiano
	bomb:GetData().ToyPianoPlayerDamage = obomb:GetData().ToyPianoPlayerDamage
	bomb:GetData().ToyPianoPlayerLuck = obomb:GetData().ToyPianoPlayerLuck
	bomb:GetData().IsPrankCookieDoom = obomb:GetData().IsPrankCookieDoom
	bomb:GetData().PrankCookieDoomPlayerDamage = obomb:GetData().PrankCookieDoomPlayerDamage
	bomb:GetData().isRerolliganTear = obomb:GetData().isRerolliganTear
	bomb:GetData().BlackMoonInflicting = obomb:GetData().BlackMoonInflicting
	bomb:GetData().ApplyMultiEuclidean = obomb:GetData().ApplyMultiEuclidean
	bomb:GetData().ApplyMultiEuclideanDuration = obomb:GetData().ApplyMultiEuclideanDuration
	bomb:GetData().FFSlippyBomb = obomb:GetData().FFSlippyBomb
	
	bomb:GetData().FFIsScatter = true
end

function mod:testForPostScatterBomb(obomb)
	for _, bomb in pairs(bombsToBePostFired) do
		mod:postScatterBomb(bomb, obomb)
	end

	bombsToBePostFired = {}
end

mod:AddCallback(ModCallbacks.MC_POST_BOMB_UPDATE, function(_, bomb)
	if bomb:IsDead() and (bomb.Flags & TearFlags.TEAR_SCATTER_BOMB == TearFlags.TEAR_SCATTER_BOMB or
						  bomb.Flags & TearFlags.TEAR_SPLIT == TearFlags.TEAR_SPLIT or
						  bomb.Flags & TearFlags.TEAR_PERSISTENT == TearFlags.TEAR_PERSISTENT or
						  bomb.Flags & TearFlags.TEAR_QUADSPLIT == TearFlags.TEAR_QUADSPLIT)
	then
		mod:testForPostScatterBomb(bomb)
	end
end)

mod:AddCallback(ModCallbacks.MC_POST_BOMB_INIT, function(_, bomb)
	if bomb.Variant == BombVariant.BOMB_THROWABLE then
		return
	elseif not bomb.SpawnerEntity then
		return
	elseif bomb.SpawnerEntity and bomb.SpawnerEntity:ToPlayer() then
		bombsToBePostFired[bomb.InitSeed] = bomb
	elseif bomb.SpawnerEntity:ToFamiliar() and bomb.SpawnerEntity:ToFamiliar().Player then
		local familiar = bomb.SpawnerEntity:ToFamiliar()

		if familiar.Variant == FamiliarVariant.INCUBUS or
		   familiar.Variant == FamiliarVariant.SPRINKLER or
		   familiar.Variant == FamiliarVariant.TWISTED_BABY or
		   familiar.Variant == FamiliarVariant.BLOOD_BABY or
		   familiar.Variant == FamiliarVariant.UMBILICAL_BABY
		then
			bombsToBePostFired[bomb.InitSeed] = bomb
		else
			return
		end
	else
		return
	end
end)

mod:AddCallback(ModCallbacks.MC_POST_ENTITY_REMOVE, function(_, bomb)
	if bombsToBePostFired[bomb.InitSeed] then
		bombsToBePostFired[bomb.InitSeed] = nil
	end
end, EntityType.ENTITY_BOMBDROP)

mod:AddCallback(ModCallbacks.MC_PRE_ENTITY_SPAWN, function(_, typ, var, subt, pos, vel, spawner, seed)
	if typ == EntityType.ENTITY_BOMBDROP then
		if not (var == BombVariant.BOMB_BIG or
		        var == BombVariant.BOMB_DECOY or
				var == BombVariant.BOMB_TROLL or
				var == BombVariant.BOMB_SUPERTROLL or
				var == BombVariant.BOMB_THROWABLE or
				var == BombVariant.BOMB_GIGA or
				var == BombVariant.BOMB_GOLDENTROLL or
				var == BombVariant.BOMB_ROCKET or
				var == BombVariant.BOMB_ROCKET_GIGA or
				var == FiendFolio.FF.CherryBomb.Var)
		then
			if spawner then
				local player = nil
				if spawner:ToPlayer() then
					player = spawner:ToPlayer()
				elseif spawner:ToFamiliar() and spawner:ToFamiliar().Player then
					if spawner.Variant == FamiliarVariant.INCUBUS or
					   spawner.Variant == FamiliarVariant.SPRINKLER or
					   spawner.Variant == FamiliarVariant.TWISTED_BABY or
					   spawner.Variant == FamiliarVariant.BLOOD_BABY or
					   spawner.Variant == FamiliarVariant.UMBILICAL_BABY
					then
						player = spawner:ToFamiliar().Player
					end
				end

				if player and player:HasCollectible(CollectibleType.COLLECTIBLE_NUGGET_BOMBS) then
					return {EntityType.ENTITY_BOMBDROP, FiendFolio.BOMB.NUGGET, 0, seed}
				elseif player and player:HasCollectible(CollectibleType.COLLECTIBLE_MUSCA) then
					return {EntityType.ENTITY_BOMBDROP, FiendFolio.BOMB.LOCUST, 0, seed}
				elseif player and player:HasCollectible(CollectibleType.COLLECTIBLE_SLIPPYS_GUTS) then
					return {EntityType.ENTITY_BOMBDROP, FiendFolio.BOMB.SLIPPY, 0, seed}
				elseif player and player:HasCollectible(CollectibleType.COLLECTIBLE_BRIDGE_BOMBS) then
					return {EntityType.ENTITY_BOMBDROP, FiendFolio.BOMB.BRIDGE, 0, seed}
				end
			end
		end
	end
end)

function mod:getPlayerFromKnife(knife)
	if knife.SpawnerEntity and knife.SpawnerEntity:ToPlayer() then
		return knife.SpawnerEntity:ToPlayer()
	elseif knife.SpawnerEntity and knife.SpawnerEntity:ToFamiliar() and knife.SpawnerEntity:ToFamiliar().Player then
		local familiar = knife.SpawnerEntity:ToFamiliar()

		if familiar.Variant == FamiliarVariant.INCUBUS or familiar.Variant == FamiliarVariant.SPRINKLER or
		   familiar.Variant == FamiliarVariant.TWISTED_BABY or familiar.Variant == FamiliarVariant.BLOOD_BABY or
		   familiar.Variant == FamiliarVariant.UMBILICAL_BABY then
			return familiar.Player
		else
			return nil
		end
	else
		return nil
	end
end

-- apparently basegame knife synergies function moreso like laser synergies so most of this is currently useless
-- still going to leave it though because it could be useful in the future / will be useful if we ever get actual spirit sword/forgotten bone support
mod:AddCallback(ModCallbacks.MC_POST_KNIFE_UPDATE, function(_, knife) -- Mom's Knife
	if knife.Variant ~= 0 and knife.Variant ~= 5 then
		return
	end

	local player = mod:getPlayerFromKnife(knife)
	if player == nil then return end

	local data = knife:GetData()
	local secondHandMultiplier = player:GetTrinketMultiplier(TrinketType.TRINKET_SECOND_HAND) + 1

	--mod:crucifixOnKnifeUpdate(player, knife, secondHandMultiplier)
	mod:erflyOnKnifeUpdate(player, knife, data)

	if data.WasFlying == nil or (data.WasFlying and not knife:IsFlying()) then
		mod:erflyOnKnifeReset(player, knife, data)
		--data.KnifeColor = nil

		--data.ApplyBerserk = nil
		--data.ApplyBleed = nil
		--data.ApplyBruise = nil
		--data.AppliedBruiseToEnemy = nil
		--data.ApplyDoom = nil
		--data.ApplyDoomDelayTilFired = nil
		--data.ApplyDrowsy = nil
		--data.ApplyDrowsyDelayTilFired = nil
		--data.ApplyMartyr = nil
		--data.ApplyMartyrConfuse = nil
		--data.ApplySewn = nil
		--data.isImpSodaTear = nil
		--data.isImpSodaTearDelayTilFired = nil
		--data.hasImpSodaProcced = nil
		--data.YinYangOrb = nil
		--data.YinYangOrbDelayTilFired = nil
		--data.IsFortuneTear = nil
		--data.IsFortuneTearDelayTilFired = nil
		--data.HasShownFortuneAlready = nil
		--data.isRerolliganTear = nil
		--data.isRerolliganTearDelayTilFired = nil

		--mod:prankCookieOnFireKnife(player, knife, secondHandMultiplier)

		--Fortune Stuff
		--[[local baseFortuneOdds = 0
		if player:HasTrinket(TrinketType.TRINKET_FORTUNE_WORM) or player:HasTrinket(FiendFolio.ITEM.ROCK.FORTUNE_WORM_FOSSIL) then
			local fortuneWormOdds = player:GetPlayerType() == FiendFolio.PLAYER.FIEND and 5 or 1
			fortuneWormOdds = fortuneWormOdds * (player:GetTrinketMultiplier(TrinketType.TRINKET_FORTUNE_WORM) + FiendFolio.GetGolemTrinketPower(player, FiendFolio.ITEM.ROCK.FORTUNE_WORM_FOSSIL))
			baseFortuneOdds = baseFortuneOdds + fortuneWormOdds
		end
		if FiendFolio.GreatFortune then
			baseFortuneOdds = baseFortuneOdds + 3
		end
		if player:HasCollectible(CollectibleType.COLLECTIBLE_LEFTOVER_TAKEOUT) then
			baseFortuneOdds = baseFortuneOdds + 17
		end

		if baseFortuneOdds > 0 then
			local freq = math.min(math.max(math.floor(22 - baseFortuneOdds - player.Luck), 3), 25)
			if math.random(freq) == 1 then
				--knife.Variant = TearVariant.STONE
				--knife:GetSprite():Load("gfx/projectiles/fortune_cookie_tear.anm2", true)
				local data = knife:GetData()
				data.IsFortuneTearDelayTilFired = true
				--knife.CollisionDamage = knife.CollisionDamage * 1.05
				data.HasShownFortuneAlready = false

				local color = Color(0.9, 0.75, 0.5, 1.0, 40/255, 20/255, 0/255)
				color:SetColorize(0.98, 0.80, 0.64, 1)
				data.KnifeColor = color
			end
		end]]--

		--Imp Soda
		--[[if player:HasCollectible(CollectibleType.COLLECTIBLE_IMP_SODA) or player:HasTrinket(FiendFolio.ITEM.ROCK.SODALITE_GEODE) then
			local extraOdds = 0
			if player:HasCollectible(CollectibleType.COLLECTIBLE_IMP_SODA) then
				extraOdds = extraOdds + 5
				if player:HasTrinket(FiendFolio.ITEM.ROCK.SODALITE_GEODE) then
					extraOdds = extraOdds + 5
				end
			end

			local trinketPower, geodeBonus = FiendFolio.GetGolemTrinketPower(player, FiendFolio.ITEM.ROCK.SODALITE_GEODE)
			if geodeBonus then
				trinketPower = trinketPower * 1.5
			end
			if trinketPower > 0 then
				extraOdds = extraOdds + 5 * (trinketPower - 1)
			end

			local ImpSodaOdds = (30 - math.floor(player.Luck * 2) - math.ceil(extraOdds))
			if math.random(math.max(3, ImpSodaOdds)) == 1 then
				--sfx:Play(mod.Sounds.CritShoot, 0.3, 0, false, math.random(80,120)/100)
				knife:GetData().isImpSodaTearDelayTilFired = true
				--local critLightning = Isaac.Spawn(1000, 1737, 1, bomb.Position, nilvector, bomb):ToEffect()
				--critLightning.Parent = bomb
				--critLightning.Color = Color(1,1,1,0,0,0,1)
				--critLightning:Update()
				--bomb.ExplosionDamage = bomb.ExplosionDamage * 5
				data.KnifeColor = Color(1.3,1.3,1.3,1,100/255,-150/255,100/255)
				--bomb.SplatColor = Color(1.3,1.3,1.3,1,100 / 255,-150 / 255,100 / 255)
			end
		end]]--

		--mod:immoralClotOnFireKnife(knife)
		--mod:lawnDartsOnFireKnife(player, knife, secondHandMultiplier)
		--mod:hypnoRingOnFireKnife(player, knife, secondHandMultiplier)
		--mod:pinheadOnFireKnife(player, knife, secondHandMultiplier)
		--mod:rubberBulletsOnFireKnife(player, knife, secondHandMultiplier)
		--mod:toyPianoOnFireKnife(player, knife, secondHandMultiplier)
		--mod:rerolliganFossilFireKnife(player, knife, nil, player:GetData(), knife:GetData())

		if player:GetData().emeticAntimonyReady then
			player:GetData().emeticAntimonyReady = false
		end
	elseif knife:IsFlying() then
		--if data.isImpSodaTearDelayTilFired then
		--	data.isImpSodaTear = true
		--end
		--if data.YinYangOrbDelayTilFired then
		--	data.YinYangOrb = true
		--end
		--if data.IsFortuneTearDelayTilFired then
		--	data.IsFortuneTear = true
		--end
		--if data.ApplyDoomDelayTilFired then
		--	data.ApplyDoom = true
		--end
		--if data.ApplyDrowsyDelayTilFired then
		--	data.ApplyDrowsy = true
		--end
		--if data.isRerolliganTearDelayTilFired then
		--	data.isRerolliganTear = true
		--end
		if not data.WasFlying then
			if player:HasCollectible(CollectibleType.COLLECTIBLE_PEPPERMINT) then
				mod:firePeppermint(player, knife.Position, Vector(10, 0):Rotated(knife.Rotation) + player:GetTearMovementInheritance(player:GetAimDirection()))
			end
			mod:erflyPostFireKnife(player, knife, data)
			mod:ferriumOnFireKnife(player, knife)
		end
	end

	data.WasFlying = knife:IsFlying()

	--knife.Color = data.KnifeColor or knife.Color
end)

function mod:updateLaserColors(_) -- Lasers and Forgotten Brimstone
	local lasers = Isaac.FindByType(EntityType.ENTITY_LASER)
	for _, laser in ipairs(lasers) do
		local var = laser.Variant
		local subt = laser.SubType
		if (var == 1 and subt == 3) or var == 5 or var == 12 then -- Maw of the Void, Revelation and Montezuma's Revenge lasers
			-- do nothing
		else
			local data = laser:GetData()

			-- Immoral Clots
			if data.ImpSodaLaserForceColor then
				local color = Color(1.0, 1.0, 1.0, 1.0, 0/255, 0/255, 0/255)
				color:SetColorize(5.7, 0.9, 3.4, 1)
				laser.Color = color
			end

			mod:prankCookieUpdateLaserColors(laser, data)
		end
	end

	local laserEndpoints = Isaac.FindByType(EntityType.ENTITY_EFFECT, EffectVariant.LASER_IMPACT)
	for _, laserEndpoint in ipairs(laserEndpoints) do
		local data = laserEndpoint:GetData()

		-- Immoral Clots
		if data.ImpSodaLaserForceColor then
			local color = Color(1.0, 1.0, 1.0, 1.0, 0/255, 0/255, 0/255)
			color:SetColorize(5.7, 0.9, 3.4, 1)
			laserEndpoint.Color = color
		end

		mod:prankCookieUpdateLaserColors(laserEndpoint, data)
	end

	local brimballs = Isaac.FindByType(EntityType.ENTITY_EFFECT, EffectVariant.BRIMSTONE_BALL)
	for _, brimball in ipairs(brimballs) do
		local data = brimball:GetData()

		-- Immoral Clots
		if data.ImpSodaLaserForceColor then
			local color = Color(1.0, 1.0, 1.0, 1.0, 0/255, 0/255, 0/255)
			color:SetColorize(5.7, 0.9, 3.4, 1)
			brimball.Color = color
		end

		mod:prankCookieUpdateLaserColors(brimball, data)
	end
end
mod:AddCallback(ModCallbacks.MC_POST_PLAYER_UPDATE, mod.updateLaserColors)
mod:AddCallback(ModCallbacks.MC_POST_UPDATE, mod.updateLaserColors)

mod:AddCallback(ModCallbacks.MC_POST_LASER_INIT, function(_, laser)
	local var = laser.Variant
	if var == 4 or var == 7 or var == 8 or var == 13 then -- Pride, Tractor Beam, Circle of Protection and Beast Lasers
		return
	end

	if laser.SpawnerEntity and laser.SpawnerEntity.Type == EntityType.ENTITY_PLAYER and var == 2 and laser.SubType == 0 then
		local familiars = Isaac.FindInRadius(laser.Position, 0.000001, EntityPartition.FAMILIAR)
		for _,familiar in ipairs(familiars) do
			if familiar.Variant == FamiliarVariant.FINGER then
				return
			end
		end
	end

	local player = nil
	if laser.SpawnerEntity and laser.SpawnerEntity:ToPlayer() then
		player = laser.SpawnerEntity:ToPlayer()
	elseif laser.SpawnerEntity and laser.SpawnerEntity:ToFamiliar() and laser.SpawnerEntity:ToFamiliar().Player then
		local familiar = laser.SpawnerEntity:ToFamiliar()

		if familiar.Variant == FamiliarVariant.INCUBUS or familiar.Variant == FamiliarVariant.SPRINKLER or
		   familiar.Variant == FamiliarVariant.TWISTED_BABY or familiar.Variant == FamiliarVariant.BLOOD_BABY or
		   familiar.Variant == FamiliarVariant.UMBILICAL_BABY then
			player = familiar.Player
		else
			return
		end
	else
		return
	end

	mod:prankCookieOnFireLaser(player, laser)
	mod:immoralClotOnFireLaser(laser)
	mod:erflyPostFireLaser(player, laser)
	mod:ferriumOnFireLaser(player, laser)

	if player:HasCollectible(CollectibleType.COLLECTIBLE_PEPPERMINT) then
		FiendFolio.scheduleForUpdate(function()
			local vec = Vector(10, 0)
			if laser.Velocity:Length() > 0 then
				vec = laser.Velocity:Resized(10)
			end

			mod:firePeppermint(player, laser.Position, vec:Rotated(laser.AngleDegrees) + player:GetTearMovementInheritance(player:GetAimDirection()))
		end, 1)
	end
end)

mod:AddCallback(ModCallbacks.MC_POST_EFFECT_INIT, function(_, laserEndpoint)
	if laserEndpoint.SpawnerEntity and laserEndpoint.SpawnerEntity.Type == EntityType.ENTITY_LASER then
		local laser = laserEndpoint.SpawnerEntity
		local var = laser.Variant
		local subt = laser.SubType
		if (var == 1 and subt == 3) or var == 5 or var == 12 then -- Maw of the Void, Revelation and Montezuma's Revenge lasers
			-- do nothing
		else
			local endpointData = laserEndpoint:GetData()
			local laserData = laser:GetData()

			mod:prankCookieOnLaserEndpointInit(endpointData, laserData)
			endpointData.ImpSodaLaserForceColor = laserData.ImpSodaLaserForceColor
		end
	end
end, EffectVariant.LASER_IMPACT)

mod:AddCallback(ModCallbacks.MC_POST_EFFECT_INIT, function(_, brimball)
	local player = nil
	if brimball.SpawnerEntity and brimball.SpawnerEntity:ToPlayer() then
		player = brimball.SpawnerEntity:ToPlayer()
	else
		return
	end

	mod:prankCookieOnFireLaser(player, brimball)
	mod:immoralClotOnFireBrimball(brimball)
end, EffectVariant.BRIMSTONE_BALL)

FiendFolio.IgnoreAquariusSynergies = false
mod:AddCallback(ModCallbacks.MC_POST_EFFECT_INIT, function(_, creep) -- Aquarius
	if not FiendFolio.IgnoreAquariusSynergies and creep.SpawnerEntity and creep.SpawnerEntity.Type == EntityType.ENTITY_PLAYER then
		local player = creep.SpawnerEntity:ToPlayer()
		local data = creep:GetData()
		local secondHandMultiplier = player:GetTrinketMultiplier(TrinketType.TRINKET_SECOND_HAND) + 1

		mod:crucifixOnFireAquarius(player, creep, secondHandMultiplier)
		local prankCookieDataFlag = mod:prankCookieRollAquariusEffect(player, creep)

		--Fortune Stuff
		local baseFortuneOdds = 0
		if player:HasTrinket(TrinketType.TRINKET_FORTUNE_WORM) or player:HasTrinket(FiendFolio.ITEM.ROCK.FORTUNE_WORM_FOSSIL) then
			local fortuneWormOdds = player:GetPlayerType() == FiendFolio.PLAYER.FIEND and 5 or 1
			fortuneWormOdds = fortuneWormOdds * (player:GetTrinketMultiplier(TrinketType.TRINKET_FORTUNE_WORM) + FiendFolio.GetGolemTrinketPower(player, FiendFolio.ITEM.ROCK.FORTUNE_WORM_FOSSIL))
			baseFortuneOdds = baseFortuneOdds + fortuneWormOdds
		end
		if FiendFolio.GreatFortune then
			baseFortuneOdds = baseFortuneOdds + 3
		end
		if player:HasCollectible(CollectibleType.COLLECTIBLE_LEFTOVER_TAKEOUT) then
			baseFortuneOdds = baseFortuneOdds + 17
		end

		if baseFortuneOdds > 0 then
			local freq = math.min(math.max(math.floor(22 - baseFortuneOdds - player.Luck), 3), 25)
			if creep.InitSeed % freq == 0 then
				--creep.Variant = TearVariant.STONE
				--creep:GetSprite():Load("gfx/projectiles/fortune_cookie_tear.anm2", true)
				local data = creep:GetData()
				data.IsFortuneTear = true
				--creep.CollisionDamage = creep.CollisionDamage * 1.05
				data.HasShownFortuneAlready = false

				local color = Color(1.0, 1.0, 1.0, 1.0, 0/255, 0/255, 0/255)
				color:SetColorize(4.5, 3.44, 2.41, 1)
				data.FFAquariusColor = color
			end
		end

		--Imp Soda
		if mod:shouldCriticalHit(player) then
			--sfx:Play(mod.Sounds.CritShoot, 0.3, 0, false, math.random(80,120)/100)
			creep:GetData().isImpSodaTear = true
			--local critLightning = Isaac.Spawn(1000, 1737, 1, creep.Position, nilvector, creep):ToEffect()
			--critLightning.Parent = creep
			--critLightning.Color = Color(1,1,1,0,0,0,1)
			--critLightning:Update()
			--creep.ExplosionDamage = creep.ExplosionDamage * 5

			local color = Color(1.0, 1.0, 1.0, 1.0, 0/255, 0/255, 0/255)
			color:SetColorize(5.7, 0.9, 3.4, 1)
			data.FFAquariusColor = color

			--creep.SplatColor = Color(1.3,1.3,1.3,1,100 / 255,-150 / 255,100 / 255)
		end

		if player:HasCollectible(CollectibleType.COLLECTIBLE_DICHROMATIC_BUTTERFLY) or player:HasTrinket(TrinketType.TRINKET_YIN_YANG_ORB) then
			local randval = 30
			if player:HasCollectible(CollectibleType.COLLECTIBLE_DICHROMATIC_BUTTERFLY) and player:HasTrinket(TrinketType.TRINKET_YIN_YANG_ORB) then
				randval = 20
			end
			local luck = math.max(math.min(math.floor(player.Luck), 7), -1)
			if math.random(randval) < 5 + (luck * 2) then
				--creep.Flags = creep.Flags | TearFlags.TEAR_HOMING
				data.YinYangOrb = true
				data.YinYangOrbDamageMultiplier = 1.25 + 0.50 * math.max(player:GetTrinketMultiplier(TrinketType.TRINKET_YIN_YANG_ORB) - 1, 0)

				local color = Color(1.4, 1.4, 1.4, 1.0, 0/255, 0/255, 0/255)
				color:SetColorize(0.096, 2.16, 3.12, 1)
				data.FFAquariusColor = color
			end
		end

		mod:prankCookieOnFireAquarius(player, creep, prankCookieDataFlag, secondHandMultiplier)
		mod:lawnDartsOnFireAquarius(player, creep, secondHandMultiplier)
		mod:hypnoRingOnFireAquarius(player, creep, secondHandMultiplier)
		mod:pinheadOnFireAquarius(player, creep, secondHandMultiplier)
		mod:rubberBulletsOnFireAquarius(player, creep, secondHandMultiplier)
		mod:toyPianoOnFireAquarius(player, creep, secondHandMultiplier)
		mod:rerolliganFossilFireAquarius(player, creep, creep:GetDropRNG(), player:GetData(), creep:GetData())
		mod:sandstoneOnFireAquarius(player, creep, secondHandMultiplier)
		mod:fragmentedOnyxOnFireAquarius(player, creep, secondHandMultiplier)
		mod:rockCandyOnFireAquarius(player, creep, secondHandMultiplier)
		mod:sheepRockOnFireAquarius(player, creep, secondHandMultiplier)
		mod:trippyFossilOnFireAquarius(player, creep, secondHandMultiplier)
		mod:petrifiedSockOnFireAquarius(player, creep, secondHandMultiplier)
		mod:fractalGeodeOnFireAquarius(player, creep, secondHandMultiplier)
		mod:erflyOnFireAquarius(player, creep, secondHandMultiplier)
	end
end, EffectVariant.PLAYER_CREEP_HOLYWATER_TRAIL)

mod:AddCallback(ModCallbacks.MC_POST_EFFECT_UPDATE, function(_, creep)
	if creep.FrameCount == 0 and creep:GetData().FFAquariusColor then
		creep.Color = creep:GetData().FFAquariusColor
	end
end, EffectVariant.PLAYER_CREEP_HOLYWATER_TRAIL)

function mod:rollEpicFetusEffects(player, target) -- Epic Fetus
	local data = target:GetData()

	if not data.FFRocketQueuedEffects then
		local secondHandMultiplier = player:GetTrinketMultiplier(TrinketType.TRINKET_SECOND_HAND) + 1

		mod:crucifixOnFireRocket(player, target, secondHandMultiplier)
		local prankCookieDataFlag = mod:prankCookieRollRocketEffect(player, target)

		--Fortune Stuff
		local baseFortuneOdds = 0
		if player:HasTrinket(TrinketType.TRINKET_FORTUNE_WORM) or player:HasTrinket(FiendFolio.ITEM.ROCK.FORTUNE_WORM_FOSSIL) then
			local fortuneWormOdds = player:GetPlayerType() == FiendFolio.PLAYER.FIEND and 5 or 1
			fortuneWormOdds = fortuneWormOdds * (player:GetTrinketMultiplier(TrinketType.TRINKET_FORTUNE_WORM) + FiendFolio.GetGolemTrinketPower(player, FiendFolio.ITEM.ROCK.FORTUNE_WORM_FOSSIL))
			baseFortuneOdds = baseFortuneOdds + fortuneWormOdds
		end
		if FiendFolio.GreatFortune then
			baseFortuneOdds = baseFortuneOdds + 3
		end
		if player:HasCollectible(CollectibleType.COLLECTIBLE_LEFTOVER_TAKEOUT) then
			baseFortuneOdds = baseFortuneOdds + 17
		end

		if baseFortuneOdds > 0 then
			local freq = math.min(math.max(math.floor(22 - baseFortuneOdds - player.Luck), 3), 25)
			if math.random(freq) == 1 then
				--target.Variant = TearVariant.STONE
				--target:GetSprite():Load("gfx/projectiles/fortune_cookie_tear.anm2", true)
				local data = target:GetData()
				data.IsFortuneTear = true
				--target.ExplosionDamage = target.ExplosionDamage * 1.05
				data.HasShownFortuneAlready = false

				local color = Color(0.9, 0.75, 0.5, 1.0, 40/255, 20/255, 0/255)
				color:SetColorize(0.98, 0.80, 0.64, 1)
				data.FFExplosionColor = color
			end
		end

		--Imp Soda
		if mod:shouldCriticalHit(player) then
			--sfx:Play(mod.Sounds.CritShoot, 0.3, 0, false, math.random(80,120)/100)
			target:GetData().isImpSodaTear = true
			--local critLightning = Isaac.Spawn(1000, 1737, 1, target.Position, nilvector, target):ToEffect()
			--critLightning.Parent = target
			--critLightning.Color = Color(1,1,1,0,0,0,1)
			--critLightning:Update()
			--target.ExplosionDamage = target.ExplosionDamage * 5
			data.FFExplosionColor = Color(1.3,1.3,1.3,1,100/255,-150/255,100/255)
			--target.SplatColor = Color(1.3,1.3,1.3,1,100 / 255,-150 / 255,100 / 255)
		end

		if player:HasCollectible(CollectibleType.COLLECTIBLE_DICHROMATIC_BUTTERFLY) or player:HasTrinket(TrinketType.TRINKET_YIN_YANG_ORB) then
			local randval = 30
			if player:HasCollectible(CollectibleType.COLLECTIBLE_DICHROMATIC_BUTTERFLY) and player:HasTrinket(TrinketType.TRINKET_YIN_YANG_ORB) then
				randval = 20
			end
			local luck = math.max(math.min(math.floor(player.Luck), 7), -1)
			if math.random(randval) < 5 + (luck * 2) then
				--target.Flags = target.Flags | TearFlags.TEAR_HOMING
				data.YinYangOrb = true
				data.YinYangOrbDamageMultiplier = 1.25 + 0.50 * math.max(player:GetTrinketMultiplier(TrinketType.TRINKET_YIN_YANG_ORB) - 1, 0)

				data.FFExplosionColor = Color(0.05, 0.65, 0.9, 1.0, 0/255, 60/255, 90/255)
			end
		end

		mod:immoralClotOnFireRocket(target)
		mod:morbidClotOnFireRocket(target)
		mod:prankCookieOnFireRocket(player, target, prankCookieDataFlag, secondHandMultiplier)
		mod:lawnDartsOnFireRocket(player, target, secondHandMultiplier)
		mod:hypnoRingOnFireRocket(player, target, secondHandMultiplier)
		mod:pinheadOnFireRocket(player, target, secondHandMultiplier)
		mod:rubberBulletsOnFireRocket(player, target, secondHandMultiplier)
		mod:toyPianoOnFireRocket(player, target, secondHandMultiplier)
		mod:rerolliganFossilFireRocket(player, target, target:GetDropRNG(), player:GetData(), target:GetData())
		mod:sandstoneOnFireRocket(player, target, secondHandMultiplier)
		mod:fragmentedOnyxOnFireRocket(player, target, secondHandMultiplier)
		mod:rockCandyOnFireRocket(player, target, secondHandMultiplier)
		mod:sheepRockOnFireRocket(player, target, secondHandMultiplier)
		mod:trippyFossilOnFireRocket(player, target, secondHandMultiplier)
		mod:petrifiedSockOnFireRocket(player, target, secondHandMultiplier)
		mod:fractalGeodeOnFireRocket(player, target, secondHandMultiplier)
		mod:erflyOnFireRocket(player, target, secondHandMultiplier)

		mod:bridgeBombsPostFireRocket(player, target)
		mod:muscaBombsPostFireRocket(player, target)
		mod:bombSackFossilPostFireRocket(player, target)

		if player:GetData().emeticAntimonyReady then
			target:GetData().emeticPlayer = player
		end

		data.FFRocketQueuedEffects = true
	end
end

mod:AddCallback(ModCallbacks.MC_POST_EFFECT_UPDATE, function(_, target)
	local player = nil
	if target.SpawnerEntity and target.SpawnerEntity:ToPlayer() then
		player = target.SpawnerEntity:ToPlayer()
	elseif target.SpawnerEntity and target.SpawnerEntity:ToFamiliar() and target.SpawnerEntity:ToFamiliar().Player then
		local familiar = target.SpawnerEntity:ToFamiliar()

		if familiar.Variant == FamiliarVariant.INCUBUS or familiar.Variant == FamiliarVariant.SPRINKLER or
		   familiar.Variant == FamiliarVariant.TWISTED_BABY or familiar.Variant == FamiliarVariant.BLOOD_BABY or
		   familiar.Variant == FamiliarVariant.UMBILICAL_BABY then
			player = familiar.Player
		else
			return
		end
	else
		return
	end

	mod:rollEpicFetusEffects(player, target)
end, EffectVariant.TARGET)

mod:AddCallback(ModCallbacks.MC_POST_EFFECT_UPDATE, function(_, rocket)
	local player = nil
	if rocket.SpawnerEntity and rocket.SpawnerEntity:ToPlayer() then
		player = rocket.SpawnerEntity:ToPlayer()
	elseif rocket.SpawnerEntity and rocket.SpawnerEntity:ToFamiliar() and rocket.SpawnerEntity:ToFamiliar().Player then
		local familiar = rocket.SpawnerEntity:ToFamiliar()

		if familiar.Variant == FamiliarVariant.INCUBUS or familiar.Variant == FamiliarVariant.SPRINKLER or
		   familiar.Variant == FamiliarVariant.TWISTED_BABY or familiar.Variant == FamiliarVariant.BLOOD_BABY or
		   familiar.Variant == FamiliarVariant.UMBILICAL_BABY then
			player = familiar.Player
		else
			return
		end
	else
		return
	end

	local rocketdata = rocket:GetData()
	if rocket.FrameCount <= 1 then
		if rocket.Parent and rocket.Parent.Type == EntityType.ENTITY_EFFECT and rocket.Parent.Variant == EffectVariant.TARGET and not rocket.Parent:GetData().FFPassedOnRocketEffects then
			local targetdata = rocket.Parent:GetData()

			rocketdata.FFExplosionColor = targetdata.FFExplosionColor

			rocketdata.IsFortuneTear = targetdata.IsFortuneTear
			rocketdata.HasShownFortuneAlready = targetdata.HasShownFortuneAlready

			rocketdata.isImpSodaTear = targetdata.isImpSodaTear

			rocketdata.ApplySewn = targetdata.ApplySewn
			rocketdata.ApplySewnDuration = targetdata.ApplySewnDuration

			rocketdata.ApplyMartyr = targetdata.ApplyMartyr
			rocketdata.ApplyMartyrDuration = targetdata.ApplyMartyrDuration
			rocketdata.ApplyMartyrConfuse = targetdata.ApplyMartyrConfuse
			rocketdata.ApplyMartyrConfuseDuration = targetdata.ApplyMartyrConfuseDuration

			rocketdata.ApplyBruise = targetdata.ApplyBruise
			rocketdata.ApplyBruiseDuration = targetdata.ApplyBruiseDuration
			rocketdata.ApplyBruiseStacks = targetdata.ApplyBruiseStacks
			rocketdata.ApplyBruiseDamagePerStack = targetdata.ApplyBruiseDamagePerStack

			rocketdata.ApplyBerserk = targetdata.ApplyBerserk
			rocketdata.ApplyBerserkDuration = targetdata.ApplyBerserkDuration

			rocketdata.ApplyBleed = targetdata.ApplyBleed
			rocketdata.ApplyBleedDuration = targetdata.ApplyBleedDuration
			rocketdata.ApplyBleedDamage = targetdata.ApplyBleedDamage

			rocketdata.ApplyDrowsy = targetdata.ApplyDrowsy
			rocketdata.ApplyDrowsyDuration = targetdata.ApplyDrowsyDuration
			rocketdata.ApplyDrowsySleepDuration = targetdata.ApplyDrowsySleepDuration

			rocketdata.YinYangOrb = targetdata.YinYangOrb
			rocketdata.YinYangOrbDamageMultiplier = targetdata.YinYangOrbDamageMultiplier

			rocketdata.FFBridgeBomb = targetdata.FFBridgeBomb

			rocketdata.FFLocustBomb = targetdata.FFLocustBomb
			rocketdata.FFLocustPlayer = targetdata.FFLocustPlayer

			rocketdata.emeticPlayer = targetdata.emeticPlayer

			rocketdata.ApplyCharm = targetdata.ApplyCharm
			rocketdata.ApplyCharmDuration = targetdata.ApplyCharmDuration

			rocketdata.ApplyFear = targetdata.ApplyFear
			rocketdata.ApplyFearDuration = targetdata.ApplyFearDuration

			rocketdata.ApplyShrink = targetdata.ApplyShrink
			rocketdata.ApplyShrinkDuration = targetdata.ApplyShrinkDuration

			rocketdata.ApplyPetrify = targetdata.ApplyPetrify
			rocketdata.ApplyPetrifyDuration = targetdata.ApplyPetrifyDuration

			rocketdata.SandstoneMultiplier = targetdata.SandstoneMultiplier
			rocketdata.RockCandyMultiplier = targetdata.RockCandyMultiplier

			rocketdata.bombSackFossil = targetdata.bombSackFossil
			rocketdata.bombSackFossilPlayer = targetdata.bombSackFossilPlayer

			rocketdata.BlackMoonInflicting = targetdata.BlackMoonInflicting
			if rocketdata.BlackMoonInflicting then
				rocket.Color = FiendFolio.ColorShadyRed
			end

			rocketdata.ApplyMultiEuclidean = targetdata.ApplyMultiEuclidean
			rocketdata.ApplyMultiEuclideanDuration = targetdata.ApplyMultiEuclideanDuration

			rocketdata.leavePowderCreep = targetdata.leavePowderCreep

			rocketdata.ApplySapphicSapphireFreeze = targetdata.ApplySapphicSapphireFreeze
			
			rocketdata.isMorbidClotToothTear = targetdata.isMorbidClotToothTear

			rocketdata.FFRocketQueuedEffects = true
			targetdata.FFPassedOnRocketEffects = true
		else
			mod:rollEpicFetusEffects(player, rocket)
		end
	end
end, EffectVariant.ROCKET)

mod:AddCallback(ModCallbacks.MC_POST_EFFECT_INIT, function(_, explosion)
	if explosion.SpawnerEntity and explosion.SpawnerType == EntityType.ENTITY_EFFECT and explosion.SpawnerVariant == EffectVariant.ROCKET then
		local rocket = explosion.SpawnerEntity
		mod:erflyPostRocketExplosion(explosion, rocket)
		explosion:GetData().FFExplosionColor = rocket:GetData().FFExplosionColor
		if rocket:GetData().emeticPlayer then
			local player = rocket:GetData().emeticPlayer
			if player:GetData().emeticAntimonyReady then
				player:GetData().emeticAntimonyReady = false
			end
		end
	end
end, EffectVariant.BOMB_EXPLOSION)

mod:AddCallback(ModCallbacks.MC_POST_EFFECT_RENDER, function(_, explosion)
	if explosion.FrameCount <= 0 then
		explosion.Color = explosion:GetData().FFExplosionColor or explosion.Color
	end
end, EffectVariant.BOMB_EXPLOSION)

mod:AddCallback(ModCallbacks.MC_POST_TEAR_UPDATE, function(_, tear)
	local td = tear:GetData()

	mod:erflyTearUpdate(tear, td)

	if td.PissPuddler == true then
		if tear:IsDead() then
			local piss = Isaac.Spawn(1000, 46, 0, tear.Position, nilvector, tear):ToEffect()
			local pisscolor = Color(1,1,1,1,0,0,0)
			pisscolor:SetColorize(7, 7, 1, 1)
			piss.Color = pisscolor
			piss.CollisionDamage = td.DMG * 0.4
			piss.Timeout = 60
			piss:Update()
		end
	end
	if td.spriteRotatin and (tear.Variant == 0 or tear.Variant == 1) then
		local rotOff = td.spriteRotatinOff or 0
		tear.SpriteRotation = tear.Velocity:GetAngleDegrees() + rotOff
	end
	if td.customtype == "makeyinyangorb" or td.YinYangOrb then
		local strength = td.yinyangstrength or 0.3
		local chosenenemy
		local closestdist = 999
		for _,enemy in ipairs(Isaac.FindInRadius(tear.Position, 100, EntityPartition.ENEMY)) do
			if enemy:ToNPC() and not (enemy:HasEntityFlags(EntityFlag.FLAG_FRIENDLY) or enemy:HasEntityFlags(EntityFlag.FLAG_NO_TARGET)) then
				local vec = enemy.Position - tear.Position
				if vec:Length() < closestdist then
					chosenenemy = enemy
					closestdist = vec:Length()
				end
			end
		end
		if chosenenemy then
			tear.Velocity = mod:Lerp(tear.Velocity, (chosenenemy.Position - tear.Position) * 0.3, strength)
		end
	end

	if td.isTrinityWormTear then
		td.HolyWormPos = td.HolyWormPos or 1
		td.HolyWormValue = td.HolyWormValue or 1

		local val = 1.5 * td.HolyWormPos
		if td.ModelRocketTear and td.ModelRocketFrame < 13 then
			val = 0
		end
		td.HolyWormValue = td.HolyWormValue + val

		if td.HolyWormValue >= 19 then
			td.HolyWormPos = -1
		elseif td.HolyWormValue <= 1 then
			td.HolyWormPos = 1
		end

		tear.Velocity = tear.Velocity:Rotated(td.HolyWormValue)
	end
end)

mod:AddCallback(ModCallbacks.MC_POST_EFFECT_RENDER, function(_, e)
	local d = e:GetData()
	if d.overridepoof then
		for _, en in pairs(Isaac.FindByType(1000, -1, -1)) do
			if en.Variant == 12 or en.Variant == 13 or en.Variant == 79 or en.Variant == 80 then
				local ed = en:GetData()
				if not ed.overridepoof and en.FrameCount <= 1 then
					en:Remove()
				end
			end
		end
	end
end, 12)

mod:AddCallback(ModCallbacks.MC_POST_ENTITY_REMOVE, function(_, tear)
	if game:IsPaused() then return end
	local data = tear:GetData()
	--Brick Tear Break
	if data.isBrickTear then
		--print("BrickFired")
		local gibCol = Color(1, 1, 1, 1, 0, 0, 0)
		local poof = Isaac.Spawn(1000, EffectVariant.IMPACT, 0, tear.Position, nilvector, tear)
		gibCol:SetColorize(0.9, 0.8, 0.5, 1)
		poof:GetSprite().Color = gibCol

		gibCol:SetColorize(0.82, 0.62, 0.43, 1)
		for i = 1, 5 do
			local gib = Isaac.Spawn(1000, EffectVariant.TOOTH_PARTICLE, 0, tear.Position, RandomVector()*2, tear)
			gib:GetSprite().Color = gibCol
		end
	end
	mod:erflyPostTearRemove(tear,data)
end, EntityType.ENTITY_TEAR)

FiendFolio.FortuneTearCooldown = 0
mod:AddCallback(ModCallbacks.MC_PRE_TEAR_COLLISION, function(_, tear, ent)
	local data = tear:GetData()

	mod:erflyPreTearCollision(tear, ent, data)

	if data.IsFortuneTear and ent:IsEnemy() then
		if not tear:GetData().HasShownFortuneAlready then
			if FiendFolio.FortuneTearCooldown <= 0 then
				--game:ShowFortune()
				mod:ShowFortune(false, true)
				FiendFolio.FortuneTearCooldown = 20
				tear:GetData().HasShownFortuneAlready = true
			end
		end
	end

	if data.isImpSodaTear and ent:IsEnemy() then
		data.hasImpSodaProcced = data.hasImpSodaProcced or {}
		if not data.hasImpSodaProcced[ent.InitSeed] then
			mod:doCriticalHitFx(tear.Position, ent, tear)
			data.hasImpSodaProcced[ent.InitSeed] = true
		end
	end

	--Melt Eroded Host
	if ent.Type == mod.FF.ErodedHost.ID and ent.Variant == mod.FF.ErodedHost.Var and tear:HasTearFlags(TearFlags.TEAR_ACID) then
		if ent:GetData().skullhealth > 0 and ent.SubType < 2 then
			ent:GetData().skullhealth = -1
			if ent.SubType == 0 then
				ent.SubType = 1
			end
			ent:Update()
		end
	end

	--Honey Shot
	if data.HoneySlow and not (ent:HasEntityFlags(EntityFlag.FLAG_NO_STATUS_EFFECTS)) and ent:ToNPC() then
		--local honeycolor = Color(1,1,1,1,255 / 255,165 / 255,0 / 255)
		--print(ent:ToNPC())
		local honeycolor = Color(255 / 255,165 / 255,0 / 255,1,0,0,0)
		ent:AddSlowing(EntityRef(tear),30,0.5,honeycolor)
	end
end)

mod:AddCallback(ModCallbacks.MC_POST_UPDATE, function()
	if FiendFolio.FortuneTearCooldown > 0 then
		FiendFolio.FortuneTearCooldown = FiendFolio.FortuneTearCooldown - 1
	end

	local room = game:GetRoom()
	if room:GetType() == RoomType.ROOM_DUNGEON then
		local updateGrids
		if FiendFolio.RoomGrids then
			for _, v in pairs({"GRID_ROCK", "GRID_ROCKT", "GRID_ROCK_ALT", "GRID_ROCK_BOMB", "GRID_ROCK_SS", "GRID_ROCK_SPIKED", "GRID_ROCK_GOLD", "GRID_ROCK_ALT2"}) do
				if FiendFolio.RoomGrids[GridEntityType[v]] then
					for i = 1, #FiendFolio.RoomGrids[GridEntityType[v]] do
						if i > #FiendFolio.RoomGrids[GridEntityType[v]] then break end
						local g = FiendFolio.RoomGrids[GridEntityType[v]][i]

						if g then
							if g.Desc.State ~= 1 then
								local g2 = room:GetGridEntityFromPos(g.Position + Vector(0, 40))
								if g2 then
									local g2t = g2:GetType()
									if FiendFolio.RequiresRocktops[g2t] and g2.Desc.State == 1 or g2.Desc.State == 4 then
										local e = Isaac.Spawn(1000, Isaac.GetEntityVariantByName("Crawlspace Rocktop"), 0, g2.Position + Vector(0, -80), nilvector, nil)
										e:GetData().myrock = g2
										e.PositionOffset = Vector(0, 40)
										local suffix = mod:getCrawlspaceBackdropSuffix()
										local esprite = e:GetSprite()
										esprite:ReplaceSpritesheet(0, "gfx/grid/rocktop grids/rocktop_" .. suffix .. ".png")
										esprite:LoadGraphics()
										e:Update()
										updateGrids = true
									elseif v ~= "GRID_ROCK_ALT" and g2 and (g2t == GridEntityType.GRID_ROCKB or g2t == GridEntityType.GRID_WALL or g2t == GridEntityType.GRID_DOOR) then
										--print(g2.Desc.State)
										local e = Isaac.Spawn(1000, Isaac.GetEntityVariantByName("Crawlspace Rocktop"), 0, g2.Position + Vector(0, -80), nilvector, nil)
										e:GetData().myrock = g2
										e:GetData().perm = true
										e.PositionOffset = Vector(0, 40)
										local suffix = mod:getCrawlspaceBackdropSuffix()
										local rockString = "_" .. suffix
										if rockString == "_default" then 
											rockString = ""
										end
										local esprite = e:GetSprite()
										esprite:Load("gfx/grid/tiles_itemdungeon.anm2")
										esprite:ReplaceSpritesheet(0, "gfx/grid/tiles_itemdungeon" .. rockString .. ".png")
										esprite:LoadGraphics()
										esprite:SetFrame("Floor1", 1)
										e:Update()
									end

									--table.remove(FiendFolio.RoomGrids[GridEntityType[v]], i)
									--i = i - 1
								end
							end
						end
					end
				end
			end
		else
			FiendFolio.GatherGrids()
		end
		if updateGrids then
			FiendFolio.GatherGrids()
		end

		for i = 0, room:GetGridSize() do
			local g = room:GetGridEntity(i)
			local gt = g and g:GetType()
			if g and not StageAPI.IsCustomGrid(i, "FFRubberRock") and g.Desc.State == 2 and FiendFolio.RequiresRocktops[gt] then
				local g2 = room:GetGridEntityFromPos(g.Position + Vector(0, 40))
				local g2t = g2 and g2:GetType()

				g = gt == GridEntityType.GRID_ROCK_ALT and Isaac.GridSpawn(GridEntityType.GRID_DECORATION, (g2t == GridEntityType.GRID_ROCKB or g2t == GridEntityType.GRID_WALL or g2t == GridEntityType.GRID_DOOR) and 1 or 0, g.Position, true) or Isaac.GridSpawn(GridEntityType.GRID_GRAVITY, 0, g.Position, true)

				local topsprite = g:GetSprite()
				if gt == GridEntityType.GRID_ROCK_ALT then
					local suffix = mod:getCrawlspaceBackdropSuffix()
					local rockString = "_" .. suffix
					if rockString == "_default" then 
						rockString = ""
					end
					topsprite:Load("gfx/grid/tiles_itemdungeon.anm2")
					topsprite:ReplaceSpritesheet(0, "gfx/grid/tiles_itemdungeon" .. rockString .. ".png")
					topsprite:LoadGraphics()

					topsprite:Play("Ladder"..(g:GetVariant() + 1))
				end

				if g2 and (g2t == GridEntityType.GRID_ROCKB or g2t == GridEntityType.GRID_WALL or g2t == GridEntityType.GRID_DOOR) then
					topsprite = g2:GetSprite()
					if gt ~= GridEntityType.GRID_ROCK_ALT then
						topsprite:Play("Floor"..math.random(3))
					end

					topsprite:Play("Brick"..math.random(3))
				end
			end
		end
	end
end)

function mod:impSodaCritZap(e)
	if e.SubType == 1 then
		if not e.Parent or e.Parent and not e.Parent:Exists() then
			e:Remove()
		end
		if e.Parent and e.Parent:Exists() and e.Parent:ToTear() then
			local alpha = 1
			if e.FrameCount < 10 then
				alpha = e.FrameCount / 10
			end
			e.Color = Color(0.5,1,1,alpha,0,0,1)
			local p = e.Parent:ToTear()
			e.Position = p.Position + p.PosDisplacement + p.PositionOffset + p.SpriteOffset - p.Velocity
			e.Velocity = p.Velocity
			e.SpriteScale = Vector(1,1) * p.Scale
			e.SpriteOffset = Vector(0, 16 * p.Scale)
		end
	end
end
mod:AddCallback(ModCallbacks.MC_POST_EFFECT_RENDER, mod.impSodaCritZap, 1737)

mod:AddCallback(ModCallbacks.MC_POST_BOMB_UPDATE, function(_, bomb)
	local data = bomb:GetData()

	if data.customtype == "makeyinyangorb" or data.YinYangOrb then
		local strength = data.yinyangstrength or 0.3
		local chosenenemy
		local closestdist = 999
		for _,enemy in ipairs(Isaac.FindInRadius(bomb.Position, 100, EntityPartition.ENEMY)) do
			if enemy:ToNPC() and not (enemy:HasEntityFlags(EntityFlag.FLAG_FRIENDLY) or enemy:HasEntityFlags(EntityFlag.FLAG_NO_TARGET)) then
				local vec = enemy.Position - bomb.Position
				if vec:Length() < closestdist then
					chosenenemy = enemy
					closestdist = vec:Length()
				end
			end
		end
		if chosenenemy then
			bomb.Velocity = mod:Lerp(bomb.Velocity, (chosenenemy.Position - bomb.Position) * 0.3, strength)
		end
	end
	mod:erflyPostBombUpdate(bomb, data)
end)

mod:AddCallback(ModCallbacks.MC_POST_EFFECT_INIT, function(_, explosion)
	if explosion.SpawnerEntity and explosion.SpawnerEntity:ToBomb() then
		local boomie = explosion.SpawnerEntity
		
		if boomie:GetData().FFSlippyBomb and not boomie:GetData().slippyCherry then
			local cloud = Isaac.Spawn(mod.FF.SlippyFart.ID, mod.FF.SlippyFart.Var, mod.FF.SlippyFart.Sub, explosion.Position, nilvector, boomie)
			sfx:Play(mod.Sounds.FartFrog1,0.2,0,false,math.random(80,120)/100)
			
			if boomie:GetData().FFIsScatter or boomie:GetData().isScatter or boomie:GetData().MaliceSplit then
				cloud:GetData().RadiusMult = 0.5
				cloud.SpriteScale = Vector(0.5, 0.5)
			end
			
			boomie:GetData().FFSlippyBombDoneFirstSpawn = true
		end
	end
end, EffectVariant.BOMB_EXPLOSION)

mod:AddCallback(ModCallbacks.MC_POST_BOMB_RENDER, function(_, bomb, offset)
	local data = bomb:GetData()
	mod:erflyPostBombRender(bomb, offset, data)
end)

mod:AddCallback(ModCallbacks.MC_POST_EFFECT_UPDATE, function(_, creep)
	local data = creep:GetData()

	if data.customtype == "makeyinyangorb" or data.YinYangOrb then
		local strength = data.yinyangstrength or 0.3
		local chosenenemy
		local closestdist = 999
		for _,enemy in ipairs(Isaac.FindInRadius(creep.Position, 100, EntityPartition.ENEMY)) do
			if enemy:ToNPC() and not (enemy:HasEntityFlags(EntityFlag.FLAG_FRIENDLY) or enemy:HasEntityFlags(EntityFlag.FLAG_NO_TARGET)) then
				local vec = enemy.Position - creep.Position
				if vec:Length() < closestdist then
					chosenenemy = enemy
					closestdist = vec:Length()
				end
			end
		end
		if chosenenemy then
			creep.Velocity = mod:Lerp(creep.Velocity, (chosenenemy.Position - creep.Position) * 0.3, strength)
		end
	end
end, EffectVariant.PLAYER_CREEP_HOLYWATER_TRAIL)

mod:AddCallback(ModCallbacks.MC_POST_EFFECT_UPDATE, function(_, target)
	local data = target:GetData()

	if data.customtype == "makeyinyangorb" or data.YinYangOrb then
		local strength = data.yinyangstrength or 0.3
		local chosenenemy
		local closestdist = 999
		for _,enemy in ipairs(Isaac.FindInRadius(target.Position, 100, EntityPartition.ENEMY)) do
			if enemy:ToNPC() and not (enemy:HasEntityFlags(EntityFlag.FLAG_FRIENDLY) or enemy:HasEntityFlags(EntityFlag.FLAG_NO_TARGET)) then
				local vec = enemy.Position - target.Position
				if vec:Length() < closestdist then
					chosenenemy = enemy
					closestdist = vec:Length()
				end
			end
		end
		if chosenenemy then
			target.Velocity = mod:Lerp(target.Velocity, (chosenenemy.Position - target.Position) * 0.5, strength)
		end
	end
end, EffectVariant.TARGET)

mod:AddCallback(ModCallbacks.MC_POST_NEW_LEVEL, function()
	for _, p in pairs(Isaac.FindByType(EntityType.ENTITY_PLAYER, -1, -1, false, false)) do
		p = p:ToPlayer()
		local data = p:GetData()
		data.revealboss = nil
		data.treasureport = nil
		mod:erflyPostNewLevelPlayer(p, data)

		if p:HasCollectible(CollectibleType.COLLECTIBLE_BEGINNERS_LUCK) then
			p:AddCacheFlags(CacheFlag.CACHE_LUCK)
			p:EvaluateItems()
		end

		--Corrodes Battery
		for i = 1, 2 do
		local isBattery = p:GetCard(i-1)

			if isBattery == Card.STORAGE_BATTERY_0 then
			p:SetCard(i-1,Card.CORRODED_BATTERY_0)
			sfx:Play(SoundEffect.SOUND_REDLIGHTNING_ZAP_BURST, 1, 0, false, 1)
			elseif isBattery == Card.STORAGE_BATTERY_1 then
			p:SetCard(i-1,Card.CORRODED_BATTERY_1)
			sfx:Play(SoundEffect.SOUND_REDLIGHTNING_ZAP_BURST, 1, 0, false, 1)
			elseif isBattery == Card.STORAGE_BATTERY_2 then
			p:SetCard(i-1,Card.CORRODED_BATTERY_2)
			sfx:Play(SoundEffect.SOUND_REDLIGHTNING_ZAP_BURST, 1, 0, false, 1)
			elseif isBattery == Card.STORAGE_BATTERY_3 then
			p:SetCard(i-1,Card.CORRODED_BATTERY_3)
			sfx:Play(SoundEffect.SOUND_REDLIGHTNING_ZAP_BURST, 1, 0, false, 1)
			end
		end
	end

	mod.customBombs = {}
	mod.d12machines = {}
	mod.d12ed_Rooms = {}
	mod.d12switch = nil

	mod.elitejontopness = true
	mod:erflyPostNewLevelGeneral()

	mod.getFieldInit(FiendFolio.savedata, 'run', {}).level = {}
	if gamestarted then
		FiendFolio.SaveSaveData()
	end
end)

function mod:FiendNewRoomStuff()
	local room = game:GetRoom()
	local level = game:GetLevel()
	local roomtype = room:GetType()
	local humbled = false
	for _, p in pairs(Isaac.FindByType(EntityType.ENTITY_PLAYER, -1, -1, false, false)) do
		if p:Exists() then
			p = p:ToPlayer()
			local data = p:GetData()
			data.ribsout = 0
			p:AddCacheFlags(CacheFlag.CACHE_FAMILIARS)
			p:EvaluateItems()
			if p:HasCollectible(CollectibleType.COLLECTIBLE_HUMBLEING_BUNDLE) and not humbled then humbled = true end

			if level:GetCurrentRoomIndex() == level:GetStartingRoomIndex() then
				data.treasureport = nil
			end

			if data.treasureport and roomtype == RoomType.ROOM_DEFAULT then
				while p:GetData().treasureport do
					local idx = level:QueryRoomTypeIndex(RoomType.ROOM_TREASURE, false, grng)
					local roomdesc = level:GetRoomByIdx(idx)
					if roomdesc.Data.Type == RoomType.ROOM_TREASURE then
						level:ChangeRoom(idx)
						level.EnterDoor = -1
						level.LeaveDoor = -1
						local room = level:GetCurrentRoom()
						local tl = room:GetTopLeftPos()
						local br = room:GetBottomRightPos()
						for i = 0, 4 do
							local d = room:GetDoor(i)
							if d then
								if d.TargetRoomType == RoomType.ROOM_DEFAULT then
									p.Position = d.Position + Vector(0, -30):Rotated(90*(d.Direction-1))
									break
								end
							end
						end
						data.treasureport = false
					end
				end
			end
			if data.treasureport and (roomtype == RoomType.ROOM_BOSS or roomtype == RoomType.ROOM_DEVIL or roomtype == RoomType.ROOM_ANGEL) then
				data.treasureport = nil
			end

			if p:HasCollectible(CollectibleType.COLLECTIBLE_COOL_SUNGLASSES) and not room:IsClear() then
				local p1 = Isaac.GetPlayer(0)
				local coins = p1:GetNumCoins()
				local coinstostrew = 0
				--adding some no pickup cap compat
				if PickupCapCoinNum then
					coinstostrew = (humbled and (PickupCapCoinNum >= 6 and 6 or (PickupCapCoinNum % 2 == 0 and PickupCapCoinNum or PickupCapCoinNum - 1)) or (PickupCapCoinNum >= 3 and 3 or PickupCapCoinNum))
					PickupCapCoinNum = PickupCapCoinNum - coinstostrew
				else
					coinstostrew = (humbled and (coins >= 6 and 6 or (coins % 2 == 0 and coins or coins - 1)) or (coins >= 3 and 3 or coins))
					p1:AddCoins(-coinstostrew)
				end

				for i = 1, (humbled and coinstostrew/2 or coinstostrew) do
					local subSpawn = 1
					if humbled then subSpawn = 4 end
					Isaac.Spawn(5, 20, subSpawn, room:FindFreePickupSpawnPosition(Isaac.GetRandomPosition(), 40, true), nilvector, nil)
				end
			end
		end
	end
	for _, d in pairs(Isaac.FindByType(3, FamiliarVariant.DICE_BAG, -1, false, false)) do
		d:GetData().roomcompleted = room:IsClear()
	end

	for _, f in pairs(Isaac.FindByType(3, FamiliarVariant.BABY_CRATER, -1, false, false)) do
		f:GetSprite():Play("Walk")
		f:GetData().tears = 0
	end

	for _, h in pairs(Isaac.FindByType(5, PickupVariant.PICKUP_FIEND_MINION, -1, false, false)) do
		local hdata = h:GetData()
		if hdata.mixPersistent and hdata.mixRemainingRooms >= 0 then
			if h.Parent then
				h.Position = h.Parent.Position + Vector(1 * math.random() - 0.5, 1 * math.random() - 0.5)
			else
				h.Position = Isaac.GetPlayer(0).Position + Vector(1 * math.random() - 0.5, 1 * math.random() - 0.5)
			end
			h.Velocity = nilvector

			if mod.IsActiveRoom() then
				hdata.mixRemainingRooms = hdata.mixRemainingRooms - 1
				if hdata.mixRemainingRooms <= 0 then
					hdata.mixPersistent = nil
					hdata.mixRemainingRooms = nil
					h:ClearEntityFlags(EntityFlag.FLAG_PERSISTENT)
				end
			end
		else
			h:Remove()

			if h.SubType == 10 then
				Isaac.Spawn(5, 10, HeartSubType.HEART_HALF_SOUL, h.Position, nilvector, nil)
			elseif h.SubType == 9 then
				Isaac.Spawn(5, 10, HeartSubType.HEART_SOUL, h.Position, nilvector, nil)
			elseif h.SubType == 8 then
				Isaac.Spawn(5, 10, HeartSubType.HEART_ROTTEN, h.Position, nilvector, nil)
			elseif h.SubType == 7 then
				Isaac.Spawn(5, 10, HeartSubType.HEART_HALF, h.Position, nilvector, nil)
			elseif h.SubType == 6 then
				Isaac.Spawn(5, 10, HeartSubType.HEART_FULL, h.Position, nilvector, nil)
			elseif h.SubType == 5 then
				Isaac.Spawn(5, 10, HeartSubType.HEART_GOLDEN, h.Position, nilvector, nil)
			elseif h.SubType == 4 then
				Isaac.Spawn(5, 10, HeartSubType.HEART_ETERNAL, h.Position, nilvector, nil)
			elseif h.SubType == 3 then
				Isaac.Spawn(5, PickupVariant.PICKUP_HALF_IMMORAL_HEART, 0, h.Position, nilvector, nil)
			elseif h.SubType == 2 then
				Isaac.Spawn(5, PickupVariant.PICKUP_IMMORAL_HEART, 0, h.Position, nilvector, nil)
			else
				Isaac.Spawn(5, 10, 6, h.Position, nilvector, nil)
			end
		end
	end
	for _, h in pairs(Isaac.FindByType(1000, 1736, -1, false, false)) do
		local hdata = h:GetData()
		if hdata.mixPersistent and hdata.mixRemainingRooms >= 0 then
			if h.Parent then
				h.Position = h.Parent.Position + Vector(1 * math.random() - 0.5, 1 * math.random() - 0.5)
			else
				h.Position = Isaac.GetPlayer(0).Position + Vector(1 * math.random() - 0.5, 1 * math.random() - 0.5)
			end
			h.Velocity = nilvector

			if mod.IsActiveRoom() then
				hdata.mixRemainingRooms = hdata.mixRemainingRooms - 1
				if hdata.mixRemainingRooms <= 0 then
					hdata.mixPersistent = nil
					hdata.mixRemainingRooms = nil
					h:ClearEntityFlags(EntityFlag.FLAG_PERSISTENT)
				end
			end
		end
	end
end

function mod.IsActiveRoom(roomtype)
	local room = Game():GetRoom()
	return room:IsAmbushActive() or not room:IsClear()
end

FiendFolio.Vessels = {
	TrinketType.TRINKET_EXTRA_VESSEL,
	TrinketType.TRINKET_HALF_VESSEL,
	TrinketType.TRINKET_FULL_VESSEL
}

for i, trink in ipairs(FiendFolio.Vessels) do
	FiendFolio.AddTrinketPickupCallback(nil, nil, trink, function(player)
		player:AddMaxHearts(2)
		player:AddHearts(i - 1)
	end)
end

FiendFolio.RockVessels = {
	FiendFolio.ITEM.ROCK.VESSEL_ROCK,
	FiendFolio.ITEM.ROCK.HALF_VESSEL_ROCK,
	FiendFolio.ITEM.ROCK.FULL_VESSEL_ROCK
}

for i, trink in ipairs(FiendFolio.RockVessels) do
	FiendFolio.AddTrinketPickupCallback(nil, nil, trink, function(player)
		player:AddMaxHearts(2)
		player:AddHearts(i - 1)
	end)
end

-- returns spill-over amount, false if no trinket change happened, and nil if there are no trinkets
-- if a player ever has more than one of these trinkets, it will break
function FiendFolio.HandleVesselTrinketChange(player, amount)
	for idx, checking in ipairs(FiendFolio.Vessels) do
		local slot = FiendFolio.GetTrinketSlot(player, checking)
		if slot >= 0 then
			local ret = 0 -- normal processing

			local newidx = math.ceil(idx + amount)
			if newidx < 1 then
				ret = newidx - 1 -- went below vessel
				newidx = 1
			end
			local len = #FiendFolio.Vessels
			if newidx > len then
				ret = newidx - len -- went above vessel
				newidx = len
			end

			local newtrink = FiendFolio.Vessels[newidx]
			if newtrink ~= checking then
				player:TryRemoveTrinket(checking)
				player:AddTrinket(newtrink)
				return ret
			end

			return false
		end
	end
end

--For Vessel Rock
function FiendFolio.HandleVesselTrinketChange2(player, amount)
	for idx, checking in ipairs(FiendFolio.RockVessels) do
		local slot = FiendFolio.GetTrinketSlot(player, checking)

		if slot >= 0 then
			local ret = 0 -- normal processing

			local newidx = math.ceil(idx + amount)
			if newidx < 1 then
				player:TryRemoveTrinket(checking)
				sfx:Play(SoundEffect.SOUND_ROCK_CRUMBLE, 1, 0, false, 1)
				for i=1,3 do
					local gibs = Isaac.Spawn(1000, 35, 0, player.Position, RandomVector():Resized(math.random(10,20)/6), player):ToEffect()
					gibs.Color = mod.ColorRockGibs
					gibs:Update()
					local smoke = Isaac.Spawn(1000, EffectVariant.DUST_CLOUD, 0, player.Position, RandomVector()*3, player):ToEffect()
					smoke:SetTimeout(15)
					smoke.SpriteScale = Vector(0.05,0.05)
				end
				player:AddTrinket(FiendFolio.ITEM.ROCK.POCKET_SAND)
				return 0
			end
			local len = #FiendFolio.RockVessels
			if newidx > len then
				ret = newidx - len -- went above vessel
				newidx = len
			end

			local newtrink = FiendFolio.RockVessels[newidx]
			if newtrink ~= checking then
				player:TryRemoveTrinket(checking)
				player:AddTrinket(newtrink)
				return ret
			end

			return false
		end
	end
end

mod:AddCallback(ModCallbacks.MC_PRE_PLAYER_COLLISION, function(_, player, collider, low)
	player = player:ToPlayer()
	if collider.Type == 9 and collider:GetData().projType then
		if collider:GetData().projType == "killerNeedle" then
			player:Kill()
			for i = 36, 360, 36 do
				local proj = Isaac.Spawn(9, 0, 0, player.Position + Vector(0,9):Rotated(i), Vector(0,9):Rotated(i), player):ToProjectile();
				local psprite = proj:GetSprite()
				psprite:ReplaceSpritesheet(0, "gfx/needle_tears.png")
				psprite:LoadGraphics()
				proj:GetData().projType = "killerNeedle"
				proj:Update()
			end
		end
	elseif collider.Type == 4 and collider.Variant == 13 and collider.SubType == 114 then
		if not collider:GetData().pickedUp and not player:IsHoldingItem() then
			--[[if collider.PositionOffset.Y < 30 then
				player:TryHoldEntity(collider)
				sfx:Play(SoundEffect.SOUND_FETUS_FEET, 1, 0, false, 1)
				collider:GetData().pickedUp = true
				collider.EntityCollisionClass = EntityCollisionClass.ENTCOLL_ALL
			end]]
			player:TryHoldEntity(collider)
			sfx:Play(SoundEffect.SOUND_FETUS_FEET, 1, 0, false, 1)
			collider:GetData().pickedUp = true
			collider.EntityCollisionClass = EntityCollisionClass.ENTCOLL_ALL
		end
	end

	mod:erflyPrePlayerCollision(player, collider)

	--KEEP AT End
	local heal = 0
	if collider.Type == EntityType.ENTITY_PICKUP and collider.Variant == PickupVariant.PICKUP_HEART then
		collider = collider:ToPickup()
		if collider:GetSprite():IsPlaying("Collect") or collider.Touched then return end

		if collider.SubType == HeartSubType.HEART_FULL or collider.SubType == HeartSubType.HEART_BLENDED
		or collider.SubType == HeartSubType.HEART_SCARED or collider.SubType == HeartSubType.HEART_DOUBLEPACK then
			if not player:CanPickRedHearts() then
				heal = 2
			end
		elseif collider.SubType == HeartSubType.HEART_HALF then
			if not player:CanPickRedHearts() then
				heal = 1
			end
		end
	end

	if heal == 0 then return end

	local spill = FiendFolio.HandleVesselTrinketChange2(player, heal)
	if spill and spill >= 0 then
		collider.Touched = true
		collider.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
		collider.Velocity = nilvector

		sfx:Play(SoundEffect.SOUND_BOSS2_BUBBLES, 1, 0, false, 1)
		collider:GetSprite():Play("Collect")
		FiendFolio.scheduleForUpdate(function()
			collider:Remove()
		end, 5)

		return false
	end

	local spill = FiendFolio.HandleVesselTrinketChange(player, heal)
	if spill and spill >= 0 then
		collider.Touched = true
		collider.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
		collider.Velocity = nilvector

		sfx:Play(SoundEffect.SOUND_BOSS2_BUBBLES, 1, 0, false, 1)
		collider:GetSprite():Play("Collect")
		FiendFolio.scheduleForUpdate(function()
			collider:Remove()
		end, 5)

		return false
	end
end)

mod:AddCallback(ModCallbacks.MC_ENTITY_TAKE_DMG, function(_, entity, amount, flags, src, frames)
	local adjusted = amount

	local player = entity:ToPlayer()
	local data = player:GetData()

	if player:GetPlayerType() == PlayerType.PLAYER_JACOB_B and src.Type == EntityType.ENTITY_DARK_ESAU then
		return
	end

	if flags & DamageFlag.DAMAGE_CURSED_DOOR > 0 then
		data.lastDamageSourceWasCursedDoor = true

		local room = game:GetRoom()
		if room:GetType() == RoomType.ROOM_CURSE then
			mod.TryDireChestConversion(true)
		end
	else
		data.lastDamageSourceWasCursedDoor = false
	end

	--On hit effects

	if player:HasCollectible(CollectibleType.COLLECTIBLE_SPARE_RIBS) then
		if not data.ribsout or data.ribsout <= 0 then
			sfx:Play(SoundEffect.SOUND_BONE_SNAP, 0.6, 0, false, 1)
			local ribs = 6 * player:GetCollectibleNum(CollectibleType.COLLECTIBLE_SPARE_RIBS)
			data.ribsout = ribs
			for i = 1, ribs do
				local tear = player:FireTear(player.Position, Vector(11, 0):Rotated(i * 360/ribs), false, true, false):ToTear()
				tear.TearFlags = TearFlags.TEAR_PIERCING | TearFlags.TEAR_SPECTRAL
				tear.FallingAcceleration = 0
				tear.FallingAcceleration = 0
				tear:GetData().isrib = true
				--tear:GetSprite():Load("gfx/projectiles/boomerang rib.anm2", true)
				--tear:GetSprite():Play("friendly", true)
				mod:changeTearVariant(tear, TearVariant.BOOMERANG_RIB)
			end
		end
	end

	local spill = FiendFolio.HandleVesselTrinketChange(player, -adjusted)
	if spill then
		adjusted = spill
		-- TODO remove when below applies
		player:UseActiveItem(486, false, false, true, false)
		player:SetMinDamageCooldown(60 * amount)
		return false
	end

	local spill = FiendFolio.HandleVesselTrinketChange2(player, -adjusted)
	if spill then
		adjusted = spill
		player:UseActiveItem(486, false, false, true, false)
		player:SetMinDamageCooldown(60 * amount)
		return false
	end

	if mod.WillDamageBeFatal(player, amount, flags) then
		if mod.CanPlayerReviveWithFrogPuppet(player) then
			mod.DoFrogPuppetRevive(player)
		elseif mod.CanPlayerReviveWithCursedUrn(player) then
			mod.DoCursedUrnRevive(player)
		end
	end

	-- TODO use this instead once the API sucks less and lets us change damage amount
	--if adjusted ~= amount then
	--    player:TakeDamage(adjusted, flags, src, frames)
	--    return false
	--end

	--Merged with custom health handling
	--[[local souls = player:GetSoulHearts()
	local blacks = 0
	local CurrentSoulHeart = 0
	for i = 0, souls - 1 do
		if not player:IsBoneHeart(i) then
			if player:IsBlackHeart(CurrentSoulHeart + 1) then
				if souls - CurrentSoulHeart >= 2 then
					blacks = blacks + 2
				elseif souls - CurrentSoulHeart == 1 then
					blacks = blacks + 1
				end
			end
			CurrentSoulHeart = CurrentSoulHeart + 2
		end
	end

	local friendlyfire = Isaac.GetItemIdByName("Friendly Fire")
	local heartburn = friendlyfire and friendlyfire > 0 and player:HasCollectible(friendlyfire)

	if NoHealthCapModEnabled and mod.IsActiveRoom() and not fiendconfig.ImpBabyMode and not (heartburn and flags & DamageFlag.DAMAGE_FIRE ~= 0) then
		data.fiendtakedamage = true
	end

	if flags & DamageFlag.DAMAGE_FAKE == 0 and -- Don't trigger the black heart effect on fake damage!!
	player:GetPlayerType() == FiendFolio.PLAYER.FIEND and blacks - adjusted > 0
	and mod.IsActiveRoom()
	and not fiendconfig.ImpBabyMode
	and not (heartburn and flags & DamageFlag.DAMAGE_FIRE ~= 0)
	then
		data.miniontime = adjusted
	end]]--
end, EntityType.ENTITY_PLAYER)

FiendFolio.AddItemPickupCallback(function(player, added)
	if player:HasCollectible(CollectibleType.COLLECTIBLE_THE_DELUXE) then
		player:AddHearts(99)
	else
		player:AddHearts(-2);
		if player:GetHearts() == 0 then
			player:AddHearts(1);
			if player:GetPlayerType() == PlayerType.PLAYER_MAGDALENA_B and player:GetHearts() > 1 then
				player:AddHearts(1 - player:GetHearts())
			end
		end
	end
end, nil, CollectibleType.COLLECTIBLE_BACON_GREASE)

FiendFolio.AddItemPickupCallback(function(player, added)
	local pillcount = player:HasCollectible(CollectibleType.COLLECTIBLE_LITTLE_BAGGY) and 10 or 7
	FiendFolio.QueuePills(player, added * pillcount)
	player.ControlsEnabled = false
	player:GetData().gmofrozen = true
end, nil, CollectibleType.COLLECTIBLE_GMO_CORN)

FiendFolio.AddItemPickupCallback(function(player, added)
	player:AddBoneHearts(added)
end, nil, CollectibleType.COLLECTIBLE_SPARE_RIBS)

FiendFolio.AddItemPickupCallback(function(player, added)
	player:AddRottenHearts(2)
end, nil, CollectibleType.COLLECTIBLE_FRAUDULENT_FUNGUS)

local function getBasegameDamageMultiplier(player)
	local data = player:GetData()
	local sdata = data.ffsavedata
	local effects = player:GetEffects()

	local multi = 1.0
	if effects:GetCollectibleEffectNum(CollectibleType.COLLECTIBLE_MEGA_MUSH) > 0 then
		multi = multi * 4.0
	end
	if player:GetCollectibleNum(CollectibleType.COLLECTIBLE_EVES_MASCARA) > 0 then
		multi = multi * 2.0
	end
	if player:GetCollectibleNum(CollectibleType.COLLECTIBLE_POLYPHEMUS) > 0 and
	   player:GetCollectibleNum(CollectibleType.COLLECTIBLE_20_20) == 0
	then
		multi = multi * 2.0
	end
	if player:GetCollectibleNum(CollectibleType.COLLECTIBLE_SACRED_HEART) > 0 then
		multi = multi * 2.3
	end
	if player:GetCollectibleNum(CollectibleType.COLLECTIBLE_SOY_MILK) > 0 then
		multi = multi * 0.2
	end
	if player:GetCollectibleNum(CollectibleType.COLLECTIBLE_ALMOND_MILK) > 0 then
		multi = multi * 0.3
	end
	if player:GetCollectibleNum(CollectibleType.COLLECTIBLE_IMMACULATE_HEART) > 0 then
		multi = multi * 1.2
	end
	if effects:GetCollectibleEffectNum(CollectibleType.COLLECTIBLE_CROWN_OF_LIGHT) > 0 then
		multi = multi * 2.0
	end
	if player:GetCollectibleNum(CollectibleType.COLLECTIBLE_HAEMOLACRIA) > 0 then
		multi = multi * 1.5
	end
	if player:GetCollectibleNum(CollectibleType.COLLECTIBLE_20_20) > 0 then
		multi = multi * 0.75
	end

	if player:GetCollectibleNum(CollectibleType.COLLECTIBLE_CRICKETS_HEAD) > 0 or
	   player:GetCollectibleNum(CollectibleType.COLLECTIBLE_MAGIC_MUSHROOM) > 0 or
	   (player:GetCollectibleNum(CollectibleType.COLLECTIBLE_BLOOD_OF_THE_MARTYR) > 0 and
		effects:GetCollectibleEffectNum(CollectibleType.COLLECTIBLE_BOOK_OF_BELIAL) > 0)
	then
		multi = multi * 1.5
	end

	if data.FFInBethlehemAura and data.FFInBethlehemAura > 0 then -- Star of Bethlehem
		multi = multi * 1.8
	elseif data.FFInHallowAura and data.FFInHallowAura > 0 then -- Hallowed Ground
		multi = multi * 1.2
	elseif data.FFInHallowDipAura and data.FFInHallowDipAura > 0 then -- Hallowed Ground + Dirty Mind
		multi = multi * 1.2
	end

	multi = multi * (1 + 0.2 * player:GetTrinketMultiplier(TrinketType.TRINKET_CRACKED_CROWN))

	local succubi = Isaac.FindByType(EntityType.ENTITY_FAMILIAR, FamiliarVariant.SUCCUBUS)
	for _, succubus in ipairs(succubi) do
		if (player.Position - succubus.Position):Length() < 100 then
			multi = multi * 1.5
		end
	end

	return multi
end

local function diminishedDamageUp(player)
	local data = player:GetData()
	local sdata = data.ffsavedata
	local effects = player:GetEffects()

	local toBeDiminished = 0

	toBeDiminished = toBeDiminished + effects:GetCollectibleEffectNum(CollectibleType.COLLECTIBLE_RAZOR_BLADE) * 1.2
	toBeDiminished = toBeDiminished + effects:GetCollectibleEffectNum(CollectibleType.COLLECTIBLE_BOOK_OF_BELIAL) * 2.0
	toBeDiminished = toBeDiminished + effects:GetCollectibleEffectNum(CollectibleType.COLLECTIBLE_THE_NAIL) * 2.0
	toBeDiminished = toBeDiminished + effects:GetCollectibleEffectNum(CollectibleType.COLLECTIBLE_GOLDEN_RAZOR) * 1.2
	toBeDiminished = toBeDiminished + math.max(0, effects:GetCollectibleEffectNum(CollectibleType.COLLECTIBLE_SULFUR) +
												  player:GetCollectibleNum(CollectibleType.COLLECTIBLE_BRIMSTONE) - 1) * 1.8

	toBeDiminished = toBeDiminished + player:GetCollectibleNum(CollectibleType.COLLECTIBLE_ABADDON) * 1.5
	toBeDiminished = toBeDiminished + player:GetCollectibleNum(CollectibleType.COLLECTIBLE_CAPRICORN) * 0.5
	toBeDiminished = toBeDiminished + player:GetCollectibleNum(CollectibleType.COLLECTIBLE_CAT_O_NINE_TAILS) * 1.0
	toBeDiminished = toBeDiminished + player:GetCollectibleNum(CollectibleType.COLLECTIBLE_CHAMPION_BELT) * 1.0
	toBeDiminished = toBeDiminished + player:GetCollectibleNum(CollectibleType.COLLECTIBLE_CRICKETS_HEAD) * 0.5
	toBeDiminished = toBeDiminished + player:GetCollectibleNum(CollectibleType.COLLECTIBLE_DARK_MATTER) * 1.0
	toBeDiminished = toBeDiminished + player:GetCollectibleNum(CollectibleType.COLLECTIBLE_DEATHS_TOUCH) * 1.5
	toBeDiminished = toBeDiminished + player:GetCollectibleNum(CollectibleType.COLLECTIBLE_GODHEAD) * 0.5
	toBeDiminished = toBeDiminished + player:GetCollectibleNum(CollectibleType.COLLECTIBLE_GROWTH_HORMONES) * 1.0
	toBeDiminished = toBeDiminished + player:GetCollectibleNum(CollectibleType.COLLECTIBLE_GUILLOTINE) * 1.0
	toBeDiminished = toBeDiminished + player:GetCollectibleNum(CollectibleType.COLLECTIBLE_IRON_BAR) * 0.3
	toBeDiminished = toBeDiminished + player:GetCollectibleNum(CollectibleType.COLLECTIBLE_JESUS_JUICE) * 0.5
	toBeDiminished = toBeDiminished + player:GetCollectibleNum(CollectibleType.COLLECTIBLE_MAGIC_MUSHROOM) * 0.3
	toBeDiminished = toBeDiminished + player:GetCollectibleNum(CollectibleType.COLLECTIBLE_MEAT) * 0.3
	toBeDiminished = toBeDiminished + player:GetCollectibleNum(CollectibleType.COLLECTIBLE_ODD_MUSHROOM_LARGE) * 1.0
	toBeDiminished = toBeDiminished + player:GetCollectibleNum(CollectibleType.COLLECTIBLE_PENTAGRAM) * 1.0
	toBeDiminished = toBeDiminished + player:GetCollectibleNum(CollectibleType.COLLECTIBLE_SMB_SUPER_FAN) * 0.3
	toBeDiminished = toBeDiminished + player:GetCollectibleNum(CollectibleType.COLLECTIBLE_STEVEN) * 1.0
	toBeDiminished = toBeDiminished + player:GetCollectibleNum(CollectibleType.COLLECTIBLE_STIGMATA) * 0.3
	toBeDiminished = toBeDiminished + player:GetCollectibleNum(CollectibleType.COLLECTIBLE_SYNTHOIL) * 1.0
	toBeDiminished = toBeDiminished + player:GetCollectibleNum(CollectibleType.COLLECTIBLE_HALO) * 0.3
	toBeDiminished = toBeDiminished + player:GetCollectibleNum(CollectibleType.COLLECTIBLE_MARK) * 1.0
	toBeDiminished = toBeDiminished + player:GetCollectibleNum(CollectibleType.COLLECTIBLE_PACT) * 0.5
	toBeDiminished = toBeDiminished + (effects:GetCollectibleEffectNum(CollectibleType.COLLECTIBLE_WHORE_OF_BABYLON) ^ 2) * 1.5
	toBeDiminished = toBeDiminished + player:GetCollectibleNum(CollectibleType.COLLECTIBLE_8_INCH_NAILS) * 1.5
	toBeDiminished = toBeDiminished + math.min(effects:GetCollectibleEffectNum(CollectibleType.COLLECTIBLE_LUSTY_BLOOD), 10) * 0.5
	toBeDiminished = toBeDiminished + player:GetCollectibleNum(CollectibleType.COLLECTIBLE_DOG_TOOTH) * 0.3
	toBeDiminished = toBeDiminished + player:GetCollectibleNum(CollectibleType.COLLECTIBLE_HAEMOLACRIA) * 1.0
	toBeDiminished = toBeDiminished + player:GetCollectibleNum(CollectibleType.COLLECTIBLE_SULFURIC_ACID) * 0.3
	toBeDiminished = toBeDiminished + (effects:GetNullEffectNum(NullItemID.ID_BLOOD_OATH) ^ 2) * 0.15
	toBeDiminished = toBeDiminished + player:GetCollectibleNum(CollectibleType.COLLECTIBLE_DOGMA) * 2.0
	toBeDiminished = toBeDiminished + player:GetCollectibleNum(CollectibleType.COLLECTIBLE_EYE_OF_THE_OCCULT) * 1.0
	toBeDiminished = toBeDiminished + player:GetCollectibleNum(CollectibleType.COLLECTIBLE_GLASS_EYE) * 0.75
	toBeDiminished = toBeDiminished + player:GetCollectibleNum(CollectibleType.COLLECTIBLE_MOMS_RING) * 1.0
	toBeDiminished = toBeDiminished + player:GetCollectibleNum(CollectibleType.COLLECTIBLE_SAUSAGE) * 0.5
	toBeDiminished = toBeDiminished + player:GetCollectibleNum(CollectibleType.COLLECTIBLE_STAPLER) * 1.0
	toBeDiminished = toBeDiminished + player:GetCollectibleNum(CollectibleType.COLLECTIBLE_TERRA) * 1.0
	toBeDiminished = toBeDiminished + effects:GetTrinketEffectNum(TrinketType.TRINKET_RED_PATCH) * 1.8
	toBeDiminished = toBeDiminished + effects:GetTrinketEffectNum(TrinketType.TRINKET_SAMSONS_LOCK) * 0.5
	toBeDiminished = toBeDiminished + effects:GetNullEffectNum(49) * 0.5 -- Lazarus revival boost

	local evilTotal = player:GetCollectibleNum(CollectibleType.COLLECTIBLE_ABADDON) +
					  player:GetCollectibleNum(CollectibleType.COLLECTIBLE_BLACK_CANDLE) +
					  player:GetTrinketMultiplier(TrinketType.TRINKET_BLACK_LIPSTICK) +
					  player:GetCollectibleNum(CollectibleType.COLLECTIBLE_CEREMONIAL_ROBES) +
					  player:GetTrinketMultiplier(TrinketType.TRINKET_DAEMONS_TAIL) +
					  player:GetCollectibleNum(CollectibleType.COLLECTIBLE_FALSE_PHD) +
					  player:GetCollectibleNum(CollectibleType.COLLECTIBLE_GOAT_HEAD) +
					  player:GetCollectibleNum(CollectibleType.COLLECTIBLE_MATCH_BOOK) +
					  player:GetCollectibleNum(CollectibleType.COLLECTIBLE_MISSING_PAGE_2) +
					  player:GetCollectibleNum(CollectibleType.COLLECTIBLE_SAFETY_PIN)
	toBeDiminished = toBeDiminished + player:GetTrinketMultiplier(TrinketType.TRINKET_BLACK_FEATHER) * 0.5 * evilTotal

	toBeDiminished = toBeDiminished + ((player:HasCollectible(CollectibleType.COLLECTIBLE_BLOOD_OF_THE_MARTYR) and 1.0) or 0.0)
	toBeDiminished = toBeDiminished + ((player:HasCollectible(CollectibleType.COLLECTIBLE_CEREMONIAL_ROBES) and 1.0) or 0.0)
	toBeDiminished = toBeDiminished + ((player:HasCollectible(CollectibleType.COLLECTIBLE_PROPTOSIS) and 0.5) or 0.0)
	toBeDiminished = toBeDiminished + ((player:HasCollectible(CollectibleType.COLLECTIBLE_SMALL_ROCK) and 1.0) or 0.0)
	toBeDiminished = toBeDiminished + ((player:HasCollectible(CollectibleType.COLLECTIBLE_HEARTBREAK) and (0.25 * player:GetBrokenHearts())) or 0.0)
	toBeDiminished = toBeDiminished + ((player:HasPlayerForm(PlayerForm.PLAYERFORM_BABY) and 0.3) or 0.0)
	toBeDiminished = toBeDiminished + ((player:HasPlayerForm(PlayerForm.PLAYERFORM_DRUGS) and 2.0) or 0.0)
	toBeDiminished = toBeDiminished + ((effects:GetNullEffectNum(NullItemID.ID_BLOODY_BABYLON) > 0 and 1.5) or 0.0)

	local activeItem = player:GetActiveItem(0)
	if activeItem ~= 0 then
		local charge = player:GetBatteryCharge(0)
		local maxCharge = Isaac.GetItemConfig():GetCollectible(activeItem).MaxCharges
		toBeDiminished = toBeDiminished + ((player:HasTrinket(TrinketType.TRINKET_DIM_BULB) and
											maxCharge > 0 and
											charge == 0 and
											1.5) or 0.0)
		toBeDiminished = toBeDiminished + ((player:HasTrinket(TrinketType.TRINKET_VIBRANT_BULB) and
											maxCharge > 0 and
											charge == maxCharge and
											0.5) or 0.0)
	end

	-- Purity (red): +4.0
	-- Binge Eater (temporary): +3.6
	-- False PHD (per stat down pill): +0.6
	-- Red Stew (temporary): +21.6
	-- Redemption: +1.0
	-- Judas Birthright: ???
	-- Camo Undies: ???

	local toBeDiminishedFF = 0

	-- PUT FF STUFF HERE

	toBeDiminishedFF = toBeDiminishedFF + player:GetCollectibleNum(CollectibleType.COLLECTIBLE_GMO_CORN) * 1.0
	toBeDiminishedFF = toBeDiminishedFF + player:GetCollectibleNum(CollectibleType.COLLECTIBLE_FETAL_FIEND) * 1.5
	toBeDiminishedFF = toBeDiminishedFF + player:GetCollectibleNum(CollectibleType.COLLECTIBLE_SMALL_PIPE) * 0.2
	toBeDiminishedFF = toBeDiminishedFF + player:GetCollectibleNum(CollectibleType.COLLECTIBLE_SMALL_WOOD) * 0.2
	toBeDiminishedFF = toBeDiminishedFF + player:GetCollectibleNum(CollectibleType.COLLECTIBLE_FRAUDULENT_FUNGUS) * 0.3
	toBeDiminishedFF = toBeDiminishedFF + player:GetCollectibleNum(CollectibleType.COLLECTIBLE_GRIDDLED_CORN) * 0.3
	toBeDiminishedFF = toBeDiminishedFF + player:GetCollectibleNum(mod.ITEM.COLLECTIBLE.STRANGE_RED_OBJECT) * 0.3
	toBeDiminishedFF = toBeDiminishedFF + player:GetCollectibleNum(mod.ITEM.COLLECTIBLE.HOST_ON_TOAST) * 0.5
	toBeDiminishedFF = toBeDiminishedFF + player:GetCollectibleNum(mod.ITEM.COLLECTIBLE.SMASH_TROPHY) * 1
	toBeDiminishedFF = toBeDiminishedFF + (data.dichromaticgraze or 0) * 0.2
	toBeDiminishedFF = toBeDiminishedFF + math.min((sdata.CursedPennyStats or 0) * 0.05, 10)
	toBeDiminishedFF = toBeDiminishedFF + player:GetTrinketMultiplier(FiendFolio.ITEM.TRINKET.LOCKED_SHACKLE) * 1
	toBeDiminishedFF = toBeDiminishedFF + (player:GetData().belialD122 or 0)
	toBeDiminishedFF = toBeDiminishedFF + (player:GetData().insatiableApatiteStrength or 0)
	toBeDiminishedFF = toBeDiminishedFF + (player:GetData().prismaticGeodeDamageBoost or 0)
	toBeDiminishedFF = toBeDiminishedFF + (sdata.heartShardOfChinaDamage or 0)
	if player:GetData().prismaticGeodeRainbowTimer then
		local geode = 1
		if mod.HasTwoGeodes(player) then
			geode = 2
		end
		toBeDiminishedFF = toBeDiminishedFF + 0.3*geode
	end
	if player:HasTrinket(FiendFolio.ITEM.ROCK.SMALLER_ROCK) and player:GetData().ffsavedata.RunEffects.smallerRockCount then
		toBeDiminishedFF = toBeDiminishedFF+0.33*player:GetData().ffsavedata.RunEffects.smallerRockCount
	end

	local ffEvilTotal = player:GetCollectibleNum(CollectibleType.COLLECTIBLE_BLACK_LANTERN) +
						player:GetCollectibleNum(mod.ITEM.COLLECTIBLE.EVIL_STICKER)
	toBeDiminishedFF = toBeDiminishedFF + player:GetTrinketMultiplier(TrinketType.TRINKET_BLACK_FEATHER) * 0.5 * ffEvilTotal

	toBeDiminishedFF = toBeDiminishedFF + ((sdata.alphacoinchallenge and 0.5) or 0.0)
	toBeDiminishedFF = toBeDiminishedFF + ((player:HasCollectible(CollectibleType.COLLECTIBLE_CHIRUMIRU) and 0.9) or 0.0)
	toBeDiminishedFF = toBeDiminishedFF + ((player:HasCollectible(CollectibleType.COLLECTIBLE_THE_DELUXE) and
											player:GetCollectibleNum(CollectibleType.COLLECTIBLE_MEAT) * 0.3) or 0.0)
	
	if sdata.RunEffects then
		toBeDiminishedFF = toBeDiminishedFF + mod.golemDiminishingDamage(player)
	end

	-- END OF FF STUFF

	player:GetData().FFLastDiminishedDamage = toBeDiminishedFF

	toBeDiminishedFF = toBeDiminishedFF + toBeDiminished

	if player:HasCollectible(CollectibleType.COLLECTIBLE_ODD_MUSHROOM_THIN) then
		toBeDiminished = toBeDiminished * 0.9 - 0.4
		toBeDiminishedFF = toBeDiminishedFF * 0.9 - 0.4
	end

	local diminished = 3.50 * math.sqrt(toBeDiminished * 1.2 + 1)
	local diminishedFF = 3.50 * math.sqrt(toBeDiminishedFF * 1.2 + 1)

	local damage = diminishedFF - diminished

	local playerType = player:GetPlayerType()
	if (playerType == PlayerType.PLAYER_EVE and effects:GetCollectibleEffectNum(CollectibleType.COLLECTIBLE_WHORE_OF_BABYLON) == 0) or
	   playerType == PlayerType.PLAYER_MAGDALENE_B
	then
		damage = damage * 0.75
	end

	if playerType == PlayerType.PLAYER_BLUEBABY then
		damage = damage * 1.05
	end

	if playerType == PlayerType.PLAYER_CAIN or
	   playerType == PlayerType.PLAYER_KEEPER or
	   (playerType == PlayerType.PLAYER_EVE_B and effects:GetNullEffectNum(NullItemID.ID_BLOODY_BABYLON) == 0)
	then
		damage = damage * 1.20
	end

	if playerType == PlayerType.PLAYER_JUDAS then
		damage = damage * 1.35
	end

	if playerType == PlayerType.PLAYER_BLACKJUDAS then
		damage = damage * 2.00
	end

	if playerType == PlayerType.PLAYER_AZAZEL or
	   playerType == PlayerType.PLAYER_THEFORGOTTEN or
	   playerType == PlayerType.PLAYER_AZAZEL_B or
	   playerType == PlayerType.PLAYER_LAZARUS2_B or
	   playerType == PlayerType.PLAYER_THEFORGOTTEN_B
	then
		damage = damage * 1.50
	end

	if playerType == PlayerType.PLAYER_THELOST_B then
		damage = damage * 1.30
	end

	if playerType == PlayerType.PLAYER_LAZARUS2 then
		damage = damage * 1.40
	end

	damage = damage * getBasegameDamageMultiplier(player)

	-- Eden: ???
	-- D8: ???
	-- Dead Eye: ???

	-- co-op babies go in here somewhere lol

	player.Damage = player.Damage + damage
end

local function tearsUp(firedelay, val)
	local currentTears = 30 / (firedelay + 1)
	local newTears = currentTears + val
	return math.max((30 / newTears) - 1, -0.99)
end

mod.FamiliarsToBeEvaluated = {
	{mod.ITEM.COLLECTIBLE.DICE_BAG, mod.ITEM.FAMILIAR.DICE_BAG},
	{mod.ITEM.COLLECTIBLE.LIL_FIEND, mod.ITEM.FAMILIAR.LIL_FIEND},
	{mod.ITEM.COLLECTIBLE.BABY_CRATER, mod.ITEM.FAMILIAR.BABY_CRATER},
	{mod.ITEM.COLLECTIBLE.MAMA_SPOOTER, mod.ITEM.FAMILIAR.MAMA_SPOOTER},
	{mod.ITEM.COLLECTIBLE.RANDY_THE_SNAIL, mod.ITEM.FAMILIAR.RANDY_THE_SNAIL},
	{mod.ITEM.COLLECTIBLE.PEACH_CREEP, mod.ITEM.FAMILIAR.PEACH_CREEP},
	{mod.ITEM.COLLECTIBLE.GORGON, mod.ITEM.FAMILIAR.GORGON},
	{mod.ITEM.COLLECTIBLE.DEIMOS, mod.ITEM.FAMILIAR.DEIMOS},
	{mod.ITEM.COLLECTIBLE.PET_ROCK, mod.ITEM.FAMILIAR.PETROCK},
	{mod.ITEM.COLLECTIBLE.LIL_MINX, mod.ITEM.FAMILIAR.LIL_MINX},
	{mod.ITEM.COLLECTIBLE.LIL_LAMB, mod.ITEM.FAMILIAR.LIL_LAMB},
	{mod.ITEM.COLLECTIBLE.SIBLING_SYL, mod.ITEM.FAMILIAR.SIBLING_SYL},
	{mod.ITEM.COLLECTIBLE.GREG_THE_EGG, mod.ITEM.FAMILIAR.GREG},
	{mod.ITEM.COLLECTIBLE.FAMILIAR_FLY, mod.ITEM.FAMILIAR.ORANGE_BOOM_FLY},
	{mod.ITEM.COLLECTIBLE.WIMPY_BRO, mod.ITEM.FAMILIAR.WIMPY_BRO},
	{mod.ITEM.COLLECTIBLE.ROBOBABY3, mod.ITEM.FAMILIAR.ROBOBABY3},
	{mod.ITEM.COLLECTIBLE.D3, mod.ITEM.FAMILIAR.D3},
	{mod.ITEM.COLLECTIBLE.SACK_OF_SPICY, mod.ITEM.FAMILIAR.SACK_OF_SPICY},
	{mod.ITEM.COLLECTIBLE.CLUTCHS_CURSE, mod.ITEM.FAMILIAR.CLUTCHS_CURSE},
	{mod.ITEM.COLLECTIBLE.PET_PEEVE, mod.ITEM.FAMILIAR.PET_PEEVE},
	{mod.ITEM.COLLECTIBLE.BAG_OF_BOBBIES, mod.ITEM.FAMILIAR.BAG_OF_BOBBIES},
}

function mod.GetExpectedFamiliarNum(player, item)
  return player:GetCollectibleNum(item) + player:GetEffects():GetCollectibleEffectNum(item)
end

mod:AddCallback(ModCallbacks.MC_EVALUATE_CACHE, function(_, player, flag)
--IF THIS ERRORS IT MEANS SOMETHING'S CALLING EVALUATE CACHE WAY TOO EARLY, SOMETIMES FROM ANOTHER MOD
	local basedata = player:GetData()
	local data = basedata.ffsavedata
	if not data then
		Isaac.DebugString("Something called evaluate cache way too early")
		return
	end

	if flag == CacheFlag.CACHE_FAMILIARS then
		local itemconfig = Isaac.GetItemConfig()

		for i = 1, #mod.FamiliarsToBeEvaluated do
			player:CheckFamiliar(mod.FamiliarsToBeEvaluated[i][2], mod.GetExpectedFamiliarNum(player, mod.FamiliarsToBeEvaluated[i][1]), player:GetCollectibleRNG(mod.FamiliarsToBeEvaluated[i][1]), itemconfig:GetCollectible(mod.FamiliarsToBeEvaluated[i][1]))
		end

		--because blaz birthright these need subtypes to flicker properly
		player:CheckFamiliar(mod.ITEM.FAMILIAR.OPHIUCHUS,
							 mod.GetExpectedFamiliarNum(player, mod.ITEM.COLLECTIBLE.OPHIUCHUS),
							 player:GetCollectibleRNG(mod.ITEM.COLLECTIBLE.OPHIUCHUS),
							 nil,
							 0)

		local numGrabber = mod.GetExpectedFamiliarNum(player, mod.ITEM.COLLECTIBLE.GRABBER)
		if Isaac.GetChallenge() == mod.challenges.handsOn then
			local numZero = 0
			local numTen = 0
			local numEleven = 0

			while numZero + numTen + numEleven < numGrabber do
				local sum = numZero + numTen + numEleven
				if sum % 3 == 0 then
					numZero = numZero + 1
				elseif sum % 3 == 1 then
					numTen = numTen + 1
				elseif sum % 3 == 2 then
					numEleven = numEleven + 1
				end
			end

			player:CheckFamiliar(mod.ITEM.FAMILIAR.GRABBER,
								 numZero,
								 player:GetCollectibleRNG(mod.ITEM.COLLECTIBLE.GRABBER),
								 nil,
								 0)

			player:CheckFamiliar(mod.ITEM.FAMILIAR.GRABBER,
								 numTen,
								 player:GetCollectibleRNG(mod.ITEM.COLLECTIBLE.GRABBER),
								 nil,
								 10)

			player:CheckFamiliar(mod.ITEM.FAMILIAR.GRABBER,
								 numEleven,
								 player:GetCollectibleRNG(mod.ITEM.COLLECTIBLE.GRABBER),
								 nil,
								 11)
		else
			player:CheckFamiliar(mod.ITEM.FAMILIAR.GRABBER,
								 numGrabber,
								 player:GetCollectibleRNG(mod.ITEM.COLLECTIBLE.GRABBER),
								 nil,
								 0)
		end

		if data and data.orbitingfireballs ~= nil then
			player:CheckFamiliar(mod.ITEM.FAMILIAR.FIEND_ORBITING_FIREBALL, data.orbitingfireballs, grng)
		end
		--[[if data and data.bobbyBagSpawnCount ~= nil then
			player:CheckFamiliar(mod.ITEM.FAMILIAR.FRAGILE_BOBBY, data.bobbyBagSpawnCount, grng)
		end]]
		if basedata.KeyGhostData ~= nil then
			for variant, collectedKeys in pairs(basedata.KeyGhostData) do
				player:CheckFamiliar(variant, #collectedKeys, grng)
			end
		end
		if data and data.MorbidChunks ~= nil then
			local morbidRNG = player:GetCollectibleRNG(mod.ITEM.COLLECTIBLE.YICK_HEART)
			player:CheckFamiliar(FiendFolio.ITEM.FAMILIAR.MORBID_CHUNK, data.MorbidChunks, morbidRNG)
			morbidRNG:Next()
		end

		local mernCount = mod.GetExpectedFamiliarNum(player, mod.ITEM.COLLECTIBLE.CORN_KERNEL)
		local mernRng = player:GetCollectibleRNG(mod.ITEM.COLLECTIBLE.CORN_KERNEL)

		player:CheckFamiliar(FamiliarVariant.MERN_4, math.floor(mernCount / 4), mernRng)
		for i = 1, 3 do
			local n = mernCount % 4 == i and 1 or 0
			player:CheckFamiliar(FamiliarVariant["MERN_"..i], n, mernRng, itemconfig:GetCollectible(mod.ITEM.COLLECTIBLE.CORN_KERNEL))
		end
	elseif flag == CacheFlag.CACHE_SPEED then
		if basedata.closeenough then
			player.MoveSpeed = player.MoveSpeed + basedata.closeenough
		end
		if player:GetPlayerType() == FiendFolio.PLAYER.FIEND and not fiendconfig.ImpBabyMode then
			player.MoveSpeed = player.MoveSpeed + fiendstats.speed
		end

		if data.alphacoinfloorstats then
			player.MoveSpeed = player.MoveSpeed + (0.2 * data.alphacoinfloorstats)
		end

		player.MoveSpeed = player.MoveSpeed + 0.1 * (data.CursedPennyStats or 0) ^ 0.5

		if player:HasCollectible(CollectibleType.COLLECTIBLE_GOLEMS_ORB) then
			player.MoveSpeed = player.MoveSpeed + 0.2
		end
		if player:HasCollectible(CollectibleType.COLLECTIBLE_LEFTOVER_TAKEOUT) then
			player.MoveSpeed = player.MoveSpeed + 0.3
		end
		if player:HasCollectible(CollectibleType.COLLECTIBLE_BINGE_EATER) and player:HasCollectible(CollectibleType.COLLECTIBLE_TEA) then
			player.MoveSpeed = player.MoveSpeed + (-0.03 * player:GetCollectibleNum(CollectibleType.COLLECTIBLE_TEA))
		end
		if player:HasCollectible(CollectibleType.COLLECTIBLE_SMALL_PIPE) then
			player.MoveSpeed = player.MoveSpeed + (0.2 * player:GetCollectibleNum(CollectibleType.COLLECTIBLE_SMALL_PIPE))
		end
		if player:HasCollectible(CollectibleType.COLLECTIBLE_FRAUDULENT_FUNGUS) then
			player.MoveSpeed = player.MoveSpeed + (0.2 * player:GetCollectibleNum(CollectibleType.COLLECTIBLE_FRAUDULENT_FUNGUS))
		end
		if player:HasCollectible(mod.ITEM.COLLECTIBLE.STRANGE_RED_OBJECT) then
			player.MoveSpeed = player.MoveSpeed + (0.05 * player:GetCollectibleNum(mod.ITEM.COLLECTIBLE.STRANGE_RED_OBJECT))
		end
		if data.RunEffects and data.RunEffects.DeathCapFossilBoost then
			player.MoveSpeed = player.MoveSpeed + 0.04*data.RunEffects.DeathCapFossilBoost
		end
		if basedata.smokyQuartzSpeed then
			player.MoveSpeed = player.MoveSpeed + basedata.smokyQuartzSpeed
		end
		if basedata.prismaticGeodeSpeedTimer then
			player.MoveSpeed = player.MoveSpeed + basedata.prismaticGeodeSpeedBoost
		end
		if basedata.prismaticGeodeRainbowTimer then
			local geode = 1
			if mod.HasTwoGeodes(player) then
				geode = 2
			end
			player.MoveSpeed = player.MoveSpeed + 0.15*geode
		end
		if player:HasTrinket(FiendFolio.ITEM.ROCK.HEAVY_METAL) then
			player.MoveSpeed = player.MoveSpeed-0.15
		end
		if player:HasTrinket(FiendFolio.ITEM.ROCK.SMALLER_ROCK) and data.RunEffects.smallerRockCount then
			player.MoveSpeed = player.MoveSpeed-0.06*data.RunEffects.smallerRockCount
		end
		if player:HasTrinket(FiendFolio.ITEM.ROCK.NITRO_CRYSTAL) then
			if basedata.nitroCrystalStatBoost then
				player.MoveSpeed = player.MoveSpeed + math.log(basedata.nitroCrystalStatBoost, 10)/5
			end
		end
		if player:HasCollectible(FiendFolio.ITEM.COLLECTIBLE.ANGELIC_LYRE_B) or (player:HasCollectible(CollectibleType.COLLECTIBLE_VOID) and data.VoidedLyre == 1) then
			player.MoveSpeed = player.MoveSpeed + mod.AngelicLyreStats.Blue.Speed
		end
		if data.Cyanide then
			player.MoveSpeed = player.MoveSpeed + (0.05 * data.Cyanide.Strength)
		end
	elseif flag == CacheFlag.CACHE_DAMAGE then
		local basemulti = getBasegameDamageMultiplier(player)

		-- diminishing returns damage
		diminishedDamageUp(player)

		-- pre multipliers flat damage (multiply by basemulti)
		if player:HasCollectible(CollectibleType.COLLECTIBLE_COMMUNITY_ACHIEVEMENT) then
			player.Damage = player.Damage + math.log(FiendFolio.CountingChannelWorldRecords.Canon.Regular * math.log(FiendFolio.CountingChannelWorldRecords.Canon.Hardcore, 10),15) * basemulti
		end
		if basedata.spireGrowth then
			player.Damage = player.Damage + basedata.spireGrowth * basemulti
		end
		if basedata.goldenSlotTempDamage then
			player.Damage = player.Damage * basedata.goldenSlotTempDamage * basemulti
		end

		player.Damage = player.Damage + mod.obsidianGrindStoneDamage(player) * basemulti
		player.Damage = player.Damage + 1.5 * mod.GetSmeltedTrinketMultiplier(player, TrinketType.TRINKET_SHARD_OF_CHINA) * basemulti
		player.Damage = player.Damage + 1.8 * mod.GetSmeltedTrinketMultiplier(player, FiendFolio.ITEM.ROCK.SHARD_OF_GOLEM) * basemulti
		player.Damage = player.Damage + mod.GetActiveShardOfChinaDamage(player) * basemulti

		-- mulipliers
		if player:GetPlayerType() == FiendFolio.PLAYER.FIEND and not fiendconfig.ImpBabyMode then
			player.Damage = player.Damage * fiendstats.damage
		end

		local debt = mod.getField(FiendFolio.savedata, 'run', 'dadsdebt')
		if debt and player:HasCollectible(CollectibleType.COLLECTIBLE_DADS_WALLET) then
			local debtPercent = debt / 99
			player.Damage = player.Damage * mod:Lerp(1, 0.1, debtPercent)
		end

		mod:updateMartyrDamage(player)

		if player:HasCollectible(CollectibleType.COLLECTIBLE_LEFTOVER_TAKEOUT) then
			player.Damage = player.Damage * 1.5
		end
		if player:HasCollectible(CollectibleType.COLLECTIBLE_FIDDLE_CUBE) then
			player:GetData().storedFiddleCubeClicks = player:GetData().storedFiddleCubeClicks or {}
			player.Damage = player.Damage * (1 + (0.1 * math.min(#player:GetData().storedFiddleCubeClicks, 5)))
		end
		if player:HasCollectible(FiendFolio.ITEM.COLLECTIBLE.ANGELIC_LYRE_B) or (player:HasCollectible(CollectibleType.COLLECTIBLE_VOID) and data.VoidedLyre == 1) then

		end
		if player:HasCollectible(FiendFolio.ITEM.COLLECTIBLE.ANGELIC_LYRE_R) or (player:HasCollectible(CollectibleType.COLLECTIBLE_VOID) and data.VoidedLyre == 2) then
			player.Damage = player.Damage * mod.AngelicLyreStats.Red.DamageMult
		end
		if player:HasCollectible(FiendFolio.ITEM.COLLECTIBLE.ANGELIC_LYRE_Y) or (player:HasCollectible(CollectibleType.COLLECTIBLE_VOID) and data.VoidedLyre == 0) then
			player.Damage = player.Damage * mod.AngelicLyreStats.Yellow.DamageMult
		end

		if data.Cyanide then
			player.Damage = player.Damage * (1 + (0.5 * data.Cyanide.Strength))
		end
		
		if basedata.crazyJackpotStats and basedata.crazyJackpotStats.Damage then
			player.Damage = player.Damage * (1.2^basedata.crazyJackpotStats.Damage)
		end

		-- post multipliers flat damage (don't multiply by basemulti)
		player.Damage = player.Damage + mod.curvedGeodeDamage(player)

		if player:HasCollectible(FiendFolio.ITEM.COLLECTIBLE.DEVILS_ABACUS) then
			local sd = data.RunEffects
			if sd.AbacusBuff and sd.AbacusBuff > 0 then
				player.Damage = player.Damage + math.log(1 + sd.AbacusBuff/3)
			end
		end
	elseif flag == CacheFlag.CACHE_FIREDELAY then
		if player:GetPlayerType() == FiendFolio.PLAYER.FIEND and not fiendconfig.ImpBabyMode then
			player.MaxFireDelay = math.floor(player.MaxFireDelay * fiendstats.tears)
		end

		mod:updateDevilledEggFireDelay(player)

		if data.alphacoinfloorstats and player.MaxFireDelay > 2 then
			player.MaxFireDelay = math.max(2, player.MaxFireDelay - math.floor(data.alphacoinfloorstats))
		end
		if basedata.alphacointearsup and player.MaxFireDelay > 1 then
			player.MaxFireDelay = math.floor(player.MaxFireDelay * basedata.alphacointearsmulti)
			player.MaxFireDelay = math.max(1, math.floor(player.MaxFireDelay - basedata.alphacointearsup))
		end

		mod:updateMartyrFireDelay(player)
		mod:updateTheDeluxeFireDelay(player)

		player.MaxFireDelay = player.MaxFireDelay - math.min(math.floor(1 * (data.CursedPennyStats or 0) ^ 0.5), 5)

		if player:HasCollectible(CollectibleType.COLLECTIBLE_LEFTOVER_TAKEOUT) then
			player.MaxFireDelay = math.floor(player.MaxFireDelay * 0.9)
		end
		if player:HasCollectible(CollectibleType.COLLECTIBLE_FIDDLE_CUBE) then
			player:GetData().storedFiddleCubeClicks = player:GetData().storedFiddleCubeClicks or {}
			player.MaxFireDelay = tearsUp(player.MaxFireDelay, 0.2 * math.min(#player:GetData().storedFiddleCubeClicks, 5))
		end
		if player:HasCollectible(CollectibleType.COLLECTIBLE_SMALL_PIPE) then
			player.MaxFireDelay = tearsUp(player.MaxFireDelay, (0.2 * player:GetCollectibleNum(CollectibleType.COLLECTIBLE_SMALL_PIPE)))
		end
		if player:HasCollectible(CollectibleType.COLLECTIBLE_SMALL_WOOD) then
			player.MaxFireDelay = tearsUp(player.MaxFireDelay, (1 * player:GetCollectibleNum(CollectibleType.COLLECTIBLE_SMALL_WOOD)))
		end
		if mod.HasTrinityWorm(player) then
			player.MaxFireDelay = tearsUp(player.MaxFireDelay, (0.4 * mod.GetTrinityWormMultiplier(player)))
		end
		if data.RunEffects.DeathCapFossilBoost then
			local tearCap = (player.MaxFireDelay < 5 and player.MaxFireDelay) or 5
			player.MaxFireDelay = math.max(tearCap, player.MaxFireDelay - 0.28*data.RunEffects.DeathCapFossilBoost)
		end
		if player:HasTrinket(FiendFolio.ITEM.TRINKET.LOCKED_SHACKLE) then
			local mult = player:GetTrinketMultiplier(FiendFolio.ITEM.TRINKET.LOCKED_SHACKLE)
			player.MaxFireDelay = tearsUp(player.MaxFireDelay, (0.35*mult))
		end
		if basedata.prismaticGeodeTearTimer then
			player.MaxFireDelay = tearsUp(player.MaxFireDelay, basedata.prismaticGeodeTearBoost)
		end
		if basedata.prismaticGeodeRainbowTimer then
			local geode = 1
			if mod.HasTwoGeodes(player) then
				geode = 2
			end
			player.MaxFireDelay = tearsUp(player.MaxFireDelay, 0.7*geode)
		end
		if player:HasTrinket(FiendFolio.ITEM.ROCK.NITRO_CRYSTAL) then
			if basedata.nitroCrystalStatBoost then
				player.MaxFireDelay = tearsUp(player.MaxFireDelay, math.log(basedata.nitroCrystalStatBoost, 10)/5)
			end
		end
		if player:HasCollectible(FiendFolio.ITEM.COLLECTIBLE.DEVILS_ABACUS) then
			local sd = data.RunEffects
			if sd.AbacusBuff and sd.AbacusBuff > 0 then
				player.MaxFireDelay = tearsUp(player.MaxFireDelay, math.log(1 + sd.AbacusBuff/3))
			end
		end
		if player:HasCollectible(FiendFolio.ITEM.COLLECTIBLE.ANGELIC_LYRE_B) or (player:HasCollectible(CollectibleType.COLLECTIBLE_VOID) and data.VoidedLyre == 1) then
			player.MaxFireDelay = player.MaxFireDelay * mod.AngelicLyreStats.Blue.TearMult
		end
		if player:HasCollectible(FiendFolio.ITEM.COLLECTIBLE.ANGELIC_LYRE_R) or (player:HasCollectible(CollectibleType.COLLECTIBLE_VOID) and data.VoidedLyre == 2) then
			player.MaxFireDelay = player.MaxFireDelay * mod.AngelicLyreStats.Red.TearMult
		end
		if player:HasCollectible(FiendFolio.ITEM.COLLECTIBLE.ANGELIC_LYRE_Y) or (player:HasCollectible(CollectibleType.COLLECTIBLE_VOID) and data.VoidedLyre == 0) then
			player.MaxFireDelay = player.MaxFireDelay * mod.AngelicLyreStats.Yellow.TearMult
		end

		if data.Cyanide then
			player.MaxFireDelay = player.MaxFireDelay / (1 + (0.5 * data.Cyanide.Strength))
		end

		if basedata.crazyJackpotStats and basedata.crazyJackpotStats.Tears then
			player.MaxFireDelay = player.MaxFireDelay / (1.2^basedata.crazyJackpotStats.Tears)
		end
		if basedata.rapidFireOpalAmmo then
			local strength = FiendFolio.GetGolemTrinketPower(player, FiendFolio.ITEM.ROCK.FRIENDLY_RAPID_FIRE_OPAL)
			player.MaxFireDelay = player.MaxFireDelay * 0.5
		end
	elseif flag == CacheFlag.CACHE_RANGE then
		mod:updateModelRocketRange(player)

		--player.TearHeight = player.TearHeight - 2 * (data.CursedPennyStats or 0)
		player.TearRange = player.TearRange + 20 * (data.CursedPennyStats or 0)

		if player:HasCollectible(CollectibleType.COLLECTIBLE_BINGE_EATER) and player:HasCollectible(CollectibleType.COLLECTIBLE_TEA) then
			player.TearRange = player.TearRange + (60 * player:GetCollectibleNum(CollectibleType.COLLECTIBLE_TEA))
		end
		if player:HasCollectible(CollectibleType.COLLECTIBLE_LEFTOVER_TAKEOUT) then
			player.TearRange = player.TearRange + 60
		end
		if player:HasCollectible(CollectibleType.COLLECTIBLE_FRAUDULENT_FUNGUS) then
			player.TearRange = player.TearRange + (15 * player:GetCollectibleNum(CollectibleType.COLLECTIBLE_FRAUDULENT_FUNGUS))
		end
		if mod.HasTrinityWorm(player) then
			player.TearRange = player.TearRange + (500 * mod.GetTrinityWormMultiplier(player))
		end
		if data.RunEffects and data.RunEffects.DeathCapFossilBoost then
			player.TearRange = player.TearRange + 5*data.RunEffects.DeathCapFossilBoost
		end
		if player:HasTrinket(FiendFolio.ITEM.TRINKET.LOCKED_SHACKLE) then
			local mult = player:GetTrinketMultiplier(FiendFolio.ITEM.TRINKET.LOCKED_SHACKLE)
			player.TearRange = player.TearRange + 40*mult
		end
		if basedata.prismaticGeodeRangeTimer then
			player.TearRange = player.TearRange + basedata.prismaticGeodeRangeBoost
		end
		if basedata.prismaticGeodeRainbowTimer then
			local geode = 1
			if mod.HasTwoGeodes(player) then
				geode = 2
			end
			player.TearRange = player.TearRange + 30*geode
		end
		if player:HasCollectible(FiendFolio.ITEM.COLLECTIBLE.ANGELIC_LYRE_Y) or (player:HasCollectible(CollectibleType.COLLECTIBLE_VOID) and data.VoidedLyre == 0) then
			player.TearRange = player.TearRange + mod.AngelicLyreStats.Yellow.Range
		end
		if data.Cyanide then
			player.TearRange = player.TearRange + (25 * data.Cyanide.Strength)
		end
		if player:HasCollectible(FiendFolio.ITEM.COLLECTIBLE.MOMS_STOCKINGS) then
			player.TearRange = player.TearRange + (90 * player:GetCollectibleNum(FiendFolio.ITEM.COLLECTIBLE.MOMS_STOCKINGS))
		end
		if basedata.rapidFireOpalAmmo then
			local strength = FiendFolio.GetGolemTrinketPower(player, FiendFolio.ITEM.ROCK.FRIENDLY_RAPID_FIRE_OPAL)
			player.TearRange = player.TearRange + (250 * strength)
		end
		if player:HasCollectible(FiendFolio.ITEM.COLLECTIBLE.HOST_ON_TOAST) then
			player.TearRange = player.TearRange + (15 * player:GetCollectibleNum(mod.ITEM.COLLECTIBLE.HOST_ON_TOAST))
		end
	elseif flag == CacheFlag.CACHE_SHOTSPEED then
		if player:GetPlayerType() == FiendFolio.PLAYER.FIEND and not fiendconfig.ImpBabyMode then
			player.ShotSpeed = player.ShotSpeed + fiendstats.shotspeed
		end
		if player:HasTrinket(TrinketType.TRINKET_FORTUNE_WORM) then
			local factor = 1 + 0.5 * (player:GetTrinketMultiplier(TrinketType.TRINKET_FORTUNE_WORM) - 1)
			player.ShotSpeed = player.ShotSpeed + 0.2 * factor
		end

		player.ShotSpeed = player.ShotSpeed + 0.4 * (data.CursedPennyStats or 0) ^ 0.5 -- >:)

		if player:HasCollectible(CollectibleType.COLLECTIBLE_GOLEMS_ORB) then
			player.ShotSpeed = player.ShotSpeed + (0.23 * player:GetCollectibleNum(CollectibleType.COLLECTIBLE_GOLEMS_ORB))
		end
		if player:HasCollectible(CollectibleType.COLLECTIBLE_BACON_GREASE) then
			player.ShotSpeed = player.ShotSpeed + (0.15 * player:GetCollectibleNum(CollectibleType.COLLECTIBLE_BACON_GREASE))
		end
		if player:HasCollectible(CollectibleType.COLLECTIBLE_SMALL_PIPE) then
			player.ShotSpeed = player.ShotSpeed + (0.2 * player:GetCollectibleNum(CollectibleType.COLLECTIBLE_SMALL_PIPE))
		end
		if player:HasCollectible(CollectibleType.COLLECTIBLE_SMALL_WOOD) then
			player.ShotSpeed = player.ShotSpeed - (0.2 * player:GetCollectibleNum(CollectibleType.COLLECTIBLE_SMALL_WOOD))
		end
		if data.RunEffects and data.RunEffects.DeathCapFossilBoost then
			player.ShotSpeed = player.ShotSpeed + 0.03*data.RunEffects.DeathCapFossilBoost
		end
		if player:HasTrinket(FiendFolio.ITEM.TRINKET.LOCKED_SHACKLE) then
			player.ShotSpeed = player.ShotSpeed + 0.16
		end
		if basedata.prismaticGeodeShotTimer then
			player.ShotSpeed = player.ShotSpeed + basedata.prismaticGeodeShotBoost
		end
		if basedata.prismaticGeodeRainbowTimer then
			local geode = 1
			if mod.HasTwoGeodes(player) then
				geode = 2
			end
			player.ShotSpeed = player.ShotSpeed + 0.18*geode
		end
		if player:HasCollectible(FiendFolio.ITEM.COLLECTIBLE.ANGELIC_LYRE_B) or (player:HasCollectible(CollectibleType.COLLECTIBLE_VOID) and data.VoidedLyre == 1) then
			player.ShotSpeed = player.ShotSpeed + mod.AngelicLyreStats.Blue.Shotspeed
		end
		if basedata.rapidFireOpalAmmo then
			local strength = FiendFolio.GetGolemTrinketPower(player, FiendFolio.ITEM.ROCK.FRIENDLY_RAPID_FIRE_OPAL)
			player.ShotSpeed = player.ShotSpeed * (1.5 + strength/2)
		end
	elseif flag == CacheFlag.CACHE_LUCK then
		if player:GetPlayerType() == FiendFolio.PLAYER.FIEND and not fiendconfig.ImpBabyMode then
			player.Luck = player.Luck + fiendstats.luck
		end
		if player:HasTrinket(TrinketType.TRINKET_FORTUNE_WORM) then
			local multiplier = player:GetTrinketMultiplier(TrinketType.TRINKET_FORTUNE_WORM)
			player.Luck = player.Luck + 2 * multiplier
		end
		if player:HasTrinket(TrinketType.TRINKET_FORTUNE_GRUB) then
			local multiplier = player:GetTrinketMultiplier(TrinketType.TRINKET_FORTUNE_WORM)
			player.Luck = player.Luck + 1 * multiplier
		end

		player.Luck = player.Luck + 0.5 * (data.CursedPennyStats or 0)

		if player:HasCollectible(CollectibleType.COLLECTIBLE_BEGINNERS_LUCK) then
			local level = Game():GetLevel()
			local levelNum = level:GetStage()
			local stageType = level:GetStageType()
			if stageType == StageType.STAGETYPE_REPENTANCE or stageType == StageType.STAGETYPE_REPENTANCE_B then
				levelNum = levelNum + 1
			end
			player.Luck = player.Luck + (math.max(0.5, 5.5 - levelNum / 2))
		end
		if player:HasCollectible(CollectibleType.COLLECTIBLE_GOLEMS_ORB) then
			player.Luck = player.Luck + (1 * player:GetCollectibleNum(CollectibleType.COLLECTIBLE_GOLEMS_ORB))
		end
		if player:HasCollectible(CollectibleType.COLLECTIBLE_LEFTOVER_TAKEOUT) then
			player.Luck = player.Luck + (1 * player:GetCollectibleNum(CollectibleType.COLLECTIBLE_LEFTOVER_TAKEOUT))
		end
		if player:HasCollectible(CollectibleType.COLLECTIBLE_BINGE_EATER) and player:HasCollectible(CollectibleType.COLLECTIBLE_TEA) then
			player.Luck = player.Luck + (1 * player:GetCollectibleNum(CollectibleType.COLLECTIBLE_TEA))
		end
		if player:HasCollectible(mod.ITEM.COLLECTIBLE.STRANGE_RED_OBJECT) then
			player.Luck = player.Luck + (2 * player:GetCollectibleNum(mod.ITEM.COLLECTIBLE.STRANGE_RED_OBJECT))
		end
		if data.RunEffects and data.RunEffects.DeathCapFossilBoost then
			player.Luck = player.Luck + math.ceil(data.RunEffects.DeathCapFossilBoost/3)
		end
		if player:HasTrinket(FiendFolio.ITEM.TRINKET.LOCKED_SHACKLE) then
			local mult = player:GetTrinketMultiplier(FiendFolio.ITEM.TRINKET.LOCKED_SHACKLE)
			player.Luck = player.Luck + mult
		end
		if data.RunEffects and data.RunEffects.dogrockRock then
			player.Luck = player.Luck-math.ceil(data.RunEffects.dogrockRock)
		end
		if player:HasCollectible(FiendFolio.ITEM.COLLECTIBLE.ANGELIC_LYRE_B) or (player:HasCollectible(CollectibleType.COLLECTIBLE_VOID) and data.VoidedLyre == 1) then
			player.Luck = player.Luck + mod.AngelicLyreStats.Blue.Luck
		end
		if basedata.crazyJackpotStats and basedata.crazyJackpotStats.Luck then
			player.Luck = player.Luck + (3 * basedata.crazyJackpotStats.Luck)
		end
		if player:HasCollectible(mod.ITEM.COLLECTIBLE.GOLDEN_POPSICLE) then
			player.Luck = player.Luck + (1 * player:GetCollectibleNum(mod.ITEM.COLLECTIBLE.GOLDEN_POPSICLE))
		end
		if player:HasCollectible(mod.ITEM.COLLECTIBLE.BOX_TOP) then
			player.Luck = player.Luck + (2 * player:GetCollectibleNum(mod.ITEM.COLLECTIBLE.BOX_TOP))
		end
	elseif flag == CacheFlag.CACHE_TEARFLAG then
		if player:GetPlayerType() == FiendFolio.PLAYER.FIEND and fiendconfig.ClassicTears and not fiendconfig.ImpBabyMode then
			player.TearFlags = player.TearFlags | fiendstats.flag
		end
		if player:HasCollectible(FiendFolio.ITEM.COLLECTIBLE.ANGELIC_LYRE_R) or (player:HasCollectible(CollectibleType.COLLECTIBLE_VOID) and data.VoidedLyre == 2) then
			player.TearFlags = player.TearFlags | mod.AngelicLyreStats.Red.Flags
		end
		if player:HasCollectible(FiendFolio.ITEM.COLLECTIBLE.ANGELIC_LYRE_Y) or (player:HasCollectible(CollectibleType.COLLECTIBLE_VOID) and data.VoidedLyre == 0) then
			player.TearFlags = player.TearFlags | mod.AngelicLyreStats.Yellow.Flags
		end
		if basedata.rapidFireOpalAmmo then
			player.TearFlags = player.TearFlags | TearFlags.TEAR_PIERCING
		end
		if player:HasCollectible(FiendFolio.ITEM.COLLECTIBLE.MIME_DEGREE) then
			if player:HasCollectible(CollectibleType.COLLECTIBLE_TECHNOLOGY) then
				player.TearFlags = player.TearFlags | TearFlags.TEAR_SPECTRAL
			end
		end
		mod:updateMartyrTearFlags(player)
	elseif flag == CacheFlag.CACHE_TEARCOLOR then
		if player:GetPlayerType() == FiendFolio.PLAYER.FIEND and fiendconfig.ClassicTears and not fiendconfig.ImpBabyMode then
			player.TearColor = fiendstats.colour
		end
		if player:HasCollectible(FiendFolio.ITEM.COLLECTIBLE.ANGELIC_LYRE_R) or (player:HasCollectible(CollectibleType.COLLECTIBLE_VOID) and data.VoidedLyre == 2) then
			player.TearColor = mod.AngelicLyreStats.Red.Color
		end
		if player:HasCollectible(FiendFolio.ITEM.COLLECTIBLE.ANGELIC_LYRE_Y) or (player:HasCollectible(CollectibleType.COLLECTIBLE_VOID) and data.VoidedLyre == 0) then
			player.TearColor = mod.AngelicLyreStats.Yellow.Color
			player.LaserColor = mod.AngelicLyreStats.Yellow.Color
		end

		mod:updateMartyrTearLaserColor(player)
		mod:updateCrucifixTearLaserColor(player)
		mod:updateToyPianoTearLaserColor(player)
		mod:updateBlackMoonTearLaserColor(player)

		if player:HasTrinket(TrinketType.TRINKET_FORTUNE_WORM) or player:HasTrinket(FiendFolio.ITEM.ROCK.FORTUNE_WORM_FOSSIL) or player:HasCollectible(CollectibleType.COLLECTIBLE_LEFTOVER_TAKEOUT) then
			local lasercolor = Color(1.0, 1.0, 1.0, 1.0, 0/255, 0/255, 0/255)
			lasercolor:SetColorize(4.5, 3.44, 2.41, 1)
			player.LaserColor = lasercolor
		end
		if player:HasCollectible(CollectibleType.COLLECTIBLE_IMP_SODA) or player:HasTrinket(FiendFolio.ITEM.ROCK.SODALITE_GEODE) then
			local lasercolor = Color(1.0, 1.0, 1.0, 1.0, 0/255, 0/255, 0/255)
			lasercolor:SetColorize(5.7, 0.9, 3.4, 1)
			player.LaserColor = lasercolor
		end

		mod:updateLawnDartsLaserColor(player)
		mod:updateHypnoRingLaserColor(player)
		mod:updatePinheadLaserColor(player)
		mod:updateRubberBulletsLaserColor(player)
		mod:updateRerolliganFossilLaserColor(player)

		if player:HasCollectible(CollectibleType.COLLECTIBLE_MODERN_OUROBOROS) then
			player.TearColor = FiendFolio.ColorModernOuroboros
		end
	end

	if player:GetPlayerType() == FiendFolio.PLAYER.SLIPPY then
		if flag == CacheFlag.CACHE_FIREDELAY then
			player.MaxFireDelay = math.floor(player.MaxFireDelay * 1.5)
		end
	end
end)

-- so model rocket shotspeed multiplier, badges and glizzy come after everything else even other mods
function mod:AddCacheCallback()
	mod:AddCallback(ModCallbacks.MC_EVALUATE_CACHE, function(_, player, flag)
		mod:updateModelRocketStats(player, flag)

		if flag == CacheFlag.CACHE_DAMAGE then
			local badgeCount = 0
			for i = 1, #mod.RewardBadges do
				badgeCount = badgeCount + player:GetCollectibleNum(mod.RewardBadges[i])
			end
			player.Damage = player.Damage + (0.1 * badgeCount)
			player.Damage = player.Damage + (0.1 * player:GetCollectibleNum(mod.ITEM.COLLECTIBLE.YOUR_ETERNAL_REWARD))

			if player:HasCollectible(CollectibleType.COLLECTIBLE_GLIZZY) then
				player.Damage = player.Damage + (0.1 * player:GetCollectibleNum(CollectibleType.COLLECTIBLE_GLIZZY))
			end
		elseif flag == CacheFlag.CACHE_FIREDELAY then
			if player:HasCollectible(CollectibleType.COLLECTIBLE_GLIZZY) then
				player.MaxFireDelay = tearsUp(player.MaxFireDelay, (0.1 * player:GetCollectibleNum(CollectibleType.COLLECTIBLE_GLIZZY)))
			end
		elseif flag == CacheFlag.CACHE_SPEED then
			if player:HasCollectible(CollectibleType.COLLECTIBLE_GLIZZY) then
				player.MoveSpeed = player.MoveSpeed + (0.1 * player:GetCollectibleNum(CollectibleType.COLLECTIBLE_GLIZZY))
			end
		elseif flag == CacheFlag.CACHE_RANGE then
			if player:HasCollectible(CollectibleType.COLLECTIBLE_GLIZZY) then
				player.TearRange = player.TearRange + (4 * player:GetCollectibleNum(CollectibleType.COLLECTIBLE_GLIZZY))
			end
		elseif flag == CacheFlag.CACHE_SHOTSPEED then
			if player:HasCollectible(CollectibleType.COLLECTIBLE_GLIZZY) then
				player.ShotSpeed = player.ShotSpeed + (0.1 * player:GetCollectibleNum(CollectibleType.COLLECTIBLE_GLIZZY))
			end
		elseif flag == CacheFlag.CACHE_LUCK then
			if player:HasCollectible(CollectibleType.COLLECTIBLE_GLIZZY) then
				player.Luck = player.Luck + (0.1 * player:GetCollectibleNum(CollectibleType.COLLECTIBLE_GLIZZY))
			end
		end
	end)
end

mod:AddCallback(ModCallbacks.MC_USE_ITEM, function()
	mod.petRocksKilled = 0
	for _, rock in pairs(Isaac.FindByType(3, FamiliarVariant.PETROCK, -1, false, false)) do
		rock:GetData().init = nil
		rock:Update()
	end
end, CollectibleType.COLLECTIBLE_BOX_OF_FRIENDS)

local changingvar = {
	[TearVariant.BLUE] = TearVariant.BLOOD,
	[TearVariant.CUPID_BLUE] = TearVariant.CUPID_BLOOD,
	[TearVariant.PUPULA] = TearVariant.PUPULA_BLOOD,
	[TearVariant.GODS_FLESH] = TearVariant.GODS_FLESH_BLOOD,
	[TearVariant.NAIL] = TearVariant.NAIL_BLOOD,
	[TearVariant.GLAUCOMA] = TearVariant.GLAUCOMA_BLOOD,
	[TearVariant.EYE] = TearVariant.EYE_BLOOD,
}

local FiendFireballConstants = {
	TearMult = 3,
	AOEMult = 1,
	FireCooldown = 10,
}

function FiendFolio.LaunchFireball(player, dir, mode)
	local isSuperpositioned = mod:isSuperpositionedPlayer(player)

	local tear = Isaac.Spawn(2, TearVariant.FIRE_MIND, 0, player.Position, dir, player):ToTear()
	tear.CollisionDamage = math.max(3.5, player.Damage) * FiendFireballConstants.TearMult
	tear.FallingAcceleration = 0
	tear.FallingSpeed = 0
	sfx:Play(mod.Sounds.FireballLaunch, 0.4, 0, false, math.random(90, 110)/100)
	--[[if tear.Variant ~= TearVariant.FIRE_MIND then
		tear:ChangeVariant(TearVariant.FIRE_MIND)
	end

	tear.TearFlags = (tear.TearFlags)
									& ~(
										TearFlags.TEAR_PIERCING
									  | TearFlags.TEAR_ABSORB
									  | TearFlags.TEAR_BOOGER
									  | TearFlags.TEAR_STICKY
										)

	tear.Color = Color(1,1,1,1,0,0,0) -- reset the color]]
	tear.TearFlags = TearFlags.TEAR_NORMAL
	tear.Size = tear.Size * 2.5
	local sprite = tear:GetSprite()
	local suff
	if sprite:IsPlaying("MoveVert") then
		suff = "Vert"
	else
		suff = "Hori"
	end
	if mode == "implosion" then
		sprite:ReplaceSpritesheet(0, "gfx/projectiles/fireball_implosion.png")
	elseif mode == "fiendSpecial" then
		sprite:ReplaceSpritesheet(0, "gfx/projectiles/projectile_fiendishfireball.png")
	else
		sprite:ReplaceSpritesheet(0, "gfx/projectiles/fireball.png")
	end
	sprite:LoadGraphics()
	sprite.Scale = sprite.Scale * 3

	local tdata = tear:GetData()
	tdata.YinYangOrb = true
	if mode == "fiendSpecial" then
		tdata.yinyangstrength = 0.08
	else
		tdata.yinyangstrength = 0.02
	end
	tdata.specialfiend = true
	if mode == "implosion" then
		tdata.implosionCard = true
	elseif player:GetPlayerType() == FiendFolio.PLAYER.FIEND then
		tdata.spawnTempBlackHeart = true
	end
	if mode == "fiendSpecial" then
		tdata.fiendishfire = true
	end
	sfx:Play(SoundEffect.SOUND_FLAME_BURST, 0.3, 0, false, math.random(90,110)/100)
	sfx:Play(SoundEffect.SOUND_FLAMETHROWER_END, 0.3, 0, false, math.random(90,110)/100)

	if isSuperpositioned then
		local tearcolor = Color.Lerp(tear.Color, Color(1,1,1,1,0,0,0), 0)
		tearcolor.A = tearcolor.A / 4
		tear.Color = tearcolor
		tdata.IsSuperpositioned = true
	end
end

function FiendFolio.HandleDoubleTapFire(player, action)
	local data = player:GetData()
	local sdata = data.ffsavedata

	-- Hijacking this for Hatred thanks guys
	if Isaac.CountEntities(player, 3, mod.ITEM.FAMILIAR.HATRED) > 0 then
		mod.TryLaunchHatredFamiliars(player)
	end

	mod:erflyOnDoubleTap(player, data, sdata)

	--Fireball shit below here

	if sdata.orbitingfireballs <= 0
	or (data.fireballtimer and player.FrameCount - data.fireballtimer < FiendFireballConstants.FireCooldown) then
		return
	end

	if player:GetFireDirection() < 0 then return end

	local dir = FiendFolio.GetCorrectedFiringInput(player)
	local idealPos = player.Position + (dir * 10)

	local idealDist = 99999999
	local orbiter
	for _, fam in ipairs(Isaac.FindByType(3, FamiliarVariant.FIEND_ORBITING_FIREBALL, -1, false, false)) do
		if fam:ToFamiliar().Player.Index == player.Index then
			local dist = fam.Position:DistanceSquared(idealPos)
			if dist < idealDist then
				idealDist = dist
				orbiter = fam
			end
		end
	end

	data.firechargetimer = nil

	local mode = nil
	if orbiter:GetData().IsFiendishFire then
		mode = "fiendSpecial"
	end
	FiendFolio.LaunchFireball(player, dir * 30, mode)

	data.fireballtimer = player.FrameCount
	sdata.orbitingfireballs = sdata.orbitingfireballs - 1
	orbiter:Remove()
	player:AddCacheFlags(CacheFlag.CACHE_FAMILIARS)
	player:EvaluateItems()
end

function mod:fiendTears(player, tear)
	if (player:GetPlayerType() == FiendFolio.PLAYER.FIEND and
	   not fiendconfig.ClassicTears and
	   not fiendconfig.ImpBabyMode)
	   or player:GetPlayerType() == FiendFolio.PLAYER.BIEND
	   or player:GetData().MaliceMinion
	   or player:GetData().TheRealTaintedFiend
	then
		if changingvar[tear.Variant] then
			tear:ChangeVariant(changingvar[tear.Variant])
		end
		tear:GetData().IsBloodyTear = true
	end
end

function mod:explodeFiendProj(tear, fireDamage, spreadMulti)
	local tdata = tear:GetData()
	local isSuperpositioned = tear:GetData().IsSuperpositioned
	spreadMulti = spreadMulti or 5
	math.randomseed(tear.Index + tear.FrameCount)
	if sfx:IsPlaying(SoundEffect.SOUND_TEARIMPACTS) then sfx:Stop(SoundEffect.SOUND_TEARIMPACTS) end
	sfx:Play(mod.Sounds.FireballLand, 1.4, 0, false, math.random(90, 110)/100)
	local explosion = Isaac.Spawn(1000, 7018, 0, tear.Position, nilvector, nil)
	if isSuperpositioned then
		local explosioncolor = Color.Lerp(explosion.Color, Color(1,1,1,1,0,0,0), 0)
		explosioncolor.A = explosioncolor.A / 4
		explosion.Color = explosioncolor
	end
	local aoeMult = FiendFireballConstants.AOEMult / FiendFireballConstants.TearMult
	local rotExtra = math.random(60)
	colorSet = mod.ColorNormal
	if tdata.implosionCard then
		colorSet = Color(1,1,1,1,-0.5,0.5,-0.5)
	elseif tdata.fiendishfire then
		colorSet = Color(1,1,1,1,66 / 255,13 / 255,202 / 255)
	end
	if tdata.implosionCard or (tdata.fiendishfire and math.random(1,3) == 1) then
		local spood = Isaac.Spawn(1000, EffectVariant.PICKUP_FIEND_MINION, 0, tear.Position, nilvector, tear.SpawnerEntity)
		--[[if tdata.fiendishfire then
			local sprit = spood:GetSprite()
			sprit:ReplaceSpritesheet(0, "gfx/familiar/fiend/minions/morsel_minion_fiendish_half.png")
			sprit:ReplaceSpritesheet(1, "gfx/familiar/fiend/minions/morsel_minion_fiendish_half.png")
			sprit:ReplaceSpritesheet(6, "gfx/familiar/fiend/minions/morsel_minion_fiendish_half.png")
			sprit:ReplaceSpritesheet(7, "gfx/familiar/fiend/minions/morsel_minion_fiendish_half.png")
			sprit:LoadGraphics()
		end]]
		spood:GetData().canreroll = false
		spood.EntityCollisionClass = 4
		spood.Parent = tear.SpawnerEntity
		spood:GetData().hollow = true
	end
	for i = 1, 6 do
		for j = 0, 2 do
			local rotInd = 0.33 * j
			local vecMinus = 0
			if j > 0 then
				vecMinus = 10
			end
			local e = Isaac.Spawn(1000, 7015, 0, tear.Position, Vector(0, 1):Resized((30 - vecMinus)/spreadMulti):Rotated((i - rotInd)*60 + rotExtra), tear.Parent)
			e:GetData().damage = fireDamage
			e:GetData().implosionCard = tear:GetData().implosionCard
			e:GetData().spawnTempBlackHeart  = tear:GetData().spawnTempBlackHeart
			e.Color = colorSet
			if isSuperpositioned then
				local ecolor = Color.Lerp(e.Color, Color(1,1,1,1,0,0,0), 0)
				ecolor.A = ecolor.A / 4
				e.Color = ecolor
				e:GetData().IsSuperpositioned = true
			end
			e.Size = 16
		end
	end
end

mod:AddCallback(ModCallbacks.MC_POST_TEAR_UPDATE, function(_, tear)
	local d, tsprite = tear:GetData(), tear:GetSprite()
	if d.specialfiend then
		tear.FallingAcceleration = 0
		tear.FallingSpeed = 0

		if tear.FrameCount % 2 == 1 then
			local fire = Isaac.Spawn(1000, 7015, 0, tear.Position, nilvector, tear.Parent)
			fire.Size = 1
			fire:GetData().implosionCard = tear:GetData().implosionCard
			if d.IsSuperpositioned then
				local firecolor = Color.Lerp(fire.Color, Color(1,1,1,1,0,0,0), 0)
				firecolor.A = firecolor.A / 4
				fire.Color = firecolor
				fire:GetData().IsSuperpositioned = true
			end
			fire:Update()

			local firesub = 0
			if d.fiendishfire then
				firesub = 1
			end
			local plume = Isaac.Spawn(1000, 147, firesub, tear.Position, nilvector, tear.Parent)
			plume.SpriteScale = plume.SpriteScale * 0.75
			plume.SpawnerEntity = tear.Parent
			plume.Parent = tear.Parent
			plume.CollisionDamage = 0
			if d.implosionCard then
				plume.Color = Color(1,1,1,1,-0.5,0.5,-0.5)
			end
			if d.IsSuperpositioned then
				local plumecolor = Color.Lerp(plume.Color, Color(1,1,1,1,0,0,0), 0)
				plumecolor.A = plumecolor.A / 4
				plume.Color = plumecolor
			end
			plume:Update()
		end

		if tear:IsDead() then
			local npcs = Isaac.FindInRadius(tear.Position, 500, EntityPartition.ENEMY)
			for _,npc in ipairs(npcs) do
				if (tear.Position - npc.Position):Length() < 75 * 0.75 + npc.Size and
				   game:GetRoom():CheckLine(tear.Position, npc.Position, 2) and
				   not npc:HasEntityFlags(EntityFlag.FLAG_FRIENDLY)
				then
					npc:TakeDamage(6, DamageFlag.DAMAGE_EXPLOSION, EntityRef(tear), 0)
					if not (npc:HasEntityFlags(EntityFlag.FLAG_NO_KNOCKBACK) or npc:HasEntityFlags(EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK)) then
						npc.Velocity = npc.Velocity + (npc.Position - tear.Position):Resized(8)
					end
				end
			end
			local crater = Isaac.Spawn(1000, 18, 0, tear.Position, nilvector, nil)
			crater.SpriteScale = Vector(0.75, 0.75)
			sfx:Play(SoundEffect.SOUND_BOSS1_EXPLOSIONS, 1, 0, false, 1)
			--game:BombExplosionEffects(tear.Position, 6, 0, Color(0, 0, 0, 0, 0, 0, 0), npc, 0.75, false, true)
			mod:explodeFiendProj(tear, FiendFireballConstants.AOEMult / FiendFireballConstants.TearMult)
		end
	end
	if d.isrib then
		tear = tear:ToTear()
		tear.Height = -24
		tear.Velocity = tear.Velocity:Resized(tear.Velocity:Length() * ((tear.Position:Distance(tear.Parent.Position) > 60 or tear.FrameCount < 20) and 0.9 or 0.6)) + (tear.Parent.Position - tear.Position):Resized(tear.Position:Distance(tear.Parent.Position) > 60 and 0.9 or (tear.FrameCount < 20 and 0.9 or 20))
		if tear.Velocity:Length() < 11 then
			tear.Velocity = tear.Velocity * 1.2
		end
		if tear.Velocity:Length() > 11 then
			tear.Velocity = tear.Velocity:Resized(11)
		end
		for _, p in pairs(Isaac.FindByType(9, -1, -1, false, false)) do
			if tear.Position:Distance(p.Position) - tear.Size - p.Size <= 0 then
				p:Kill()
			end
		end
		if tear.Position:Distance(tear.Parent.Position) - tear.Size - tear.Parent.Size <= 0 and tear.FrameCount > 10 then
			tear:Remove()
			--sfx:Play(SoundEffect.SOUND_SCAMPER, 0.6, 0, false, 1)
			if tear.Parent:GetData().ribsout then
				tear.Parent:GetData().ribsout = tear.Parent:GetData().ribsout - 1
			end
		end
		if d.removaltime then tear:Remove() end
	end

	mod.babyCraterTears(tear, d)
	mod.ferriumTear(tear, d)
end)

function mod:fiendTearCollision(tear, collider)
	if tear:GetData().specialfiend then
		tear:GetData().removaltime = true
		local npcs = Isaac.FindInRadius(tear.Position, 500, EntityPartition.ENEMY)
		for _,npc in ipairs(npcs) do
			if (tear.Position - npc.Position):Length() < 75 * 0.5 + npc.Size and
			   game:GetRoom():CheckLine(tear.Position, npc.Position, 2) and
			   not npc:HasEntityFlags(EntityFlag.FLAG_FRIENDLY)
			then
				npc:TakeDamage(2, DamageFlag.DAMAGE_EXPLOSION, EntityRef(tear), 0)
				if not (npc:HasEntityFlags(EntityFlag.FLAG_NO_KNOCKBACK) or npc:HasEntityFlags(EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK)) then
					npc.Velocity = npc.Velocity + (npc.Position - tear.Position):Resized(8)
				end
			end
		end
		local crater = Isaac.Spawn(1000, 18, 0, tear.Position, nilvector, nil)
		crater.SpriteScale = Vector(0.5, 0.5)
		sfx:Play(SoundEffect.SOUND_BOSS1_EXPLOSIONS, 1, 0, false, 1)
		--game:BombExplosionEffects(tear.Position, 2, 0, Color(0, 0, 0, 0, 0, 0, 0), npc, 0.5, false, true)
		mod:explodeFiendProj(tear, tear.CollisionDamage * 1/12, 10)
	end
end

mod:AddCallback(ModCallbacks.MC_POST_EFFECT_UPDATE, function(_, effect)
	local sprite = effect:GetSprite()
	for _, npc in pairs(Isaac.GetRoomEntities()) do
		if npc:IsEnemy() and npc:IsVulnerableEnemy() and npc.Position:Distance(effect.Position) - effect.Size - npc.Size <= 0 then
			npc:TakeDamage(effect:GetData().damage or 1.4, DamageFlag.DAMAGE_FIRE, EntityRef(effect), 4)
		end
	end
	if effect.FrameCount % 1 == 0 then
		sprite.Scale = sprite.Scale:Resized(sprite.Scale:Length() - 0.1)--(effect.Size - 1) / effect.Size)
		effect.Size = effect.Size - 1
	end
	if effect.Size < 10 then
		local alpha = effect.Size / 10
		if effect:GetData().IsSuperpositioned then
			alpha = alpha / 4
		end
		effect.Color = Color(effect.Color.R, effect.Color.G, effect.Color.B, alpha, effect.Color.RO, effect.Color.GO, effect.Color.BO)
	end
	if effect.Size <= 0 then
		effect:Remove()
		effect.Visible = false
	end
end, 7015)

mod:AddCallback(ModCallbacks.MC_POST_EFFECT_UPDATE, function(_, effect)
	if effect.SubType == 24 then
		local sprite = effect:GetSprite()
		if sprite:IsPlaying("Flush") then
			if sprite:IsFinished("Flush") then
				effect:Remove()
			end
		else
			effect.SpriteRotation = effect.FrameCount * 20
			effect.SpriteScale = effect.SpriteScale * 0.95
			if effect.FrameCount > 60 then
				effect:Remove()
			end
		end
	else
		local sprite = effect:GetSprite()
		if sprite:IsFinished("Explosion") then
			effect:Remove()
		end
	end
end, 7018)

mod:AddCallback(ModCallbacks.MC_USE_ITEM, function()
	local player = mod:GetPlayerUsingItem()
	local trinket = FiendFolio.GetMostRecentTrinket(player)
	if trinket ~= -1 then
		if player:TryRemoveTrinket(trinket) then
			FiendFolio.CrushRockTrinket(player, trinket, player)
			local trink = Isaac.Spawn(EntityType.ENTITY_PICKUP, PickupVariant.PICKUP_TRINKET, FiendFolio.GetNextMiningMachineTrinket(trinket, player), player.Position, Vector.FromAngle(math.random(30, 150)):Resized(5), player)
		end
	end
	
	local hasVirtues = player:HasCollectible(CollectibleType.COLLECTIBLE_BOOK_OF_VIRTUES)
	if hasVirtues then
		player:AddWisp(FiendFolio.ITEM.COLLECTIBLE.GOLEMS_ROCK, player.Position) -- because its not recognizing that the wisp exists yet otherwise
		sfx:Play(SoundEffect.SOUND_CANDLE_LIGHT, 1, 0, false, 1)
		player:AddCacheFlags(CacheFlag.CACHE_ALL)
		player:EvaluateItems()
	end
	
	return true
end, CollectibleType.COLLECTIBLE_GOLEMS_ROCK)

mod:AddCallback(ModCallbacks.MC_POST_ENTITY_KILL, function(_, e)
	if e.Variant == FamiliarVariant.WISP and e.SubType == FiendFolio.ITEM.COLLECTIBLE.GOLEMS_ROCK then
		local player = e:ToFamiliar().Player
		if player then
			player:AddCacheFlags(CacheFlag.CACHE_ALL)
			player:EvaluateItems()
		end
	end
end, EntityType.ENTITY_FAMILIAR)

local golemsRockWispTearsToBePostFired = {}
mod:AddCallback(ModCallbacks.MC_FAMILIAR_UPDATE, function(_, familiar)
	if familiar.SubType == FiendFolio.ITEM.COLLECTIBLE.GOLEMS_ROCK then
		for _, t in pairs(golemsRockWispTearsToBePostFired) do
			local tear = t:ToTear()
			local randMult = math.random()
			if math.random(2) == 1 then
				tear.CollisionDamage = tear.CollisionDamage * (randMult + 1)
				tear.Scale = (tear.Scale + 0.1) * (randMult / 5 + 1)
			else
				tear.CollisionDamage = tear.CollisionDamage / (randMult + 1)
				tear.Scale = (tear.Scale + 0.1) / (randMult / 6 + 1)
			end
			tear:ResetSpriteScale()
		end

		golemsRockWispTearsToBePostFired = {}
	end
end, FamiliarVariant.WISP)

mod:AddCallback(ModCallbacks.MC_POST_TEAR_INIT, function(_, tear)
	if tear.SpawnerEntity and
	   tear.SpawnerEntity.Type == EntityType.ENTITY_FAMILIAR and
	   tear.SpawnerEntity.Variant == FamiliarVariant.WISP and
	   tear.SpawnerEntity.SubType == FiendFolio.ITEM.COLLECTIBLE.GOLEMS_ROCK
	then
		golemsRockWispTearsToBePostFired[tear.Index .. " " .. tear.InitSeed] = tear
	end
end)

mod:AddCallback(ModCallbacks.MC_POST_ENTITY_REMOVE, function(_, tear)
	if golemsRockWispTearsToBePostFired[tear.Index .. " " .. tear.InitSeed] then
		golemsRockWispTearsToBePostFired[tear.Index .. " " .. tear.InitSeed] = nil
	end
end, EntityType.ENTITY_TEAR)

mod:AddCallback(ModCallbacks.MC_POST_NEW_ROOM, function()
	golemsRockWispTearsToBePostFired = {}
end)

mod:AddCallback(ModCallbacks.MC_USE_ITEM, function()
	local player = mod:GetPlayerUsingItem()
	local chest = Isaac.Spawn(EntityType.ENTITY_PICKUP,711,0,Isaac.GetFreeNearPosition(player.Position,40), nilvector, player):ToPickup()
		chest:GetData().funny = true
	local poof = Isaac.Spawn(1000, EffectVariant.POOF01, 15, chest.Position, nilvector, nil)

	local rand = math.random(31)
	if rand == 1 then
		sfx:Play(mod.Sounds.BusterWhistle, 1, 0, false, 1)
	elseif rand < 12 then
		sfx:Play(SoundEffect.SOUND_DANGLE_WHISTLE,1,0,false,1)
	else
		sfx:Play(SoundEffect.SOUND_WHISTLE,1,0,false,1)
	end
	return true
end, CollectibleType.COLLECTIBLE_STORE_WHISTLE)

mod:AddCallback(ModCallbacks.MC_USE_ITEM, function()
	local room = game:GetRoom()
	for _, npc in pairs(Isaac.GetRoomEntities()) do
		if npc:IsEnemy() then
			npc.Position = Vector(npc.Position.X, room:GetGridHeight() * 50)
		end
	end
	return true
end, CollectibleType.COLLECTIBLE_MARIAS_IPAD)

local ipadWispTearsToBePostFired = {}
mod:AddCallback(ModCallbacks.MC_FAMILIAR_UPDATE, function(_, familiar)
	if familiar.SubType == FiendFolio.ITEM.COLLECTIBLE.MARIAS_IPAD then
		for _, t in pairs(ipadWispTearsToBePostFired) do
			local tdata = t:GetData()
			tdata.ipadTear = true
		end

		ipadWispTearsToBePostFired = {}
	end
end, FamiliarVariant.WISP)

mod:AddCallback(ModCallbacks.MC_POST_TEAR_INIT, function(_, tear)
	if tear.SpawnerEntity and
	   tear.SpawnerEntity.Type == EntityType.ENTITY_FAMILIAR and
	   tear.SpawnerEntity.Variant == FamiliarVariant.WISP and
	   tear.SpawnerEntity.SubType == FiendFolio.ITEM.COLLECTIBLE.MARIAS_IPAD
	then
		ipadWispTearsToBePostFired[tear.Index .. " " .. tear.InitSeed] = tear
	end
end)

mod:AddCallback(ModCallbacks.MC_POST_ENTITY_REMOVE, function(_, tear)
	if ipadWispTearsToBePostFired[tear.Index .. " " .. tear.InitSeed] then
		ipadWispTearsToBePostFired[tear.Index .. " " .. tear.InitSeed] = nil
	end
end, EntityType.ENTITY_TEAR)

mod:AddCallback(ModCallbacks.MC_POST_NEW_ROOM, function()
	ipadWispTearsToBePostFired = {}
end)

function mod:ipadOnTearDamage(sourcedata, ent)
	if sourcedata.ipadTear then
		ent.Position = Vector(ent.Position.X, room:GetGridHeight() * 50)
	end
end

mod:AddCallback(ModCallbacks.MC_USE_ITEM, function(_, ItemID, rng, player)
	local vec = Vector(0, -10)
	if player.Velocity:Length() > 0 then
		vec = player.Velocity:Resized(10)
	end
	for i = 72, 360, 72 do
		local fire = Isaac.Spawn(1000, 10, 0, player.Position, vec:Rotated(i), player):ToEffect()
		fire.Parent = player
		fire.Color = mod.ColorNormal
		fire.CollisionDamage = player.Damage
		fire.Timeout = 300
		fire:Update()
	end

	if player:HasCollectible(CollectibleType.COLLECTIBLE_BOOK_OF_VIRTUES) then
		for i = 1, 5 do
			player:AddWisp(CollectibleType.COLLECTIBLE_CANDLE, player.Position)
		end
		sfx:Play(SoundEffect.SOUND_CANDLE_LIGHT, 1, 0, false, 1)
	end

	sfx:Play(SoundEffect.SOUND_FIRE_RUSH, 1, 0, false, math.random(90, 110)/100)

	for _, griddle in pairs (Isaac.FindByType(mod.FF.GriddleHorn.ID, mod.FF.GriddleHorn.Var, 0)) do
		griddle:BloodExplode()
		local death = Isaac.Spawn(1000, 77, 0, griddle.Position, nilvector, player)
		death:Update()
		if Game():GetRoom():GetType() == RoomType.ROOM_BOSS then
			Isaac.Spawn(5,100,CollectibleType.COLLECTIBLE_SPATULA_BADGE,griddle.Position, nilvector, nil)
			sfx:Play(SoundEffect.SOUND_FIREDEATH_HISS, 1, 0, false, 1)
		end
		griddle:Remove()
	end

	return true
end, CollectibleType.COLLECTIBLE_WHITE_PEPPER)

-- Eternal D12
-- 2 charges
mod:AddCallback(ModCallbacks.MC_USE_ITEM, function(_, id, rng, player, useflags, activeslot, customvardata)
    local RoomSeed = game:GetRoom():GetSpawnSeed() * 10
	if game:GetRoom():IsMirrorWorld() then RoomSeed = RoomSeed+1 end
    if rng:RandomFloat() <= 2/3 then
      mod.reroll_grids({2, 3, 4, 5, 6, 11, 12, 14, 22, 24, 25, 27}, false, false, false)
      mod:ChangeD12Grids(mod.ED12Grid)
      if not mod.d12ed_Rooms[RoomSeed] then mod.d12ed_Rooms[RoomSeed] = {} end
      mod.d12ed_Rooms[RoomSeed].Type = 2    -- 1: d12   ; 2: ed12
    else
      mod.wipe_grids({2, 4, 6, 14, 22, 27}, false)
      SFXManager():Play(SoundEffect.SOUND_DEATH_CARD, 1, 0, false, 1)
    end
	if activeslot and activeslot > 0 then
		player:RemoveCollectible(id, true, activeslot)
		player:AddCollectible(Isaac.GetItemIdByName(" Eternal D12 "), 0, false, activeslot)
    end
	return true
end, Isaac.GetItemIdByName("Eternal D12"))

-- 1 charge (99% copy paste)
mod:AddCallback(ModCallbacks.MC_USE_ITEM, function(_, id, rng, player, useflags, activeslot, customvardata)
    local RoomSeed = game:GetRoom():GetSpawnSeed() * 10
	if game:GetRoom():IsMirrorWorld() then RoomSeed = RoomSeed+1 end
    if rng:RandomFloat() <= 1/3 then
      mod.reroll_grids({2, 3, 4, 5, 6, 11, 12, 14, 22, 24, 25, 27}, false, false, false)
      mod:ChangeD12Grids(mod.ED12Grid)
      if not mod.d12ed_Rooms[RoomSeed] then mod.d12ed_Rooms[RoomSeed] = {} end
      mod.d12ed_Rooms[RoomSeed].Type = 2    -- 1: d12   ; 2: ed12
    else
      mod.wipe_grids({2, 4, 6, 14, 22, 27}, false)
      SFXManager():Play(SoundEffect.SOUND_DEATH_CARD, 1, 0, false, 1)
    end
	if activeslot and activeslot >= 0 then
		player:RemoveCollectible(id, true, activeslot)
		player:AddCollectible(Isaac.GetItemIdByName("Eternal D12"), 0, false, activeslot)
    end
	return true
end, Isaac.GetItemIdByName(" Eternal D12 "))

-- also DICHROMATIC BUTTERFLY new room!
mod:AddCallback(ModCallbacks.MC_POST_NEW_ROOM, function()
	mod:erflyPrePlayerNewRoom()

	local players = Isaac.FindByType(1, -1, -1, false, false)
	for _, player in ipairs(players) do
		local data = player:GetData()
		local savedata = data.ffsavedata
		if data.dichromaticgraze then
			data.dichromaticgrazecooldown = nil
			data.dichromaticgrazedbullets = nil
			data.dichromaticgraze = nil
			player = player:ToPlayer()
			player:AddCacheFlags(CacheFlag.CACHE_DAMAGE)
			player:EvaluateItems()
		end

		mod:alphaCoinNewRoom(player, savedata)

		--Slapping this in here since it fits in snugly
		if data.holdingFFItem then
			data.holdingFFItem = nil
		end

		mod:erflyPlayerNewRoom(player:ToPlayer(), data, savedata)
	end

	mod:erflyPostPlayerNewRoom()
end)

--[[
Dad's Wallet
"Damage Debt"

Buy shop items you can't afford, pay it later!
]]

mod:AddCallback(ModCallbacks.MC_POST_PEFFECT_UPDATE, function(_, player)
	local savedata = FiendFolio.savedata.run

	local debtChange
	if player:HasCollectible(CollectibleType.COLLECTIBLE_DADS_WALLET) then
		local pickups = Isaac.FindInRadius(player.Position, player.Size, EntityPartition.PICKUP)
		for _, pickup in ipairs(pickups) do
			pickup = pickup:ToPickup()
			if pickup and pickup:IsShopItem() and pickup.Price > player:GetNumCoins()
			and FiendFolio.CanPurchasePickup(player, pickup)
			and player:IsExtraAnimationFinished() then
				local coins = player:GetNumCoins()
				local debt = pickup.Price - coins
				if not savedata.dadsdebt then
					savedata.dadsdebt = 0
				end

				if (savedata.dadsdebt + debt) <= 99 then
					pickup.Price = PickupPrice.PRICE_FREE
					pickup.AutoUpdatePrice = false
					savedata.dadsdebt = savedata.dadsdebt + debt
					player:AddCoins(-coins)
					debtChange = true
				end
			end
		end
	end

	if savedata.dadsdebt and player:GetNumCoins() > 0 then
		local coins = player:GetNumCoins()
		player:AddCoins(-savedata.dadsdebt)
		savedata.dadsdebt = savedata.dadsdebt - coins
		debtChange = true
		if savedata.dadsdebt <= 0 then
			savedata.dadsdebt = nil
		end
	end

	if debtChange then
		player:AddCacheFlags(CacheFlag.CACHE_DAMAGE)
		player:EvaluateItems()
	end
end)

mod:AddCallback(ModCallbacks.MC_POST_RENDER, function()
	if StageAPI and StageAPI.Loaded and StageAPI.IsHUDAnimationPlaying() then
		return
	end

	local debt = mod.getField(FiendFolio.savedata, 'run', 'dadsdebt')

	if debt and debt > 0 then
		local hudOffset = Options.HUDOffset * 10
		local coinOffset = Vector(30, 33) + Vector(hudOffset * 2, hudOffset * 1.2)
		roomNamesFont:DrawStringScaled("-" .. tostring(debt), coinOffset.X, coinOffset.Y, 1, 1, KColor(0.631, 0.278, 0.278, 1), 0, false)
	end
end)

FiendFolio.AddItemPickupCallback(function(player, added)
	local pos = game:GetRoom():FindFreePickupSpawnPosition(player.Position, 40, true)
	Isaac.Spawn(EntityType.ENTITY_PICKUP, PickupVariant.PICKUP_TAROTCARD, Card.CARD_CREDIT, pos, nilvector, player)
end, nil, CollectibleType.COLLECTIBLE_DADS_WALLET)

--[[
Dichromatic Butterfly
Treasure, Secret
"Hitbox down, Danger graze"

Hitbox down, marked by the red hitbox dot.

Tears that brush close to your hitbox will "graze", which will increase your damage by +0.2 for the remainder of the room, up to +3. (grazing will have a slight cooldown?)

Graze has a cooldown of 1 second between each activation
]]

local dichromaticDot = Sprite()
dichromaticDot:Load("gfx/characters/reimu_hitbox.anm2", true)
dichromaticDot:SetFrame("Hitbox", 0)

local dichromaticRadius = 25

mod:AddCallback(ModCallbacks.MC_POST_PEFFECT_UPDATE, function(_, player)
	local room = game:GetRoom()
	local data = player:GetData()
	if player:HasCollectible(CollectibleType.COLLECTIBLE_DICHROMATIC_BUTTERFLY) then
		local needsMulti = 2 / player.Size
		player.SizeMulti = Vector(needsMulti, needsMulti)

		data.dichromaticsized = true

		if data.dichromaticgrazecooldown then
			data.dichromaticgrazecooldown = data.dichromaticgrazecooldown - 1
			if data.dichromaticgrazecooldown <= 0 then
				data.dichromaticgrazecooldown = nil
			end
		end

		local newGraze
		if data.dichromaticgrazedcheck then
			for i = #data.dichromaticgrazedcheck, 1, -1 do
				local proj = data.dichromaticgrazedcheck[i]
				if not proj:Exists() then
					table.remove(data.dichromaticgrazedcheck, i)
				else
					local dist = proj.Position:DistanceSquared(player.Position)
					local distData = data.dichromaticgrazedbullets[GetPtrHash(proj)]
					if dist > distData[1] then
						distData[2] = frame
						newGraze = true
						table.remove(data.dichromaticgrazedcheck, i)
					end

					distData[1] = dist
				end
			end
		end

		local projs = Isaac.FindInRadius(player.Position, dichromaticRadius, EntityPartition.BULLET)
		if #projs > 0 then
			local frame = game:GetFrameCount()
			if not data.dichromaticgrazedbullets then
				data.dichromaticgrazedbullets = {}
				data.dichromaticgrazedcheck = {}
			end

			-- store grazing projectiles to iterate over them later and check if they are no longer grazing
			for _, proj in ipairs(projs) do
				local hash = GetPtrHash(proj)
				if not data.dichromaticgrazedbullets[hash] or (data.dichromaticgrazedbullets[hash][2] and frame > (data.dichromaticgrazedbullets[hash][2] + 30)) then
					data.dichromaticgrazedbullets[hash] = {proj.Position:DistanceSquared(player.Position)}
					data.dichromaticgrazedcheck[#data.dichromaticgrazedcheck + 1] = proj
				end
			end
		end

		if newGraze and not data.dichromaticgrazecooldown and (not data.dichromaticgraze or data.dichromaticgraze < 15) then
			sfx:Play(mod.Sounds.DichromaticGraze,1,0,false,1)

			data.dichromaticgrazecooldown = 30
			-- 0.2 damage per graze, caps at 3
			data.dichromaticgraze = (data.dichromaticgraze or 0) + 1
			player:AddCacheFlags(CacheFlag.CACHE_DAMAGE)
			player:EvaluateItems()
		end

		if room:GetType() == RoomType.ROOM_DUNGEON then -- hacky way to make collectibles possible to pickup in crawlspaces, by increasing their hitbox
			local colls = Isaac.FindByType(5, 100, -1, false, false)
			for _, coll in ipairs(colls) do
				coll.SizeMulti = Vector(2, 2)
			end
		end
	-- sizemulti doesn't automatically reset itself; this will probably make for some funky mod interactions so sorry about that
	elseif data.dichromaticsized then
		player.SizeMulti = onevector
		player:AddCacheFlags(CacheFlag.CACHE_ALL)
		player:EvaluateItems()
	end
end)

mod:AddCallback(ModCallbacks.MC_POST_PLAYER_RENDER, function(_, player)
	if player:HasCollectible(CollectibleType.COLLECTIBLE_DICHROMATIC_BUTTERFLY) then
		local pos = Isaac.WorldToRenderPosition(player.Position) + game:GetRoom():GetRenderScrollOffset()
		dichromaticDot:Render(pos, nilvector, nilvector)
	end
end)

-- Minions

function mod:getClosestEnemyMinion(position, radius)
	radius = radius ^ 2
	local target
	for _, ent in ipairs(Isaac.GetRoomEntities()) do
		if ent:IsActiveEnemy() and ent:IsVulnerableEnemy() and not ent:IsDead()
		and not ent:HasEntityFlags(EntityFlag.FLAG_FRIENDLY) and ent.Type ~= mod.FFID.Tech
		and ent:ToNPC().Pathfinder:HasPathToPos(position, false) then
			local distance = position:DistanceSquared(ent.Position)
			if distance < radius then
				radius = distance
				target = ent
			end
		end
	end
	return target
end
function mod:getClosestEnemyFlyingMinion(position, radius)
	radius = radius ^ 2
	local target
	for _, ent in ipairs(Isaac.GetRoomEntities()) do
		if ent:IsActiveEnemy() and ent:IsVulnerableEnemy() and not ent:IsDead()
		and not ent:HasEntityFlags(EntityFlag.FLAG_FRIENDLY) and ent.Type ~= mod.FFID.Tech then
			local distance = position:DistanceSquared(ent.Position)
			if distance < radius then
				radius = distance
				target = ent
			end
		end
	end
	return target
end


mod:AddCallback(ModCallbacks.MC_POST_PICKUP_UPDATE, function(_, pickup)
	local data = pickup:GetData()
	local sprite = pickup:GetSprite()
	math.randomseed(pickup.Index)
	if not data.proof then
		pickup.Parent = Isaac.GetPlayer(0)
		pickup.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
		sprite:Play("Appear", false)
		data.proof = true
	end
	if sprite:IsEventTriggered("Bang") then
		if data.spawnhollow then
			local spood = Isaac.Spawn(1000, EffectVariant.PICKUP_FIEND_MINION, 0, pickup.Position, Vector(math.random(-5, 5), math.random(-5, 5)), pickup.Parent)
			spood:GetData().hollow = true
			spood:GetData().canreroll = false
			spood:Update()
		else
			local spood = Isaac.Spawn(5, PickupVariant.PICKUP_FIEND_MINION, pickup.SubType, pickup.Position, Vector(math.random(-5, 5), math.random(-5, 5)), pickup.Parent)
			spood.Parent = pickup.Parent
			spood:Update()
		end
	end
	if sprite:IsFinished("Appear") then
		pickup:Remove()
	end
end, PickupVariant.PICKUP_FIEND_EGG)

--Fiend Minions, fiendminions
function mod:FiendMinionAI(pickup)
	if not pickup.Parent then
		pickup.Parent = Isaac.GetPlayer(0)
	end
	local room = game:GetRoom()
	local roomtype = room:GetType()
	local player = pickup.Parent:ToPlayer()
	local sprite = pickup:GetSprite()
	local data = pickup:GetData()

	local isEffect
	if pickup.Type == 1000 then
		if pickup.SubType == 10 then
			data.amethyst = true
		else
			data.hollow = true
		end
		isEffect = true
	end

	if not data.triedToMinionfy then
		local rand = math.random(100000)
		if rand == 1 and not data.amethyst then
			for i = 0, 7 do
				sprite:ReplaceSpritesheet(i, "gfx/familiar/fiend/minions/morsel_minion_gru.png")
			end
			sprite:LoadGraphics()
			data.isMinion = true
		end
		data.triedToMinionfy = true
	end

	if sprite:IsPlaying("Drop") then
		pickup.Velocity = pickup.Velocity * 0.8
	end

	if player.CanFly then
		data.flying = true
	else
		data.flying = false
	end

	local playerIsFiend = player:GetPlayerType() == mod.PLAYER.FIEND

	--[[if player:GetEffects() then
		if player:HasCollectible(CollectibleType.COLLECTIBLE_GNAWED_LEAF) and player:GetMovementVector():Length() < 0.01 then
			if not data.gnawedLeafFrozen then
				data.gnawedLeafFrozen = true
				pickup.Color = Color(1.5, 1.5, 1.5, 1, 0, 0 ,0)
				local poof = Isaac.Spawn(1000, 15, 0, pickup.Position, nilvector, nil)
				poof.SpriteScale = poof.SpriteScale * 0.5
			end
		else
			data.gnawedLeafFrozen = false
			pickup.Color = mod.ColorNormal
		end
	end]]

	--[[if player:HasCollectible(247) then
		if not data.setbig then
			pickup:SetSize(26, Vector(2,2), 12)
			pickup.SpriteScale = pickup.SpriteScale * 2
			data.setbig = true
		end
	end]]

	local headsprite = "Head"
	if data.amethyst then
		data.headframe = data.headframe or math.random(120) - 1
	elseif data.hollow or data.hollowanim then
		data.headframe = data.headframe or math.random(10) - 1
	end
	data.headframe = data.headframe or math.random(206) - 1
	if not sprite:IsPlaying("Drop") then
		sprite:SetOverlayFrame(headsprite, data.headframe)
	end

	if not data.dead then
		if data.flying then
			pickup.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_WALLS
		else
			pickup.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_GROUND
		end
		pickup.EntityCollisionClass = EntityCollisionClass.ENTCOLL_ALL

		if (not mod.IsActiveRoom() and (not data.persistent or data.remainingRooms <= 0) and (not data.mixPersistent or data.mixRemainingRooms <= 0)) or (data.amethyst and pickup.FrameCount > 300) then
			if data.amethyst then
				local poof = Isaac.Spawn(1000, 15, 0, pickup.Position, nilvector, nil)
				poof.SpriteScale = poof.SpriteScale * 0.5
				poof.Color = Color(1,0.3,1,1,10 / 255,0,10 / 255)
				pickup:Remove()
			elseif data.hollow or isEffect then
				--data.dead = true
				local dedbaby = Isaac.Spawn(1000, 2, 1, pickup.Position, nilvector, nil)
				dedbaby.Color = Color(0,0,0,0.7,0,0,0)
				local poof = Isaac.Spawn(1000, 15, 0, pickup.Position, nilvector, nil)
				poof.SpriteScale = poof.SpriteScale * 0.5
				poof.Color = Color(0.3,0.3,0.3,1,10 / 255,0,10 / 255)
				pickup:Remove()
			else
				data.transforming = true
				sprite.FlipX = false
				mod:spritePlay(sprite, "Transform")
				sprite:RemoveOverlay()
				pickup.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS
				if sprite:IsPlaying("Transform") and sprite:GetFrame() > 20 then
					local anim
					if pickup.SubType == 10 then
						pickup:Morph(5, 10, HeartSubType.HEART_HALF_SOUL, true)
						anim = "gfx/familiar/fiend/minions/morsel_minion_soul_half.anm2"
					elseif pickup.SubType == 9 then
						pickup:Morph(5, 10, HeartSubType.HEART_SOUL, true)
						anim = "gfx/familiar/fiend/minions/morsel_minion_soul.anm2"
					elseif pickup.SubType == 8 then
						pickup:Morph(5, 10, HeartSubType.HEART_ROTTEN, true)
						anim = "gfx/familiar/fiend/minions/morsel_minion_rotten.anm2"
					elseif pickup.SubType == 7 then
						pickup:Morph(5, 10, HeartSubType.HEART_HALF, true)
						anim = "gfx/familiar/fiend/minions/morsel_minion_red_half.anm2"
					elseif pickup.SubType == 6 then
						pickup:Morph(5, 10, HeartSubType.HEART_FULL, true)
						anim = "gfx/familiar/fiend/minions/morsel_minion_red.anm2"
					elseif pickup.SubType == 5 then
						pickup:Morph(5, 10, HeartSubType.HEART_GOLDEN, true)
						anim = "gfx/familiar/fiend/minions/morsel_minion_gold.anm2"
					elseif pickup.SubType == 4 then
						pickup:Morph(5, 10, HeartSubType.HEART_ETERNAL, true)
						anim = "gfx/familiar/fiend/minions/morsel_minion_eternal_half.anm2"
					elseif pickup.SubType == 3 then
						pickup:Morph(5, PickupVariant.PICKUP_HALF_IMMORAL_HEART, 0, true)
						anim = "gfx/familiar/fiend/minions/morsel_minion_fiendish_half.anm2"
					elseif pickup.SubType == 2 then
						pickup:Morph(5, PickupVariant.PICKUP_IMMORAL_HEART, 0, true)
						anim = "gfx/familiar/fiend/minions/morsel_minion_fiendish.anm2"
					else
						pickup:Morph(5, 10, 6, true)
						anim = "gfx/familiar/fiend/minions/morsel_minion_black.anm2"
					end
					sprite:Load(anim, true)
					sprite:Play("Appear",true)
					sprite:Update()
				end
			end
		elseif pickup.FrameCount >= 15 then
			if data.target and (data.target:IsDead() or pickup.FrameCount % 60 == 0 or (data.target.Type == 1 and pickup.FrameCount % 15 == 0)) then
				data.target = nil
			end
			if not data.target then
				if data.flying then
					data.target = mod:getClosestEnemyFlyingMinion(pickup.Position, 900)
				else
					data.target = mod:getClosestEnemyMinion(pickup.Position, 900)
				end
				if not data.target then
					data.target = pickup.Parent
				end
			end

				local speed = math.max(3, player.MoveSpeed * 5)

			if data.gnawedLeafFrozen then
				pickup.Velocity = pickup.Velocity * 0.7
			elseif data.target and pickup.FrameCount % 2 == 0 then
				if data.flying or room:CheckLine(pickup.Position,data.target.Position,0,1,false,false) then
					pickup.Velocity = mod:Lerp(pickup.Velocity, (data.target.Position - pickup.Position):Resized(speed), 0.3)
				else
					local room = Game():GetRoom()
					if room:GetGridCollisionAtPos(pickup.Position) > 0 then
						local freepos = room:FindFreeTilePosition(pickup.Position, 999999)
						pickup.Velocity = mod:Lerp(pickup.Velocity, (freepos - pickup.Position):Resized(speed), 0.3)
					else
						mod:CatheryPathFinding(pickup, data.target.Position, {
							Speed = speed,
							Accel = 0.6
						})
					end
				end
			end
		end

		data.FrameOff = math.random(15) - 1

		if (pickup.FrameCount + data.FrameOff) % math.floor(math.max(3, player.MaxFireDelay)) == 0 and not data.gnawedLeafFrozen then
			for _,g in ipairs(Isaac.GetRoomEntities()) do
				if g:IsActiveEnemy() and g:IsVulnerableEnemy() and not g:HasEntityFlags(EntityFlag.FLAG_FRIENDLY) then
					if g.Position:Distance(pickup.Position) - g.Size - pickup.Size <= 0 then
						g:GetData().fiendminiondamage = true -- mod compat fun so that i can tell when the minion deals the damage

						local startpos = 250
						if pickup.Parent:ToPlayer():HasCollectible(CollectibleType.COLLECTIBLE_IMP_SODA) then
							startpos = startpos - 100
						end
						if pickup:GetData().fiendBonus then
							startpos = startpos - 100
						end

						local targetData = g:GetData()
						local damageDealt
						if math.random(math.max(10, startpos - math.floor(player.Luck * 20))) == 1 then
							damageDealt = player.Damage * 5
							g:TakeDamage(player.Damage * 5, 0, EntityRef(player), 0)
							if data.isMinion then
								sfx:Play(mod.Sounds.MinionSoundscape,0.6,0,false,math.random(80,120)/100)
							else
								sfx:Play(SoundEffect.SOUND_BONE_SNAP,1,0,false,math.random(80,120)/100)
							end
							local crit = Isaac.Spawn(1000, 1734, 0, pickup.Position, nilvector, pickup):ToEffect()
							crit.SpriteOffset = Vector(0, -15)
							--crit:FollowParent(pickup)
							crit:Update()
							g:BloodExplode()
						else
							if pickup:GetData().persistent then --curse of the imp minions deal more damage
								damageDealt = player.Damage * 0.5
								g:TakeDamage(player.Damage * 0.5, 0, EntityRef(player), 0)
							elseif pickup:GetData().fiendBonus then
								damageDealt = player.Damage * 0.4
								g:TakeDamage(player.Damage * 0.4, 0, EntityRef(player), 0)
							else
								damageDealt = player.Damage * 0.2
								g:TakeDamage(player.Damage * 0.2, 0, EntityRef(player), 0)
							end
							sfx:Play(SoundEffect.SOUND_MEATY_DEATHS,0.2,0,false,math.random(150,200)/100)
							local dedbaby = Isaac.Spawn(1000, 2, 1, g.Position + Vector(0, 1), nilvector, nil)
							dedbaby.Color = g.SplatColor
							dedbaby.SpriteOffset = g.SpriteOffset + Vector(0,-5) + RandomVector() * math.random(15)
							dedbaby:Update()
						end
						--Whatever
						if playerIsFiend then
							targetData.spawnFiendFireball = player
							player:GetData().ffsavedata.fiendDamageDealt = (player:GetData().ffsavedata.fiendDamageDealt or 0) + damageDealt
							mod.FiendDoingFireballs = true
						end



						if damageDealt >= g.HitPoints and not targetData.incrementedMinionKilled and mod.CanRunUnlockAchievements() then
							targetData.incrementedMinionKilled = true
							mod.savedata.immoralMinionKills = mod.savedata.immoralMinionKills + 1
						end

						g:GetData().fiendminiondamage = nil
						--g:BloodExplode()
					end
				elseif g.Type == 1000 and g.Variant == 1736 then
					if g.Position:Distance(pickup.Position) - g.Size - pickup.Size <= 0 then
						pickup.Velocity = pickup.Velocity + (pickup.Position - g.Position):Resized(1)
						g.Velocity = pickup.Velocity + (g.Position - pickup.Position):Resized(1)
					end
				end
			end
		end
		if (not data.transforming) and not (sprite:IsPlaying("Drop")) then
			local extraString = ""
			--if data.hollow or data.hollowimmoral or data.holloweternal or data.hollowred or data.hollowrotten or data.hollowsoul then extraString = "2" end
			if pickup.Velocity:Length() > 0.3 then
				if pickup.Velocity.X > 0 then
					sprite.FlipX = false
				else
					sprite.FlipX = true
				end
				if data.flying then
					if math.abs(pickup.Velocity.X) > math.abs(pickup.Velocity.Y) then
						mod:spritePlay(sprite, "FlyHori" .. extraString)
					else
						mod:spritePlay(sprite, "FlyVert" .. extraString)
					end
				else
					if math.abs(pickup.Velocity.X) > math.abs(pickup.Velocity.Y) then
						mod:spritePlay(sprite, "WalkHori" .. extraString)
					else
						mod:spritePlay(sprite, "WalkVert" .. extraString)
					end
				end
			else
				if data.flying then
					mod:spritePlay(sprite, "FlyVert")
				else
					sprite:SetFrame("WalkVert", 0)
				end
			end
		end
	else
		pickup.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
		sprite:Play("Death", false)
		if sprite:IsFinished("Death") then
			pickup:Remove()
		end
	end
end
mod:AddCallback(ModCallbacks.MC_POST_PICKUP_UPDATE, mod.FiendMinionAI, PickupVariant.PICKUP_FIEND_MINION)
mod:AddCallback(ModCallbacks.MC_POST_EFFECT_UPDATE, mod.FiendMinionAI, 1736)

mod:AddCallback(ModCallbacks.MC_PRE_PICKUP_COLLISION, function(_, pickup, collider, low)
	if collider.Type == 1 or (collider.Type == 5 and collider.Variant ~= PickupVariant.PICKUP_FIEND_MINION) then
		return true
	end
end, PickupVariant.PICKUP_FIEND_MINION)

mod:AddCallback(ModCallbacks.MC_PRE_GAME_EXIT, function()
	for _, minion in ipairs(Isaac.FindByType(EntityType.ENTITY_PICKUP, PickupVariant.PICKUP_FIEND_MINION, -1)) do
		if minion:GetData().mixPersistent then
			minion:ClearEntityFlags(EntityFlag.FLAG_PERSISTENT)
		end
	end
end)

function mod:CritHit(e)
	if e:GetSprite():IsFinished("Crit") then
		e:Remove()
	end
	e.SpriteOffset = e.SpriteOffset + Vector(0, -1)
end
mod:AddCallback(ModCallbacks.MC_POST_EFFECT_UPDATE, mod.CritHit, 1734)

-- Familiars

mod:AddCallback(ModCallbacks.MC_FAMILIAR_INIT, function(_, familiar)
	familiar.IsFollower = true
	familiar:GetData().rooms = 0
end, FamiliarVariant.DICE_BAG)

mod:AddCallback(ModCallbacks.MC_FAMILIAR_UPDATE, function(_, familiar)
	local data = familiar:GetData()
	local sprite = familiar:GetSprite()
	if not data.rooms then data.rooms = 0 end
	if not data.init then
		data.chances = {
			Card.GLASS_D6, Card.GLASS_D6, Card.GLASS_D6, Card.GLASS_D6, Card.GLASS_D6,
			Card.GLASS_D4, Card.GLASS_D4, Card.GLASS_D4,
			Card.GLASS_D8, Card.GLASS_D8, Card.GLASS_D8, Card.GLASS_D8,
			Card.GLASS_D100,
			Card.GLASS_D10, Card.GLASS_D10, Card.GLASS_D10, Card.GLASS_D10,
			Card.GLASS_D20, Card.GLASS_D20, Card.GLASS_D20, Card.GLASS_D20, Card.GLASS_D20, Card.GLASS_D20,
			Card.GLASS_D12, Card.GLASS_D12, Card.GLASS_D12, Card.GLASS_D12,
			Card.GLASS_SPINDOWN,
			Card.GLASS_AZURITE_SPINDOWN,Card.GLASS_AZURITE_SPINDOWN,
			mod.ITEM.CARD.GLASS_D2, mod.ITEM.CARD.GLASS_D2, mod.ITEM.CARD.GLASS_D2,
		}
	end
	local payoutNum = 8
	if Sewn_API then
		if Sewn_API:IsUltra(data) then
			payoutNum = 4
		elseif Sewn_API:IsSuper(data) then
			payoutNum = 6
		end
	end
	if familiar.Player:HasCollectible(CollectibleType.COLLECTIBLE_BFFS) then
		payoutNum = math.ceil(payoutNum / 2)
	end
	if data.rooms >= payoutNum then
		sprite:Play("Spawn", false)
		data.rooms = 0
	end
	if sprite:IsFinished("Spawn") then
		sprite:Play("FloatDown", false)
		local die = Isaac.Spawn(5, 300, data.chances[familiar.Player:GetCollectibleRNG(CollectibleType.COLLECTIBLE_DICE_BAG):RandomInt(#data.chances) + 1], familiar.Position, nilvector, familiar)
	end
	familiar:FollowParent()
end, FamiliarVariant.DICE_BAG)

if StageAPI and StageAPI.Loaded then
	StageAPI.AddCallback("FiendFolio", "PRE_STAGEAPI_SELECT_BOSS_ITEM", 1, function(pickup, currentRoom)
		local isFFBoss
		local bossData
		if currentRoom and currentRoom.PersistentData.BossID then
			bossData = StageAPI.GetBossData(currentRoom.PersistentData.BossID)
			if bossData and bossData.IsFFBoss then
				isFFBoss = true
			end
		end

		if isFFBoss and bossData.Horseman and #Isaac.FindByType(5, 100, CollectibleType.COLLECTIBLE_CORN_KERNEL) == 0 then
			pickup:Morph(5, 100, CollectibleType.COLLECTIBLE_CORN_KERNEL, true)
			return true
		end
	end)
end

local dirToStr = {
	[Direction.NO_DIRECTION] = "",
	[Direction.DOWN] = "Down",
	[Direction.UP] = "Up",
	[Direction.LEFT] = "Side",
	[Direction.RIGHT] = "Side",
}
local dirToVec = {
	[Direction.NO_DIRECTION] = Vector(0,0),
	[Direction.LEFT] = Vector(-1,0),
	[Direction.UP] = Vector(0,-1),
	[Direction.RIGHT] = Vector(1,0),
	[Direction.DOWN] = Vector(0,1)
}

for i = 1, 2 do
	local variant = FamiliarVariant["MERN_"..i]
	mod:AddCallback(ModCallbacks.MC_FAMILIAR_INIT, function(_, fam)
		fam:AddToOrbit(0)
	end, variant)

	mod:AddCallback(ModCallbacks.MC_PRE_FAMILIAR_COLLISION, function(_, fam, other, low)
		if other:ToProjectile() and other:GetData().CharmedMernProj == fam.Index .. " " .. fam.InitSeed then
			return true
		elseif other:ToProjectile() then
			other:Die()
		end
	end, variant)
end

mod:AddCallback(ModCallbacks.MC_FAMILIAR_UPDATE, function(_,  fam)
	local off = EntityFamiliar.GetOrbitDistance(0)
	local val = math.sin(math.rad(fam.FrameCount) * 8)
	local dist = off:Length() + (val ^ 2 + 0.5) * 20
	fam.OrbitDistance = off:Resized(dist)
  --  fam.OrbitSpeed = -fam.OrbitSpeed
	fam.Velocity = fam:GetOrbitPosition(fam.Player.Position - fam.Player.Velocity) - fam.Position
end, FamiliarVariant.MERN_1)

function mod:mernsCherryBombProjectileDeath(tear, data)
	if data.DoCherryBombExplosion then
		explosion = Isaac.Spawn(1000, 1, 0, tear.Position, Vector.Zero, tear):ToEffect()
		explosion.SpriteScale = Vector(0.6, 0.6)
		explosion.DepthOffset = 10
		local crater = Isaac.Spawn(1000, 18, 0, tear.Position, Vector.Zero, tear):ToEffect()
		crater.SpriteScale = Vector(0.6, 0.6)

		local radius = 30
		for _, enemy in ipairs(Isaac.FindInRadius(tear.Position, radius, EntityPartition.ENEMY)) do
			if enemy:IsActiveEnemy() and (not mod:isFriend(enemy)) and (enemy:IsVulnerableEnemy() or enemy:GetData().FFCopperBombHitbox) then
				local damage = 10
				enemy:TakeDamage(damage, DamageFlag.DAMAGE_EXPLOSION | DamageFlag.DAMAGE_IGNORE_ARMOR, EntityRef(tear), 0)
			end
		end
		for _, pickup in ipairs(Isaac.FindInRadius(tear.Position, radius, EntityPartition.PICKUP)) do
			local dist = (radius+70)/pickup.Position:Distance(tear.Position)
			pickup.Velocity = (pickup.Position-tear.Position):Resized(dist)
			if pickup.Velocity:Length() > 10 then
				pickup.Velocity = pickup.Velocity:Resized(10)
			end
		end
	end
end

function FiendFolio.SpawnMernIpecac(pos, vel, spawner, lvl2)
	local isSuperpositioned = mod:isSuperpositionedPlayer(spawner.Player)
	local isSirenCharmed = mod:isSirenCharmed(spawner)

	if isSirenCharmed then
		local proj = Isaac.Spawn(9, 0, 0, pos, vel, spawner):ToProjectile()

		proj.FallingSpeed = -15
		proj.FallingAccel = 1
		proj:GetData().CharmedMernProj = spawner.Index .. " " .. spawner.InitSeed

		return proj
	else
		local corn = Isaac.Spawn(2, 22, 0, pos, vel, spawner):ToTear()

		local sprite = corn:GetSprite()
		sprite:Load("gfx/009.005_corn projectile.anm2", true)

		corn.FallingSpeed = -15
		corn.FallingAcceleration = 1
		corn.Color = Color(1,0.8,0,1,0,0,0)


		if lvl2 then
			sprite:Play("Small0"..math.random(4))
			corn:GetData().DoCherryBombExplosion = true
		else
			sprite:Play("Big0"..math.random(4))
			corn.Scale = 2
			corn.TearFlags = TearFlags.TEAR_EXPLOSIVE
		end

		if isSuperpositioned then
			local tearcolor = Color.Lerp(corn.Color, Color(1,1,1,1,0,0,0), 0)
			tearcolor.A = tearcolor.A / 4
			corn.Color = tearcolor
		end

		return corn
	end
end

mod:AddCallback(ModCallbacks.MC_FAMILIAR_UPDATE, function(_,  fam)
	-- copied from mern_1
	local off = EntityFamiliar.GetOrbitDistance(0)
	local val = math.sin(math.rad(fam.FrameCount) * 8)
	local dist = off:Length() + (val ^ 2 + 0.5) * 20
	fam.OrbitDistance = off:Resized(dist)
	fam.Velocity = fam:GetOrbitPosition(fam.Player.Position - fam.Player.Velocity) - fam.Position

	local p = fam.Player
	local d = fam:GetData()
	local s = fam:GetSprite()
	local dir = p:GetFireDirection()
	local animdir = dirToStr[dir]
	d.animpre = d.animpre or "Float"
	d.cooldown = d.cooldown or 0

	if not (p:GetFireDirection() == Direction.NO_DIRECTION) and d.cooldown - fam.FrameCount <= 0 then
		d.animpre = "FloatShoot"
		d.cooldown = fam.FrameCount + 60
		s.FlipX = dir == Direction.LEFT

		FiendFolio.SpawnMernIpecac(fam.Position, dirToVec[dir]:Resized(11), fam, true)
	end

	if d.animpre == "Float" then
		local shootInput = p:GetFireDirection()
		if shootInput == Direction.NO_DIRECTION then
			animdir = "Down"
		end
		s.FlipX = dir == Direction.LEFT
	end

	s:SetFrame(d.animpre..animdir, fam.FrameCount % 15)

	if d.animpre == "FloatShoot" and d.cooldown - fam.FrameCount <= 50 then
		d.animpre = "Float"
	end

end, FamiliarVariant.MERN_2)

for i = 3, 4 do
	mod:AddCallback(ModCallbacks.MC_FAMILIAR_INIT, function(_, f)
		f.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_GROUND
	end, FamiliarVariant["MERN_"..i])
end

mod.MernWhitelist = {
	[EntityType.ENTITY_STONEY] = true,
	[EntityType.ENTITY_STONEHEAD] = true,
	[EntityType.ENTITY_POKY] = true,
}

mod:AddCallback(ModCallbacks.MC_FAMILIAR_UPDATE, function(_, f)
	local s = f:GetSprite()
	local d = f:GetData()
	local room = game:GetRoom()
	local isSirenCharmed = mod:isSirenCharmed(f)

	d.doneframe = d.doneframe or 0
	if room:GetFrameCount() == 0 then
		d.doneframe = f.FrameCount
	end

	if d.teleporttime then
		f.Velocity = f.Velocity * 0.8

		s:Play("Anger")

		if not d.target:Exists() or d.target:IsDead() or (d.target.Type == 1 and not isSirenCharmed) or (d.target.Type ~= 1 and isSirenCharmed) then
			d.teleporttime = false
			d.doneframe = f.FrameCount
			return
		end

		if (f.FrameCount - d.teleporttime) % 10 == 5 then
			if f.FrameCount - d.teleporttime < 25 then
				f.Position = room:GetRandomPosition(0)
				while isSirenCharmed and mod:isCollidingWithPlayer(f, 40) do
					f.Position = room:GetRandomPosition(0)
				end
			else
				f.Position = d.target.Position
				if isSirenCharmed then
					f.Position = room:GetClampedPosition(d.target.Position + RandomVector():Resized(d.target.Size + f.Size + 40), 0)
					while (f.Position - d.target.Position):Length() < d.target.Size + f.Size + 40 do
						f.Position = room:GetClampedPosition(d.target.Position + RandomVector():Resized(d.target.Size + f.Size + 40), 0)
					end
				end
				d.teleporttime = false
				d.doneframe = f.FrameCount
			end
			sfx:Play(SoundEffect.SOUND_HELL_PORTAL1, 0.5, 0, false, 1)
			f:SetColor(Color(1,1,1,1,1,1,1), 5, 5, true, false)
		end
	else
		if not d.dir or f.FrameCount % 15 == math.random(15) then
			d.dir = RandomVector()
		end

		if f.Velocity:Length() > 0.3 then
			if math.abs(f.Velocity.X) > math.abs(f.Velocity.Y) then
				s:Play("WalkHori")
				s.FlipX = f.Velocity.X < 0
			else
				s:Play("WalkVert")
				s.FlipX = false
			end
		else
			s:Play("Idle")
		end

		f.Velocity = f.Velocity + d.dir
		f.Velocity = f.Velocity:Resized(math.min(f.Velocity:Length() * 1.2, 2))

		if FiendFolio.IsActiveRoom() and (f.FrameCount - d.doneframe) >= 180 then
			if isSirenCharmed then
				local population = Isaac.FindInRadius(f.Position, 99999, EntityPartition.PLAYER)

				if #population > 0 then
					d.target = population[math.random(#population)]
					d.teleporttime = f.FrameCount
				end
			else
				local population = Isaac.FindInRadius(f.Position, 99999, EntityPartition.ENEMY)

				if #population > 0 then
					local found = false
					for i = 1, 30 do
						d.target = population[math.random(#population)]
						if mod.MernWhitelist[d.target.Type] or not d.target:HasEntityFlags(EntityFlag.FLAG_NO_TARGET) then
							found = true
							break
						end
					end

					if found then
						d.teleporttime = f.FrameCount
					end
				end
			end
		end
	end
end, FamiliarVariant.MERN_3)

mod:AddCallback(ModCallbacks.MC_FAMILIAR_UPDATE, function(_, f)
	local s = f:GetSprite()
	local d = f:GetData()
	local room = game:GetRoom()
	local isSirenCharmed = mod:isSirenCharmed(f)

	d.doneframe = d.doneframe or 0
	if room:GetFrameCount() == 0 then
		d.doneframe = f.FrameCount
	end

	if f.Velocity:Length() > 0.3 then
		if math.abs(f.Velocity.X) > math.abs(f.Velocity.Y) then
			s:Play("WalkHori")
			s.FlipX = f.Velocity.X < 0
		else
			s:Play("WalkVert")
			s.FlipX = false
		end
	else
		s:Play("Idle")
	end

	if not d.target or not d.target:Exists() or d.target:IsDead() or (d.target.Type == 1 and not isSirenCharmed) or (d.target.Type ~= 1 and isSirenCharmed) then
		if not FiendFolio.IsActiveRoom() then
			d.target = nil
		else
			if isSirenCharmed then
				local population = Isaac.FindInRadius(f.Position, 99999, EntityPartition.PLAYER)

				if #population > 0 then
					d.target = population[math.random(#population)]
					d.doneframe = f.FrameCount
				else
					d.target = nil
				end
			else
				local found = false

				local population = Isaac.FindInRadius(f.Position, 99999, EntityPartition.ENEMY)
				if #population > 0 then
					for i = 1, 30 do
						d.target = population[math.random(#population)]
						if mod.MernWhitelist[d.target.Type] or not d.target:HasEntityFlags(EntityFlag.FLAG_NO_TARGET) then
							found = true
							break
						end
					end
				end

				if found then
					d.doneframe = f.FrameCount
				else
					d.target = nil
				end
			end
		end
	end

	local pathTarget, size, speed
	if d.target then
		pathTarget = d.target.Position
		size = d.target.Size
		speed = 9
		if isSirenCharmed then speed = 5 end
	else
		local dir = f.Player:GetMovementVector()
		if dir:LengthSquared() < 0.1 then
			d.direction =  d.direction or Vector(0, 1)
		else
			d.direction = Vector(dir.X, dir.Y)
		end
		pathTarget = f.Player.Position - d.direction * 40
		size = f.Player.Size
		speed = 5
	end

	if d.target and f.FrameCount % 50 == 0 then
		s:PlayOverlay("Spit", true)
	end

	if s:IsOverlayPlaying("Spit") then
		f.Velocity = f.Velocity * 0.8

		--if s:IsEventTriggered("spit") then
		if s:GetOverlayFrame() == 3 then
			local corn = FiendFolio.SpawnMernIpecac(f.Position, (pathTarget - f.Position):Resized(10), f)

			corn.FallingSpeed = -20
		end
	else
		s:PlayOverlay("Attack", true)
	end

	local close = f.Position:DistanceSquared(pathTarget) < (size + f.Size + 10) ^ 2

	if not close and f.FrameCount - d.doneframe >= 40 then
		f.Velocity = f.Velocity * 0.8

		local bet = mod:Lerp(f.Position, pathTarget, math.random())
		bet = room:FindFreeTilePosition(bet, 1600)

		local orig = f.Position
		f.Position = bet

		if isSirenCharmed and mod:isCollidingWithPlayer(f, 20) then
			f.Position = orig
			return
		end

		sfx:Play(SoundEffect.SOUND_HELL_PORTAL1, 0.5, 0, false, 1)
		f:SetColor(Color(1,1,1,1,1,1,1), 5, 5, true, false)
		d.doneframe = f.FrameCount
	else
		mod:CatheryPathFinding(f, pathTarget, {
			Speed = speed,
			Accel = 0.3,
			Threshold = 600
		})
	end
end, FamiliarVariant.MERN_4)

mod:AddCallback(ModCallbacks.MC_FAMILIAR_INIT, function(_, familiar)
	if familiar.Player:GetPlayerType() == FiendFolio.PLAYER.FIEND then
		local sprite = familiar:GetSprite()
		sprite:ReplaceSpritesheet(0, "gfx/familiar/fiend/fiend_leprocy.png")
		sprite:LoadGraphics()
	end
end, FamiliarVariant.LEPROCY)

mod:AddCallback(ModCallbacks.MC_FAMILIAR_INIT, function(_, familiar)
	if familiar.Player:GetPlayerType() == FiendFolio.PLAYER.FIEND then
		local sprite = familiar:GetSprite()
		sprite:ReplaceSpritesheet(0, "gfx/familiar/fiend/fiend_isaacsheart.png")
		sprite:LoadGraphics()
	end
end, FamiliarVariant.ISAACS_HEART)

-- Technical Entities

mod:AddCallback(ModCallbacks.MC_FAMILIAR_INIT, function(_, familiar)
	familiar:AddToOrbit(7019)
	familiar.EntityCollisionClass = EntityCollisionClass.ENTCOLL_ENEMIES
	familiar.Color = Color(familiar.Color.R, familiar.Color.G, familiar.Color.B, 0)
	familiar:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
	sfx:Play(SoundEffect.SOUND_CANDLE_LIGHT)
end, FamiliarVariant.FIEND_ORBITING_FIREBALL)

mod:AddCallback(ModCallbacks.MC_FAMILIAR_UPDATE, function(_, familiar)
	local sprite = familiar:GetSprite()
	local data = familiar:GetData()
	local pdata = familiar.Player:GetData()
	data.specialfiend = true
	sprite:Play("MoveHori", false)

	familiar.OrbitDistance = Vector(30, 30)
	familiar.OrbitSpeed = -0.08
	familiar.Velocity = familiar:GetOrbitPosition(familiar.Player.Position + familiar.Player.Velocity) - familiar.Position

	--sprite.Rotation = (familiar.Position - familiar.Player.Position):GetAngleDegrees() + 90
	sprite.Offset = Vector(0, -14)

	local fcABH = 5
	if familiar.FrameCount <= fcABH then
		familiar.Color = Color(familiar.Color.R, familiar.Color.G, familiar.Color.B, familiar.FrameCount / fcABH, familiar.Color.RO, familiar.Color.GO, familiar.Color.BO)
	end
	if familiar.Player:GetPlayerType() == FiendFolio.PLAYER.FIEND and familiar.Player:HasCollectible(CollectibleType.COLLECTIBLE_BIRTHRIGHT) then
		sprite:ReplaceSpritesheet(0, "gfx/familiar/fiend/effect_fiendishfireballwisp.png")
		sprite:LoadGraphics()
		data.IsFiendishFire = true
	end
end, FamiliarVariant.FIEND_ORBITING_FIREBALL)

mod:AddCallback(ModCallbacks.MC_PRE_FAMILIAR_COLLISION, function(_, familiar, collider) --Yeah nobody likes them blowing up on enemies lol
	--[[local isFiendish = (familiar:GetData().IsFiendishFire)
	if collider:IsEnemy() and collider:IsVulnerableEnemy() and collider:IsActiveEnemy() then
		sfx:Play(mod.Sounds.FireballLand, 1.4, 0, false, 0.7)
		local explosion = Isaac.Spawn(1000, 7018, 0, familiar.Position, nilvector, nil)
		if mod:isSuperpositionedPlayer(familiar.Player) then
			local explosioncolor = Color.Lerp(explosion.Color, Color(1,1,1,1,0,0,0), 0)
			explosioncolor.A = explosioncolor.A / 4
			explosion.Color = explosioncolor
		end
		if isFiendish then
			local spood = Isaac.Spawn(1000, EffectVariant.PICKUP_FIEND_MINION, 0, familiar.Position, nilvector, familiar.Player)
			local sprit = spood:GetSprite()
			sprit:ReplaceSpritesheet(0, "gfx/familiar/fiend/minions/morsel_minion_fiendish_half.png")
			sprit:ReplaceSpritesheet(1, "gfx/familiar/fiend/minions/morsel_minion_fiendish_half.png")
			sprit:ReplaceSpritesheet(6, "gfx/familiar/fiend/minions/morsel_minion_fiendish_half.png")
			sprit:ReplaceSpritesheet(7, "gfx/familiar/fiend/minions/morsel_minion_fiendish_half.png")
			sprit:LoadGraphics()
			spood:GetData().canreroll = false
			spood.EntityCollisionClass = 4
			spood.Parent = familiar.Player
			spood:GetData().hollow = true
		end
		local sdata = familiar.Player:GetData().ffsavedata
		sdata.orbitingfireballs = sdata.orbitingfireballs - 1
		familiar:Remove()
		familiar.Player:AddCacheFlags(CacheFlag.CACHE_FAMILIARS)
		familiar.Player:EvaluateItems()
		collider:TakeDamage(familiar.Player.Damage * 5, DamageFlag.DAMAGE_EXPLOSION, EntityRef(familiar.Player), 0)
	end]]
end, FamiliarVariant.FIEND_ORBITING_FIREBALL)

function mod:isAnyoneNotKeeper()
	for i = 1, game:GetNumPlayers() do
		local player = Isaac.GetPlayer(i - 1)
		local playerType = player:GetPlayerType()

		if player.Variant == 0 and playerType ~= PlayerType.PLAYER_KEEPER and playerType ~= PlayerType.PLAYER_KEEPER_B then
			return true
		end
	end
	return false
end

function mod:keeperFlyCheck(pickup)
	if (mod.isAnyoneCharacter(PlayerType.PLAYER_KEEPER) or mod.isAnyoneCharacter(PlayerType.PLAYER_KEEPER_B)) and not mod:isAnyoneNotKeeper() then
		for i = 1, 2 do
			local afly = Isaac.Spawn(3, 43, 0, pickup.Position, nilvector, pickup)
			afly:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
			afly:Update()
		end
		pickup:Remove()
	end
end

mod:AddCallback(ModCallbacks.MC_POST_PICKUP_UPDATE, function(_, pickup)
	mod:keeperFlyCheck(pickup)
	local sprite = pickup:GetSprite()
	if sprite:IsFinished("Appear") then
		sprite:Play("Idle", false)
	end
	if sprite:IsPlaying("Collect") and sprite:GetFrame() == 5 then
		pickup:Remove()
	end
	if sprite:IsEventTriggered("DropSound") then
		sfx:Play(SoundEffect.SOUND_MEAT_FEET_SLOW0, 1, 0, false, 1.0)
	end
end, PickupVariant.PICKUP_FIENDFOLIO_HALF_BLACK_HEART)

mod:AddCallback(ModCallbacks.MC_PRE_PICKUP_COLLISION, function(_, pickup, collider)
	if collider.Type == EntityType.ENTITY_PLAYER then
		local collider = collider:ToPlayer()
		local sprite = pickup:GetSprite()
		
		if pickup:IsShopItem() and (pickup.Price > collider:GetNumCoins() or not collider:IsExtraAnimationFinished()) then
			return true
		elseif sprite:IsPlaying("Collect") then
			return true
		elseif pickup.Wait > 0 then
			return not sprite:IsPlaying("Idle")
		elseif sprite:WasEventTriggered("DropSound") or sprite:IsPlaying("Idle") then
			if pickup.Price == PickupPrice.PRICE_SPIKES then
				local tookDamage = collider:TakeDamage(2.0, 268435584, EntityRef(nil), 30)
				if not tookDamage then
					return pickup:IsShopItem()
				end
			end
			
			if collider:CanPickBlackHearts() then
				collider:AddBlackHearts(1)
				if collider:HasTrinket(FiendFolio.ITEM.ROCK.ODDLY_SMOOTH_STONE) then
					local mult = math.ceil(mod.GetGolemTrinketPower(collider, FiendFolio.ITEM.ROCK.ODDLY_SMOOTH_STONE))
					local heartString = mod:intToBinary(collider:GetBlackHearts())
					local _,hearts = string.gsub(heartString, "1", " ")
					local black = (collider:GetHeartLimit()/2)-hearts
					local souls = collider:GetSoulHearts()-hearts*2
					local fakeMult = mult
					if mult % 2 ~= 0 then
						fakeMult = mult+1
					end

					if fakeMult >= souls and souls > 0 then
						mult = souls-2
					elseif mult >= black*2 then
						mult = (black*2)-1
					end
					collider:AddBlackHearts(mult)
				end
				sfx:Play(SoundEffect.SOUND_UNHOLY, 1, 0, false, 1)
			else
				return pickup:IsShopItem()
			end

			if pickup.OptionsPickupIndex ~= 0 then
				local pickups = Isaac.FindByType(EntityType.ENTITY_PICKUP)
				for _, entity in ipairs(pickups) do
					if entity:ToPickup().OptionsPickupIndex == pickup.OptionsPickupIndex and
					   (entity.Index ~= pickup.Index or entity.InitSeed ~= pickup.InitSeed)
					then
						Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.POOF01, 0, entity.Position, Vector.Zero, nil)
						entity:Remove()
					end
				end
			end

			if pickup:IsShopItem() then
				local pickupSprite = pickup:GetSprite()
				local holdSprite = Sprite()
				
				holdSprite:Load(pickupSprite:GetFilename(), true)
				holdSprite:Play(pickupSprite:GetAnimation(), true)
				holdSprite:SetFrame(pickupSprite:GetFrame())
				collider:AnimatePickup(holdSprite)
				
				if pickup.Price > 0 then
					collider:AddCoins(-1 * pickup.Price)
				end
				
				CustomHealthAPI.Library.TriggerRestock(pickup)
				CustomHealthAPI.Helper.TryRemoveStoreCredit(collider)
				
				pickup.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
				pickup:Remove()
			else
				sprite:Play("Collect", true)
				pickup.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
				pickup:Die()
			end
			
			Game():GetLevel():SetHeartPicked()
			Game():ClearStagesWithoutHeartsPicked()
			Game():SetStateFlag(GameStateFlag.STATE_HEART_BOMB_COIN_PICKED, true)
			
			return true
		else
			return false
		end
	end
end, PickupVariant.PICKUP_FIENDFOLIO_HALF_BLACK_HEART)

mod:AddCallback(ModCallbacks.MC_POST_PICKUP_UPDATE, function(_, pickup)
	mod:keeperFlyCheck(pickup)
	local sprite = pickup:GetSprite()
	if sprite:IsFinished("Appear") then
		sprite:Play("Idle", false)
	end
	if sprite:IsPlaying("Collect") and sprite:GetFrame() == 5 then
		pickup:Remove()
	end
	if sprite:IsEventTriggered("DropSound") then
		sfx:Play(SoundEffect.SOUND_MEAT_FEET_SLOW0, 1, 0, false, 1.0)
	end
end, PickupVariant.PICKUP_FIENDFOLIO_BLENDED_BLACK_HEART)

mod:AddCallback(ModCallbacks.MC_PRE_PICKUP_COLLISION, function(_, pickup, collider)
	if collider.Type == EntityType.ENTITY_PLAYER then
		local collider = collider:ToPlayer()
		local sprite = pickup:GetSprite()
		
		if pickup:IsShopItem() and (pickup.Price > collider:GetNumCoins() or not collider:IsExtraAnimationFinished()) then
			return true
		elseif sprite:IsPlaying("Collect") then
			return true
		elseif pickup.Wait > 0 then
			return not sprite:IsPlaying("Idle")
		elseif sprite:WasEventTriggered("DropSound") or sprite:IsPlaying("Idle") then
			local redIsDoubled = collider:HasCollectible(CollectibleType.COLLECTIBLE_MAGGYS_BOW)
			
			if pickup.Price == PickupPrice.PRICE_SPIKES then
				local tookDamage = collider:TakeDamage(2.0, 268435584, EntityRef(nil), 30)
				if not tookDamage then
					return pickup:IsShopItem()
				end
			end
			
			if collider:CanPickRedHearts() or 
			   collider:CanPickBlackHearts()
			then
				for i = 1, 2 do
					if collider:CanPickRedHearts() then
						local hp = 1
						if redIsDoubled then
							hp = hp * 2
						end
						collider:AddHearts(hp)
						if collider:HasTrinket(FiendFolio.ITEM.ROCK.ODDLY_SMOOTH_STONE) then
							local mult = math.ceil(mod.GetGolemTrinketPower(collider, FiendFolio.ITEM.ROCK.ODDLY_SMOOTH_STONE))
							local reds = (collider:GetEffectiveMaxHearts() - collider:GetHearts())
							if mult >= reds then
								mult = reds-1
							end
							collider:AddHearts(mult)
						end
						SFXManager():Play(SoundEffect.SOUND_BOSS2_BUBBLES, 1, 0, false, 1.0)
					elseif collider:CanPickBlackHearts() then
						collider:AddBlackHearts(1)
						sfx:Play(SoundEffect.SOUND_UNHOLY, 1, 0, false, 1)
					end
				end
			else
				return pickup:IsShopItem()
			end

			if pickup.OptionsPickupIndex ~= 0 then
				local pickups = Isaac.FindByType(EntityType.ENTITY_PICKUP)
				for _, entity in ipairs(pickups) do
					if entity:ToPickup().OptionsPickupIndex == pickup.OptionsPickupIndex and
					   (entity.Index ~= pickup.Index or entity.InitSeed ~= pickup.InitSeed)
					then
						Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.POOF01, 0, entity.Position, Vector.Zero, nil)
						entity:Remove()
					end
				end
			end

			if pickup:IsShopItem() then
				local pickupSprite = pickup:GetSprite()
				local holdSprite = Sprite()
				
				holdSprite:Load(pickupSprite:GetFilename(), true)
				holdSprite:Play(pickupSprite:GetAnimation(), true)
				holdSprite:SetFrame(pickupSprite:GetFrame())
				collider:AnimatePickup(holdSprite)
				
				if pickup.Price > 0 then
					collider:AddCoins(-1 * pickup.Price)
				end
				
				CustomHealthAPI.Library.TriggerRestock(pickup)
				CustomHealthAPI.Helper.TryRemoveStoreCredit(collider)
				
				pickup.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
				pickup:Remove()
			else
				sprite:Play("Collect", true)
				pickup.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
				pickup:Die()
			end
			
			Game():GetLevel():SetHeartPicked()
			Game():ClearStagesWithoutHeartsPicked()
			Game():SetStateFlag(GameStateFlag.STATE_HEART_BOMB_COIN_PICKED, true)
			
			return true
		else
			return false
		end
	end
end, PickupVariant.PICKUP_FIENDFOLIO_BLENDED_BLACK_HEART)

mod.d12ed_Rooms = {}
mod:AddCallback(ModCallbacks.MC_USE_ITEM, function()
	mod:ChangeD12Grids(mod.D12Grid)
	local RoomSeed = game:GetRoom():GetSpawnSeed() * 10
	if game:GetRoom():IsMirrorWorld() then RoomSeed = RoomSeed+1 end
	if not mod.d12ed_Rooms[RoomSeed] then mod.d12ed_Rooms[RoomSeed] = {} end
	mod.d12ed_Rooms[RoomSeed].Type = 1		-- 1: d12   ; 2: ed12
end, CollectibleType.COLLECTIBLE_D12)

function mod:checkD12Rocks()
	local RoomSeed = game:GetRoom():GetSpawnSeed() * 10
	if game:GetRoom():IsMirrorWorld() then RoomSeed = RoomSeed+1 end
	if mod.d12ed_Rooms[RoomSeed] then
		if mod.d12ed_Rooms[RoomSeed].Type == 1 then
			mod:ChangeD12Grids(mod.D12Grid)
		elseif mod.d12ed_Rooms[RoomSeed].Type == 2 then
			mod:ChangeD12Grids(mod.ED12Grid)
		end
		if mod.d12ed_Rooms[RoomSeed].fromPal == 1 then mod.d12ed_Rooms[RoomSeed].fromPal = nil end
	end
end

function mod:ChangeD12Grids(D12GridType)
  local room = game:GetRoom()
  local backdrop = 1<<(Game():GetRoom():GetBackdropType())
  local backdropFlags =  1<<1 | 1<<2 | 1<<3 | 1<<15 | 1<<19 | 1<<20 | 1<<21 | 1<<22 | 1<<24 | 1<<25 | 1<<26 | 1<<28 | 1<<35 | 1<<50 | 1<<51 | 1<<52 | 1<<53 | 1<<54
  local potGfx = (backdropFlags & backdrop) ~= 0
  local d12Gfx = D12GridType.Rocks
  local altGfx
  local roomgfx = mod:getCurrentRoomGfx()
  if roomgfx and type(roomgfx) ~= "function" and roomgfx.Grids and roomgfx.Grids.Rocks then
	altGfx = roomgfx.Grids.Rocks
  end
  for i = 0, room:GetGridSize() do
	local customGrids = StageAPI.GetCustomGrids(i)
	local customGridBlocking = false
	for _, cgrid in ipairs(customGrids) do
		if not cgrid.GridConfig.NoOverrideGridSprite then
			customGridBlocking = true
		end
	end
	if not customGridBlocking then
	  grid = room:GetGridEntity(i)
	  if grid then
		local send = {Grid = grid}
		if StageAPI.RockTypes[grid.Desc.Type] then
		  if grid.Desc.Type == GridEntityType.GRID_ROCK_ALT then
			if potGfx then
			  StageAPI.ChangeRock(send, d12Gfx)
			elseif altGfx then
			  StageAPI.ChangeRock(send, altGfx)
			end
		  else
			StageAPI.ChangeRock(send, d12Gfx)
		  end
		end
	  end
	end
  end
  StageAPI.CallGridPostInit()
end

--D12 Dice Room, D12DiceRoom
mod:AddCallback(ModCallbacks.MC_PRE_ENTITY_SPAWN, function(_, etype, evar, esub, pos, vel, spawner, seed)
  	local room = game:GetRoom()
  	if etype == 1000 and evar == 76 and esub <= 5 
 	and room:GetFrameCount() == 0 
  	and room:IsFirstVisit() 
  	and math.random(4) 
  	and not (TaintedTreasure and TaintedTreasure:IsRoomDescTainted(game:GetLevel():GetCurrentRoomDesc())) then
		math.randomseed(room:GetSpawnSeed())
		if math.random(7) == 7 then
	 		return {1000, 76, 880, seed}
		end
  	end
end)

mod:AddCallback(ModCallbacks.MC_POST_EFFECT_UPDATE, function(_, effect)
  	if (effect.SubType == 880 or effect.SubType == 881) and effect.FrameCount == 0 then
		StageAPI.ChangeRoomGfx(mod.D12BackdropExt)
 	end
end, 76)

mod:AddCallback(ModCallbacks.MC_POST_EFFECT_UPDATE, function(_, effect)
  if effect.SubType == 880 then
	local players = Isaac.FindByType(1, -1, -1, false, false)
	for _, player in ipairs(players) do
	  local pos = player.Position - effect.Position
	  --print(tostring(pos.X) .. " " .. tostring(pos.Y))
	  if pos.X > -75 and pos.X < 75 and pos.Y > -75 and pos.Y < 75 then
		Isaac.Spawn(1000, 76, 881, effect.Position, Vector(0, 0), nil)
		effect:Remove()
		mod.d12switch = true
	  end
	end
  end
end, 76)

mod:AddCallback(ModCallbacks.MC_POST_UPDATE, function()
	local room = game:GetRoom()
	if room:IsClear() and mod.d12switch then
		local RoomSeed = room:GetSpawnSeed() * 10
		if room:IsMirrorWorld() then RoomSeed = RoomSeed+1 end
		if not mod.d12ed_Rooms[RoomSeed] then mod.d12ed_Rooms[RoomSeed] = {} end
		if not mod.d12ed_Rooms[RoomSeed].fromPal then
			local delay = 25
			if room:GetFrameCount() == 1 then delay = 0 end
			mod.scheduleForUpdate(function()
				--mod.d12ed_Rooms[RoomSeed].fromPal = true
				local pos = room:FindFreeTilePosition(room:GetCenterPos(), 1000)
				Isaac.Spawn(1000, 1880, 0, pos, Vector(0,0), nil)
			end, delay)
			mod.d12ed_Rooms[RoomSeed].fromPal = 1		--In progress
		end
	end
end)

mod:AddCallback(ModCallbacks.MC_POST_EFFECT_UPDATE, function(_, effect)
	local sprite = effect:GetSprite()
	if effect.FrameCount == 1 then
		sprite:PlayOverlay("1+", true)
		SFXManager():Play(173, 1.5, 0, false, 3.5)
	end
	if sprite:IsEventTriggered("Drop") then
		local room = game:GetRoom()
		local RoomSeed = room:GetSpawnSeed() * 10
		if room:IsMirrorWorld() then RoomSeed = RoomSeed+1 end
		SFXManager():Play(49, 1, 0, false, 0.75)
		mod.reroll_grids({2, 3, 4, 5, 6, 12, 14, 22, 25, 27}, false, true, false)
		if not mod.d12ed_Rooms[RoomSeed] then mod.d12ed_Rooms[RoomSeed] = {} end
		mod.d12ed_Rooms[RoomSeed].fromPal = true
	end
	if sprite:IsEventTriggered("Vanish") then
		for i=0, 10 do
			local vec = RandomVector()
			vec = Vector(vec.X*2, -math.abs(vec.Y)-0.25)*(0.6 + math.random()*0.6)
			local p = Isaac.Spawn(1000, 111, 0, effect.Position + vec*10, vec*3, effect)
			p:GetSprite().Scale = Vector(0.1, 0.1)
			p:SetColor(Color(1,1,1,1,255,255,255), 0, 0, false, false)
		end
	end
end, 1880)

function mod:stopTNTBarrelsFromBeinDumb(eff)
	if not eff:GetData().turnedIntoCoolBetterParticles then
		if mod.FindClosestEntity(eff.Position, 5, 292, 750) then
			eff:GetSprite():ReplaceSpritesheet(0, "gfx/grid/super_tnt.png")
			eff:GetSprite():LoadGraphics()
		end

		eff:GetData().turnedIntoCoolBetterParticles = true
	end

end
mod:AddCallback(ModCallbacks.MC_POST_EFFECT_UPDATE, mod.stopTNTBarrelsFromBeinDumb, EffectVariant.WOOD_PARTICLE)

-- Pocket Items


mod:AddCallback(ModCallbacks.MC_PRE_USE_ITEM, function(_, CollectibleID, r, player, flags, ActiveSlot)
	local card = player:GetCard(0)
	if card then
		if FiendFolio.GlassDiceBySubtype[card] then
			player:AnimateCollectible(CollectibleType.COLLECTIBLE_BLANK_CARD, "UseItem", "PlayerPickup")
			return true
		elseif card == Card.TWO_OF_WANDS then
			player:SetActiveCharge(0,ActiveSlot)
		end
	end
end, CollectibleType.COLLECTIBLE_BLANK_CARD)

mod:AddCallback(ModCallbacks.MC_POST_PICKUP_INIT, function(_, pickup)
	--[[local cardConfig = FiendFolio.CardsBySubtype[pickup.SubType]
	if cardConfig then
		local sprite = pickup:GetSprite()
		local appear = sprite:IsPlaying("Appear")
		sprite:Load(cardConfig.back, true)
		sprite:Play(appear and "Appear" or "Idle", false)
	end]]
end, PickupVariant.PICKUP_TAROTCARD)

mod:AddCallback(ModCallbacks.MC_POST_PICKUP_UPDATE, function(_, pickup) --ref 1
	if not FiendFolio.ItemsEnabled and FiendFolio.CardsBySubtype[pickup.SubType] then
		pickup:Remove()
		Isaac.Spawn(5, PickupVariant.PICKUP_TAROTCARD, 0, pickup.Position, nilvector, nil)
		return
	end
end, PickupVariant.PICKUP_TAROTCARD)

-- Replaces the pickup sound for FF objects from the default card sound to the correct one for objects.
mod:AddCallback(ModCallbacks.MC_POST_UPDATE, function()
	if mod.ReplaceObjectPickupSound then
		mod.ReplaceObjectPickupSound = false
		if sfx:IsPlaying(SoundEffect.SOUND_BOOK_PAGE_TURN_12) then
			sfx:Play(SoundEffect.SOUND_SHELLGAME, 1, 0, false, 1)
			sfx:Stop(SoundEffect.SOUND_BOOK_PAGE_TURN_12)
		end
	end
end)

-- Triggers the above sound replacement.
mod:AddCallback(ModCallbacks.MC_PRE_PICKUP_COLLISION, function(_, p, c)
	if c.Type == 1 and FiendFolio.PocketObjects[p.SubType] then
		if c:ToPlayer():CanPickupItem() and not c:ToPlayer():IsHoldingItem() then
			mod.ReplaceObjectPickupSound = true
		end
	end
end, 300)

mod:AddCallback(ModCallbacks.MC_USE_CARD, function(_, card, player, flags)
	local data = player:GetData().ffsavedata

	data.orbitingfireballs = math.min(data.orbitingfireballs + 3, 12)
	player:AddCacheFlags(CacheFlag.CACHE_FAMILIARS)
	player:EvaluateItems()

	FiendFolio:trySayAnnouncerLine(mod.Sounds.VACardThreeFireballs, flags, 20)
end, Card.PLUS_3_FIREBALLS)

mod:AddCallback(ModCallbacks.MC_USE_CARD, function(...)
	local player = mod:GetPlayerUsingItem()
	player:UseActiveItem(CollectibleType.COLLECTIBLE_D6, false, false, true, false)
end, Card.GLASS_D6)

mod:AddCallback(ModCallbacks.MC_USE_CARD, function(...)
	local player = mod:GetPlayerUsingItem()
	local bags = player:GetCollectibleNum(CollectibleType.COLLECTIBLE_DICE_BAG)
	for i = 1, bags do
		player:RemoveCollectible(CollectibleType.COLLECTIBLE_DICE_BAG)
	end
	player:UseActiveItem(CollectibleType.COLLECTIBLE_D4, false, false, true, false)
	for i = 1, bags do
		player:AddCollectible(CollectibleType.COLLECTIBLE_DICE_BAG, 0, false)
	end
end, Card.GLASS_D4)

mod:AddCallback(ModCallbacks.MC_USE_CARD, function(...)
	local player = mod:GetPlayerUsingItem()
	player:UseActiveItem(CollectibleType.COLLECTIBLE_D8, false, false, true, false)
end, Card.GLASS_D8)

mod:AddCallback(ModCallbacks.MC_USE_CARD, function(...)
	local player = mod:GetPlayerUsingItem()
	local bags = player:GetCollectibleNum(CollectibleType.COLLECTIBLE_DICE_BAG)
	for i = 1, bags do
		player:RemoveCollectible(CollectibleType.COLLECTIBLE_DICE_BAG)
	end
	player:UseActiveItem(CollectibleType.COLLECTIBLE_D100, false, false, true, false)
	for i = 1, bags do
		player:AddCollectible(CollectibleType.COLLECTIBLE_DICE_BAG, 0, false)
	end
end, Card.GLASS_D100)

mod:AddCallback(ModCallbacks.MC_USE_CARD, function(...)
	local player = mod:GetPlayerUsingItem()
	player:UseActiveItem(CollectibleType.COLLECTIBLE_D10, false, false, true, false)
end, Card.GLASS_D10)

mod:AddCallback(ModCallbacks.MC_USE_CARD, function(...)
	local player = mod:GetPlayerUsingItem()
	player:UseActiveItem(CollectibleType.COLLECTIBLE_D20, false, false, true, false)
end, Card.GLASS_D20)

mod:AddCallback(ModCallbacks.MC_USE_CARD, function(...)
	local player = mod:GetPlayerUsingItem()
	player:UseActiveItem(CollectibleType.COLLECTIBLE_D12, false, false, true, false)
end, Card.GLASS_D12)

mod:AddCallback(ModCallbacks.MC_USE_CARD, function(...)
	local player = mod:GetPlayerUsingItem()
	player:UseActiveItem(CollectibleType.COLLECTIBLE_SPINDOWN_DICE , false, false, true, false)
end, Card.GLASS_SPINDOWN)

mod:AddCallback(ModCallbacks.MC_USE_CARD, function(...)
	local player = mod:GetPlayerUsingItem()
	player:UseActiveItem(CollectibleType.COLLECTIBLE_AZURITE_SPINDOWN , false, false, true, false)
end, Card.GLASS_AZURITE_SPINDOWN)

--Storage Battery Code
mod:AddCallback(ModCallbacks.MC_POST_PICKUP_UPDATE, function(_, pickup)
	local data = pickup:GetData()
	if not data.CheckedStorageBatterySheet then
		data.CheckedStorageBatterySheet = true

		local sprite = pickup:GetSprite()

		--Change Spritesheet
		if pickup.SubType == Card.STORAGE_BATTERY_1 then
			sprite:ReplaceSpritesheet(0, "gfx/items/pick ups/storage_battery_02.png")
		elseif pickup.SubType == Card.STORAGE_BATTERY_2 then
			sprite:ReplaceSpritesheet(0, "gfx/items/pick ups/storage_battery_03.png")
		elseif pickup.SubType == Card.STORAGE_BATTERY_3 then
			sprite:ReplaceSpritesheet(0, "gfx/items/pick ups/storage_battery_04.png")
		elseif pickup.SubType == Card.CORRODED_BATTERY_1 then
			sprite:ReplaceSpritesheet(0, "gfx/items/pick ups/corroded_battery_02.png")
		elseif pickup.SubType == Card.CORRODED_BATTERY_2 then
			sprite:ReplaceSpritesheet(0, "gfx/items/pick ups/corroded_battery_03.png")
		elseif pickup.SubType == Card.CORRODED_BATTERY_3 then
			sprite:ReplaceSpritesheet(0, "gfx/items/pick ups/corroded_battery_04.png")
		end
		sprite:LoadGraphics()
	end
end, PickupVariant.PICKUP_TAROTCARD)

--Clear Case
mod:AddCallback(ModCallbacks.MC_PRE_PICKUP_COLLISION, function(_, collectible, collider, low)
	local player = collider:ToPlayer()
	if not player or collectible.SubType == 0 or not player:CanPickupItem() then return end

	local isCainB = player:GetPlayerType() == PlayerType.PLAYER_CAIN_B
	local customPickedUp
	local morphed
	if collectible.SubType == CollectibleType.COLLECTIBLE_CLEAR_CASE and not isCainB then
		customPickedUp = true
		local collectibleConfig = Isaac.GetItemConfig():GetCollectible(CollectibleType.COLLECTIBLE_CLEAR_CASE_PASSIVE)
		player:AnimateCollectible(CollectibleType.COLLECTIBLE_CLEAR_CASE_PASSIVE)
		player:QueueItem(collectibleConfig, 0, true)
		game:GetHUD():ShowItemText(player, collectibleConfig)
		local pocketActive = player:GetActiveItem(ActiveSlot.SLOT_POCKET)
		if pocketActive > 0 then
			player:RemoveCollectible(pocketActive, false, ActiveSlot.SLOT_POCKET)
			collectible:Morph(collectible.Type, collectible.Variant, pocketActive, true, true, true)
			morphed = true
		end
	elseif player:HasCollectible(CollectibleType.COLLECTIBLE_CLEAR_CASE_PASSIVE) and isCainB then
		customPickedUp = true
		player:RemoveCollectible(CollectibleType.COLLECTIBLE_CLEAR_CASE_PASSIVE)
		local collectibleConfig = Isaac.GetItemConfig():GetCollectible(collectible.SubType)
		player:QueueItem(collectibleConfig, 0, true)
		player:AnimateCollectible(collectible.SubType)
		game:GetHUD():ShowItemText(player, collectibleConfig)
		sfx:Play(SoundEffect.SOUND_CHEST_OPEN, 1, 0, false, 1)
	elseif player:HasCollectible(CollectibleType.COLLECTIBLE_CLEAR_CASE) and collectible.SubType > 0 and not isCainB then
		local collectibleConfig = Isaac.GetItemConfig():GetCollectible(collectible.SubType)
		if collectibleConfig.Type == ItemType.ITEM_ACTIVE then
			customPickedUp = true
			player:RemoveCollectible(CollectibleType.COLLECTIBLE_CLEAR_CASE)
			player:SetPocketActiveItem(collectible.SubType)
			player:AnimateCollectible(collectible.SubType)
			game:GetHUD():ShowItemText(player, collectibleConfig)
			sfx:Play(SoundEffect.SOUND_CHEST_OPEN, 1, 0, false, 1)
		end
	end

	if customPickedUp then
		if not morphed then
			collectible.SubType = 0
			collectible:GetSprite():Play("Empty", true)

			-- hacky fix for collectible shadow
			collectible:GetSprite():ReplaceSpritesheet(4, "stageapi/none.png")
			collectible:GetSprite():LoadGraphics()
		end

		local pickupGroupNumber
		if collectible.OptionsPickupIndex ~= 0 then
			pickupGroupNumber = collectible.OptionsPickupIndex
		end

		for _, pickup in ipairs(Isaac.FindByType(5, 100, -1, false, false)) do
			if pickup:ToPickup().OptionsPickupIndex == pickupGroupNumber and pickupGroupNumber ~= 0 then
				local e = Isaac.Spawn(1000, 15, 2, pickup.Position, nilvector, nil)
				pickup:Remove()
			end
		end
	end
end, PickupVariant.PICKUP_COLLECTIBLE)

--Small Contraband
mod:AddCallback(ModCallbacks.MC_POST_PICKUP_INIT, function(_, pickup)
	local savedata = Isaac.GetPlayer():GetData().ffsavedata
	if (pickup.SubType == Card.SMALL_CONTRABAND) then
		if pickup.SpawnerEntity ~= nil then
			local e = Isaac.Spawn(154, 0, 0, Vector(300,-50), nilvector, nil)
			e.GridCollisionClass = 0
			e:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
			e:AddEntityFlags(EntityFlag.FLAG_NO_REWARD)
			local en = e:ToNPC()
			en.CanShutDoors = false
		end
	end
end, PickupVariant.PICKUP_TAROTCARD)

mod:AddCallback(ModCallbacks.MC_USE_CARD, function(_, cardid, player, flags)
	local suspiciouswhitecolor = Color(1,1,1,0.5,0,0,0)
	local creepEnt = Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.PLAYER_CREEP_WHITE, 0, player.Position, Vector(0,0), player);
	local creep = creepEnt:ToEffect()
	creepEnt:SetColor(suspiciouswhitecolor,99999, 1, false, false)
	creep.SpriteScale = Vector(0.2, 0.2)
	creep:SetTimeout(88888)
	creep:Update()
	FiendFolio:trySayAnnouncerLine(mod.Sounds.VACardSmallContraband, flags, 20)
end, Card.SMALL_CONTRABAND)

--Snagger Steals contraband
mod:AddCallback(ModCallbacks.MC_POST_NEW_ROOM, function(_)
	 for _, card in ipairs(Isaac.FindByType(5, 300, Card.SMALL_CONTRABAND, false, false)) do
			local e = Isaac.Spawn(154, 0, 0, card.Position, nilvector, nil)
			e.GridCollisionClass = 0
			e:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
			e:AddEntityFlags(EntityFlag.FLAG_NO_REWARD)
			local en = e:ToNPC()
			en.CanShutDoors = false
	end
		 for _, card in ipairs(Isaac.FindByType(5, 100, CollectibleType.COLLECTIBLE_CONTRABAND, false, false)) do
			local e = Isaac.Spawn(154, 0, 0, card.Position, nilvector, nil)
			e.GridCollisionClass = 0
			e:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
			e:AddEntityFlags(EntityFlag.FLAG_NO_REWARD)
			local en = e:ToNPC()
			en.CanShutDoors = false
		end
end)

--There's probably a better way to make vanilla defusables; but the entity ENUM only gives ID.
FiendFolio.DefusableEnums = {
DEFUSABLE_FLY_BOMB = {ID = 819, Var = 0, Sub = 0},
DEFUSABLE_BOMB = {ID = 4, Var = 0, Sub = 0},
DEFUSABLE_TROLL_BOMB = {ID = 4, Var = 3, Sub = 0},
DEFUSABLE_MEGATROLL_BOMB = {ID = 4, Var = 4, Sub = 0},
DEFUSABLE_GIGA_BOMB = {ID = 4, Var = 17, Sub = 0},
DEFUSABLE_GOLDEN_TROLL_BOMB = {ID = 4, Var = 18, Sub = 0},
DEFUSABLE_TICKING_SPIDER = {ID = 250, Var = 0, Sub = 0},
DEFUSABLE_TICKING_FLY = {ID = 214, Var = 715, Sub = 0},
DEFUSABLE_SPLODUM = {ID = 23, Var = 961, Sub = 0},
DEFUSABLE_POISON_MIND = {ID = 301, Var = 0, Sub = 0},
DEFUSABLE_MULLIBOOM = {ID = 16, Var = 2, Sub = 0},
DEFUSABLE_MULLIKABOOM = {ID = 160, Var = 550, Sub = 0},
DEFUSABLE_BOOM_FLY = {ID = 25, Var = 0, Sub = 0},
DEFUSABLE_KAMIKAZE_LEECH = {ID = 55, Var = 1, Sub = 0},
DEFUSABLE_MIGRAINE = {ID = 869, Var = 0, Sub = 0},
DEFUSABLE_BLACK_BONY = {ID = 277, Var = 0, Sub = 0},
DEFUSABLE_COIN_BOMB = {ID = 293, Var = 2, Sub = 0},
DEFUSABLE_BOMB_BUM = {ID = 6, Var = 9, Sub = 0},
DEFUSABLE_ANTI_GOLEM = {ID = 114, Var = 19, Sub = 1},
DEFUSABLE_TAINTED_BOOM_FLY = {ID = 25, Var = 6, Sub = 0},
DEFUSABLE_WRATH = {ID = 48, Var = 0, Sub = 0},
DEFUSABLE_SUPER_WRATH = {ID = 48, Var = 1, Sub = 0}
}

mod.DefusableBombs = {
	mod.DefusableEnums.DEFUSABLE_FLY_BOMB,
	mod.DefusableEnums.DEFUSABLE_BOMB,
	mod.DefusableEnums.DEFUSABLE_TROLL_BOMB,
	mod.DefusableEnums.DEFUSABLE_MEGATROLL_BOMB,
	mod.DefusableEnums.DEFUSABLE_COIN_BOMB,
}

--Write Defusable enemy constants here
mod.DefusableUniques = {
	mod.FF.Bombmuncher,
	mod.DefusableEnums.DEFUSABLE_TICKING_SPIDER,
	mod.DefusableEnums.DEFUSABLE_TICKING_FLY,
	mod.DefusableEnums.DEFUSABLE_SPLODUM,
	mod.DefusableEnums.DEFUSABLE_POISON_MIND,
	mod.DefusableEnums.DEFUSABLE_GIGA_BOMB,
	mod.DefusableEnums.DEFUSABLE_GOLDEN_TROLL_BOMB,
	mod.DefusableEnums.DEFUSABLE_MULLIBOOM,
	mod.DefusableEnums.DEFUSABLE_MULLIKABOOM,
	mod.DefusableEnums.DEFUSABLE_BOOM_FLY,
	mod.DefusableEnums.DEFUSABLE_KAMIKAZE_LEECH,
	mod.DefusableEnums.DEFUSABLE_MIGRAINE,
	mod.DefusableEnums.DEFUSABLE_BLACK_BONY,
	mod.DefusableEnums.DEFUSABLE_BOMB_BUM,
	mod.DefusableEnums.DEFUSABLE_ANTI_GOLEM,
	mod.DefusableEnums.DEFUSABLE_TAINTED_BOOM_FLY,
	mod.DefusableEnums.DEFUSABLE_WRATH,
	mod.DefusableEnums.DEFUSABLE_SUPER_WRATH,
}

local function uniqueDefuses()
  for i = 1, #mod.DefusableUniques do
	local enemDefuse = mod.DefusableUniques[i]
	--print("Size: "..#mod.DefusableUniques)
	--print("ID: "..enemDefuse.ID)
	--print("Var: "..enemDefuse.Var)
	--print("Sub: "..enemDefuse.Sub)
	local bombdrop = 0
	 for _, enemy in ipairs(Isaac.FindByType(enemDefuse.ID, enemDefuse.Var, enemDefuse.Sub, false, false)) do
		if enemDefuse == mod.FF.Bombmuncher then
		  local newEnemu = Isaac.Spawn(29, 1, 0, enemy.Position, nilvector, nil):ToNPC()
		  newEnemu:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
		  Isaac.Spawn(1000, 15, 2, enemy.Position, nilvector, nil)
		  bombdrop = 1
		elseif enemDefuse == mod.DefusableEnums.DEFUSABLE_TICKING_SPIDER then
		  local newEnemu = Isaac.Spawn(215, 0, 0, enemy.Position, nilvector, nil):ToNPC()
		  newEnemu:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
		  Isaac.Spawn(1000, 15, 2, enemy.Position, nilvector, nil)
		  bombdrop = 1
		elseif enemDefuse == mod.DefusableEnums.DEFUSABLE_TICKING_FLY then
		  local newEnemu = Isaac.Spawn(214, 0, 0, enemy.Position, nilvector, nil):ToNPC()
		  newEnemu:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
		  Isaac.Spawn(1000, 15, 2, enemy.Position, nilvector, nil)
		  bombdrop = 1
		elseif enemDefuse == mod.DefusableEnums.DEFUSABLE_SPLODUM then
		  local newEnemu = Isaac.Spawn(23, 960, 0, enemy.Position, nilvector, nil):ToNPC()
		  newEnemu:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
		  Isaac.Spawn(1000, 15, 2, enemy.Position, nilvector, nil)
		  bombdrop = 1
		elseif enemDefuse == mod.DefusableEnums.DEFUSABLE_POISON_MIND then
		  local newEnemu = Isaac.Spawn(32, 0, 0, enemy.Position, nilvector, nil):ToNPC()
		  newEnemu:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
		  Isaac.Spawn(1000, 15, 2, enemy.Position, nilvector, nil)
		  bombdrop = 1
		elseif enemDefuse == mod.DefusableEnums.DEFUSABLE_BOOM_FLY then
		  local newEnemu = Isaac.Spawn(1000, 15, 0, enemy.Position, nilvector, nil)
		  bombdrop = 1
		elseif enemDefuse == mod.DefusableEnums.DEFUSABLE_GIGA_BOMB then
		  local newEnemu = Isaac.Spawn(5, 40, 7, enemy.Position, nilvector, nil):ToPickup()
		  bombdrop = 0
		elseif enemDefuse == mod.DefusableEnums.DEFUSABLE_GOLDEN_TROLL_BOMB then
		  local newEnemu = Isaac.Spawn(5, 40, 4, enemy.Position, nilvector, nil):ToPickup()
		  bombdrop = 0
		elseif enemDefuse == mod.DefusableEnums.DEFUSABLE_MULLIBOOM then
		  local newEnemu = Isaac.Spawn(16, 0, 0, enemy.Position, nilvector, nil):ToNPC()
		  newEnemu:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
		  Isaac.Spawn(1000, 15, 2, enemy.Position, nilvector, nil)
		  bombdrop = 1
		elseif enemDefuse == mod.DefusableEnums.DEFUSABLE_BLACK_BONY then
		  local newEnemu = Isaac.Spawn(227, 0, 0, enemy.Position, nilvector, nil):ToNPC()
		  newEnemu:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
		  Isaac.Spawn(1000, 15, 2, enemy.Position, nilvector, nil)
		  bombdrop = 1
		elseif enemDefuse == mod.DefusableEnums.DEFUSABLE_KAMIKAZE_LEECH then
		  local newEnemu = Isaac.Spawn(55, 0, 0, enemy.Position, nilvector, nil):ToNPC()
		  newEnemu:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
		  Isaac.Spawn(1000, 15, 2, enemy.Position, nilvector, nil)
		  bombdrop = 1
		elseif enemDefuse == mod.DefusableEnums.DEFUSABLE_BOMB_BUM then
		  local newEnemu = Isaac.Spawn(6, 4, 0, enemy.Position, nilvector, nil):ToPickup()
		  local newBomb = Isaac.Spawn(5, 40, 1, enemy.Position+Vector(0,30), nilvector, nil):ToPickup()
		  bombdrop = 0
		elseif enemDefuse == mod.DefusableEnums.DEFUSABLE_MIGRAINE then
		  local newEnemu = Isaac.Spawn(215, 0, 0, enemy.Position, nilvector, nil):ToNPC()
		  newEnemu:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
		  Isaac.Spawn(1000, 15, 2, enemy.Position, nilvector, nil)
		  bombdrop = 0
		  Isaac.Spawn(5, 40, 1, enemy.Position, Vector(math.random(4, 7), 0):Rotated(math.random(90)+45), nil):ToPickup()
		  Isaac.Spawn(5, 40, 1, enemy.Position, Vector(math.random(4, 7), 0):Rotated(math.random(90)+45), nil):ToPickup()
		  Isaac.Spawn(5, 40, 1, enemy.Position, Vector(math.random(4, 7), 0):Rotated(math.random(90)+45), nil):ToPickup()
		elseif enemDefuse == mod.DefusableEnums.DEFUSABLE_MULLIKABOOM then
		  local newEnemu = Isaac.Spawn(16, 0, 0, enemy.Position, nilvector, nil):ToPickup()
		  local newItem = Isaac.Spawn(5, 100, 353, enemy.Position+Vector(0,30), nilvector, nil):ToPickup()
		  bombdrop = 0
		elseif enemDefuse == mod.DefusableEnums.DEFUSABLE_ANTI_GOLEM then
		  local newEnemu = Isaac.Spawn(114, 19, 0, enemy.Position, nilvector, nil):ToNPC()
		  newEnemu:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
		  local newBomb = Isaac.Spawn(5, 41, 0, enemy.Position+Vector(0,30), nilvector, nil):ToPickup()
		  bombdrop = 0
		elseif enemDefuse == mod.DefusableEnums.DEFUSABLE_TAINTED_BOOM_FLY then
		  local newEff = Isaac.Spawn(1000, 15, 0, enemy.Position, nilvector, nil)
		  local newEnemu = Isaac.Spawn(25, 1, 0, enemy.Position, nilvector, nil):ToNPC()
		  newEnemu:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
		  local newBomb = Isaac.Spawn(5, 40, 1, enemy.Position+Vector(0,30), nilvector, nil):ToPickup()
		  newBomb = Isaac.Spawn(5, 40, 1, enemy.Position+Vector(0,-30), nilvector, nil):ToPickup()
		  newBomb = Isaac.Spawn(5, 40, 1, enemy.Position+Vector(-30,0), nilvector, nil):ToPickup()
		  newBomb = Isaac.Spawn(5, 40, 1, enemy.Position+Vector(30,0), nilvector, nil):ToPickup()
		  bombdrop = 0
		elseif enemDefuse == mod.DefusableEnums.DEFUSABLE_WRATH then
		  local newEnemu = Isaac.Spawn(10, 1, 0, enemy.Position, nilvector, nil):ToPickup()
		  local newItem = Isaac.Spawn(5, 100, 106, enemy.Position+Vector(30,0), nilvector, nil):ToPickup()
		  bombdrop = 0
		elseif enemDefuse == mod.DefusableEnums.DEFUSABLE_SUPER_WRATH then
		  local newEnemu = Isaac.Spawn(160, 1210, 0, enemy.Position, nilvector, nil):ToPickup()
		  local newItem = Isaac.Spawn(5, 100, 106, enemy.Position+Vector(30,0), nilvector, nil):ToPickup()
		  bombdrop = 0
		end
		 if bombdrop == 1 then
		  local bombPickup = Isaac.Spawn(5, 40, 1, enemy.Position, nilvector, nil):ToPickup()
		 end
		bombdrop = 0
		enemy:Remove()
	 end
	end
end


mod:AddCallback(ModCallbacks.MC_USE_CARD, function(_, cardID, player, flags)
	local room = game:GetRoom()
	local newGrids = {}
	for i=0, room:GetGridSize() do
		local gridEntity = room:GetGridEntity(i)
		if gridEntity then
			local gridpos = room:GetGridPosition(i)
			local desc = gridEntity.Desc.Type
			local pickup
			if gridEntity.Desc.Type == GridEntityType.GRID_ROCK_BOMB then
				pickup = Isaac.Spawn(5, 40, 1, gridpos, nilvector, nil):ToPickup()
				Isaac.Spawn(1000, 4, 0, gridpos, Vector(math.random(1,5),math.random(1,5)), nil)
				Isaac.Spawn(1000, 4, 0, gridpos, Vector(math.random(1,5),math.random(1,5)), nil)
				Isaac.Spawn(1000, 4, 0, gridpos, Vector(math.random(1,5),math.random(1,5)), nil)
			end
			if pickup then
				room:RemoveGridEntity(i, 0, false)
				table.insert(newGrids, i)
			end
		end
	end

	if #newGrids > 0 then
		--print(#newGrids)
		for i = 1, #newGrids do
			for k = 1, 3 do
				mod.scheduleForUpdate(function()
					room:SpawnGridEntity(newGrids[i], GridEntityType.GRID_DECORATION, 0, 0, 0)
				end, k)
			end
		end
	end

-- Defusable Bombs
	for i = 1, #mod.DefusableBombs do
	local enemDefuse = mod.DefusableBombs[i]
	 for _, enemy in ipairs(Isaac.FindByType(enemDefuse.ID, enemDefuse.Var, enemDefuse.Sub, false, false)) do
		 --print("Removing bomb!")
		local bombPickup = Isaac.Spawn(5, 40, 1, enemy.Position, nilvector, nil):ToPickup()
		enemy:Remove()
		--enemy:Explode()
	 end
	end
-- Unique Defusables
	uniqueDefuses()

--Other (I don't want it to remove him if he's still alive)
	for _, enemy in ipairs(Isaac.FindByType(mod.FF.Buster.ID, mod.FF.Buster.Var, -1, false, false)) do
		if enemy:GetSprite():IsPlaying("Death") then
			enemy:BloodExplode()
			if game:GetRoom():GetType() == RoomType.ROOM_BOSS then
				local newItem = Isaac.Spawn(5, 100, CollectibleType.COLLECTIBLE_COMMISSIONED_BADGE, enemy.Position, nilvector, nil):ToPickup()
			end
			enemy:Remove()
		end
	end
	sfx:Play(SoundEffect.SOUND_GOLDENBOMB, 1, 0, false, 1)
	FiendFolio:trySayAnnouncerLine(mod.Sounds.VACardDefuse, flags, 40)
end, Card.DEFUSE)

mod:AddCallback(ModCallbacks.MC_USE_CARD, function(_, cardID, player, flags)
	sfx:Play(mod.Sounds.YgoCard, 1, 0, false, 1)

	local drops = 2
	for i = 1, drops do
		Isaac.Spawn(5, 300, Game():GetItemPool():GetCard(player:GetCardRNG(Card.POT_OF_GREED):Next(), true, false, false), player.Position, RandomVector():Resized(math.random(4, 7)), pickup)
	end

	FiendFolio:trySayAnnouncerLine(mod.Sounds.VACardPotofGreed, flags, 40)
	if math.random(3) == 1 then
		FiendFolio:trySayAnnouncerLine(mod.Sounds.VACardPotofGreedRare, flags, 120)
	end
end, Card.POT_OF_GREED)

----------------------------------------------------------------------------------------------------------------

function mod:spritePlay(sprite, anim)
	if not sprite:IsPlaying(anim) then
		sprite:Play(anim)
	end
end

function mod:spriteOverlayPlay(sprite, anim)
	if not sprite:IsOverlayPlaying(anim) then
		sprite:PlayOverlay(anim)
	end
end

function mod:flipX(npc, vec)
	vec = vec or npc.Velocity
	local sprite = npc:GetSprite()
	if vec.X > 0 then
		sprite.FlipX = true
	else
		sprite.FlipX = false
	end
end


function mod:entIs(spawner, etype, evar, esub)
	etype = etype or nil
	evar = evar or nil
	esub = esub or nil
	if spawner ~= nil and spawner:IsEnemy() then
		if etype == nil or etype == spawner.Type then
			if evar == nil or evar == spawner.Variant then
				if esub == nil or esub == spawner.SubType then
					return true
				end
			end
		end
	end
end

function mod:momFFChampionAI(npc, var)
	local d = npc:GetData()
	local sprite = npc:GetSprite()
	if not d.init then
		d.init = true
	end

	if bpattern and hmbppttn and (Game().Difficulty % 2 == 1) then
		--remove that godawful hp scaling
		for _, enmy in ipairs(Isaac.GetRoomEntities()) do
			if (enmy.Type == 396 or enmy.Type == 45) then
				--im very good at code see
			else
				enmy:GetData().ChangedHP = true
				enmy:GetData().HPIncrease = 0.1
			end
		end

		local mom = npc
		local npcdata = mom:GetData()
		local target = mom:GetPlayerTarget()

		if (not npcdata.ffinit) then
			npcdata.ffinit = true
			npcdata.spriteswaps = 0
			npcdata.spriteswapsneeded = 2
			--vanilla that might be needed
			npcdata.eyeHp = math.max(15, 1.5*GetPlayerDps)
			npcdata.hurt = false
			npcdata.doorbroken = false
			npcdata.handpos = Vector(0,0)
			npcdata.numspider = 1
			npcdata.footframes = 0
			npcdata.checkphase2 = true
			npcdata.imfat = false
			mom.I1 = 0
		end

		if npcdata.checkphase2 then
			if npcdata.phase2 then
				npcdata.checkphase2 = false
				mod.secondphasestomp = true
			end
		end

		--Isaac.ConsoleOutput(tostring(mod.secondphasestomp))

		if npcdata.doorbroken then
			mod.secondphasestomp = false
			npcdata.spriteswapsneeded = 3
		end

		if npcdata.spriteswaps < npcdata.spriteswapsneeded then
			if mom.Variant == 10 or mom.Variant == 20 then
				sprite:Load("gfx/bosses/champions/mom/momstomphmmbp.anm2", true)
				sprite:SetFrame("Stomp", 0)
				if mom.Variant == 20 then
					if mod.momframes then
						npcdata.secondfoot = true
					end
					mod.momframes = true
				end
			else
				if npcdata.doorbroken then
					sprite:Load("gfx/bosses/champions/mom/momdoorhmmbp.anm2", true)
					sprite:Play("DoorBreak", true)
					npcdata.imfat = true
					npcdata.numspider = 1
				else
					sprite:Load("gfx/bosses/champions/mom/momhmmbp.anm2", true)
					sprite:Play("MomDefalut", true)
				end
			end
			npc.Color = mod.ColorNormal
			sprite:ReplaceSpritesheet(0, "gfx/bosses/champions/mom/boss_mom_purple_hmmbp.png")
			sprite:ReplaceSpritesheet(1, "gfx/bosses/champions/mom/boss_mom_purple_hmmbp.png")
			sprite:LoadGraphics()
			npcdata.spriteswaps = npcdata.spriteswaps + 1
		end

		--sprite:ReplaceSpritesheet(0, "gfx/bosses/champions/boss_mom_purple_hmmbp.png")
		--sprite:LoadGraphics()
		--finagleing with hmmbp

		if mom.Variant == 10 then
			--foot
			npcdata.footframes = npcdata.footframes + 1
			mod.momfleshframes = mod.momfleshframes - 1
			mod.momfleshbuffer = mod.momfleshbuffer - 1

			if mom.State == 7 then
				npcdata.footframes = 0
			elseif npcdata.footframes >= 180 and not (hmbppttn.MomStomping or mod.secondphasestomp) then
				npcdata.footframes = 0
				mom.State = 7
				hmbppttn.MomStomping = true
				if (math.random(1,5) > 1 and mom:GetAliveEnemyCount() < 8) or sfx:IsPlaying(84) then
					mom:PlaySound(93, 1, 0, false, 1)
					if math.random(1,2) == 1 and npcdata.phase2 then
						sprite:Play("Stomp2",true)
					else
						sprite:Play("Stomp",true)
					end
					if mom.FrameCount > 30 then
						mom.Position = target.Position
					end
				else
					sprite:Play("Stronger Stomp",true)
					mom:PlaySound(84, 1, 0, false, 1)
				end
			elseif not mod.secondframestomp then
				hmbppttn.MomStomping = false
			end

			if sprite:IsEventTriggered("Stomp") and not mod.secondphasestomp then
				local numberofflames = 12
				for i = 1, numberofflames do
					local vec = Vector(6,0):Rotated((360/numberofflames) * i)
					local fire = Isaac.Spawn(1000,7005, 1, npc.Position + vec:Resized(15), vec, npc)
					fire.Color = Color(1,1,1,1,66 / 255,13 / 255,202 / 255)
					fire:Update()
				end
			elseif sprite:IsPlaying("Stomp2") and sprite:GetFrame() == 68 then
				local numberofflames = 12
				for i = 1, numberofflames do
					local vec = Vector(6,0):Rotated((360/numberofflames) * i)
					local fire = Isaac.Spawn(1000,7005, 1, npc.Position + vec:Resized(25), vec:Resized(math.random(4, 16)), npc)
					fire.Color = Color(1,1,1,1,66 / 255,13 / 255,202 / 255)
					fire:Update()
				end
			end
		elseif mom.Variant == 20 then
			--lastfoot
			if sprite:IsEventTriggered("Stomp") then
				local numberofflames = math.random(6,10)
				for i = 1, numberofflames do
					local vec = Vector(6,0):Rotated((360/numberofflames) * i)
					local fire = Isaac.Spawn(1000,7005, 1, npc.Position + vec:Resized(25), vec:Resized(math.random(1, 12)), npc)
					fire.Color = Color(1,1,1,1,66 / 255,13 / 255,202 / 255)
					fire:Update()
				end
			end
		else
			--door
			mom.StateFrame = mom.StateFrame - 1
			if mom.State == 10 then
				mom.StateFrame = mom.StateFrame + 2
			end

			local canspawn = mod.momfleshframes <= 0 or mod.momfleshbuffer > 0

			if mom.State == 3 and mom.FrameCount >= 100 and mom.StateFrame <= 0 and not hmbppttn.MomStomping and canspawn then
				if math.random(1,12) == 3 then
					if mom.I1 ~= 1 then
						mom.State = 9
						sprite:Play("Fat0"..math.random(1,2), true)
					end
				end
			elseif npcdata.isfat and mom:GetAliveEnemyCount() >= 7 then
				mom.State = 30
				sprm:Play("KnifeThrow", true)
				hmbppttn.MomHand = hmbppttn.MomHand + 1
			end

			if sprite:IsPlaying("Wig") or sprite:IsPlaying("WigHit") or sprite:IsPlaying("WigClose") then
				for _, spidermaybe in ipairs(Isaac.GetRoomEntities()) do
					if spidermaybe.Type == 85 and spidermaybe.Variant == 0 and spidermaybe.SpawnerType == 396 then
						local r = math.random(1, 2)
						--spooter
						for i = 1, r do
							local p = spidermaybe.Position + RandomVector() * math.random(15, 35)
							EntityNPC.ThrowSpider(spidermaybe.Position, spidermaybe, p, false, 0)
						end
						for _, spidermaybelayertwo in ipairs(Isaac.GetRoomEntities()) do
							if spidermaybelayertwo.Type == 85 and spidermaybelayertwo.Variant == 0 and spidermaybelayertwo.SpawnerType == 85 then
								spidermaybelayertwo:ToNPC():Morph(85, 962 + math.random(0,math.random(0,1)), 0, -1)
							end
						end
						--baby
						local r = math.random(5, 8)
						for i = 1, r do
							local p = spidermaybe.Position + RandomVector() * math.random(15, 35)
							EntityNPC.ThrowSpider(spidermaybe.Position, spidermaybe, p, false, 0)
						end
						for _, spidermaybelayertwo in ipairs(Isaac.GetRoomEntities()) do
							if spidermaybelayertwo.Type == 85 and spidermaybelayertwo.Variant == 0 and spidermaybelayertwo.SpawnerType == 85 then
								spidermaybelayertwo:ToNPC():Morph(85, 962, 0, -1)
							end
						end
						--kill the og
						spidermaybe:Remove()
					end
				end
			elseif sprite:IsEventTriggered("ffclose") then
				mom.EntityCollisionClass = 0
			elseif sprite:IsEventTriggered("ffspawn") then
				mod:momhardpatspawn(npc, npcdata)
				mom.EntityCollisionClass = 4
			elseif sprite:IsFinished("Fat01") or sprite:IsFinished("Fat02") then
				--mom.State = 3
				--mom.StateFrame = math.random(35,100)
				mom.EntityCollisionClass = 0
			end
		end
	else
		--I'm really sorry to do this each frame, but it seems to break the door bits if not
		sprite:ReplaceSpritesheet(0, "gfx/bosses/champions/mom/boss_mom_purple.png")
		sprite:ReplaceSpritesheet(1, "gfx/bosses/champions/mom/boss_mom_purple.png")
		sprite:LoadGraphics()
		if var == 10 then
			--Isaac.ConsoleOutput(npc.State .. ", " .. sprite:GetFrame() .. "\n")
			if npc.State == 7 and sprite:GetFrame() == 27 then
				local numberofflames = 8
				for i = 1, numberofflames do
					local vec = Vector(6,0):Rotated((360/numberofflames) * i)
					local fire = Isaac.Spawn(1000,7005, 1, npc.Position + vec:Resized(20), vec, npc)
					fire.Color = Color(1,1,1,1,66 / 255,13 / 255,202 / 255)
					fire:Update()
				end
			end
		else
			if npc.State == 9 then --No hand slaps
				npc.State = 3
				sprite:SetFrame("ArmOpen", 0)
			end
		end
	end
end

function mod:momhardpatspawn(npc, npcdata)
	mod.momfleshbuffer = 10
	mod.momfleshframes = math.max(mod.momfleshframes, 0)
	if npcdata.imfat then
		mod.momfleshframes = mod.momfleshframes + 90
		npc:PlaySound(SoundEffect.SOUND_SUMMONSOUND, 1, 0, false, 0.8)
		npc:PlaySound(SoundEffect.SOUND_DEATH_BURST_LARGE, 0.75, 0, false, 1)
		--stronger selection
		local randy = math.random(1, 33)
		if randy == 1 then
			--soft serve
			e = Isaac.Spawn(mod.FF.SoftServe.ID, mod.FF.SoftServe.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 2 then
			--honeydrip
			e = Isaac.Spawn(mod.FF.Honeydrip.ID, mod.FF.Honeydrip.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 2 then
			--tallboy
			e = Isaac.Spawn(mod.FF.Tallboi.ID, mod.FF.Tallboi.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 3 then
			--calzone / panini
			e = Isaac.Spawn(mod.FF.Calzone.ID, mod.FF.Calzone.Var, math.random(0, math.random(0,1)), npc.Position, nilvector,npc):ToNPC()
		elseif randy == 4 then
			--sack boy
			e = Isaac.Spawn(mod.FF.Sackboy.ID, mod.FF.Sackboy.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 5 then
			--scythe rider
			e = Isaac.Spawn(mod.FF.ScytheRider.ID, mod.FF.ScytheRider.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 6 then
			--gis
			e = Isaac.Spawn(mod.FF.Gis.ID, mod.FF.Gis.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 7 then
			--homer
			e = Isaac.Spawn(mod.FF.Homer.ID, mod.FF.Homer.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 8 then
			--pitcher
			e = Isaac.Spawn(mod.FF.Pitcher.ID, mod.FF.Pitcher.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 9 then
			--melty
			e = Isaac.Spawn(mod.FF.Melty.ID, mod.FF.Melty.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 10 then
			--drooler
			e = Isaac.Spawn(mod.FF.Drooler.ID, mod.FF.Drooler.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 11 then
			--craterface
			e = Isaac.Spawn(mod.FF.Craterface.ID, mod.FF.Craterface.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 12 then
			--peepy
			e = Isaac.Spawn(mod.FF.Peepling.ID, mod.FF.Peepling.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 13 then
			--head honcho
			e = Isaac.Spawn(mod.FF.HeadHoncho.ID, mod.FF.HeadHoncho.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 14 then
			--brooter
			e = Isaac.Spawn(mod.FF.Brooter.ID, mod.FF.Brooter.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 15 then
			--looker
			e = Isaac.Spawn(mod.FF.Looker.ID, mod.FF.Looker.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 16 then
			--deadfly
			e = Isaac.Spawn(mod.FF.DeadFly.ID, mod.FF.DeadFly.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 17 then
			--watcher
			e = Isaac.Spawn(mod.FF.Watcher.ID, mod.FF.Watcher.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 18 then
			--sombra
			e = Isaac.Spawn(mod.FF.Sombra.ID, mod.FF.Sombra.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 19 then
			--foreseer/psyleech
			e = Isaac.Spawn(mod.FF.Foreseer.ID, mod.FF.Foreseer.Var + math.random(0,1), 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 20 then
			--crosseye
			e = Isaac.Spawn(mod.FF.Crosseyes.ID, mod.FF.Crosseyes.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 21 then
			--primemeind
			e = Isaac.Spawn(mod.FF.Primemind.ID, mod.FF.Primemind.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 22 then
			--curdle
			e = Isaac.Spawn(666, 140, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 23 then
			--ghostse
			e = Isaac.Spawn(mod.FF.Ghostse.ID, mod.FF.Ghostse.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 24 then
			--valvo
			e = Isaac.Spawn(mod.FF.Valvo.ID, mod.FF.Valvo.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 25 then
			--dr funny bones spooky scary (shambles)
			e = Isaac.Spawn(mod.FF.DrShambles.ID, mod.FF.DrShambles.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 26 then
			--cistern
			e = Isaac.Spawn(22, 666, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 27 then
			--mr gob
			e = Isaac.Spawn(mod.FF.MrGob.ID, mod.FF.MrGob.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 28 then
			--looker
			e = Isaac.Spawn(mod.FF.Looker.ID, mod.FF.Looker.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 29 then
			--enlightened
			e = Isaac.Spawn(mod.FF.Enlightened.ID, mod.FF.Var.ID, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 30 then
			--weaver variants
			e = Isaac.Spawn(mod.FF.Weaver.ID, math.random(2, 3), 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 31 then
			--peekaboo
			e = Isaac.Spawn(mod.FF.Peekaboo.ID, mod.FF.Peekaboo.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 32 then
			--squire
			e = Isaac.Spawn(mod.FF.Squire.ID, mod.FF.Squire.Var, 0, npc.Position, nilvector,npc):ToNPC()
		else
			--sniffle
			e = Isaac.Spawn(mod.FF.Sniffle.ID, mod.FF.Sniffle.Var, 0, npc.Position, nilvector,npc):ToNPC()
		end
	else
		mod.momfleshframes = mod.momfleshframes + 45
		npc:PlaySound(SoundEffect.SOUND_SUMMONSOUND, 1, 0, false, 1)
		--weaker seclection
		local randy = math.random(1, 53)
		if randy == 1 then
			--soft serve
			e = Isaac.Spawn(666, 1, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 2 then
			--soft serve sundae
			e = Isaac.Spawn(666, 2, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 3 then
			--uncommon
			randy = math.random(1, 7)
			if randy == 1 then
				--honeydrip
				e = Isaac.Spawn(mod.FF.Honeydrip.ID, mod.FF.Honeydrip.Var, 0, npc.Position, nilvector,npc):ToNPC()
			elseif randy == 2 then
				--homer
				e = Isaac.Spawn(mod.FF.Homer.ID, mod.FF.Homer.Var, 0, npc.Position, nilvector,npc):ToNPC()
			elseif randy == 3 then
				--weaver sr.
				e = Isaac.Spawn(mod.FF.WeaverSr.ID, mod.FF.WeaverSr.Var, 0, npc.Position, nilvector,npc):ToNPC()
			elseif randy == 4 then
				--roly poly
				e = Isaac.Spawn(mod.FF.RolyPoly.ID, mod.FF.RolyPoly.Var, 0, npc.Position, nilvector,npc):ToNPC()
			elseif randy == 5 then
				--bumbler
				e = Isaac.Spawn(mod.FF.Bumbler.ID, mod.FF.Bumbler.Var, 0, npc.Position, nilvector,npc):ToNPC()
			else
				--offal
				e = Isaac.Spawn(mod.FF.Offal.ID, mod.FF.Offal.Var, 0, npc.Position, nilvector,npc):ToNPC()
			end
		elseif randy == 4 then
			--hover
			e = Isaac.Spawn(mod.FF.Hover.ID, mod.FF.Hover.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 5 then
			--mr horf
			randy = math.random(1, 2)
			if randy == 1 then
				e = Isaac.Spawn(mod.FF.MrHorf.ID, mod.FF.MrHorf.Var, 0, npc.Position, nilvector,npc):ToNPC()
			else
				e = Isaac.Spawn(mod.FF.MrRedHorf.ID, mod.FF.MrRedHorf.Var, 0, npc.Position, nilvector,npc):ToNPC()
			end
		elseif randy == 6 then
			--bowler
			e = Isaac.Spawn(mod.FF.Bowler.ID, mod.FF.Bowler.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 7 then
			--rambler
			e = Isaac.Spawn(mod.FF.RamblinEvilMushroom.ID, mod.FF.RamblinEvilMushroom.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 8 then
			--woodburner
			e = Isaac.Spawn(mod.FF.Woodburner.ID, mod.FF.Woodburner.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 9 then
			--foamy
			e = Isaac.Spawn(666, 40, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 10 then
			--fathead
			e = Isaac.Spawn(666, 50, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 11 then
			--wobbles
			e = Isaac.Spawn(666, 110, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 12 then
			--dung
			e = Isaac.Spawn(mod.FF.Dung.ID, mod.FF.Dung.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 13 then
			--slim
			e = Isaac.Spawn(mod.FF.PaleSlim.ID, mod.FF.PaleSlim.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 14 then
			--dweller
			e = Isaac.Spawn(mod.FF.Dweller.ID, mod.FF.Dweller.Var, 1000, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 15 then
			--bbdb
			e = Isaac.Spawn(mod.FF.BubbleBaby.ID, mod.FF.BubbleBaby.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 16 then
			--sniffle
			e = Isaac.Spawn(mod.FF.Sniffle.ID, mod.FF.Sniffle.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 17 then
			--tadokid
			e = Isaac.Spawn(mod.FF.TadoKid.ID, mod.FF.TadoKid.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 18 then
			--boomflies
			randy = math.random(1,2)
			if randy == 1 then
				e = Isaac.Spawn(25, 960, 0, npc.Position, nilvector,npc):ToNPC()
			else
				e = Isaac.Spawn(25, 962, 0, npc.Position, nilvector,npc):ToNPC()
			end
		elseif randy == 19 then
			--spitum
			e = Isaac.Spawn(mod.FF.Spitum.ID, mod.FF.Spitum.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 20 then
			--sourpatch
			e = Isaac.Spawn(mod.FF.Sourpatch.ID, mod.FF.Sourpatch.Var, math.random(0,1), npc.Position, nilvector,npc):ToNPC()
		elseif randy == 21 then
			--nimbus
			e = Isaac.Spawn(21, 666, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy >= 22 and randy <= 25 then
			--morslel
			for i = 0, math.random(2,4) do
				e = Isaac.Spawn(mod.FF.Morsel.ID, mod.FF.Morsel.Var, 0, npc.Position + RandomVector() * math.random(0, 5), nilvector,npc):ToNPC()
				e:GetData().ChangedHP = true
				e:GetData().HPIncrease = 0.1
			end
		elseif randy == 26 then
			--ragurge
			e = Isaac.Spawn(750, 100, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy <= 27 and randy >= 29 then
			--menace
			e = Isaac.Spawn(mod.FF.Menace.ID, mod.FF.Menace.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 30 then
			--slammer
			e = Isaac.Spawn(mod.FF.Slammer.ID, math.random(4, 5), 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 31 then
			--bone slammer
			e = Isaac.Spawn(750, 140, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 32 then
			--splodum
			e = Isaac.Spawn(23, 961, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 33 then
			--posessed
			e = Isaac.Spawn(227, 750, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 34 then
			--crepitus
			e = Isaac.Spawn(227, 666, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 35 then
			--melty
			e = Isaac.Spawn(mod.FF.Melty.ID, mod.FF.Melty.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 36 then
			--tarmaw
			e = Isaac.Spawn(mod.FF.Gunk.ID, mod.FF.Gunk.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 37 then
			--guflush
			e = Isaac.Spawn(mod.FF.Guflush.ID, mod.FF.Guflush.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 38 then
			--piper
			e = Isaac.Spawn(mod.FF.Piper.ID, mod.FF.Piper.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 39 then
			--facade
			e = Isaac.Spawn(mod.FF.Facade.ID, mod.FF.Facade.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 40 then
			--gleek
			e = Isaac.Spawn(mod.FF.Gleek.ID, mod.FF.Gleek.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 41 then
			--charlie
			e = Isaac.Spawn(mod.FF.Charlie.ID, mod.FF.Charlie.Var + math.random(0,1), 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 42 then
			--beeter
			e = Isaac.Spawn(mod.FF.Beeter.ID, mod.FF.Beeter.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 43 then
			--hasunted
			e = Isaac.Spawn(mod.FF.Haunted.ID, mod.FF.Haunted.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 44 then
			--marge
			e = Isaac.Spawn(mod.FF.Marge.ID, mod.FF.Marge.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 45 then
			--sticky
			e = Isaac.Spawn(mod.FF.WalkingStickySack.ID, mod.FF.WalkingStickySack.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 46 then
			--spinneretch
			e = Isaac.Spawn(mod.FF.Spinneretch.ID, mod.FF.Spinneretch.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 47 then
			--spitroast
			e = Isaac.Spawn(mod.FF.Spitroast.ID, mod.FF.Spitroast.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 48 then
			--balor/eyesore
			e = Isaac.Spawn(mod.FF.Balor.ID, mod.FF.Balor.Var + math.random(0,1), 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 49 then
			--fishface
			e = Isaac.Spawn(mod.FF.Fishaac.ID, mod.FF.Fishaac.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 50 then
			--dr funny bones spooky scary (shambles)
			e = Isaac.Spawn(mod.FF.DrShambles.ID, mod.FF.DrShambles.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 51 then
			--gob
			e = Isaac.Spawn(mod.FF.Gob.ID, mod.FF.Gob.Var, 0, npc.Position, nilvector,npc):ToNPC()
		elseif randy == 52 then
			--umbra
			e = Isaac.Spawn(mod.FF.Umbra.ID, mod.FF.Umbra.Var, math.random(1,2), npc.Position, nilvector,npc):ToNPC()
		else
			--poople
			e = Isaac.Spawn(mod.FF.Poople.ID, mod.FF.Poople.Var, 0, npc.Position, nilvector,npc):ToNPC()
		end
	end
	e:GetData().ChangedHP = true
	e:GetData().HPIncrease = 0.1
end

mod:AddCallback(ModCallbacks.MC_POST_EFFECT_UPDATE, function(_, eff)
	local data = eff:GetData()

	eff.RenderZOffset = -1000

	if not data.myrock or (data.myrock.Desc.State ~= 1 and data.myrock.Desc.State ~= 4 and not data.perm) then
		local g
		local room = game:GetRoom()

		eff.Visible = false
		eff:Remove()
	end
end, Isaac.GetEntityVariantByName("Crawlspace Rocktop"))

mod:AddCallback(ModCallbacks.MC_POST_EFFECT_UPDATE, function(_, eff)
	local data = eff:GetData()

	eff.RenderZOffset = -1000

	if data.GridIndex == nil then
		eff:Remove()
	else
		local g = room:GetGridEntity(data.GridIndex)
		if data.WasKeyBlock and not (g and mod.IsKeyBlock(g)) then
			local perch = room:GetGridEntityFromPos(room:GetGridPosition(data.GridIndex) + Vector(0, 40))
			local perchtype = perch and perch:GetType()
			local rocktop = perch and FiendFolio.RequiresRocktops[perchtype] and not StageAPI.IsCustomGrid(perch:GetGridIndex(), "FFRubberRock")

			local perchable = perch and 
			                  not mod.IsKeyBlock(perch) and
			                  (perchtype == GridEntityType.GRID_DOOR or 
			                   perchtype == GridEntityType.GRID_WALL or 
			                   perchtype == GridEntityType.GRID_ROCKB or 
			                   rocktop) and
							  (not data.Rocktop or perch.Desc.State == 1)

			if data.PerchRemoved == nil and not perchable then
				local rendersprite = eff:GetSprite()
				
				rendersprite:ReplaceSpritesheet(1, "gfx/grid/blank.png")
				rendersprite:LoadGraphics()
				
				data.PerchRemoved = true
			end
		elseif g then
			local gt = g:GetType()
			
			if gt == GridEntityType.GRID_TNT or
			   gt == GridEntityType.GRID_POOP or
			   (StageAPI.IsCustomGrid(data.GridIndex, "FFRubberRock") and g.Desc.State == 1) or
			   mod.IsKeyBlock(g)
			then
				local gridsprite = g:GetSprite()
				local rendersprite = eff:GetSprite()
				
				rendersprite:Play(gridsprite:GetAnimation(), true)
				rendersprite:SetFrame(gridsprite:GetFrame())
			else
				eff:Remove()
			end
		
			local perch = room:GetGridEntityFromPos(g.Position + Vector(0, 40))
			local perchtype = perch and perch:GetType()
			local rocktop = perch and FiendFolio.RequiresRocktops[perchtype] and not StageAPI.IsCustomGrid(perch:GetGridIndex(), "FFRubberRock")

			local perchable = perch and 
			                  not mod.IsKeyBlock(perch) and
			                  (perchtype == GridEntityType.GRID_DOOR or 
			                   perchtype == GridEntityType.GRID_WALL or 
			                   perchtype == GridEntityType.GRID_ROCKB or 
			                   rocktop) and
							  (not data.Rocktop or perch.Desc.State == 1)

			if data.PerchRemoved == nil and not perchable then
				local rendersprite = eff:GetSprite()
				
				if gt == GridEntityType.GRID_TNT then
					rendersprite:ReplaceSpritesheet(2, "gfx/grid/blank.png")
					rendersprite:LoadGraphics()
				elseif gt == GridEntityType.GRID_POOP then
					rendersprite:ReplaceSpritesheet(2, "gfx/grid/blank.png")
					rendersprite:LoadGraphics()
				elseif StageAPI.IsCustomGrid(data.GridIndex, "FFRubberRock") then
					rendersprite:ReplaceSpritesheet(2, "gfx/grid/blank.png")
					rendersprite:LoadGraphics()
				elseif mod.IsKeyBlock(g) then
					rendersprite:ReplaceSpritesheet(1, "gfx/grid/blank.png")
					rendersprite:LoadGraphics()
				end
				
				data.PerchRemoved = true
			end
		else
			eff:Remove()
		end
	end
end, Isaac.GetEntityVariantByName("Crawlspace Grid Rerenderer"))

--Erfly - AI

--Actual enemies

function mod:sniffleAI(npc)
	local room = game:GetRoom()
	local path = npc.Pathfinder
	local d = npc:GetData()
	local sprite  = npc:GetSprite()
	local params = ProjectileParams()
	local target = npc:GetPlayerTarget()

	local speed = 6
	local acc = 0.2
	local attackint = 40
	if npc.Variant == mod.FF.DryWheeze.Var then
		attackint = 52
	end
	local projspeed = 10

	if npc.Variant == 10 and not d.init then
		d.init = true
		npc:AddEntityFlags(EntityFlag.FLAG_NO_BLOOD_SPLASH)
	end

		if target.Position.X < npc.Position.X then
			sprite.FlipX = true
		else
			sprite.FlipX = false
		end

		if npc.Velocity:Length() > 1 then
			if math.abs(npc.Velocity.Y) > math.abs(npc.Velocity.X) and not npc.Variant == mod.FF.DryWheeze.Var then
					if npc.Variant == 0 then
						mod:spritePlay(sprite, "WalkVert")
					--[[elseif npc.Variant == 10 then
						if npc.Velocity.Y < 0 then
							mod:spritePlay(sprite, "WalkUp")
						else
							mod:spritePlay(sprite, "WalkDown")
						end]]
					end
				else
					if npc.Velocity.X < 0 then
						if sprite.FlipX then
							mod:spritePlay(sprite, "WalkRight")
						else
							mod:spritePlay(sprite, "WalkLeft")
						end
					else
						if sprite.FlipX then
							mod:spritePlay(sprite, "WalkLeft")
						else
							mod:spritePlay(sprite, "WalkRight")
						end
					end
				end
			else
				if npc.Variant == 0 then
					sprite:SetFrame("WalkVert", 0)
				elseif npc.Variant == 10 then
					sprite:SetFrame("WalkRight", 0)
				end
			end
		--FindGridPath(npc, target.Position + target.Velocity*15, speed, acc, false, 100, false, false)

		local targetpos = mod:confusePos(npc, target.Position)
			local distanceabs = npc.Position:Distance(targetpos)

			if (not mod:isScareOrConfuse(npc)) and distanceabs < 250 and room:CheckLine(npc.Position,targetpos,0,3,false,false) then
				local extravec = 0
				if distanceabs < 175 then
					extravec = distanceabs / 3
				end

				local gangang = 145
				if not d.rotang then
					d.rotang = gangang + (target.Position - npc.Position):GetAngleDegrees()
				else
					if math.abs(math.abs(d.rotang) - math.abs(gangang + (target.Position - npc.Position):GetAngleDegrees())) > 1 then
						d.rotang = gangang + (target.Position - npc.Position):GetAngleDegrees()
					end
				end

				local tpa = target.Position
				--tpa = target.Position + (target.Position - npc.Position):Resized(distanceabs + extravec):Rotated(90+targdistance:GetAngleDegrees())
				tpa = target.Position + (target.Position + npc.Position):Resized(distanceabs + extravec):Rotated(d.rotang)



				--Isaac.ConsoleOutput((target.Position + npc.Position):GetAngleDegrees() .. "\n")
				--Isaac.ConsoleOutput(90 % 13.2 .. "\n")

				if npc.Position:Distance(tpa) > 10 then
					d.targetvelocity = (tpa - npc.Position):Resized(speed)
					npc.Velocity = mod:Lerp(d.targetvelocity, npc.Velocity, 0.8)
				else
					npc.Velocity = npc.Velocity * 0.8
				end

			else
				if room:CheckLine(npc.Position,targetpos,0,1,false,false) or mod:isScare(npc) then
					d.targetvelocity = mod:reverseIfFear(npc, (targetpos - npc.Position):Resized(speed))
					npc.Velocity = mod:Lerp(d.targetvelocity, npc.Velocity, 0.8)
				else
					 mod:CatheryPathFinding(npc, targetpos, {
						Speed = speed,
						Accel = acc,
						Interval = 1,
						GiveUp = true
					 })
				end
			end

	if npc.State == NpcState.STATE_MOVE then
		sprite:PlayOverlay("Head", true)
		if npc.StateFrame > attackint and math.random(3) == 1 and room:CheckLine(npc.Position, target.Position + target.Velocity*5,3,1,false,false) and not mod:isScareOrConfuse(npc) then
		npc.StateFrame = 0
		npc.State = NpcState.STATE_ATTACK
		end

	elseif npc.State == NpcState.STATE_ATTACK then
		if npc.Variant == 0 then
				--npc.Velocity = nilvector + (npc.Velocity * 0.6)
				--sprite:SetFrame("WalkVert", 0)
			if sprite:IsOverlayFinished("Shoot") then
				npc.StateFrame = 0
				npc.State = NpcState.STATE_MOVE
			elseif npc.StateFrame == 2 then
				npc:PlaySound(mod.Sounds.SniffleShoot,1,0,false,math.random(9,11)/10)
			elseif npc.StateFrame == 7 then
				params.Scale = 1
				params.FallingSpeedModifier = 0
				params.FallingAccelModifier = 0
				local targcoord = mod:intercept(npc, target, projspeed)
				local shootvec = targcoord:Normalized() * projspeed
				npc:FireProjectiles(npc.Position, shootvec, 0, params)
			else
				mod:spriteOverlayPlay(sprite, "Shoot")
			end
		elseif npc.Variant == 10 then
			npc.Velocity = mod:Lerp(npc.Velocity, Vector.Zero, 0.4)
			if sprite:IsOverlayFinished("Shoot") then
				npc.StateFrame = 0
				npc.State = NpcState.STATE_MOVE
			elseif npc.StateFrame == 2 then
				npc:PlaySound(mod.Sounds.SniffleShoot,1,0,false,math.random(9,11)/10)
			elseif npc.StateFrame == 7 then
				local targcoord = mod:intercept(npc, target, projspeed)
				local shootvec = targcoord:Normalized() * projspeed
				local proj = Isaac.Spawn(9, 1, 0, npc.Position, shootvec, npc):ToProjectile()
				proj.Scale = 1
				proj.FallingSpeed = 0
				proj.FallingAccel = 0
				proj:GetData().projType = "DryWheeze"
				proj:GetData().rand = npc:GetDropRNG()
				proj:GetData().target = target
				local pSprite = proj:GetSprite()
				pSprite:Load("gfx/projectiles/skull_shot.anm2", true)
				if mod:CheckStage("Ashpit", {46,59}) then
					pSprite:ReplaceSpritesheet(0, "gfx/projectiles/skull_shot_ashpit.png")
					pSprite:LoadGraphics()
				end
				if mod:isFriend(npc) then
					proj.ProjectileFlags = proj.ProjectileFlags | ProjectileFlags.CANT_HIT_PLAYER | ProjectileFlags.HIT_ENEMIES
					proj:GetData().friend = true
					pSprite:Play("friendly", true)
				elseif mod:isCharm(npc) then
					proj.ProjectileFlags = proj.ProjectileFlags | ProjectileFlags.HIT_ENEMIES
					proj:GetData().charm = true
					pSprite:Play("friendly", true)
				else
					pSprite:Play("spin", true)
				end
				proj:Update()
			else
				mod:spriteOverlayPlay(sprite, "Shoot")
			end
		end
	else
		npc.State = NpcState.STATE_MOVE
		sprite:PlayOverlay("Head", true)
	end
	npc.StateFrame = npc.StateFrame + 1
end

function mod.dryWheezeProj(v, d)
	if d.projType == "DryWheeze" then
		if v:IsDead() then
			sfx:Play(SoundEffect.SOUND_BONE_BREAK, 0.6, 0, false, math.random(80, 120)/100)
			for i=0,2 do
				local dir
				if i==0 then
					dir = (d.target.Position-v.Position):Resized(1+(20+d.rand:RandomInt(20))/10)
				else
					dir = RandomVector()*((2*i)+d.rand:RandomInt(20*i)/10)
				end
				local proj = Isaac.Spawn(9, 1, 0, v.Position, dir, v):ToProjectile()
				if math.random(2) == 1 then
					local sprite = proj:GetSprite()
					sprite:Load("gfx/002.030_black tooth tear.anm2", true)
					sprite:ReplaceSpritesheet(0, "gfx/projectiles/white_tooth.png")
					sprite:LoadGraphics()
					sprite:Play("Tooth2Move", false)
					proj:GetData().tooth = true
				end
				proj.FallingAccel = (d.rand:RandomInt(10)+8)/10
				proj.FallingSpeed = -(30+d.rand:RandomInt(120))/5
				if d.friend then
					proj.ProjectileFlags = proj.ProjectileFlags | ProjectileFlags.CANT_HIT_PLAYER | ProjectileFlags.HIT_ENEMIES
				elseif d.charm then
					proj.ProjectileFlags = proj.ProjectileFlags | ProjectileFlags.HIT_ENEMIES
				end
				proj:Update()
			end
		end
	end
end

function mod:slammerAI(npc)
	local room = game:GetRoom()
	local var = npc.Variant
	local path = npc.Pathfinder
	local sprite = npc:GetSprite()
	local npcd = npc:GetData()
	local r = npc:GetDropRNG()

	local entitynpc = npc:ToNPC()
	local target = npc:GetPlayerTarget()
	entitynpc.Target = target

	if npc.FrameCount <= 1 and var == 0 and ((REVEL and REVEL.STAGE.Glacier:IsStage()) or npcd.FromIceHazard) then
		npc.SplatColor = Color(0, 0.2, 0.8, 1, 0,20/255,70/255)
		sprite:ReplaceSpritesheet(0, "gfx/enemies/slamboy/slammerNEW_glacier.png")
		sprite:LoadGraphics()
	end
	
	if npcd.AshLeave and not npcd.unignited then
		if var == 5 or var == 6 then
			if npcd.LastAshSpawn then
				if npc.Position:Distance(npcd.LastAshSpawn) > 10 then
					if var == 5 then
						mod.SpawnAsh(npc, npc.Position)
					elseif var == 6 then
						local creep = Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.CREEP_GREEN, 0, npc.Position, nilvector, npc):ToEffect();
						creep.Timeout = 20
						creep:Update()
					end
					npcd.LastAshSpawn = npc.Position
				end
			else
				if var == 5 then
					mod.SpawnAsh(npc, npc.Position)
				elseif var == 6 then
					local creep = Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.CREEP_GREEN, 0, npc.Position, nilvector, npc):ToEffect();
					creep.Timeout = 20
					creep:Update()
				end
				npcd.LastAshSpawn = npc.Position
			end
		end
	end
	if npcd.IsJumping == 1 then
		npc.Friction = 1
		--Wimpy Slammer
		--[[if var == 1 then
			if (npc.Position - npcd.PlayerPos):Length() < 20 then
				npcd.targetVelocity = npcd.targetVelocity * 0.3
			else
				--npcd.targetVelocity = npcd.targetVelocity + Vector(-(npc.Position.X - npcd.PlayerPos.X), -(npc.Position.Y - npcd.PlayerPos.Y)):Normalized() * 7
				npcd.targetVelocity = npcd.targetVelocity + -(npc.Position - npcd.PlayerPos):Normalized() * 7
					local arcvel = npcd.targetVelocity
					if arcvel:Length() >= 25 then
						npcd.targetVelocity = arcvel:Resized(25)
					end
			end]]
		--Pale Slammers
	--[[	elseif var == 4 then
		local dist = (npc.Position - npcd.PlayerPos):Length()
			if dist < 20 and npcd.targetVelocity:Length() < 20 then
				npcd.targetVelocity = npcd.targetVelocity * 0.3
			else
			room:FindFreeTilePosition]]

		--Regular Slammers, Rock Slammers
	--	else
			local dist = (npc.Position - npcd.PlayerPos):Length()
			if dist < 20 --[[and npcd.targetVelocity:Length() < 10]] then
				--npcd.targetVelocity = npcd.targetVelocity * 0.3
				npcd.targetVelocity = (npcd.PlayerPos - npc.Position):Resized(5)
				if var == 5 or var == 0 or var == 6 or var == 7 or var == 8 or var == mod.FF.Marzy.Var or var == mod.FF.Flinty.Var then
					npc.State = 9
					npcd.IsJumping = 0
					npcd.targetVelocity = nilvector
		end
			elseif (var == 5 or var == 0 or var == 6) and dist < 40 then
				npcd.targetVelocity = (npcd.PlayerPos - npc.Position):Resized(2)
			else
				if var == 0 or var == 7 then
					npcd.targetVelocity = npcd.targetVelocity + -(npc.Position - npcd.PlayerPos):Normalized() * (dist / 65)
				elseif var == 4 or var == 8 or var == 9 then
					--npcd.targetVelocity = npcd.targetVelocity + Vector(-(npc.Position.X - npcd.PlayerPos.X), -(npc.Position.Y - npcd.PlayerPos.Y)):Normalized() * (dist / 25)
					npcd.targetVelocity = npcd.targetVelocity + -(npc.Position - npcd.PlayerPos):Normalized() * (dist / 25)
				elseif var == 1 then
					npcd.targetVelocity = npcd.targetVelocity + -(npc.Position - npcd.PlayerPos):Normalized() * (dist / 20)
				elseif var == 5 then
					npcd.targetVelocity = npcd.targetVelocity + -(npc.Position - npcd.PlayerPos):Normalized() * (dist / 65)
				elseif var < 4 then
					npcd.targetVelocity = npcd.targetVelocity + Vector(-(npc.Position.X - npcd.PlayerPos.X), -(npc.Position.Y - npcd.PlayerPos.Y)):Normalized() * (dist / 60)
		elseif var == mod.FF.Flinty.Var then
		  npcd.targetVelocity = npcd.targetVelocity - (npc.Position - npcd.PlayerPos):Normalized() * (dist / 175)
				else
					npcd.targetVelocity = npcd.targetVelocity + Vector(-(npc.Position.X - npcd.PlayerPos.X), -(npc.Position.Y - npcd.PlayerPos.Y)):Normalized() * (dist / 30)
				end
				local arcvel = npcd.targetVelocity
				if arcvel:Length() >= dist then
					npcd.targetVelocity = arcvel:Resized(dist)
				end
			end
		--end
	else
	npcd.targetVelocity = nilvector
	end

	--Init
	if not npcd.init then
		if var > 1 and var < 4 then
			npc:AddEntityFlags(EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK | EntityFlag.FLAG_NO_STATUS_EFFECTS | EntityFlag.FLAG_NO_DEATH_TRIGGER | EntityFlag.FLAG_NO_TARGET | EntityFlag.FLAG_NO_FLASH_ON_DAMAGE)
			npc.SplatColor = Color(0.15, 0, 0, 1, 25 / 255, 25 / 255, 25 / 255)
		--else
			--npc:AddEntityFlags(EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK)
		end
		if var == 2 or var == 3 then
			npc:AddEntityFlags(EntityFlag.FLAG_NO_BLOOD_SPLASH)
		elseif var == mod.FF.Marzy.Var then
			npc.SplatColor = mod.ColorStinkyCheese
	elseif var == mod.FF.Flinty.Var then
	  npc.SplatColor = Color(0,0,0,1,0.25,0.25,0.25)
		end
		npcd.Wait = 0
		npcd.init = true
		if npcd.waited then
			npc.State = 9
			npc.Visible = true
	  if var == mod.FF.Flinty.Var then
		sprite:Play("FallWait", true)
		npcd.FallWait = true
	  else
		sprite:Play("Fall", true)
	  end
		elseif npc.SubType == 1 then
			mod.makeWaitFerr(npc, npc.Type, npc.Variant, npc.SubType, 60, false)
		else
			npc.State = 3
		end
		npcd.dontBrim = true


	--Idle
	elseif npc.State == 3 then
		npc.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_GROUND
		if npcd.Wait == 0 then
			sprite:Play("Idle", 0)
			if var == 3 then
				npcd.waitrng = 0
			elseif var == 5 or var == 6 then
				npcd.waitrng = math.random(5,20) + 20
			elseif var == 1 then
				npcd.waitrng = math.random(10) + 15
			elseif var == 8 then
				npcd.waitrng = math.random(5)
			elseif var == mod.FF.Flinty.Var then
		if npc.Subtype == 0 then
		  npcd.waitrng = math.random(10) + npc.Index*3
		else
		  npcd.waitrng = math.random(10) + (npc.Index % 10)*2
		end        
	  else
				npcd.waitrng = math.random(10)
			end
		end
		npcd.Wait = npcd.Wait + 1
		if var > 1 and var < 4 then
			if room:IsClear() == true then
				npc.State = 15
			end
			if npcd.Wait > 20 + npcd.waitrng and not mod:isScareOrConfuse(npc) then
				npc.State = 8
				npcd.Wait = 0
			end
		elseif var == 1 then
			if npcd.Wait > 1 + npcd.waitrng and not mod:isScareOrConfuse(npc) then
				npc.State = 8
				npcd.Wait = 0
			end
		elseif var == 8 then
			if npcd.Wait > 15 + npcd.waitrng and not mod:isScareOrConfuse(npc) then
				if npcd.dontBrim then
					npcd.dontBrim = nil
					npc.State = 8
					npcd.Wait = 0
				else
					npc.State = 10
					npcd.Wait = 0
					npcd.brimState = nil
				end
			end
		elseif var == mod.FF.Marzy.Var then
			if npcd.Wait > 45 + npcd.waitrng and not mod:isScareOrConfuse(npc) then
				npc.State = 8
				npcd.Wait = 0
			end
	elseif var == mod.FF.Flinty.Var then
	  if npcd.Wait > 30 + npcd.waitrng and not mod:isScareOrConfuse(npc) then
				npc.State = 8
				npcd.Wait = 0
			end
		else    
			if npcd.Wait > 10 + npcd.waitrng and not mod:isScareOrConfuse(npc) then
				npc.State = 8
				npcd.Wait = 0
			end
		end

	--Doomer attack
	elseif npc.State == 10 then
		npc.StateFrame = npc.StateFrame + 1
		if not npcd.brimState then
			if sprite:IsFinished("BrimstoneStart") then
				npcd.brimState = "firing"
			elseif sprite:IsEventTriggered("rrerr") then
				for i = 90, 360, 90 do
					local tracer = Isaac.Spawn(1000, 198, 0, npc.Position + Vector(10, 0):Rotated(i), Vector(0.001,0), npc):ToEffect()
					tracer.Timeout = 20
					tracer.TargetPosition = Vector(1,0):Rotated(i)
					tracer.LifeSpan = 15
					tracer:FollowParent(npc)
					if npc.SubType == 666 then
						tracer.SpriteScale = Vector(30,30)
					else
						tracer.SpriteScale = Vector(2,2)
					end
					tracer.Color = Color(1,0.2,0,0.3,0,0,0)
					tracer:Update()
				end
			elseif sprite:IsEventTriggered("Shoot") then
				local laserVar = 1
				if npc.SubType == 666 then
					laserVar = 13
					npc:PlaySound(SoundEffect.SOUND_BEAST_LASER,1,2,false,1)
				end
				for i = 90, 360, 90 do
					local laser = EntityLaser.ShootAngle(laserVar, npc.Position, i, 20, Vector(0, -10), npc)
					if i == 90 then
						laser.DepthOffset = -500
					end
					laser.Parent = npc
					laser:Update()
				end
				npc.StateFrame = 0
			else
				mod:spritePlay(sprite, "BrimstoneStart")
			end
		elseif npcd.brimState == "firing" then
			mod:spritePlay(sprite, "BrimstoneLoop")
			if npc.StateFrame > 20 then
				npcd.brimState = "end"
			end
		elseif npcd.brimState == "end" then
			if sprite:IsFinished("BrimstoneEnd") then
				npcd.Wait = 0
				npcd.init = true
				npcd.dontBrim = true
				npc.State = 3
			else
				mod:spritePlay(sprite, "BrimstoneEnd")
			end
		end


	--Jump Up
	elseif npc.State == 8 then
		if not npcd.IsJumping then
			if var > 1 and var < 4 then
				if room:IsClear() then
					npc.State = 15
				end
			end
		end
	
	--Flinty smoke
	if var == mod.FF.Flinty.Var and sprite:IsPlaying("Jump") and sprite:WasEventTriggered("Sound") then
	  local smoke = Isaac.Spawn(1000, 59, 0, npc.Position+RandomVector()*10, Vector(0,-5), npc):ToEffect()
	  smoke:SetTimeout(20)
	  smoke.Scale = 1000
	  local offsetY = sprite:GetFrame()-30
	  smoke.PositionOffset = Vector(0, -50*offsetY)
	end
	
		if sprite:IsFinished("Jump") then
			if var > 0 and var < 5 then
				npc.State = 9
				npcd.IsJumping = 0
				npcd.targetVelocity = nilvector
			end
		elseif not sprite:IsPlaying("Jump") then
			sprite:Play("Jump", 0)
		elseif sprite:IsEventTriggered("GetPlayer") then
			if var == 0 or var == 7 or var == mod.FF.Flinty.Var then
				local dist = (npc.Position - target.Position):Length()
				local fgkhj = (target.Position - npc.Position):Normalized() * math.min(300,dist)

				npcd.PlayerPos = room:FindFreeTilePosition(npc.Position + fgkhj, 40) + (RandomVector())
			elseif var == 4 or var == 1 then
				local dist = (npc.Position - target.Position):Length()
				local fgkhj = (target.Position - npc.Position):Normalized() * math.min(200,dist)

				npcd.PlayerPos = room:FindFreeTilePosition(npc.Position + fgkhj, 40) + (RandomVector())
			elseif var == mod.FF.Doomer.Var or var == mod.FF.Marzy.Var then
				local dist = (npc.Position - target.Position):Length()
				local fgkhj = (target.Position - npc.Position):Normalized() * math.min(400,dist)
				fgkhj = fgkhj:Resized(fgkhj:Length() * 0.8) --idk it works
				npcd.PlayerPos = room:FindFreeTilePosition(npc.Position + fgkhj, 40) + (RandomVector())
			elseif var == 5 or var == 6 then
				local randtarg = mod:FindRandomFreePos(npc, 200, nil, true)
				local dist = (npc.Position - randtarg):Length()
				local fgkhj = (randtarg - npc.Position):Normalized() * math.min(300,dist)
				npcd.PlayerPos = room:FindFreeTilePosition(npc.Position + fgkhj, 40) + (RandomVector())
			else
				npcd.PlayerPos = room:FindFreeTilePosition(entitynpc.Target.Position, 40) + (RandomVector()*10)
			end
			npcd.AshLeave = true
			npcd.AshTable = {}
			npcd.IsJumping = 1
			npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
			npc.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_NONE
			npc:AddEntityFlags(EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK)
		elseif sprite:IsEventTriggered("Sound") then
			if (var == 0 or var > 3) and var ~= mod.FF.Flinty.Var then
				npc:PlaySound(SoundEffect.SOUND_MEAT_JUMPS,1,2,false,1)
			elseif var == 1 then
				npc:PlaySound(SoundEffect.SOUND_MEAT_JUMPS,1,2,false,1.4)
			elseif var == 2 then
				npc:PlaySound(SoundEffect.SOUND_SHELLGAME,1,2,false,0.7)
			end
	  
	  -- Flinty's pit/s
	  if var == mod.FF.Flinty.Var then
		game:BombExplosionEffects(npc.Position, 20, TearFlags.TEAR_NORMAL, Color.Default, npc, 0.75, false, true, DamageFlag.DAMAGE_EXPLOSION)
		local pits = {npc.Position}
		local offsetX
		local offsetY
		if (npc.Position.X+20)%40 < 10 then offsetX = -1 end
		if (npc.Position.X+20)%40 > 30 then offsetX = 1 end
		if (npc.Position.Y+20)%40 < 10 then offsetY = -1 end
		if (npc.Position.Y+20)%40 > 30 then offsetY = 1 end
		if offsetX then table.insert(pits, npc.Position + Vector(40*offsetX, 0)) end
		if offsetY then table.insert(pits, npc.Position + Vector(0, 40*offsetY)) end
		
		for _, pos in pairs(pits) do
		  if mod.canGeneratePit(pos, 0, nil, true, true) then
			for i=1, 3 do
			  Isaac.Spawn(1000, 4, 0, room:GetGridPosition(room:GetGridIndex(pos)), RandomVector()*math.random()*5, npc)
			end
			local index = room:GetGridIndex(pos)
			room:SpawnGridEntity(index, 7, 0, 0, 0)
			mod:UpdatePits(index)
		  end
		  --npcd.jumpCountdown = 35
		end
	  end
		end



	--Jump Down
	elseif npc.State == 9 then
		if sprite:IsFinished("Fall") or sprite:IsFinished("FallWait") then
			npc.State = 3
		elseif not (sprite:IsPlaying("Fall") or sprite:IsPlaying("FallWait")) then
			sprite:Play("Fall", 0)
			--npc.Position = npcd.PlayerPos
		elseif sprite:IsEventTriggered("Blaze") then
			if not npcd.unignited and npcd.AshTable then
				npcd.AshLeave = false
				local ash = npcd.AshTable[#npcd.AshTable]
				ash:GetData().asplode = true
			end
		elseif sprite:IsEventTriggered("Land") then
			if var == 0 or var > 3 then
				npc:PlaySound(SoundEffect.SOUND_MEAT_IMPACTS,1,2,false,1)
				if var == 5 and not npcd.unignited then
					local smoke = Isaac.Spawn(1000, EffectVariant.DARK_BALL_SMOKE_PARTICLE, 0, npc.Position, nilvector, npc):ToEffect()
					--smoke.Scale = 10
					smoke.SpriteScale = Vector(2,2)
					smoke.SpriteOffset = Vector(0,-10)
					smoke:Update()
				end
			elseif var == 1 then
				npc:PlaySound(SoundEffect.SOUND_MEAT_JUMPS,1,2,false,1.4)
			else
				npc:PlaySound(SoundEffect.SOUND_POT_BREAK,1,2,false,1)
			end
			npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_ALL
			npc.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_GROUND
			if var > 1 and var < 4 then
				if room:IsClear() then
					npc.State = 15
				else
					game:ShakeScreen(6)
					local wave
					if not npcd.waited then
						wave = Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.SHOCKWAVE, 0, npc.Position, nilvector, g):ToEffect()
						wave.Parent = npc
						wave.MaxRadius = 50
					end
				end
			else
				npc:ClearEntityFlags(EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK)
			end
			if var == 4 and not npcd.waited then
				--Creep
				local creep = Isaac.Spawn(1000, 22, 0, npc.Position, nilvector, npc)
				creep.SpriteScale = creep.SpriteScale * 2
				for i = 1, 3 do
					local creep = Isaac.Spawn(1000, 22, 0, npc.Position + (Vector.FromAngle(i * (360 / 3)) * 22), nilvector, npc)
				end
				--Splatter
				local params = ProjectileParams()
				for i = 30, 360, 30 do
					local rand = r:RandomFloat()
					params.FallingSpeedModifier = -1 * (math.random(5, 20) + math.random());
					params.FallingAccelModifier = 2
					params.VelocityMulti = 0.65 + mod:RandomInt(0,4) * 0.2
					npc:FireProjectiles(npc.Position, Vector(0,4):Rotated(i-40+rand*80) + nilvector, 0, params)
				end
			elseif var == 7 and not npcd.waited then
				local creep = Isaac.Spawn(1000, 22, 0, npc.Position, nilvector, npc):ToEffect()
				creep.SpriteScale = creep.SpriteScale * 2
				creep:SetTimeout(60)
				creep:Update()
				local params = ProjectileParams()
				params.FallingAccelModifier = 0.3
				local choiceVec = (target.Position - npc.Position):Resized(5)
				for i = 72, 360, 72 do
					npc:FireProjectiles(npc.Position + choiceVec:Rotated(i):Resized(15), choiceVec:Rotated(i), 0, params)
				end
			elseif var == mod.FF.Marzy.Var and not npcd.waited then --Marzy land
				local cap = (mod.GetEntityCount(853) < mod.GetEntityCount(mod.FF.Marzy.ID, mod.FF.Marzy.Var) * 6)
				if cap then
					for i = 1, mod:RandomInt(1,2) do
						local maggotvel = (mod:FindRandomValidPathPosition(npc, 3) - npc.Position)/mod:RandomInt(20,25)
						FiendFolio.ThrowMaggot(npc.Position, maggotvel, -5, mod:RandomInt(-20, -10), npc)
					end
				end
				npcd.WormyShoot = 3
				npcd.WormPoint = npc.Position
				npcd.WormVec = RandomVector()
				local effect = Isaac.Spawn(1000,7,0,npc.Position,Vector.Zero,npc)
				effect.Color = mod.ColorStinkyCheese
				effect = Isaac.Spawn(1000,16,3,npc.Position,Vector.Zero,npc)
				effect.Color = mod.ColorStinkyCheese
				effect.SpriteScale = effect.SpriteScale * 0.6
			end
			npcd.waited = nil
		end
	
	--Flinty smoke
	if var == mod.FF.Flinty.Var and sprite:IsPlaying("Fall") and sprite:GetFrame() < 25 then
	  local smoke = Isaac.Spawn(1000, 59, 0, npc.Position+RandomVector()*15, Vector(0,-5), npc):ToEffect()
	  smoke:SetTimeout(10)
	  smoke:SetColor(Color(0,0,0,0.5,0,0,0), 0, 0, false, false)
	  smoke.Scale = 1000
	  local offsetY = sprite:GetFrame()
	  if offsetY > 6 then offsetY = 6 end
	  smoke.PositionOffset = Vector(0, -220+(offsetY*33.3))
	end



	--Ded
	elseif npc.State == 15 then
		if sprite:IsFinished("Off") then
			--[[for i = 1, 10 do
				local rock = Isaac.Spawn(1000, 4, 0, npc.Position, npc.Velocity+RandomVector()*3, npc):ToEffect()
				rock.Color = Color(1.5,1.5,1.5,1,0,0,0)
				rock:Update()
			end]]
			npc:Kill()
		else
			mod:spritePlay(sprite, "Off")
		end
	end
	if npc.Variant == mod.FF.Marzy.Var then
		npcd.WormyShoot = npcd.WormyShoot or -1
		npcd.WormyShoot = npcd.WormyShoot - 1
		npcd.WormPoint = npcd.WormPoint or npc.Position
		if npcd.WormyShoot >= 0 then
			local params = ProjectileParams()
			params.Color = mod.ColorWigglyMaggot
			params.FallingAccelModifier = -0.15
			params.BulletFlags = ProjectileFlags.NO_WALL_COLLIDE
			params.Scale = 0.6
			mod:SetGatheredProjectiles()
			for i = 0, 240, 120 do
				local shootvec = npcd.WormVec:Rotated(i):Resized(8)
				npc:FireProjectiles(npcd.WormPoint + shootvec:Resized(npcd.WormyShoot * 2), shootvec, 0, params)
			end
			for _, projectile in pairs(mod:GetGatheredProjectiles()) do
				local data = projectile:GetData()
				data.projType = "wigglyWorm"
				local dist = projectile.Position:Distance(npc.Position)
			end
		end
		if npc:IsDead() then
			--[[for i = 1, mod:RandomInt(1,2) do
				local maggotvel = (mod:FindRandomValidPathPosition(npc, 3) - npc.Position)/mod:RandomInt(20,25)
				FiendFolio.ThrowMaggot(npc.Position, maggotvel, -5, mod:RandomInt(-20, -10), npc)
			end]]
		end
	end
	npc.Velocity = (npcd.targetVelocity * 0.3) + (npc.Velocity * 0.6)
end

function mod:WigglyWormProjectile(projectile, data)
	data.WiggleCurve = data.WiggleCurve or 4
	data.WiggleAngle = data.WiggleAngle or 12
	projectile.Velocity = projectile.Velocity:Rotated(data.WiggleAngle)
	data.WiggleAngle = data.WiggleAngle + data.WiggleCurve
	if math.abs(data.WiggleAngle) > 12 then
		data.WiggleCurve = -data.WiggleCurve
	end
end

function mod:slammerHurt(npc, damage, flag, source)
	local variant = npc.Variant
	if variant == 2 or variant == 3 then
		return false
	end
  if variant == mod.FF.Flinty.Var then
		if source and source.Entity and source.Entity.Type == mod.FF.Flinty.ID and source.Entity.Variant == mod.FF.Flinty.Var then return false end
	end
	if flag & DamageFlag.DAMAGE_FIRE ~= 0 and source.Type ~= 1 then
		if variant == 0 then
			--[[npc:ToNPC():Morph(951, 5, 0, -1)
			return false]]
		elseif variant == 5 then
			return false
		end
	end
end
mod:AddCallback(ModCallbacks.MC_ENTITY_TAKE_DMG, mod.slammerHurt, mod.FF.Slammer.ID)

function mod:TrashbaggerHurt(npc, damage, flag, source)
	if npc.SubType == mod.FF.Stomy.Sub then
		if flag & DamageFlag.DAMAGE_EXPLOSION ~= 0 and not mod:IsPlayerDamage(source) --[[and source.Type == 4 and subtype == 2 and source.Entity.SpawnerEntity and source.Entity.SpawnerEntity.Variant == npc.Variant]] then
			return false
		end
	end
end
mod:AddCallback(ModCallbacks.MC_ENTITY_TAKE_DMG, mod.TrashbaggerHurt, mod.FF.Trashbagger.ID)

function mod:BombmuncherHurt(npc, damage, flag, source)
	local variant = npc.Variant
	local subtype = npc.SubType
	if flag & DamageFlag.DAMAGE_EXPLOSION ~= 0 and source.Type == 4 and variant == 1 and subtype == 5 and source.Entity.SpawnerEntity and source.Entity.SpawnerEntity.Variant == npc.Variant then
			return false
	end
end
mod:AddCallback(ModCallbacks.MC_ENTITY_TAKE_DMG, mod.BombmuncherHurt, mod.FF.Bombmuncher.ID)

function mod:CappinHurt(npc, damage, flag, source)
	local variant = npc.Variant
	local data = npc:GetData()
	local sprite = npc:GetSprite()

	if variant == 12 and source.Type == 4 and data.state ~= "tripped" then
			npc.Velocity = npc.Velocity *0.2
			data.state = "trip"
			sprite:Play("TripDown", false)
			return false
	elseif variant == 12 and data.state ~= "tripped" then
			return false
	end
end
mod:AddCallback(ModCallbacks.MC_ENTITY_TAKE_DMG, mod.CappinHurt, mod.FF.Cappin.ID)

function mod:snaggerHurt(npc, damage, flag, source)
	--print(source.Entity.Type)
	--REVEL.DebugLog(source.Entity)
end
mod:AddCallback(ModCallbacks.MC_ENTITY_TAKE_DMG, mod.snaggerHurt, mod.FF.Snagger.ID)

function mod:AshCreepAI(e)
local d = e:GetData()
local s = e:GetSprite()

	--mod:spritePlay(s, "SmallBlood0" .. d.val)

	if d.asplode then
		if not d.spawndfire then
			local fire = Isaac.Spawn(1000,7005, 0, e.Position, nilvector, e.SpawnerEntity):ToEffect()
			fire.Parent = d.Spawner
			fire.SpawnerEntity = d.Spawner
			fire:Update()
			fire.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS
			if e.Parent then
				e.Parent:GetData().asplode = true
			end
			d.spawndfire = true
			d.StateFrame = 0
		elseif d.spawndfire then
			d.StateFrame = d.StateFrame + 1
			if d.StateFrame > 30 then
			e:Remove()
			elseif d.StateFrame > 20 then
			e.SpriteScale = Vector(1,1) * (1 - ((d.StateFrame - 20)/10))
			end
		end
	end
end

FiendFolio.CollisionFires = {}

--Fire Creep, Ash Fire, Creep Fire, Fatty Fire, FireCreep
function mod:AshCreepFireAI(e)
	local s = e:GetSprite()
	local d = e:GetData()
	local subt = e.SubType

	if not d.init then
		mod:spritePlay(s, "FireStage01")

		if subt == 1 then -- spitroast
			d.Friction = 0.91
			d.timer = 25
		elseif subt == 2 then -- blazer
			d.IsBlue = true
			d.timer = 15
		elseif subt == 20 then -- mr flare
			d.Friction = 0.95
		elseif subt == 450 then --ashtray
			d.Friction = 1
			d.Radius = 10
			d.timer = 25
			d.gridDecerement = 6
			d.offsetAdjustment = 2
			d.checkGridCollTwice = true
		end
		d.scale = d.scale or 1
		d.SpriteScale = e.SpriteScale * d.scale
		d.Size = e.Size * d.scale

		if d.IsBlue then
			s:ReplaceSpritesheet(0, "gfx/enemies/blazer/effect_005_fire_blue.png")
			s:LoadGraphics()
		end

		d.init = true
	end

	if d.makeVisibleLater and e.FrameCount == 1 then
		e.Visible = true
	end

	if d.offsetAdjustment and e.FrameCount <= 5 then
		e.SpriteOffset = Vector(0, e.SpriteOffset.Y + d.offsetAdjustment)
	end

	local room = game:GetRoom()
	--if (not mod.IsActiveRoom()) and d.timer and not d.timeTested then
	--	if e.FrameCount < d.timer then
	--		d.timer = e.FrameCount
	--		d.timeTested = true
	--	end
	--end

	local timer = d.timer or 20

	local parentisdead = nil

	if subt == 10 then -- woodburner neck
		e.SpriteOffset = Vector(0, -5)
		if e.Parent then
			local p = e.Parent
			local val1 = d.subt10val1 or 2.2
			local val2 = d.subt10val2 or 10
			e.Velocity = mod:Lerp(e.Velocity,(p.Position + d.initVel:Resized(e.FrameCount*val1):Rotated(e.FrameCount*val2))-e.Position, 0.6)
		else
			parentisdead = true
		end
	end

	if d.Friction then
		e.Velocity = e.Velocity * d.Friction
	end

	if parentisdead then
		d.parentcounter = d.parentcounter - 0.1
		e.Color = Color(1,1,1,d.parentcounter, 0, 0, 0)
		local ec = e.Color
		e.Color = Color(ec.R, ec.G, ec.B, d.parentcounter, ec.RO, ec.GO, ec.BO)
	end

	local fc = e.FrameCount
	if not parentisdead and fc > 3 and fc < timer + 5 and (e.InitSeed + fc) % 3 == 0 then
		table.insert(FiendFolio.CollisionFires, e)
	end

	if fc < 5 then
		if d.flamethrower then
			e.SpriteScale = (d.SpriteScale * 0.5) + (d.SpriteScale * fc / 10)
		else
			e.SpriteScale = d.SpriteScale * fc / 5
		end
	elseif e.FrameCount > timer then
		if d.flamethrower then
			e.SpriteScale = d.SpriteScale * (1 + ((fc - timer)/50))
		else
			e.SpriteScale = d.SpriteScale * (1 - ((fc - timer)/20))
		end
		--[[if e.SpriteScale.X < 0 or e.SpriteScale.Y < 0 then
			e:Remove()
		end]]
		local ec = e.Color
		if (not d.parentcounter) or (d.parentcounter and not parentisdead) then
			e.Color = Color(ec.R, ec.G, ec.B, 1 - ((fc - timer)/10), ec.RO, ec.GO, ec.BO)
		end
		if e.FrameCount > timer + 10 then
			e:Remove()
		end
	else
		e.SpriteScale = d.SpriteScale
		if d.gridcoll and fc > d.gridcoll then
			local grid = room:GetGridEntity(room:GetGridIndex(e.Position))
			if grid then
				local coll = grid.CollisionClass
				if coll > 1 then
					d.NoDamage = true
					local toRemove = d.gridDecerement or 3
					d.timer = fc - toRemove
				end
			end
			--Since Ashtray's flames move so quick they could sometimes slip through single grids
			if d.checkGridCollTwice then
				local grid = room:GetGridEntity(room:GetGridIndex(e.Position - (e.Velocity/2)))
				if grid then
					local coll = grid.CollisionClass
					if coll > 1 then
						d.NoDamage = true
						local toRemove = d.gridDecerement or 3
						d.timer = fc - toRemove
					end
				end
			end
		end
	end
end
mod:AddCallback(ModCallbacks.MC_POST_EFFECT_UPDATE, mod.AshCreepFireAI, 7005)

mod:AddCallback(ModCallbacks.MC_POST_EFFECT_UPDATE, function(_, eff)
	local data = eff:GetData()
	if data.IsScaledEff then
		eff.SpriteScale = eff.SpriteScale * eff.Scale
		if eff.FrameCount >= eff.Timeout then
			local color = eff.Color
			color.A = mod:Lerp(1, 0, (eff.FrameCount - eff.Timeout) / (eff.LifeSpan - eff.Timeout))
			eff.Color = color
		end

		if eff.FrameCount >= eff.LifeSpan then eff:Remove() end
	end

	if data.IsGravityEff then
		eff.SpriteOffset = Vector(eff.SpriteOffset.X, eff.m_Height)
		eff.m_Height = eff.m_Height + eff.FallingSpeed
		eff.FallingSpeed = eff.FallingSpeed + eff.FallingAcceleration
	end
end)

function mod:CheckFireCollision()
	local checkedFires = FiendFolio.CollisionFires
	if #checkedFires == 0 then return end

	for i = 1, #checkedFires do
		local fire = checkedFires[i]
		if not fire:GetData().NoDamage then
			local radius = fire:GetData().Radius or 20
			local colEnts = Isaac.FindInRadius(fire.Position, radius, EntityPartition.ENEMY | EntityPartition.PLAYER)
			for i = 1, #colEnts do
				local entity = colEnts[i]
				if entity.Type == 1 or (entity.EntityCollisionClass > 2 and entity:IsActiveEnemy()) then
					entity:TakeDamage(1, DamageFlag.DAMAGE_FIRE, EntityRef(fire), 0)
				end
			end
		end
	end
end

-- uncomment code for benchmarking
--local running = {}
--local maxavg = 0
--local socket = require('socket')
mod:AddCallback(ModCallbacks.MC_POST_UPDATE, function()
	--local t = socket.gettime()
	mod:CheckFireCollision()
	FiendFolio.CollisionFires = {}
	--local dt = (socket.gettime() - t) * 1000
	--table.insert(running, 1, dt)
	--table.remove(running, 11)
	--local avg = 0
	--for _, tt in pairs(running) do
	--    avg = avg + tt
	--end
	--avg = avg / #running
	--maxavg = math.max(maxavg, avg)
	--print("elapsed", dt, "avg", avg, maxavg)
end)

function mod:bouncerAI(npc)
	local room = game:GetRoom()
	local path = npc.Pathfinder
	local sprite = npc:GetSprite()
	local npcd = npc:GetData()

	--When Jumping
		if npcd.IsJumping == 1 then
			npc.Friction = 1
			local dist = (npc.Position - npcd.JumpTarget):Length()
			if dist < 20 and npc.Velocity:Length() < 20 then
				npc.Position = npcd.JumpTarget
				npcd.OnTarget = true
			else
				npc.Velocity = npc.Velocity + Vector(-(npc.Position.X - npcd.JumpTarget.X), -(npc.Position.Y - npcd.JumpTarget.Y)):Normalized() * (dist / 25)
				local arcvel = npc.Velocity
				if arcvel:Length() >= dist then
					npc.Velocity = arcvel:Resized(dist)
				end
			end
		end
	--Initialisation
		if npc.State == 0 then
			npc:AddEntityFlags(EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK)
			npcd.Wait = 0
			npc.State = 20
	--Interlude between jumps.
		elseif npc.State == 20 then
			if npcd.Wait == 0 then
				sprite:Play("Idle", 0)
				npcd.waitrng = math.random(10)
			end
			npcd.Wait = npcd.Wait + 1
			if npcd.Wait > 10 + npcd.waitrng then
				npc.State = 21
				npcd.Jumps = math.random(4) + 2
				npcd.JumpCount = 0
				npcd.Wait = 0
			end
	--Initial Jump
		elseif npc.State == 21 then
			if sprite:IsFinished("BounceUp") then
				npc.State = 25
			elseif not sprite:IsPlaying("BounceUp") then
				sprite:Play("BounceUp", 0)
			end
			if sprite:IsEventTriggered("Jump") then
				npcd.JumpTarget = room:FindFreeTilePosition(npc.Position + (RandomVector()*30), 40) + (RandomVector()*10)
				npcd.IsJumping = 1
				npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
				npc.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_WALLS
				npcd.JumpCount = npcd.JumpCount + 1
			end
	--Inbetween jumps
		elseif npc.State == 25 then
				sprite:Play("BounceAir", 0)
			if npcd.OnTarget then
				npcd.OnTarget = false
				if npcd.JumpCount > npcd.Jumps then
					npc.State = 30
				else
					npc.State = 40
				end
			end
	--Rebound Bounce
		elseif npc.State == 30 then
			if sprite:IsFinished("BounceRebound") then
				npc.State = 25
			elseif not sprite:IsPlaying("BounceRebound") then
				sprite:Play("BounceRebound", 0)
			end
			if sprite:IsEventTriggered("Slam") then
				npcd.IsJumping = 0
				npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_ALL
				npc.GridCollisionClass = GridCollisionClass.COLLISION_SOLID
			end
			if sprite:IsEventTriggered("Jump") then
				npcd.JumpTarget = room:FindFreeTilePosition(npc.Position + (RandomVector()*30), 40) + (RandomVector()*10)
				npcd.IsJumping = 1
				npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
				npc.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_WALLS
				npcd.JumpCount = npcd.JumpCount + 1
			end
	--Bounce End
		elseif npc.State == 40 then
			if sprite:IsFinished("BounceEnd") then
				npc.State = 41
			elseif not sprite:IsPlaying("BounceEnd") then
				sprite:Play("BounceEnd", 0)
			end
			if sprite:IsEventTriggered("Slam") then
				npcd.IsJumping = 0
				npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_ALL
				npc.GridCollisionClass = GridCollisionClass.COLLISION_SOLID
			end
	--Puffed Out
		elseif npc.State == 41 then
			if sprite:IsFinished("PuffedOut") then
				npc.State = 20
			elseif not sprite:IsPlaying("PuffedOut") then
				sprite:Play("PuffedOut", 0)
			end
		end
end

function mod:squareFlyAI(npc)
local s = npc:GetSprite()
local d = npc:GetData()
local v = npc.Variant
local target = npc:GetPlayerTarget()

local speed = 4.5

local pos = npc.Position
local targetPos = mod:confusePos(npc, npc:GetPlayerTarget().Position)

	if npc:IsDead() then
		local burst = Isaac.Spawn(1000, 3, 0, npc.Position, nilvector, npc):ToEffect()
		burst.SpriteOffset = Vector(0,-14)
	end

	if not s:IsPlaying("Fly") then
		s:Play("Fly", 0)
	end

	if targetPos.X - npc.Position.X > 0
		then
			d.MV1 = 2
			d.MV3 = 1
		else
			d.MV1 = 1
			d.MV3 = 2
	end

	if targetPos.Y - npc.Position.Y > 0
		then
			d.MV2 = 2
			d.MV4 = 1
		else
			d.MV2 = 1
			d.MV4 = 2
	end

	if not d.init then
		if FiendFolio.GetBits(npc.SubType, 0, 1) == 1 then
			s:Load("gfx/enemies/squarefly/square_fly_ccw.anm2", true)
		end

		d.init = true
	end

	if d.moveDir == nil then
		d.changeDir = 1
		d.moveDir = FiendFolio.GetBits(npc.SubType, 1, 2) + 1
	else
		if d.moveDir == 1 then
			d.targetVelocity = Vector(speed,0) * d.MV1
		elseif d.moveDir == 2 then
			d.targetVelocity = Vector(0,speed) * d.MV2
		elseif d.moveDir == 3 then
			d.targetVelocity = Vector((0-speed),0) * d.MV3
		elseif d.moveDir == 4 then
			d.targetVelocity = Vector(0,(0-speed)) * d.MV4
		end
	d.changeDir = d.changeDir + 1
	if mod.anyPlayerHas(CollectibleType.COLLECTIBLE_SKATOLE) then
		d.targetVelocity = d.targetVelocity * 0.5
		npc.CollisionDamage = 0
	end
	npc.Velocity = mod:runIfFear(npc, (d.targetVelocity * 0.3) + (npc.Velocity * 0.6), speed)
	end

	if d.changeDir == 25 then
		if FiendFolio.GetBits(npc.SubType, 0, 1) == 0 then
			d.moveDir = d.moveDir + 1
			if d.moveDir == 5 then
				d.moveDir = 1
			end
		else
			d.moveDir = d.moveDir - 1
			if d.moveDir == 0 then
				d.moveDir = 4
			end
		end
		d.changeDir = 1
	end
end

--FacadeAI
function mod:hungryganAI(npc)
local room = game:GetRoom()
local sprite = npc:GetSprite();
local d = npc:GetData();
local target = npc:GetPlayerTarget()
local path = npc.Pathfinder

	local facspeed = 6.5

	if target.Type == 1 then
		local playerhere = target:ToPlayer()
		if playerhere.MoveSpeed < 1 then
			facspeed = 6.5 * math.max(0.6, playerhere.MoveSpeed)
		end
	end


	if not d.init then
		d.npcState = "idle"
		d.init = true
	elseif d.init then
		npc.StateFrame = npc.StateFrame + 1
	end

	if d.npcState == "idle" then
		--Only run away mulligan style
		npc.State = 4

		--local closestplayer = mod.FindClosestEntity(npc.Position,99999,1)

		if npc.Position:Distance(target.Position) < 60 and not mod:isScareOrConfuse(npc) then
			d.npcState = "startangery"
		end

	elseif d.npcState == "startangery" then
		npc.State = 6
		local overlayFrame = sprite:GetOverlayFrame()

		if sprite:IsOverlayFinished("Explode") then
			d.npcState = "angery"
		elseif overlayFrame == 7 then
			d.angerywalk = true
			npc.StateFrame = 0
			npc:PlaySound(SoundEffect.SOUND_MEATY_DEATHS,1,0,false,0.7)
			npc:BloodExplode()
		else
			mod:spriteOverlayPlay(sprite, "Explode")
		end

		if not d.angerywalk then
			npc:AnimWalkFrame("WalkHori","WalkVert",0)
			npc.Velocity = npc.Velocity * 0.9
		end

	elseif d.npcState == "angery" then
		npc.State = 6
		local overlayFrame = sprite:GetOverlayFrame()

		mod:spriteOverlayPlay(sprite, "WalkAngery")

		if overlayFrame == 6 then
			--npc:BloodExplode()
		end
	end

	if d.angerywalk then

	--Movement
		local targetpos = mod:confusePos(npc, target.Position)
		if room:CheckLine(npc.Position,targetpos,0,1,false,false) or mod:isScare(npc) then
			d.targetvelocity = mod:reverseIfFear(npc, (targetpos - npc.Position):Resized(facspeed))
			npc.Velocity = mod:Lerp(d.targetvelocity, npc.Velocity, 0.8)
		else
			 mod:CatheryPathFinding(npc, targetpos, {
				Speed = facspeed,
				Accel = 0.2,
				GiveUp = true
			 })
		end

		npc:AnimWalkFrame("WalkHoriRage","WalkVertRage",0)

	--Anger other facades
		if npc.StateFrame % 10 == 0 then
			for index,entity in ipairs(Isaac.FindByType(16, mod.FF.Facade.Var, 0, false, false)) do
				if npc.Position:Distance(entity.Position) < 200 then
					if room:CheckLine(npc.Position, entity.Position, 3, 1, false, false) then
						if not mod:isScareOrConfuse(entity:ToNPC()) then
							entity:GetData().npcState = "startangery"
							entity.SubType = 1
						end
					end
				end
			end
		end

	--Bleed
		if npc.FrameCount % 2 == 1 then
			local blood = Isaac.Spawn(1000, 7, 0, npc.Position, nilvector, npc)
			blood.SpriteScale = Vector(0.6,0.6)
			blood:Update()
		end

	end

	if npc:IsDead() then
		for index,entity in ipairs(Isaac.GetRoomEntities()) do
			if entity.SpawnerType == 16 and entity.SpawnerVariant == mod.FF.Facade.Var then
				local entype = entity.Type
				if entype == 13 or entype == 14 or entype == 18 then
					entity:Remove()
				end
			end
		end
		local startvec = RandomVector()*8
		for i = 1, 9 do
		Isaac.Spawn(9, 0, 0, npc.Position, startvec:Rotated(360/9 * i), npc):ToProjectile();
		end
	end

end

function mod:HungerHurt(npc, damage)
	if npc.Variant == mod.FF.Facade.Var then
		if npc.SubType == 0 then
			npc:GetData().npcState = "startangery"
			npc.SubType = 1
		end
	end
end
mod:AddCallback(ModCallbacks.MC_ENTITY_TAKE_DMG, mod.HungerHurt, 16)

function mod:ffShopkeeperAI(npc)
	local subt = npc.SubType
	if subt == 0 then
		npc.SubType = math.random(9)
	end
	mod:spritePlay(npc:GetSprite(), "Shopkeeper " .. subt)
end

function mod:rolyPolyAI(npc, subt)
local room = game:GetRoom()
local sprite = npc:GetSprite();
local data = npc:GetData();
local target = npc:GetPlayerTarget()
npc:AddEntityFlags(EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK)

	if not data.initcomplete then
		data.initcomplete = true
		data.bstate = 0
		local level = game:GetLevel()
		local stage = level:GetStage()
		local stageType = level:GetStageType()

		if data.spawnedFromBubble == true then
			npc.State = 16
			sprite:Play("Roll", true)
			data.launchedEnemyInfo = {zVel = -3, height = -30, pos = true}
			--data.z_vel = -3
			npc:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
		end
	end

	if npc.State == 16 then
		if sprite:IsFinished("RollEnd") then
			npc.State = 4
		elseif npc.SpriteOffset.Y < 0 then
			mod:spritePlay(sprite, "Roll")
		elseif data.launchedEnemyLanded then
			npc.SpriteOffset = Vector.Zero
			mod:spritePlay(sprite, "RollEnd")
			data.bubbleInit = true
		end
		npc.Velocity = Vector.Zero
	elseif npc.State == 4 then
	npc.Friction = 1
		if npc.Velocity:Length() > 3 then
			npc.Velocity = npc.Velocity:Normalized() * 3
		end
			local d = target.Position - npc.Position
		if (npc.Position:Distance(target.Position) < 100 and room:CheckLine(npc.Position, target.Position,0,1,false,false)) and not mod:isScareOrConfuse(npc)
		or ((npc.Velocity:Normalized():Dot(d:Normalized()) > math.cos(0.3)) and npc.Position:Distance(target.Position) < 300 and room:CheckLine(npc.Position, target.Position,0,1,false,false)) and not mod:isScareOrConfuse(npc)
		then
			data.bstate = 1
			npc.State = 10
		end

	elseif npc.State == 10 then
		if data.bstate == 1 then
			if sprite:IsFinished("RollStart") then
				data.bstate = 2
				data.rollTime = 0
				npc.StateFrame = 1
			elseif not sprite:IsPlaying("RollStart") then
				sprite:Play("RollStart", true)
			end

		elseif data.bstate == 2 then
			data.rollTime = data.rollTime + 1
		--npc.Friction = 1.05

		--Play sound
			if not sfx:IsPlaying(mod.Sounds.RolyPolyRoll) and not npc:HasMortalDamage() then
				sfx:Play(mod.Sounds.RolyPolyRoll, 0.6, 0, true, 1)
			end

		--Too close to player?
			if data.rollTime > 120 or npc.Position:Distance(target.Position) < 30 or mod:isScareOrConfuse(npc) then
				data.bstate = 3
			end
		--Movement
		data.TargetVelocity = (target.Position - npc.Position):Normalized() * 10
		npc.Velocity = mod:Lerp(npc.Velocity, data.TargetVelocity, 0.07)

			--Grid Bounce
			if npc:CollidesWithGrid() == true then
				if npc.Velocity:Length() < 5 then
					data.bstate = 3
				else
					data.TargetVelocity = mod.bounceOffWallLegacy(npc.Position, npc.Velocity)
					data.TargetVelocity = data.TargetVelocity * 50
				end
			end

		--Septic
		if subt == 1 and npc.FrameCount % 3 == 0 then
			local creep = Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.CREEP_GREEN, 0, npc.Position, nilvector, npc):ToEffect();
			creep:Update()
		end

		--Enemy sight stop
		if not room:CheckLine(npc.Position, target.Position,0,1,false,false) then
			npc.StateFrame = npc.StateFrame + 1
			if npc.StateFrame > 180 then
				data.bstate = 3
			end
		else
			npc.StateFrame = 1
		end

		--Animations
			if not sprite:IsPlaying("Roll") then
				sprite:Play("Roll", true)
			end
			if npc.Velocity.X < 0 then
				sprite.FlipX = true
			else
				sprite.FlipX = false
			end
		--FindGridPath(npc, npc:GetPlayerTarget().Position, 5, 1, true, 100, false, false)
		elseif data.bstate == 3 then
			npc.Friction = 1
			npc.Velocity = npc.Velocity * 0.93
			if sprite:IsFinished("RollEnd") then
				npc.State = 4
				data.bstate = 0
			elseif not sprite:IsPlaying("RollEnd") then
				sprite:Play("RollEnd", true)
				sfx:Stop(mod.Sounds.RolyPolyRoll)
			end
		end
	end
end

--Kinda funny going from a maggot to a knight but thanks nicalis

function mod:psionicKnightAI(npc, sprite, d)
local room = game:GetRoom()
local subt = npc.SubType


	--The fucka's brain
	if subt == 1 then
		npc.State = 10
		npc:AddEntityFlags(EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK | EntityFlag.FLAG_NO_KNOCKBACK)
		npc.Visible = false
		npc.CollisionDamage = 0
		npc:SetSize(17, Vector(1,1), 40)
		if npc.Parent then
			--npc.EntityFlags
			if npc.Parent:GetData().state == "chargecollide" or npc.Parent:GetData().state == "chargedizzy" then
				npc.Position = npc.Parent.Position + npc.Parent.Velocity:Resized(10)
			else
				npc.Position = npc.Parent.Position - npc.Parent.Velocity:Resized(10)
			end
			npc.Velocity = nilvector
			if d.eternalFlickerspirited then
				npc.Parent:SetColor(Color(1.5,1.5,1.5,1,50 / 255,50 / 255,50 / 255),15,1,true,false)
			end
		else
			npc:Remove()
		end


	else --The actual fucka
		local target = npc:GetPlayerTarget()
		local r = npc:GetDropRNG()
		local speed = 15

		if not d.init then
			npc:AddEntityFlags(EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK | EntityFlag.FLAG_NO_KNOCKBACK)
			d.state = "idle"

			local hurtbox = mod.spawnent(npc, npc.Position, nilvector, 21, 961, 1)
			hurtbox.Parent = npc
			hurtbox.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS
			hurtbox.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_NONE
			hurtbox:GetSprite():Play("Hidden", true)
			npc.Child = hurtbox

			d.init = true
		end

		--if npc.Child then
		--	if npc.Child:IsDead() then
		--		npc:Kill()
		--	end
		--else
		--	npc:Kill()
		--end

		if (not npc.Child) and (not mod:isLeavingStatusCorpse(npc)) then
			npc:Kill()
		elseif npc.Child then
			-- For charm compatibility (DOESNT WORK BECAUSE MAGGOT VARIANT AAAAAAAAAAA)
			if target.InitSeed == npc.Child.InitSeed then
				target = Isaac.GetPlayer(0)
			end
		end
		npc.Target = target

		if npc.State == 4 then
			if npc.StateFrame > 20 and target.Position:Distance(npc.Position) < 250 and not mod:isScareOrConfuse(npc) then
				if math.abs(npc.Velocity.X) < math.abs(npc.Velocity.Y) then
					if math.abs(npc.Position.X - target.Position.X) < 20 then
						npc.State = 10
						d.state = "chargeinit"
						if npc.Velocity.Y < 0 then
							d.dir = {"Up", Vector(0,-speed)}
						else
							d.dir = {"Down", Vector(0,speed)}
						end
					end
				else
					if math.abs(npc.Position.Y - target.Position.Y) < 20 then
						npc.State = 10
						d.state = "chargeinit"
						if npc.Velocity.X < 0 then
							d.dir = {"Hori", Vector(-speed,0)}
						else
							d.dir = {"Hori", Vector(speed,0)}
						end
					end
				end
			end

		elseif npc.State == 10 then
			if d.state == "chargeinit" then
				npc.Velocity = npc.Velocity * 0.7
				if sprite:IsFinished("Brimstone" .. d.dir[1]) then
					d.state = "chargeloop"
					mod:spritePlay(sprite, "Brimstone" .. d.dir[1] .. "Loop")
				elseif sprite:IsEventTriggered("flystart") then
					d.flying = true
					npc.StateFrame = 0
					npc.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_NOPITS
					local brim = Isaac.Spawn(7,1,0,npc.Position, nilvector, npc):ToLaser()
					brim.PositionOffset = Vector(0, -26)
					brim.SpawnerEntity = npc
					brim.Parent = npc
					brim.Angle = (d.dir[2]:Rotated(180)):GetAngleDegrees()
					brim:SetTimeout(10000)
					brim:GetData().annoyingAndStupidPsionicKnightThing = true
					brim:Update()
					d.brim = brim
				else
					mod:spritePlay(sprite, "Brimstone" .. d.dir[1])
				end
			elseif d.state == "chargeloop" then
				mod:spritePlay(sprite, "Brimstone" .. d.dir[1] .. "Loop")
				if d.brim then
					d.brim:Update()
				end
				if npc:CollidesWithGrid() then
					game:ShakeScreen(5)
					npc:PlaySound(SoundEffect.SOUND_HELLBOSS_GROUNDPOUND,0.6,2,false,1.7)
					--[[if npc.Velocity:Length() > 20 then
						npc.Velocity = npc.Velocity:Resized(20)
					elseif npc.Velocity:Length() < 8 then
						npc.Velocity = npc.Velocity * 0.1
					end]]
					--npc.Position = npc.Position - npc.Velocity
					npc.Velocity = npc.Velocity * 0.1
					d.flying = false
					d.brim:SetTimeout(1)
					local coll = room:GetGridCollisionAtPos(npc.Position)
					if coll ~= GridCollisionClass.COLLISION_PIT then
						npc.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_GROUND
						d.state = "chargecollide"
					else
						npc:Kill()
					end
				end
			elseif d.state == "chargecollide" then
				npc.Velocity = npc.Velocity * 0.1
				if sprite:IsFinished(d.dir[1] .. "Collide") then
					d.state = "chargedizzy"
					npc.StateFrame = 0
				else
					mod:spritePlay(sprite, d.dir[1] .. "Collide")
				end
			elseif d.state == "chargedizzy" then
				mod:spritePlay(sprite, d.dir[1] .. "Dizzy")
				if npc.StateFrame > 30 then
					npc.State = 4
					d.state = "idle"
					npc.StateFrame = 0
				end

			end
			if d.flying then
				npc.Velocity = d.dir[2]:Resized(speed * (1 + (npc.StateFrame / 5)))
				if npc.Velocity:Length() > 30 then
					npc.Velocity = npc.Velocity:Resized(30)
				end
			end

		end
	end
end

function mod:SternumDestruction(npc)
local d = npc:GetData()
	d.keepchargin = false
	npc.State = 10

	local smoke = Isaac.Spawn(1000, EffectVariant.DARK_BALL_SMOKE_PARTICLE, 0, npc.Position, nilvector, npc)
	smoke.SpriteRotation = math.random(360)
	smoke.Color = Color(1,1,1,0.3,75 / 255,70 / 255,50 / 255)
	smoke.SpriteScale = Vector(2,2)
	smoke.SpriteOffset = Vector(0, -10)
	smoke:Update()

	npc:PlaySound(SoundEffect.SOUND_BONE_SNAP, 1, 0, false, math.random(90,110)/100)
	npc:ClearEntityFlags(EntityFlag.FLAG_NO_KNOCKBACK | EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK)
	local vec = RandomVector()
	for i = 120, 360, 120 do
		local rib = Isaac.Spawn(mod.FF.SternumRib.ID, mod.FF.SternumRib.Var, i/120, npc.Position, vec:Resized(9):Rotated(i - 30 + math.random(60)), npc):ToNPC();
		rib:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
		rib.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_NONE
		rib.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYERONLY
		rib.Parent = npc
		rib:Update()
	end
end

--sternumAI
function mod:rocketChargerAI(npc, variant)
	local d = npc:GetData()
	local sprite = npc:GetSprite()

	if not d.init then
		d.count = 0
		if variant == mod.FF.Splodum.Var then
			npc.SplatColor = Color(0,0,0,1,20 / 255,10 / 255,10 / 255)
		end
		npc:AddEntityFlags(EntityFlag.FLAG_NO_BLOOD_SPLASH)
		d.init = true
	end

	if d.keepchargin then
		npc.State = 8
	end

	if npc.State == 8 then
		npc:AddEntityFlags(EntityFlag.FLAG_NO_KNOCKBACK | EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK)
		d.keepchargin = true
		d.count = d.count + 1
		local velnew = (1.2 + (d.count / 7))^2
		npc.Velocity = npc.Velocity:Resized(math.min(25,velnew))
		if npc:CollidesWithGrid() == true then
			npc.Velocity = npc.Velocity * 0.3
			if variant == mod.FF.Splodum.Var then
				npc:Kill()
			else
				mod:SternumDestruction(npc)
			end
		end
	elseif npc.State == 10 then
		npc.Velocity = npc.Velocity * 0.3
		if not d.state then
			if sprite:IsFinished("Collide") then
				d.state = "sitThere"
				npc.StateFrame = 0
			else
				mod:spritePlay(sprite, "Collide")
			end
		elseif d.state == "sitThere" then
			if npc.StateFrame > 180 then
				d.sucking = false
				mod:spritePlay(sprite, "HeadIdle")
			elseif npc.StateFrame > 60 then
				d.sucking = true
				if sprite:IsFinished("SuckStart") then
					mod:spritePlay(sprite, "Suck")
				elseif not sprite:IsPlaying("Suck") then
					mod:spritePlay(sprite, "SuckStart")
				end
				d.returns = d.returns or {0,0,0}
				local anyNotBack
				for i = 1, #d.returns do
					if d.returns[i] == 0 then
						anyNotBack = true
					end
				end
				if not anyNotBack then
					d.state = "reform"
					sfx:Play(SoundEffect.SOUND_BONE_HEART, 1, 0, false, math.random(90,110)/100)
					local smoke = Isaac.Spawn(1000, EffectVariant.DARK_BALL_SMOKE_PARTICLE, 0, npc.Position, nilvector, npc)
					smoke.SpriteRotation = math.random(360)
					smoke.Color = Color(1,1,1,0.3,75 / 255,70 / 255,50 / 255)
					smoke.SpriteScale = Vector(2,2)
					smoke.SpriteOffset = Vector(0, -10)
					smoke:Update()
				end
			else
				mod:spritePlay(sprite, "HeadIdle")
			end
		elseif d.state == "reform" then
			d.returns = nil
			d.sucking = nil
			if sprite:IsFinished("Appear") then
				npc.State = 4
				d.count = 0
				d.state = nil
			else
				mod:spritePlay(sprite, "Appear")
			end
		end
	else
		d.count = 0
	end

	if npc:IsDead() and variant == mod.FF.Splodum.Var then
		local params = ProjectileParams()
		for i = 120, 360, 120 do
			params.Variant = 1
			params.FallingSpeedModifier = -15 - math.random(10)
			params.FallingAccelModifier = 1.4 + math.random(2)/10;
			params.VelocityMulti = ((math.random(6,7) * (math.random(7,13)/100)))
			params.Color = Color(0.3, 0.3, 0.3, 1, 0, 0, 0)
			npc:FireProjectiles(npc.Position, Vector(0,8):Rotated(i-40+math.random(80)), 0, params)
		end
		Isaac.Explode(npc.Position, npc, 10)
	end
end

function mod:sternumRibsAI(npc, subt)
	local d = npc:GetData()
	local sprite = npc:GetSprite()

	if not d.init then
		mod:spritePlay(sprite, "spin" .. subt)
		d.init = true
		npc:AddEntityFlags(EntityFlag.FLAG_NO_BLOOD_SPLASH)
		npc.SpriteOffset = Vector(0, -5)
	else
		npc.StateFrame = npc.StateFrame + 1
	end
	if npc.Parent and not mod:isStatusCorpse(npc.Parent) then
		local p = npc.Parent
		local pd = p:GetData()

		if pd.state == "reform" then
			npc:Remove()
		elseif pd.sucking and p:GetSprite():IsPlaying("Suck") then
			local targvec = (p.Position - npc.Position) * 0.1
			npc.Velocity = mod:Lerp(npc.Velocity, targvec, 0.3)
			mod:spritePlay(sprite, "spin" .. subt)
			if npc.Position:Distance(p.Position) < 10 then
				pd.returns = pd.returns or {0,0,0}
				pd.returns[subt] = 1
			end
		elseif npc.StateFrame > 30 then
			npc.Velocity = npc.Velocity * 0.8
			if p:GetSprite():IsPlaying("SuckStart") then
				mod:spritePlay(sprite, "spin" .. subt)
			else
				mod:spritePlay(sprite, "idle" .. subt)
			end
		else
			npc.Velocity = npc.Velocity * 0.96
			mod:spritePlay(sprite, "spin" .. subt)
		end
	else
		npc:Kill()
	end
end

function mod:chargerCollide(npc, npc2, mysteryBoolean)
	if npc.Variant == mod.FF.Splodum.Var or npc.Variant == mod.FF.Sternum.Var then
		if npc:ToNPC().State == 8 then
			if npc2.Type == mod.FFID.Tech and npc2.Variant < 3 then
				npc2:Kill()
			elseif npc2.Type == 1 or npc2:IsEnemy() then
				if npc.Variant == mod.FF.Sternum.Var then
					mod:SternumDestruction(npc:ToNPC())
				else
					npc:Kill()
				end
			end
		end
	end
end
mod:AddCallback(ModCallbacks.MC_PRE_NPC_COLLISION , mod.chargerCollide, 23)

--FIEND FOLIO REHEATED WHOOOOOOO

mod.reheatedEnemies = {
{23, 1700},	--Reheated Charger
{87, 710},
{214, 710},
{214, 711},
{214, 712},
{214, 713},
{214, 714},
{215, 710},
{215, 711},
{215, 712},
{215, 713},
{215, 714},
{215, 715},
{240, 710},
{240, 711},
{284, 710},
{mod.FF.ReheatedBeserker.ID, mod.FF.ReheatedBeserker.Var},
}

--Reheated Chest
mod:AddCallback(ModCallbacks.MC_POST_PICKUP_UPDATE, function(_, pickup)
	pickup.Velocity = pickup.Velocity * 0.8
	local sprite = pickup:GetSprite()
	if sprite:IsFinished("Appear") then
		sprite:Play("Idle", true)
	end
	if sprite:IsFinished("Open") then
		sprite:Play("Opened", true)
	end
	if sprite:IsPlaying("Open") and sprite:GetFrame() == 5 then
		local rand = math.random(#mod.reheatedEnemies)
		local en = mod.reheatedEnemies[rand]
		local friend = Isaac.Spawn(en[1], en[2], 0, pickup.Position + Vector(0,10), nilvector, npc)
	end
	if sprite:IsEventTriggered("DropSound") then
		sfx:Play(SoundEffect.SOUND_CHEST_DROP, 1, 0, false, 1.0)
	end
	if pickup:GetData().Opened and sprite:IsPlaying("Idle") then
		pickup:Remove()
	end
end, 710)

mod.shopChestStates = {
	Closed = 0,
	Opening = 1,
	Opened = 2,
	Leaving = 3,
	DoneLeaving = 4,
	Exploded = 5
}

mod.shopChestChances = {
1,1,1,1,1,
2,2,2,2,2,2,2,2,2,2,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
4,4,
5
}

mod.shopChestItemSpawnRots = {
[1] = {StartVec = Vector(0,40), Rotval = 0},
[2] = {StartVec = Vector(-40,0), Rotval = -180},
[3] = {StartVec = Vector(-40,0), Rotval = -90},
[4] = {StartVec = Vector(-40,-20), Rotval = -75},
[5] = {StartVec = Vector(-40,0), Rotval = -45}
}

function mod:spawnShopChestItems(chest, d)
	sfx:Play(SoundEffect.SOUND_SUMMONSOUND,1,1,false,1)
	local count = mod.shopChestChances[math.random(#mod.shopChestChances)]
	local room = Game():GetRoom()
	if room:GetType() == RoomType.ROOM_DEVIL then
		count = 1
	end
	for i = 1, count do
		if room:GetType() == RoomType.ROOM_SECRET or room:GetType() == RoomType.ROOM_SUPERSECRET then
			local spawnpos = room:FindFreePickupSpawnPosition(chest.Position + mod.shopChestItemSpawnRots[count].StartVec:Rotated((i - 1) * mod.shopChestItemSpawnRots[count].Rotval), 0, false)
			local item
			local rng = chest:GetDropRNG()
			if rng:RandomInt(20) == 0 then
				item = Isaac.Spawn(5,100,0, spawnpos, nilvector, chest):ToPickup()
			else
				item = Isaac.Spawn(5,0,3, spawnpos, nilvector, chest):ToPickup()
			end
			local rand = rng:RandomInt(20)
			if rand < 5 then
				item.AutoUpdatePrice = false
				local rando = rng:RandomInt(3)
                if rando == 1 then
                    item.Price = rng:RandomInt(10) + 1
                elseif rando == 2 then
                    item.Price = rng:RandomInt(20) + 1
                else
                    item.Price = rng:RandomInt(99) + 1
                end
			else
				item.AutoUpdatePrice = true
				item.Price = 1
			end
			item.ShopItemId = -1
			local poof = Isaac.Spawn(1000, EffectVariant.POOF01, 15, item.Position, nilvector, nil)
	
			d.items[i] = item.InitSeed
			d.itemCount = count
		else
			local spawnpos = room:FindFreePickupSpawnPosition(chest.Position + mod.shopChestItemSpawnRots[count].StartVec:Rotated((i - 1) * mod.shopChestItemSpawnRots[count].Rotval), 0, false)
			local item = Isaac.Spawn(5,150,0, spawnpos, nilvector, chest)
			local poof = Isaac.Spawn(1000, EffectVariant.POOF01, 15, item.Position, nilvector, nil)

			d.items[i] = item.InitSeed
			d.itemCount = count
		end
	end
end

mod.ShopChestGfxVariants = {
  [RoomType.ROOM_SHOP] = "slot_shop_shop_begger.png",
  [RoomType.ROOM_BOSS] = "slot_shop_boss_begger.png",
  [RoomType.ROOM_SECRET] = "slot_shop_secret_begger.png",
  [RoomType.ROOM_CURSE] = "slot_shop_devil_begger.png",
  [RoomType.ROOM_DEVIL] = "slot_shop_devil_begger.png",
  [RoomType.ROOM_LIBRARY] = "slot_shop_library_begger.png",
  [RoomType.ROOM_ANGEL] = "slot_shop_angel_begger.png",
  [RoomType.ROOM_CHEST] = "slot_shop_chest_begger.png",
  [RoomType.ROOM_BLACK_MARKET] = "slot_shop_black_market_begger.png",
  [RoomType.ROOM_PLANETARIUM]  = "slot_shop_planetarium_begger.png",
  [RoomType.ROOM_ULTRASECRET]  = "slot_shop_ultrasecret_begger.png",
  }

mod:AddCallback(ModCallbacks.MC_POST_PICKUP_INIT, function(_, chest)
  local gfxVar = mod.ShopChestGfxVariants[Game():GetRoom():GetType()]
  if gfxVar then
	local sprite = chest:GetSprite()
	sprite:ReplaceSpritesheet(0, "gfx/items/slots/" .. gfxVar)
	sprite:ReplaceSpritesheet(1, "gfx/items/slots/" .. gfxVar)
	sprite:LoadGraphics()
  end
end, 711)

--Shop chest, storechestai, shopchestai, store chest,
mod:AddCallback(ModCallbacks.MC_POST_PICKUP_UPDATE, function(_, chest)
	local room = game:GetRoom()
	chest = chest:ToPickup()
	local sprite = chest:GetSprite()
  --if chest.FrameCount == 1 then setShopChestGFX(sprite) end
	local chestseed = tostring(chest.InitSeed)
	local d = FiendFolio.getFieldInit(FiendFolio.savedata, 'run', 'level', 'ChestData', chestseed, {})
	local gd = chest:GetData()
	chest.Velocity = chest.Velocity * 0.8
	d.items = d.items or {}

	chest.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYERONLY
	--print(chest.SubType)
	--[[if gd.Opened then
		d.Opened = true
		--chest.InitSeed = 10
	end]]

	--[[if chest.FrameCount % 5 == 1 then
		print(chest.InitSeed)
		chest:Morph(5, 711, 0, false)
	end]]

	if chest.SubType > 0 and not gd.Position then
		--Keep Pos
		gd.Position = room:GetGridPosition(room:GetGridIndex(chest.Position))
	end

	if chest.SubType > 1 then
		gd.dontSpawnItems = true
	end

	if not chest:GetData().init then
		if mod.anyPlayerHas(CollectibleType.COLLECTIBLE_PAY_TO_PLAY) then
			gd.payToPlayMode = true
		end
		if chest.SubType > 2 then
			if chest.SubType == mod.shopChestStates.Leaving then
				grng:SetSeed(chest.InitSeed, 0)
				if grng:RandomInt(10) <= 7 then
					Isaac.Spawn(5, 0, 0, chest.Position, RandomVector(), nil)
				end
			end
			chest:Remove()
		elseif chest.SubType > 0 then
			if chest.SubType == mod.shopChestStates.Opening then
				if gd.funny then
					sprite:Play("Open", true)
					sfx:Play(SoundEffect.SOUND_CHEST_OPEN, 1, 0, false, 1)
				else
					sprite:Play("Opened", true)
					mod:spawnShopChestItems(chest, d)
					chest.SubType = mod.shopChestStates.Opened
				end
			else
				sprite:Play("Opened", true)
			end
		else
			if gd.payToPlayMode then
				sprite:Play("AppearP2P", true)
			end
		end
		gd.init = true
	end

	local p2pAmmend = ""
	if gd.payToPlayMode then
		p2pAmmend = "P2P"
	end

	if sprite:IsFinished("Appear" .. p2pAmmend) then
		sprite:Play("Idle" .. p2pAmmend, true)
	end
	if sprite:IsFinished("Open" .. p2pAmmend) then
		sprite:Play("Opened", true)
	end
	--[[if sprite:IsPlaying("Open") and sprite:GetFrame() == 5 then
	end]]
	if sprite:IsEventTriggered("DropSound") then
		sfx:Play(SoundEffect.SOUND_CHEST_DROP, 1, 0, false, 1.0)
	end
	if sprite:IsEventTriggered("Spawnem") then
		--Spawn Items
		if not gd.dontSpawnItems then
			mod:spawnShopChestItems(chest, d)
		end
		chest.SubType = mod.shopChestStates.Opened
	end
	if d.Opened and sprite:IsPlaying("Idle") then
		chest:Remove()
	end

	if chest.SubType > 1 and chest.SubType < 3 then
		local itemCountNew = 0
		for _, item in ipairs(Isaac.FindByType(5, -1, -1, false, false)) do
			for i = 1, #d.items do
				if item.InitSeed == d.items[i] then
					itemCountNew = itemCountNew + 1
				end
			end
		end
		--print ("#items spawned = " .. d.itemCount .. " #items detected = " .. itemCountNew)
		if itemCountNew < 1 then
			mod:spritePlay(sprite, "Close")
			chest.SubType = mod.shopChestStates.Leaving
		elseif itemCountNew < d.itemCount then
			d.itemCount = itemCountNew
			sprite:Play("OpenedHappy", true)
		end

		for _, explosion in ipairs(Isaac.FindByType(1000, 1, -1, false, false)) do
			if explosion.Position:Distance(chest.Position) < 80 then
				chest.SubType = mod.shopChestStates.Exploded
				sprite:Play("Destroyed", true)
				--Just slapping this code in as is from happy pack
				local keeper = Isaac.Spawn(EntityType.ENTITY_SHOPKEEPER, 0, 0, chest.Position, nilvector, nil)
				keeper.Visible = false
				keeper:TakeDamage(999, 0, EntityRef(explosion), 0)
				keeper:Update()
			end
		end
	end

	if sprite:IsPlaying("Close") and sprite:GetFrame() == 21 then
		chest.SubType = mod.shopChestStates.DoneLeaving
		grng:SetSeed(chest.InitSeed, 0)
		if grng:RandomInt(10) <= 7 then
			Isaac.Spawn(5, 0, 0, chest.Position, RandomVector(), nil)
		end
	end
	if sprite:IsFinished("Close") then
		chest:Remove()
	end

	if gd.Position and chest.SubType ~= mod.shopChestStates.Exploded then
		chest.Velocity = (gd.Position - chest.Position)
	end
end, 711)

--Dire Chest
mod:AddCallback(ModCallbacks.MC_POST_PICKUP_UPDATE, function(_, chest)
	chest = chest:ToPickup()
	local sprite = chest:GetSprite()
	local chestseed = tostring(chest.InitSeed)
	local d = FiendFolio.getFieldInit(FiendFolio.savedata, 'run', 'level', 'ChestData', chestseed, {})
	local gd = chest:GetData()
	chest.Velocity = chest.Velocity * 0.8
	chest.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYERONLY

	if not d.init then
		sprite:Play("Appear", true)
		d.chanceToFinish = 0
		d.init = true
	end

	if sprite:IsEventTriggered("DropSound") then
		sfx:Play(SoundEffect.SOUND_CHEST_DROP, 1, 0, false, 1.0)
	end
	if sprite:IsFinished("Appear") then
		sprite:Play("Idle", true)
	end
	if sprite:IsEventTriggered("Leave") and d.remove == true then
		chest:Remove()
	end
	if sprite:IsFinished("Open") and d.ended ~= true then
		sprite:Play("CloseBack", true)
	end
	if sprite:IsFinished("CloseBack") then
		sprite:Play("Idle", true)
	end
	if sprite:IsFinished("OpenNothing") then
		sprite:Play("OpenedNothing", true)
	end
end, 712)

mod.direChestCardPool = {
	--Fiendish
	Card.PLUS_3_FIREBALLS,
	Card.IMPLOSION,
	Card.NECROMANCER,
	Card.SKIP_CARD,
	--Jacks
	Card.JACK_OF_CLUBS,
	Card.JACK_OF_DIAMONDS,
	Card.JACK_OF_HEARTS,
	Card.JACK_OF_SPADES,
}

function mod:FFDireChestOpening(pickup, collider)
	local chestseed = tostring(pickup.InitSeed)
	local data = FiendFolio.getFieldInit(FiendFolio.savedata, 'run', 'level', 'ChestData', chestseed, {})
	local isSnagger
	if collider.Type == 1 then
		collider = collider:ToPlayer()
	elseif collider.Type == mod.FF.Snagger.ID and collider.Variant == mod.FF.Snagger.Var then
		isSnagger = true
	end
	if pickup:GetSprite():IsPlaying("Idle") then
	--print(pickup.SubType)
		sfx:Play(SoundEffect.SOUND_CHEST_OPEN, 1, 0, false, 1)
		local chance = grng:RandomInt(11)
		if chance <= data.chanceToFinish then
			local payoutChance = grng:RandomInt(5)
			if payoutChance == 0 then --Positive Payout
				--print("Payout: Positive")
				pickup:GetSprite():Play("Open")
				mod.scheduleForUpdate(function()
					sfx:Play(mod.Sounds.DirePayout, 0.4, 0, false, 1)
				end, 5)
				data.payout = "positive"
				data.ended = true
				pickup.SubType = 1
			else--Negative Payout
				--print("Payout: Negative")
				pickup:GetSprite():Play("OpenNothing")
				mod.scheduleForUpdate(function()
					sfx:Play(mod.Sounds.AceVenturaLaugh, 1, 0, false, 1.5)
				end, 10)
				data.payout = "negative"
				data.ended = true
				pickup.SubType = 1
			end
		else --Since it is set amounts of items, and not a pool, using a table is probably not the best approach?
			pickup:GetSprite():Play("Open")
			data.chanceToFinish = data.chanceToFinish+1
			local drop = grng:RandomInt(12)
			if drop == 0 or drop == 1 then -- 2 Friendly Skuzz
				if isSnagger then
					for i=1, 2 do
						local skuzz = Isaac.Spawn(666, 60, 0, pickup.Position+RandomVector() * math.random(5,15), nilvector, pickup)
						skuzz.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS
						skuzz:GetData().jumpytimer = 0
						skuzz:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
						skuzz:Update()
					end
				else
					local randVec = RandomVector() * math.random(5,15)
					local skuzz = Isaac.Spawn(3, FamiliarVariant.ATTACK_SKUZZ, 0, pickup.Position + randVec, nilvector, pickup):ToFamiliar()
					skuzz:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
					local skuzz2 = Isaac.Spawn(3, FamiliarVariant.ATTACK_SKUZZ, 0, pickup.Position + randVec, nilvector, pickup):ToFamiliar()
					skuzz2:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
				end
			elseif drop == 2 or drop == 9 then -- 2 Enemy Skuzz
				for i=1, 2 do
					local skuzz = Isaac.Spawn(666, 60, 0, pickup.Position+RandomVector() * math.random(5,15), nilvector, pickup)
					skuzz.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS
					skuzz:GetData().jumpytimer = 0
					skuzz:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
					skuzz:Update()
				end
			elseif drop == 3 or drop == 4  then -- 1-3 Cursed coins
				for i = 1, 1 + grng:RandomInt(3) do
					Isaac.Spawn(5, 20, 213, pickup.Position, Vector(math.random(4, 7), 0):Rotated(math.random(90)+45), pickup):ToPickup()
				end
			elseif drop == 5 then -- Spicy Key
					Isaac.Spawn(5, 30, 185, pickup.Position, Vector(math.random(3, 4), 0):Rotated(90), pickup):ToPickup()
			elseif drop == 6 then -- Card
				local cardChoice = grng:RandomInt(#mod.direChestCardPool)
				Isaac.Spawn(5, 300, mod.direChestCardPool[cardChoice + 1], pickup.Position, Vector(math.random(3, 4), 0):Rotated(90), pickup):ToPickup()
			elseif drop == 7 then -- Black Heart. but it's supposed to be Immoral! IT IS NOW
				Isaac.Spawn(EntityType.ENTITY_PICKUP, PickupVariant.PICKUP_IMMORAL_HEART, 0, pickup.Position, Vector(math.random(3, 4), 0):Rotated(90), pickup):ToPickup()
			elseif drop == 8 then -- Blots
				for i = 60, 120, 60 do
				local blotVec = Vector(4, 0):Rotated(i - 20 + math.random(40))
				local blot = Isaac.Spawn(mod.FF.Blot.ID, mod.FF.Blot.Var, 0, pickup.Position, blotVec, pickup):ToNPC();
				local blotdata = blot:GetData();
				blotdata.downvelocity = -25
				blotdata.downaccel = 2.5
				blot.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
				blot.GridCollisionClass = GridCollisionClass.COLLISION_NONE
				blot:GetSprite().Offset = Vector(0, -30)
				blotdata.state = "air"
				blot:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
				blot:Update()
				end
			elseif drop == 10 then -- Rules Card
				local rando = grng:RandomInt(2)
				if rando == 1 then
					Isaac.Spawn(5, 300, 44, pickup.Position, Vector(math.random(4, 7), 0):Rotated(90), pickup)
				else
					--game:ShowFortune()
					mod:ShowFortune()
				end
			elseif drop == 11 then -- Copper Bomb
				Isaac.Spawn(5, PickupVariant.PICKUP_BOMB, FiendFolio.PICKUP.BOMB.COPPER, pickup.Position, Vector(math.random(3, 4), 0):Rotated(90), pickup):ToPickup()
			end
		end
		if data.payout == "positive" then
			local drop = grng:RandomInt(3)
			--print("Drop"..drop)
			Isaac.Spawn(4,3,0,pickup.Position,nilvector,pickup)
			if drop == 0 then
				--print("positive:Item")
				local itemChoice = mod.GetItemFromCustomItemPool(mod.CustomPool.DIRE_CHEST, pickup:GetDropRNG())
				local item = Isaac.Spawn(5, 100, itemChoice, pickup.Position, Vector(0,0), pickup)
				pickup:AddEntityFlags(EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK)
				data.remove = true
			else -- Fiendish Trinket
				--print("positive:Trinket")
				Isaac.Spawn(EntityType.ENTITY_PICKUP,PickupVariant.PICKUP_TRINKET, mod.GetItemFromCustomItemPool(mod.CustomPool.DIRE_CHEST_TRINKET, pickup:GetDropRNG()), pickup.Position, Vector(math.random(4, 7), 0):Rotated(50+math.random(10, 50)), pickup)
			end
		elseif data.payout == "negative" then
			--[[local drop = grng:RandomInt(2)
			if drop == 0 then -- Tick
				Isaac.Spawn(EntityType.ENTITY_PICKUP,PickupVariant.PICKUP_TRINKET, TrinketType.TRINKET_TICK, pickup.Position, Vector(math.random(4, 7), 0):Rotated(90), pickup)
			elseif drop == 1 then -- BOOM
				Isaac.Explode(pickup.Position,pickup,4)
			end]]
			Isaac.Explode(pickup.Position,pickup,4)
			local drop = grng:RandomInt(4)
			if drop == 1 and not isSnagger then
				collider:UseCard(45,1)
			end
		end

		if pickup.OptionsPickupIndex ~= 0 then
			local pickups = Isaac.FindByType(EntityType.ENTITY_PICKUP)
			for _, entity in ipairs(pickups) do
				if entity:ToPickup().OptionsPickupIndex == pickup.OptionsPickupIndex and
					(entity.Index ~= pickup.Index or entity.InitSeed ~= pickup.InitSeed)
				then
					Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.POOF01, 0, entity.Position, nilvector, nil)
					entity:Remove()
				end
			end
			pickup.OptionsPickupIndex = 0
		end
	end
end

function mod:FFDireChestPedestal(pickup)
	if pickup.SpawnerEntity ~= nil then
		if pickup.SpawnerEntity.Variant == 712 then
			for i = 3, 5 do pickup:GetSprite():ReplaceSpritesheet(i,"gfx/items/slots/dire_pedestal.png") end
			pickup:GetSprite():LoadGraphics()
		end
	end
end

mod:AddCallback(ModCallbacks.MC_PRE_PICKUP_COLLISION, mod.FFDireChestOpening, 712)
mod:AddCallback(ModCallbacks.MC_POST_PICKUP_INIT, mod.FFDireChestPedestal)

function mod.TryDireChestConversion(boostOdds)
	if boostOdds then
		mod.savedata.direChestConvertChance = 1 / (1 / mod.savedata.direChestConvertChance / 2)
	end

	for _, chest in pairs(Isaac.FindByType(5, PickupVariant.PICKUP_REDCHEST)) do
		if chest:GetDropRNG():RandomFloat() < mod.savedata.direChestConvertChance then
			if not mod.ACHIEVEMENT.DIRE_CHEST:IsUnlocked(true) then
				mod.ACHIEVEMENT.DIRE_CHEST:Unlock()
			end

			game:BombExplosionEffects(chest.Position, 100, TearFlags.TEAR_NORMAL, mod.ColorPsy)
			sfx:Play(mod.Sounds.FiendFolioBook)

			chest:ToPickup():Morph(5, mod.PICKUP.VARIANT.DIRE_CHEST, 0)
			mod.savedata.direChestConvertChance = 1/128
			break
		end
	end
end

mod:AddCallback(ModCallbacks.MC_POST_NEW_ROOM, function()
	local room = game:GetRoom()
	if room:GetType() == RoomType.ROOM_CURSE and not room:IsFirstVisit() then
		local playerMeetsChanceBoostCondition = false
		mod.AnyPlayerDo(function(player)
			if player:GetDamageCooldown() > 0 and player:GetData().lastDamageSourceWasCursedDoor then
				playerMeetsChanceBoostCondition = true
			end
		end)

		mod.TryDireChestConversion(playerMeetsChanceBoostCondition)
	end
end)


function mod:FFChestOpening(pickup, collider)
	if collider.Type == 1 then
		collider = collider:ToPlayer()
		if (not pickup:GetData().Opened) and (pickup:GetSprite():WasEventTriggered("DropSound") or pickup:GetSprite():IsPlaying("Idle") or pickup:GetSprite():IsPlaying("IdleP2P")) then
			if (pickup:GetData().payToPlayMode and collider:GetNumCoins() > 0)
			or ((not pickup:GetData().payToPlayMode) and (collider:HasTrinket(TrinketType.TRINKET_PAPER_CLIP) or collider:TryUseKey())) then
				if pickup:GetData().payToPlayMode then
					collider:AddCoins(-1)
				end
				if pickup:GetData().payToPlayMode and pickup.Variant == 711 then
					pickup:GetSprite():Play("OpenP2P")
				else
					pickup:GetSprite():Play("Open")
				end
				pickup.SubType = mod.shopChestStates.Opening
				pickup:GetData().Opened = true
				sfx:Play(SoundEffect.SOUND_CHEST_OPEN, 1, 0, false, 1)
				sfx:Play(SoundEffect.SOUND_UNLOCK00, 1, 0, false, 1)

				if pickup.Variant == 713 then
					mod:openGlassChest(pickup)
				end

				if pickup.OptionsPickupIndex ~= 0 then
					local pickups = Isaac.FindByType(EntityType.ENTITY_PICKUP)
					for _, entity in ipairs(pickups) do
						if entity:ToPickup().OptionsPickupIndex == pickup.OptionsPickupIndex and
						   (entity.Index ~= pickup.Index or entity.InitSeed ~= pickup.InitSeed)
						then
							Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.POOF01, 0, entity.Position, nilvector, nil)
							entity:Remove()
						end
					end

					pickup.OptionsPickupIndex = 0
				end
			end
		end
	end
end

mod:AddCallback(ModCallbacks.MC_PRE_PICKUP_COLLISION, mod.FFChestOpening, 710)
mod:AddCallback(ModCallbacks.MC_PRE_PICKUP_COLLISION, mod.FFChestOpening, 711)
mod:AddCallback(ModCallbacks.MC_PRE_PICKUP_COLLISION, mod.FFChestOpening, 713)



mod:AddCallback(ModCallbacks.MC_POST_PICKUP_UPDATE, function(_, pickup)
	if pickup.SubType == 4 then
		local pd = pickup:GetData()
		if mod.getTrinketMultiplierAcrossAllPlayers(TrinketType.TRINKET_RED_RIBBON) > 1 then
			local sprite = pickup:GetSprite()
			if sprite:IsPlaying("Idle") or sprite:IsPlaying("Appear") then
				if pd.isFullFromRR ~= 2 then
					sprite:ReplaceSpritesheet(0, "gfx/items/pick ups/full_eternal_heart_2.png")
					sprite:LoadGraphics()

					if (not sprite:IsPlaying("Appear")) and pickup.FrameCount > 0 then
						local poof = Isaac.Spawn(1000, EffectVariant.POOF01, 15, pickup.Position, nilvector, nil)
						poof.Color = Color(5,5,5,1,0,0,0)
						poof:Update()
					end

					pd.isFullFromRR = 2
				end
			end
		elseif mod.anyPlayerHas(TrinketType.TRINKET_RED_RIBBON, true) then
			local sprite = pickup:GetSprite()
			if sprite:IsPlaying("Idle") or sprite:IsPlaying("Appear") then
				if pd.isFullFromRR ~= 1 then
					sprite:ReplaceSpritesheet(0, "gfx/items/pick ups/full_eternal_heart.png")
					sprite:LoadGraphics()

					if (not sprite:IsPlaying("Appear")) and pickup.FrameCount > 0 then
						local poof = Isaac.Spawn(1000, EffectVariant.POOF01, 15, pickup.Position, nilvector, nil)
						poof.Color = Color(5,5,5,1,0,0,0)
						poof:Update()
					end

					pd.isFullFromRR = 1
				end
			end
		else
			if pd.isFullFromRR then
				local sprite = pickup:GetSprite()
				sprite:ReplaceSpritesheet(0, "gfx/items/pick ups/pickup_001_heart.png")
				sprite:LoadGraphics()
				if (sprite:IsPlaying("Idle") or sprite:IsPlaying("Appear")) and pickup.FrameCount > 0 then
					local poof = Isaac.Spawn(1000, EffectVariant.POOF01, 15, pickup.Position, nilvector, nil)
					poof.Color = Color(5,5,5,1,0,0,0)
					poof:Update()
				end

				pd.isFullFromRR = false
			end
		end
	end
end, 10)

function mod:chestInit(chest)
	local room = game:GetRoom()
	local chestseed = tostring(chest.InitSeed)

	local d = FiendFolio.getFieldInit(FiendFolio.savedata, 'run', 'level', 'ChestData', chestseed, {})
	if not d.chestRerollCheck then
		grng:SetSeed(chest.InitSeed, 0)
		--Eternal Chest
		if mod.anyPlayerHas(mod.ITEM.TRINKET.RIGHT_HAND, true) then
			local rhchance = 3
			if mod.getTrinketMultiplierAcrossAllPlayers(mod.ITEM.TRINKET.RIGHT_HAND) > 1 then
				rhchance = 2
			end
			if grng:RandomInt(rhchance) == 0 then
				chest:Morph(EntityType.ENTITY_PICKUP, PickupVariant.PICKUP_ETERNALCHEST, 0, true)
			end
		end
		--Dire Chest
		if mod.anyPlayerHas(mod.ITEM.TRINKET.MIDDLE_HAND, true) then
			local rhchance = 2
			if mod.getTrinketMultiplierAcrossAllPlayers(mod.ITEM.TRINKET.MIDDLE_HAND) > 1 then
				rhchance = 1
			end
			if grng:RandomInt(rhchance) < 1 then
				chest:Morph(EntityType.ENTITY_PICKUP, PickupVariant.PICKUP_DIRE_CHEST, 0, true)
			end
		end
		--Shop Chest
		local roomType = room:GetType()
		if (roomType ~= RoomType.ROOM_CHALLENGE and roomType ~= RoomType.ROOM_BOSSRUSH) and chest.Variant == 50 then
			local maxMoolah = 0
			for i = 1, game:GetNumPlayers() do
				local player = Isaac.GetPlayer(i - 1):ToPlayer()
				if player:GetNumCoins() > maxMoolah then
					maxMoolah = player:GetNumCoins()
				end
			end
			if PickupCapCoinNum and PickupCapCoinNum > maxMoolah then
				maxMoolah = PickupCapCoinNum
			end
			local rollChance = 100
			if maxMoolah > 98 then
				rollChance = 10
			elseif maxMoolah > 50 then
				rollChance = 20
			elseif maxMoolah > 25 then
				rollChance = 40
			elseif maxMoolah > 15 then
				rollChance = 70
			elseif maxMoolah == 0 then
				rollChance = 2000
			end
			if chest.Variant == 60 then	--Used to work, disabled for now
				rollChance = math.floor(rollChance * 0.75)
			end

			if grng:RandomInt(rollChance) == 0 then
				chest:Morph(5,711,0,false)
				d.chestReplaced = true
			end
		--Dire Chest
			if not d.chestReplaced then
				rollChance = 108
				local rand = grng:RandomInt(rollChance)
				if rand == 1 then
					chest:Morph(5,712,0,false)
					d.chestReplaced = true
				end
			end
		--Glass Chest
			if not d.chestReplaced then
				rollChance = 36
				local rand = grng:RandomInt(rollChance)
				if rand == 1 then
					chest:Morph(5,713,0,false)
					d.chestReplaced = true
				end
			end
		end
		d.chestRerollCheck = true
		d.chestReplaced = true
	end
end

mod:AddCallback(ModCallbacks.MC_POST_PICKUP_INIT, mod.chestInit, 50)
mod:AddCallback(ModCallbacks.MC_POST_PICKUP_INIT, mod.chestInit, 60)

mod.d12machines = {}
mod:AddCallback(ModCallbacks.MC_POST_UPDATE, function()
  local machines = 	Isaac.FindByType(6, 880, 0, false, false)
  for _, machine in ipairs(machines) do

    local mData = machine:GetData()
    local sprite = machine:GetSprite()
    if machine.FrameCount == 1 then     --Init
      mData.State = 1
      if not mod.d12machines[machine.InitSeed] then   --New machine
        mod.d12machines[machine.InitSeed] = {}
        mod.d12machines[machine.InitSeed][0] = 4  --Rerolls left (Guaranteed)
        mod.d12machines[machine.InitSeed][1] = 0  --Bombs stored
        mData.RerollsLeft = 4
        mData.BombsStored = 0
      else
        mData.RerollsLeft = mod.d12machines[machine.InitSeed][0]
        mData.BombsStored = mod.d12machines[machine.InitSeed][1]
      end
    end

    if not mData.Countdown then mData.Countdown = 0 end
    if mData.Countdown > 0 then mData.Countdown = mData.Countdown - 1 end

    --[states] 1:Idle; 2:Gets bomb; 3:RngReroll; 4:Rerolling; 5:ded; 6:killed(by explosion/shockwave/etc)

    if mData.State ~= 5 and sprite:IsPlaying("Broken") then
      local room = game:GetRoom()
      local grids = mod.reroll_grids({2, 3, 4, 5, 6, 12, 14, 22, 25, 27}, true, true, true)
      local id = grids[math.random(#grids)]
      room:RemoveGridEntity(id, 0, false)
      mData.Countdown = 20
      mData.gPoop = id
      mData.State = 5
    elseif mData.State == 2 then
      mData.BombsStored = mData.BombsStored + 1
      mod.d12machines[machine.InitSeed][1] = mData.BombsStored
      sprite:Play("BombInsert", true)
      mData.State = 3
    elseif mData.State == 3 then
      if sprite:IsFinished("BombInsert") then
        if math.random(100) <= 15 + 25*mData.BombsStored then
          sprite:Play("Wiggle", true)
        else
          mData.State = 1
          sprite:Play("Idle", true)
          mData.Countdown = 10
        end
      end
      if sprite:IsEventTriggered("BombPlace") then SFXManager():Play(201, 1, 0, false, 0.8) end
      if sprite:IsEventTriggered("BombInsert") then SFXManager():Play(24, 1, 0, false, 0.9) end
      if sprite:IsFinished("Wiggle") then
        mData.State = 4
        sprite:Play("Prize", true)
      end
    elseif mData.State == 4 then
      if sprite:IsEventTriggered("Prize") then
        mod.reroll_grids({2, 3, 4, 5, 6, 12, 14, 22, 25, 27}, true, true, true)
        
        --mod.scheduleForUpdate(function()
        --  local room = game:GetRoom()
        --  local len = room:GetGridSize()
        --  for i=0, len do
        --    local grid = room:GetGridEntity(i)
        --    if grid then
        --      if grid:GetType() == 14 then grid = grid:ToPoop() end
        --      local color = Color(1, 1, 1, 1, 0, 0, 0)
        --      --color:SetColorize(0, 150/255, 1, 0.5)
        --      color:SetColorize(1, 0, 0, 1)
        --      
        --      grid:GetSprite().Color = color
        --      --grid:GetSprite().Rotation = 180
        --      --grid:GetSprite().Color:SetTint(1, 1, 1, 0.5)
        --    end
        --  end
				--end, 0)
        
        if mData.RerollsLeft ~= 0 or math.random(2) == 1 then     --50% chance to break after 4 rerolls ran out
          SFXManager():Play(268, 1, 0, false, 0.9)
          if mData.RerollsLeft > 0 then
            mData.RerollsLeft = mData.RerollsLeft - 1
            mod.d12machines[machine.InitSeed][0] = mData.RerollsLeft
          end
          mData.BombsStored = 0
          mod.d12machines[machine.InitSeed][1] = 0
        else
          mData.State = 5
          Isaac.Spawn(1000, 1, 0, machine.Position, Vector(0,0), machine)
          if math.random(5) == 1 then
            local altar
            if math.random(4) == 1 then
              altar = Isaac.Spawn(5, 100, Isaac.GetItemIdByName("Eternal D12"), machine.Position, Vector(0,0), machine)
            else
              altar = Isaac.Spawn(5, 100, 386, machine.Position, Vector(0,0), machine)
            end
            altar:GetData().D12machine = true
            machine:Remove()
          else
            machine:TakeDamage(1, DamageFlag.DAMAGE_EXPLOSION, EntityRef(machine), 1)
            sprite:Play("Broken", true)
          end
          mod.d12machines[machine.InitSeed] = nil
        end
      end
      if sprite:IsFinished("Prize") and mData.State ~= 5 then
        mData.State = 1
        sprite:Play("Idle", true)
      end
    elseif mData.State == 5 then
      if mData.Countdown == 18 then
        if game:GetRoom():SpawnGridEntity(mData.gPoop, 14, 0, 1, 0) then
          local fPoop = game:GetRoom():GetGridEntity(mData.gPoop)
          if fPoop then
            local fPoopSprite = fPoop:GetSprite()
            fPoopSprite:ReplaceSpritesheet(0, "gfx/grid/grid_poop_gold.png")
            fPoopSprite:LoadGraphics()
            fPoopSprite:Update() fPoopSprite:Update()
          end
        end
      end
      if mData.Countdown == 1 then mod.reroll_grids({2, 3, 4, 5, 6, 12, 14, 22, 25, 27}, true, true, true) end
    end
  end
end)

function mod:pickupsFromD12machine(type, var, sub, pos, vel, spawner, seed)
  if type == 5 and var ~= 100 then
	local machines = Isaac.FindInRadius(pos, 0.01, 0xffffffff)
	for i, machine in ipairs(machines) do
	  if machine.Type == 6 and machine.Variant == 880 then
		if machine:GetData().State ~= 5 then          --No bombs payout if machine was blown by explosion/shockwave
		  machine:GetSprite():Play("Broken", true)
		  machine:GetData().State = 6
		  return {1000, 41, 0, seed}
		else
		  if var ~= 40 then
			if math.random(3) == 1 then
			  return {5, 300, Card.GLASS_D12, seed}
			else
			  return {5, 40, 0, seed}
			end
		  end
		end
	  end
	end
  end
end
mod:AddCallback(ModCallbacks.MC_PRE_ENTITY_SPAWN , mod.pickupsFromD12machine)

mod:AddCallback(ModCallbacks.MC_POST_PICKUP_UPDATE, function(_, altar)
  if altar.SpawnerType == 6 and altar.SpawnerVariant == 880 then
	if altar:GetData().D12machine then
	  for i = 3, 5 do altar:GetSprite():ReplaceSpritesheet(i,"gfx/items/slots/slot_grid_restock_machine_pedestal.png") end
	  altar:GetSprite():LoadGraphics()
	  altar:GetSprite():SetOverlayFrame("Alternates", 1)
	else
	  altar:GetSprite():SetOverlayFrame("Alternates", 0)
	end
  end
end, 100)

--mod:AddCallback(ModCallbacks.MC_PRE_PLAYER_COLLISION, function(_, player, machine, low)
--    if machine.Type == 6 and machine.Variant == 880 then
--      if machine:GetData().State == 1 and player:GetNumBombs() > 0 and machine:GetData().Countdown == 0 then
--        player:AddBombs(-1)
--        machine:GetData().State = 2
--      end
--    end
--end)

FiendFolio.onMachineTouch(880, function(player, slot)
  if slot.Type == 6 and slot.Variant == 880 then
	if slot:GetData().State == 1 and player:GetNumBombs() > 0 and slot:GetData().Countdown == 0 then
	  player:AddBombs(-1)
	  slot:GetData().State = 2
	end
  end
end)

function mod:doomFlyAI(npc)
local sprite = npc:GetSprite()
local data = npc:GetData()

npc:AddEntityFlags(EntityFlag.FLAG_NO_BLOOD_SPLASH)

	if npc:IsDead() then
		--Isaac.Explode(npc.Position, npc, 50)
		for _, entity in ipairs(Isaac.GetRoomEntities()) do
			if entity.Type == EntityType.ENTITY_PROJECTILE
			and entity.Variant == 0
			and	entity.SpawnerType == npc.Type
			and	entity.SpawnerVariant == npc.Variant
			and entity.FrameCount < 2 then
				entity.Variant = 1
				entity.Velocity = entity.Velocity:Resized(15)
				entity:GetData().projType = "boomerang"
				entity:GetData().origpos = npc.Position
				entity.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS
				local s = entity:GetSprite()
				s:Load("gfx/projectiles/boomerang rib.anm2",true)
				s:Play("spin",false)
				s.Offset = Vector(0,-10)
				local proj = entity:ToProjectile()
				proj.ProjectileFlags = proj.ProjectileFlags | ProjectileFlags.NO_WALL_COLLIDE
				proj.FallingSpeed = 0
				proj.FallingAccel = -0.066
				--proj.FallingAccel = -0.068
			end
		end
	end

end

function mod:gbfAI(npc)
	local room = game:GetRoom()
	--[[if npc.FrameCount % 10 == 0 then
		local sparkle = Isaac.Spawn(1000, 7003, 0, npc.Position, nilvector, npc):ToEffect()
		sparkle.RenderZOffset = 10000
		sparkle:FollowParent(npc)
		sparkle.SpriteOffset = Vector(-10 + math.random(20), -30 + math.random(20))
	end]]
	--mod.sawGBF = mod.sawGBF or 0
	if npc.FrameCount % 3 == 0 then
		local sparkle = Isaac.Spawn(1000, 7003, 0, npc.Position, nilvector, npc):ToEffect()
		sparkle.RenderZOffset = -5
		sparkle.SpriteOffset = Vector(-10 + math.random(20), -30 + math.random(20))
		--sparkle.SpriteScale = Vector(0.3,0.3)
	end

	if npc:IsDead() then
		--Isaac.Explode(npc.Position, npc, 50)
		game:ShakeScreen(20)
		sfx:Play(SoundEffect.SOUND_ULTRA_GREED_COIN_DESTROY ,1.5,0,false,1)
		--Isaac.Spawn(5, 10, 7, npc.Position, RandomVector()*1, npc)
		local flash = Isaac.Spawn(1000, 7004, 0, room:GetCenterPos(), nilvector, npc):ToEffect()
		flash.RenderZOffset = 1000000
		room:TurnGold()
		for i = 1, 20 do
		Isaac.Spawn(5, 20, 0, npc.Position, RandomVector()*math.random(10,30), npc)
		end
		for _, entity in ipairs(Isaac.GetRoomEntities()) do
			if entity.Type == EntityType.ENTITY_PROJECTILE
			and entity.Variant == 0
			and	entity.SpawnerType == npc.Type
			and	entity.SpawnerVariant == npc.Variant
			and entity.FrameCount < 2 then
				entity:Remove()
			end
			if entity:IsEnemy() then
				entity:AddMidasFreeze(EntityRef(npc), 1200)
			end
		end
	end
end
function mod:gbfSparkleAI(npc)
	if npc.FrameCount > 10 then
		npc:Remove()
	end
end
mod:AddCallback(ModCallbacks.MC_POST_EFFECT_UPDATE, mod.gbfSparkleAI, 7003)

function mod:drainerAI(npc)
	npc.SplatColor = mod.ColorLemonYellow

	if npc.Velocity:Length() > 2.5 then
		npc.Velocity = npc.Velocity:Resized(2.5)
	end

	if npc.FrameCount % 3 == 0 then
		local creep = Isaac.Spawn(1000, 24, 0, npc.Position + Vector(10,0), nilvector, npc):ToEffect();
		creep.Scale = 0.5
		creep:SetTimeout(45)
		creep:Update();

	end

	if npc:IsDead() then
		local creep = Isaac.Spawn(1000, 24, 0, npc.Position + Vector(10,0), nilvector, npc):ToEffect();
		creep.SpriteScale = creep.SpriteScale * 2.5
		creep:SetTimeout(90)
		creep:Update();

		for _, entity in ipairs(Isaac.GetRoomEntities()) do
			if entity.Type == EntityType.ENTITY_PROJECTILE
			and entity.Variant == 0
			and	entity.SpawnerType == npc.Type
			and	entity.SpawnerVariant == npc.Variant
			and entity.FrameCount < 2 then
				entity:Remove()
			end
		end

		local params = ProjectileParams()
		params.Color = mod.ColorLemonYellow
		for i = 90, 360, 90 do
			npc:FireProjectiles(npc.Position, Vector(0,13):Rotated(i), 0, params)
		end
	end
end

function mod:warheadAI(npc)
	npc.SplatColor = mod.ColorLemonYellow

	if npc.Velocity:Length() > 3.5 then
		npc.Velocity = npc.Velocity:Resized(3.5)
	end

	if npc:IsDead() then

		for _, entity in ipairs(Isaac.GetRoomEntities()) do
			if entity.Type == EntityType.ENTITY_PROJECTILE
			and entity.Variant == 0
			and	entity.SpawnerType == npc.Type
			and	entity.SpawnerVariant == npc.Variant
			and entity.FrameCount < 2 then
				entity:Remove()
			end
		end

		local params = ProjectileParams()
		params.Color = mod.ColorLemonYellow
		for i = 45, 360, 45 do
			npc:FireProjectiles(npc.Position, Vector(0,10):Rotated(i), 0, params)
		end
		local creep = Isaac.Spawn(1000, 24, 0, npc.Position, nilvector, npc):ToEffect()
		creep.SpriteScale = creep.SpriteScale * 2.5
		creep:Update()

	end
end

function mod:spooterAI(npc, var)
local room = game:GetRoom()
local sprite = npc:GetSprite();
local target = npc:GetPlayerTarget()
local r = npc:GetDropRNG()
local speed

	local litterBug
	if var == 964 or var == 965 or var == 966 then
		litterBug = true
	end

	if not npc:GetData().init then
		if mod.anyPlayerHas(CollectibleType.COLLECTIBLE_BURSTING_SACK) then
			if var == 966 then
				if not mod:isFriend(npc) then
					mod:ReplaceEnemySpritesheet(npc, "gfx/enemies/litter bug/litter_bug_charmed_burstingsack", 0)
					npc.SubType = 10
					sprite:LoadGraphics()
					npc.CollisionDamage = 0
				end
			else
				if var == 961 then
					mod:ReplaceEnemySpritesheet(npc, "gfx/enemies/spooter/monster_superspooter_burstingSack", 0)
				elseif var == 963 then
					mod:ReplaceEnemySpritesheet(npc, "gfx/enemies/spooter/monster_megaspooter_burstingSack", 0)
				elseif var == 964 then
					mod:ReplaceEnemySpritesheet(npc, "gfx/enemies/litter bug/litter_bug_burstingsack", 0)
				elseif var == 965 then
					mod:ReplaceEnemySpritesheet(npc, "gfx/enemies/litter bug/litter_bug_toxic_burstingsack", 0)
				else
					mod:ReplaceEnemySpritesheet(npc,  "gfx/enemies/spooter/monster_spooter_burstingSack", 0)
				end
				sprite:LoadGraphics()
				npc.CollisionDamage = 0
				npc.SubType = 10
			end
		end
		npc:GetData().init = true
	end

	if var == 961 or var == 963 then
		speed = 7
	else
		speed = 5
	end

	if npc.Velocity:Length() > speed then
		 npc.Velocity = npc.Velocity:Resized(speed)
	end

	if sprite:IsEventTriggered("Shoot") then
		if litterBug then
			npc:PlaySound(mod.Sounds.SniffleShootOldShort,1,0,false,math.random(70,100)/100)
			local projectile = Isaac.Spawn(9, 0, 0, npc.Position, (target.Position - npc.Position):Resized(7), npc):ToProjectile();
			projectile.FallingSpeed = -15
			projectile.FallingAccel = 1.5
			projectile.Height = -30
			projectile.Scale = 1.5
			projectile.SpawnerEntity = npc
			if var == 965 then
				projectile.Color = mod.ColorToxicFart
				projectile:GetData().projType = "DangerFart"
			elseif var == 964 then
				projectile.Color = mod.ColorButterFart
				projectile:GetData().projType = "TrashFart"
			elseif var == 966 then
				local color = Color(1,1,1,1,235/255, 118/255, 1)
				color:SetColorize(1,1,1,1)
				projectile.Color = color
				projectile:GetData().projType = "CharmFart"
			end
			if mod:isFriend(npc) then
				projectile:AddProjectileFlags(ProjectileFlags.CANT_HIT_PLAYER | ProjectileFlags.HIT_ENEMIES)
			elseif mod:isCharm(npc) then
				projectile:AddProjectileFlags(ProjectileFlags.CANT_HIT_PLAYER)
			end
		else
			npc:PlaySound(SoundEffect.SOUND_BLOODSHOOT,1,2,false,1)
			if var == 960 or var == 963 then
				npc:FireProjectiles(npc.Position, (target.Position - npc.Position):Normalized()*7, 0, ProjectileParams())
			end
			if var == 961 or var == 963 then
				for i = 1, 2 do
					npc:FireProjectiles(npc.Position, ((target.Position - npc.Position):Normalized()*7):Rotated(-48 + i*32), 0, ProjectileParams())
				end
			end
		end
	end

	if npc.SubType ~= 10 and npc.State == 4 and r:RandomInt(20)+1 == 1 and (target.Position - npc.Position):Length() < 200 and room:CheckLine(target.Position,npc.Position,3,900,false,false) and not mod:isScareOrConfuse(npc) then
		npc.State = 8
	end

	if npc.State == 8 then
		if sprite:IsFinished("Attack") then
			npc.State = 4
		elseif not sprite:IsPlaying("Attack") then
			if target.Position.X < npc.Position.X then
				sprite.FlipX = true
			else
				sprite.FlipX = false
			end
			sprite:Play("Attack", 0)
		end
	end

	if npc:IsDead() and (var == 964 or var == 965 or var == 966) then
		local can = Isaac.Spawn(1000, 163, 0, npc.Position, RandomVector()*math.random(3), npc):ToEffect()
		local cSprite = can:GetSprite()
		cSprite:Load(sprite:GetFilename(),true)
		if npc.SubType == 10 then
			if var == 964 then
				cSprite:ReplaceSpritesheet(0, "gfx/enemies/litter bug/litter_bug_burstingsack.png")
			elseif var == 965 then
				cSprite:ReplaceSpritesheet(0, "gfx/enemies/litter bug/litter_bug_toxic_burstingsack.png")
			elseif var == 966 then
				cSprite:ReplaceSpritesheet(0, "gfx/enemies/litter bug/litter_bug_charmed_burstingsack.png")
			end
		end
		cSprite:LoadGraphics()
		if math.random(2) == 1 then
			cSprite.FlipX = true
		end
		cSprite:Play("Gib" .. math.random(3),true)
	end
end

function mod:stickySackAI(npc)
local sprite = npc:GetSprite();
npc.SplatColor = mod.ColorPureWhite
--Isaac.ConsoleOutput(npc.StateFrame .. "\n")
	if npc.State == 3 then
		npc.StateFrame = npc.StateFrame + 1
		if npc.MaxHitPoints == npc.HitPoints then
			if npc.StateFrame > 30 and mod.GetEntityCount(85) < 40 then
				npc.State = 8
				npc.StateFrame = 0
			end
		end
	elseif npc.State == 8 then
		if sprite:GetFrame() == 0 then
			if mod.GetEntityCount(85) > 40 then
				npc.State = 3
				mod:spritePlay(sprite, "Shake")
			end
		end
		if sprite:GetFrame() == 10 then
			for i = 1, mod:RandomInt(2,3) do
				local aaaaaaa = mod:FindRandomValidPathPosition(npc, 3) + (RandomVector() * mod:RandomInt(0,20))
				local happyhead = aaaaaaa - npc.Position
				npc:PlaySound(mod.Sounds.Plorp, 0.9, 0, false, math.random(95,105)/100)
				EntityNPC.ThrowSpider(npc.Position,npc,npc.Position + happyhead,false,0)
			end
			for _, entity in ipairs(Isaac.GetRoomEntities()) do
				if entity.Type == 85 and entity.Variant == 0 and entity.SpawnerType == 30 and entity.SpawnerVariant == mod.FF.StickySack.Var then
					if not entity:GetData().CheekySpawned then
						entity:ToNPC():Morph(85,962,0,-1)
						entity:ToNPC().HitPoints = entity:ToNPC().MaxHitPoints
						entity:GetData().CheekySpawned = true
					end
				end
			end
		end
	end
	if npc:IsDead() then
		for i = 1, math.random(4,10) do
			mod.spawnent(npc, npc.Position, RandomVector()*math.random(20), 85, 962)
		end
	end
end

function mod:walkingStickySackAI(npc)
local sprite = npc:GetSprite();
npc.SplatColor = mod.ColorPureWhite
	--Isaac.ConsoleOutput(npc.State .. ", " .. npc.StateFrame .. "\n")
	if sprite:IsPlaying("Shoot") then
		if sprite:GetFrame() == 10 then
			for i = 1, mod:RandomInt(2,3) do
				local aaaaaaa = mod:FindRandomValidPathPosition(npc, 3) + (RandomVector() * mod:RandomInt(0,20))
				local happyhead = aaaaaaa - npc.Position
				npc:PlaySound(mod.Sounds.Plorp, 0.9, 0, false, math.random(95,105)/100)
				EntityNPC.ThrowSpider(npc.Position,npc,npc.Position + happyhead,false,0)
			end
			for _, entity in ipairs(Isaac.GetRoomEntities()) do
				if entity.Type == 85 and entity.Variant == 0 and entity.SpawnerType == 88 and (entity.SpawnerVariant == mod.FF.WalkingStickySack.Var or entity.SpawnerVariant == mod.FF.StumblingStickySack.Var) then
					if not entity:GetData().CheekySpawned then
						entity:ToNPC():Morph(85,962,0,-1)
						entity:ToNPC().HitPoints = entity:ToNPC().MaxHitPoints
						entity:GetData().CheekySpawned = true

					end
				end
			end
		end
	elseif npc.Variant == 961 then
		if npc.FrameCount % 15 == math.random(15) and mod.GetEntityCount(85) < 40 then
			npc.State = NpcState.STATE_ATTACK
		end
	end
	if npc:IsDead() then
		for i = 1, math.random(4,10) do
			mod.spawnent(npc, npc.Position, RandomVector()*math.random(20), 85, 962)
		end
	end
end

function mod:squishBabySpider(npc)
	local deatheffect = Isaac.Spawn(1000, 38, 7000, npc.Position, nilvector, npc)
	deatheffect:Update()
	--npc:BloodExplode()
	sfx:Play(SoundEffect.SOUND_DEATH_BURST_SMALL, 0.8, 0, false, 1)
	local splat = npc:MakeSplat(0.5)
	splat:GetSprite().Color = npc.SplatColor
	npc:Remove()
end

function mod:babySpiderAI(npc)
--Isaac.ConsoleOutput(npc.State .. "\n")
--npc.SplatColor = Color(4,8.5,8.5,0.2,0,40 / 255,30 / 255)
npc:AddEntityFlags(EntityFlag.FLAG_NO_STATUS_EFFECTS)
	local d = npc:GetData()
	if not d.init then
		npc.SplatColor = Color(0, 0, 0, 0.2, 240 / 255, 200 / 255, 100 / 255)

		d.init = true
	end

	if npc:HasMortalDamage() then
		mod:squishBabySpider(npc)
	end
end

function mod:checkSpiderCollision(npc1, npc2, mysteryBoolean)
	if npc1.Variant == 962 then
		--local npc2npc = npc2:ToNPC()
		if npc2.Type == 1 then
			npc2 = npc2:ToPlayer()
			if npc2:HasCollectible(CollectibleType.COLLECTIBLE_E_COLI) then
				npc1:Remove()
			end
		end
		if not npc1:HasEntityFlags(EntityFlag.FLAG_FRIENDLY) then
			if (npc2.Type == 1 or npc2:HasEntityFlags(EntityFlag.FLAG_FRIENDLY)) and npc2.Velocity:LengthSquared() > 1 then
				local d = npc1:GetData()
				if not (d.flickerspirited or d.eternalFlickerspirited) then
					mod:squishBabySpider(npc1)
				end
			end
		end
	end
end
mod:AddCallback(ModCallbacks.MC_PRE_NPC_COLLISION , mod.checkSpiderCollision, 85)

function mod:WispBlacklist(familiar, collider)
	--Turn into a table if we add anything more to this, PLEASE
	if collider.Type == 85 and collider.Variant == 962 then
		return true
	end
end
mod:AddCallback(ModCallbacks.MC_PRE_FAMILIAR_COLLISION, mod.WispBlacklist, FamiliarVariant.WISP)
mod:AddCallback(ModCallbacks.MC_PRE_FAMILIAR_COLLISION, mod.WispBlacklist, FamiliarVariant.ITEM_WISP)


function mod:dankFattyAI_kindageneric(npc)
local sprite = npc:GetSprite();
	if sprite:IsEventTriggered("Shoot") then
		EntityNPC.ThrowSpider(npc.Position,npc,npc.Position+RandomVector()*(30+math.random(70)),false,0)
	end

	if npc.FrameCount % 10 then
		local creep = Isaac.Spawn(1000, 26, 0, npc.Position+RandomVector()*10, nilvector, npc)
		creep.SpriteScale = Vector(2, 2)
		creep:Update()
	end
end

-- SQUIDGEAI , SQUIDGE AI
function mod:dankFattyAI(npc)
local r = npc:GetDropRNG()
local sprite = npc:GetSprite();
npc.SplatColor = mod.ColorDankBlackReal
	if sprite:IsEventTriggered("Splort") then
		local params = ProjectileParams()
		local vec = RandomVector()
		for i = 120, 360, 120 do
			local projectile = Isaac.Spawn(9, 0, 0, npc.Position, vec:Rotated(i), npc):ToProjectile()
			local projdata = projectile:GetData();
			projectile.FallingSpeed = -35 + math.random(10)
			projectile.FallingAccel = math.random(7,13)/5;
			projectile.Velocity = projectile.Velocity:Normalized() * math.random(5, 8)
			projectile.Scale = 2
			projectile.Color = mod.ColorDankBlackReal
			projdata.projType = "dank slime"
			sfx:Play(SoundEffect.SOUND_FART)
			local effect = Isaac.Spawn(1000,16,4,npc.Position,Vector.Zero,npc)
			effect.Color = mod.ColorDankBlackReal
			effect.SpriteScale = effect.SpriteScale * 0.8
		end
	end

	if npc:IsDead() then
		--EntityNPC.ThrowSpider(npc.Position,npc,npc.Position+RandomVector()*(30+math.random(70)),false,0) --Not really needed?
		local creep = Isaac.Spawn(1000, 26, 0, npc.Position+RandomVector()*10, nilvector, npc)
		creep.SpriteScale = Vector(2, 2);
		creep:Update()
	end
end

--Tar Bubble AI, TarBubbleAI
function mod.dankSlimeInit(npc)
	if npc.SubType == 1 then
		npc.SplatColor = mod.ColorSoy
	elseif npc.SubType == 8 then
		npc.SplatColor = mod.ColorMysteriousLiquid
	elseif npc.SubType == 9 then
		npc.SplatColor = mod.ColorPeepPiss
	elseif npc.SubType == 10 then
		npc.SplatColor = mod.ColorPoop
	else
		npc.SplatColor = mod.ColorDankBlackReal
	end

	npc:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
end

function mod:dankSlimeAI(npc, subType)
	local room = game:GetRoom()
	local pos = npc.Position
	local sprite = npc:GetSprite()
	local d = npc:GetData()

	local creepvar = 26

	if subType == 1 then
		creepvar = 25
	elseif subType == 8 then
		creepvar = 23
	elseif subType == 9 then
		creepvar = 24
	elseif subType == 10 then
		creepvar = 94
	end

	npc.Velocity = nilvector
	npc:AddEntityFlags(EntityFlag.FLAG_NO_STATUS_EFFECTS)
	npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS

	if not sprite:IsPlaying("Idle") then
		sprite:Play("Idle",true)
	end

	if npc.FrameCount % 60 == 1 or npc.FrameCount == 0 then
		local creep = Isaac.Spawn(1000, creepvar, 0, npc.Position, nilvector, npc):ToEffect()
		creep.SpriteScale = Vector(2, 2);
		creep:Update()
		creep:SetTimeout(280)
	end

	if (pos:Distance(npc:GetPlayerTarget().Position) < 28 and not (d.flickerspirited or d.eternalFlickerspirited)) or (room:IsClear() and not mod.FindDoorShutter()) then
		vec1 = RandomVector()*5
		for i = 60, 360, 60 do
			local creep = Isaac.Spawn(1000, creepvar, 0, npc.Position+vec1:Rotated(i), nilvector, npc):ToEffect()
			creep.SpriteScale = Vector(2, 2);
			creep:Update()
		end
		vec2 = Vector(25,0):Rotated(math.random(2)*45)
		for i = 90, 360, 90 do
			for k = 1, 3 do
				local creep = Isaac.Spawn(1000, creepvar, 0, npc.Position + vec2:Rotated(i)*k, nilvector, npc):ToEffect()
				creep:Update()
			end
		end
		npc:Kill()
	end
end

mod.MommyTable = {0,0,0,0,0,0,2,2,3}

--Mouthful
function mod:morselMommyAI(npc, sprite)
	local r = npc:GetDropRNG()
	local target = npc:GetPlayerTarget()

	--Isaac.ConsoleOutput(npc.StateFrame .. "\n")
	if sprite:IsEventTriggered("Shoot") then
		--mod.spawnent(npc, npc.Position + Vector(0,1), nilvector, mod.FF.Morsel.ID, mod.FF.Morsel.Var)
		local randyfun = r:RandomInt(#mod.MommyTable)+1
		local baby = Isaac.Spawn(mod.FF.Morsel.ID, mod.FF.Morsel.Var, mod.MommyTable[randyfun], npc.Position + Vector(0,-5), nilvector, npc);
		baby.SpawnerEntity = npc
		baby:GetData().UglyBaby = true
	end

	if npc.State == 4 then
		if npc.StateFrame > 0 then
			local targdist = npc.Position:Distance(target.Position)
			--Isaac.DebugString(targdist)
			local ranval = math.ceil(targdist / 3)
			if targdist < 120 and r:RandomInt(ranval) == 0 and not mod:isScareOrConfuse(npc) then
				npc.State = 8
				if npc.Velocity.X > npc.Velocity.Y then
					mod:spritePlay(sprite, "AttackHori")
				else
					mod:spritePlay(sprite, "AttackVert")
				end
			end
		end
	end

	if npc:IsDead() then
		local baby = Isaac.Spawn(mod.FF.Morsel.ID, mod.FF.Morsel.Var, r:RandomInt(3)+3, npc.Position, nilvector, npc);
		baby.SpawnerEntity = npc
		baby:GetData().UglyBaby = true
	end
end

function mod:bigSmokeAI(npc, sprite)
	npc.SplatColor = mod.ColorCharred

	if sprite:IsEventTriggered("Shoot") then
		local vec = (RandomVector()*20)
		for i = 1, 6 do
			mod.SpawnGunpowder(npc,npc.Position + vec:Rotated(360/6 * i - 15 + math.random(30)):Resized(math.random(25,40)), 300, 150)
		end
	end

	if npc:IsDead() then
		local smoke = Isaac.Spawn(1000, EffectVariant.DARK_BALL_SMOKE_PARTICLE, 0, npc.Position, nilvector, npc)
		smoke.SpriteScale = Vector(3,3)
		smoke.SpriteOffset = Vector(0, -25)
		smoke:Update()
		local vec = (RandomVector()*20)
		for i = 1, 6 do
			mod.SpawnGunpowder(npc,npc.Position + vec:Rotated(360/6 * i - 15 + math.random(30)):Resized(math.random(15,30)), 300, 150)
		end
		for i = 1, 8 do
			mod.SpawnGunpowder(npc,npc.Position + vec:Rotated(360/8 * i - 15 + math.random(30)):Resized(math.random(35,60)), 300, 150)
		end
	end
end

--Bubble Bat, BubbleBat, BubbleBatAI
function mod:drownedFatBatAI(npc)
	local sprite = npc:GetSprite()
	local target = npc:GetPlayerTarget()
	local r = npc:GetDropRNG()
	local d = npc:GetData()

	if sprite:IsFinished("Shooting") then
		npc.State = 4
	elseif sprite:IsPlaying("Shooting") then
		npc.State = 9
	end

	if sprite:IsPlaying("Shooting") and sprite:GetFrame() < 1 then
		npc.ProjectileCooldown = 225
	end

	if npc.State == 11 then
		d.falling = true
		npc.Velocity = nilvector
		if sprite:IsFinished("Death") then
			npc:Remove()
		elseif not sprite:IsPlaying("Death") then
			sprite:Play("Death", true)
		end
	else
		npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_ALL
		d.bleeding = false
	end

	if sprite:IsEventTriggered("Bubble") then
		npc:PlaySound(SoundEffect.SOUND_SHAKEY_KID_ROAR,1,0,false,1)
		local vec = (target.Position - npc.Position):Normalized()
		for i = 1, 5 do
		local rand = r:RandomInt(#mod.bubbles)+1
		mod.ShootBubble(npc, -1, npc.Position+vec:Rotated(-7.5+i*2.5)*5, vec:Rotated(-7.5+i*2.5)*(math.random(55,75)/20))
		end
	elseif sprite:IsEventTriggered("SFX") then
		mod:DestroyNearbyGrid(npc)
		npc:PlaySound(mod.Sounds.SplashLarge,1.5,0,false,1)
	elseif sprite:IsEventTriggered("Splash") then
		local params = ProjectileParams()
		for i = 30, 360, 30 do
			local rand = r:RandomFloat()
			params.FallingSpeedModifier = -50 + math.random(10);
			params.FallingAccelModifier = 2
			params.VelocityMulti = math.random(13,19) / 10
			--params.Color = Color(0.4,0.4,0.4,1,0,0,0)
			params.Variant = 4
			npc:FireProjectiles(npc.Position, Vector(0,2):Rotated(i-40+rand*80) + nilvector, 0, params)
		end
	elseif sprite:IsEventTriggered("bloodstart") then
		d.bleeding = true
		npc:PlaySound(SoundEffect.SOUND_DEATH_BURST_SMALL,1,0,false,1)
	elseif sprite:IsEventTriggered("bloodend") then
		d.bleeding = false
	end

	if d.bleeding then
		if npc.FrameCount % 2 == 0 then
		local blood = Isaac.Spawn(1000, 5, 0, npc.Position, RandomVector()*3, npc):ToEffect();
		blood:Update()

		local bloo2 = Isaac.Spawn(1000, 2, 0, npc.Position, RandomVector()*3, npc):ToEffect();
		bloo2.SpriteScale = Vector(0.7,0.7)
		bloo2.SpriteOffset = Vector(0, -20)
		bloo2:Update()

		npc:PlaySound(SoundEffect.SOUND_MEAT_JUMPS,0.2,0,false,0.8)
		end
	end

	if npc:IsDead() and not d.falling then
		local params = ProjectileParams()
		for i = 30, 360, 30 do
			local rand = r:RandomFloat()
			params.FallingSpeedModifier = -50 + math.random(10);
			params.FallingAccelModifier = 2
			params.VelocityMulti = math.random(13,19) / 10
			--params.Color = Color(0.4,0.4,0.4,1,0,0,0)
			params.Variant = 4
			npc:FireProjectiles(npc.Position, Vector(0,2):Rotated(i-40+rand*80) + nilvector, 0, params)
		end
	end

end

function mod:DrownedFatHurt(npc, damage, flag)
	if npc.Variant == mod.FF.BubbleBat.Var then
		--if npc.HitPoints - damage <= 10 then
		if npc.HitPoints - damage <= 0 then
			if flag & DamageFlag.DAMAGE_EXPLOSION ~= 0 then
				--npc:Kill()
				npc:GetData().BubbleBatKilledByExplosion = true
			end
			--if not (npc:HasEntityFlags(EntityFlag.FLAG_FREEZE) or npc:HasEntityFlags(EntityFlag.FLAG_MIDAS_FREEZE)) then
			--	npc.Velocity = nilvector
			--	npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
			--	npc.HitPoints = 0
			--	npc:ToNPC().State = 11
			--	return false
			--end
		end

		if npc:ToNPC().State == 11 then
			return false
		end
	end
end
mod:AddCallback(ModCallbacks.MC_ENTITY_TAKE_DMG, mod.DrownedFatHurt, 258)

function mod.drownedFatDeathAnim(npc)
	local data = npc:GetData()
	if not data.BubbleBatKilledByExplosion then
		local onCustomDeath = function(npc, deathAnim)
			deathAnim.State = 11
			deathAnim:GetData().bleeding = npc:GetData().bleeding
			deathAnim.PositionOffset = npc.PositionOffset
		end
		mod.genericCustomDeathAnim(npc, nil, nil, onCustomDeath)
	end
end

function mod:bubbleAI(npc, variant)
subt = npc.SubType
	local d = npc:GetData()
	local pos = npc.Position
	local sprite = npc:GetSprite()

	npc.SpriteOffset = mod:Lerp(npc.SpriteOffset, nilvector, 0.05)

	if sprite:IsEventTriggered("spiderlob") then
		npc:PlaySound(SoundEffect.SOUND_PLOP,1,2,false,1)
		if subt == 4 then
			--mod.cheekyspawn(npc.Position, npc, npc.Position+RandomVector()*(30+math.random(70)), 18, 0, 0)
			mod.spawnent(npc, npc.Position, nilvector, 18)
		elseif subt == 5 then
			--mod.cheekyspawn(npc.Position, npc, npc.Position+RandomVector()*(30+math.random(70)), 85, 0, 0)
			EntityNPC.ThrowSpider(npc.Position,npc,npc.Position+RandomVector()*(30+math.random(70)),false,0);
		elseif subt == 10 then
			local isopoly = Isaac.Spawn(mod.FF.RolyPoly.ID, mod.FF.RolyPoly.Var, 2, npc.Position, Vector.Zero, npc):ToNPC()
			isopoly:GetData().spawnedFromBubble = true
			--isopoly.PositionOffset = Vector(0, -30)
			isopoly:Update()
		end
	elseif sprite:IsEventTriggered("popsound") then
		npc:PlaySound(SoundEffect.SOUND_PLOP,0.7,2,false,math.random(8,12)/10)
		if subt == 6 then
			Isaac.Explode(npc.Position, npc, 10)
		elseif subt == 7 then
			local params = ProjectileParams()
			params.Variant = 4
			npc:FireProjectiles(npc.Position, (npc:GetPlayerTarget().Position - npc.Position):Resized(7), 0, params)

		elseif subt == 8 then
			local params = ProjectileParams()
			params.Variant = 4
			local vec = Vector(7,0)
			for i = 90, 360, 90 do
				npc:FireProjectiles(npc.Position, vec:Rotated(i), 0, params)
			end
		elseif subt == 9 then
			local params = ProjectileParams()
			params.Variant = 4
			local vec = Vector(7,0)
			for i = 45, 360, 45 do
				npc:FireProjectiles(npc.Position, vec:Rotated(i), 0, params)
			end
		end
	elseif sprite:IsEventTriggered("release") then
		npc.Velocity = RandomVector()*(0.5 + math.random()*2.5)
	end

	if npc.State == 11 then
	npc.Velocity = nilvector
		if sprite:IsFinished("pop") then
			if Isaac.GetChallenge() == mod.challenges.dirtyBubble then
				mod.bubbleKillCounter = mod.bubbleKillCounter or 0
				mod.bubbleKillCounter = mod.bubbleKillCounter + 1
				--print(mod.bubbleKillCounter)
			end
			npc:Remove()
		elseif sprite:IsPlaying("pop") then
			npc.Velocity = nilvector
		elseif not npc:GetSprite():IsPlaying("pop") then
			sprite:Play("pop", true)
			npc.Velocity = nilvector
			npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
		end
	end

	if npc:HasEntityFlags(EntityFlag.FLAG_FRIENDLY) then
		for _, p in pairs(Isaac.FindByType(9, -1, -1)) do
			if p.Position:Distance(npc.Position) <= npc.Size + p.Size then
				npc.State = 11
				p:Die()
			end
		end
	end

	if not d.init then
		if npc:HasEntityFlags(EntityFlag.FLAG_FRIENDLY) then
			npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_ENEMIES
		else
			npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS
		end
		npc.SplatColor = mod.ColorInvisible
		if d.spawning then
			sprite:Play("Spawn")
		else
			sprite:Play("Idle")
		end
		--[[if npc.Velocity:Length() < 1 then
			npc.Velocity = Vector(10,0)
		end]]
		d.init = 1
	end

	if sprite:IsFinished("Spawn") then
		sprite:Play("Idle")
	end

	npc.Velocity = npc.Velocity:Rotated(-5 + math.random(9))
	if npc.Velocity:Length()>5 then
		npc.Velocity = npc.Velocity * 0.96
	else
		npc.Velocity = npc.Velocity * 0.995
	end

	if npc:CollidesWithGrid() == true then
		npc.Velocity = mod.bounceOffWall(npc.Position, npc.Velocity, d.PrevVel)
	end

	d.PrevVel = npc.Velocity

	if (not mod.IsActiveRoom()) and not mod.FindDoorShutter() or (Isaac.GetChallenge() == mod.challenges.dirtyBubble and npc.FrameCount > 250) then
		if not sprite:IsPlaying("pop") then
			npc.State = 11
		end
	end
end

function mod:technicalHurt(npc, damage, flags, source)
local r = npc:GetDropRNG()
	if npc.Variant == 1 or npc.Variant == 2 then
		if not (npc:HasEntityFlags(EntityFlag.FLAG_FREEZE) or npc:HasEntityFlags(EntityFlag.FLAG_MIDAS_FREEZE)) then
			if npc.HitPoints - damage <= 0 then
				npc.Velocity = nilvector
				npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
				npc.HitPoints = 0
				npc:ToNPC().State = 11
				return false
			end
		end
	elseif npc.Variant == 13 then
		return false
	elseif npc.Variant == 14 then
		if not (npc:HasEntityFlags(EntityFlag.FLAG_FREEZE) or npc:HasEntityFlags(EntityFlag.FLAG_MIDAS_FREEZE)) then
			if npc.HitPoints - damage <= 5 then
			npc.Velocity = nilvector
			npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
			npc.HitPoints = 0
			npc:ToNPC().State = 11
			return false
			end
		end
	elseif npc.Variant == 17 or npc.Variant == 31 or npc.Variant == 32 then
		return false
	elseif variant == mod.FF.HitcherPitchfork.Var then
		if mod:HasDamageFlag(DamageFlag.DAMAGE_FIRE, damageFlags) and not mod:IsPlayerDamage(source) then
			return false
		end
	elseif npc.Variant == 0 then
		local subT = npc.SubType
		local d = npc:GetData()
		if not (d.flickerspirited or d.eternalFlickerspirited) then
			if subT == 1 then
				for i = 1, math.random(4,10) do
					mod.spawnent(npc, npc.Position, RandomVector()*math.random(20), 85, 962)
				end
			else
				for i = 30, 360, 30 do
				local rand = r:RandomFloat()
				local projectile = Isaac.Spawn(9, npc.SubType == 10 and 3 or 0, 0, npc.Position, Vector(0,2):Rotated(i-40+rand*80), npc):ToProjectile();
					local projdata = projectile:GetData();
					projectile.FallingSpeed = -50 + math.random(10);
					projectile.FallingAccel = 2
					projectile.Velocity = projectile.Velocity * (math.random(12, 20)/10)
					projectile.Scale = math.random(8, 12)/10
					projectile.Color = (projectile.Variant == 3) and projectile.Color or (npc.SplatColor or mod.ColorDankBlackReal)
					--I honestly dont understand what the point of the line above is and its making issues so im sticking this here
					if npc.SubType == 0 then
						projectile.Color = mod.ColorDankBlackReal
					end
				end
			end
		end
	end
end
mod:AddCallback(ModCallbacks.MC_ENTITY_TAKE_DMG, mod.technicalHurt, mod.FFID.Tech)

function mod:ribboneAI(npc)
	local d = npc:GetData()
	local sprite = npc:GetSprite();
	local remains
	if not npc:HasEntityFlags(EntityFlag.FLAG_CHARM | EntityFlag.FLAG_FRIENDLY) then
		remains = mod.FindClosestEntity(npc.Position, 99999, mod.FF.JawboneCorpse.ID, mod.FF.JawboneCorpse.Var)
	end
	--npc.SplatColor = Color(0.15, 0, 0, 1, 25 / 255, 25 / 255, 25 / 255)
	npc:AddEntityFlags(EntityFlag.FLAG_NO_BLOOD_SPLASH)
	if not d.init then
		d.init = true
	end
	if remains and npc.StateFrame > 15 and not mod:isScareOrConfuse(npc) then
		npc.State = 6
		if remains.Position:Distance(npc.Position) > 40 and not sprite:IsPlaying("Summon") then
			if d.state == "dashstart" then
				if sprite:IsFinished("DashStart") then
					d.state = "dash"
				else
					mod:spritePlay(sprite, "DashStart")
				end
			elseif d.state == "dash" then
				mod:spritePlay(sprite, "Dash")
				local targetvel = (remains.Position - npc.Position):Resized(6)
				npc.Velocity = mod:Lerp(npc.Velocity, targetvel,0.25)
			end
		else
			if sprite:IsFinished("Summon") then
				d.state = "dashstart"
				npc.StateFrame = 0
			elseif sprite:IsEventTriggered("Shoot") then
				npc:PlaySound(SoundEffect.SOUND_SUMMONSOUND,1,1,false,1)
				for _, entity in ipairs(Isaac.GetRoomEntities()) do
					if entity.Type == mod.FF.JawboneCorpse.ID and entity.Variant == mod.FF.JawboneCorpse.Var then
						if entity.Position:Distance(npc.Position) < 75 then
							entity:ToNPC().State = 5
							--entity:Update()
						end
					end
				end
			else
				mod:spritePlay(sprite, "Summon")
			end
		end
	elseif not sprite:IsPlaying("Summon") then
		npc.State = 4
		npc.StateFrame = npc.StateFrame + 1
		mod:spritePlay(sprite, "Idle")
		d.state = "dashstart"
	end
end

function mod:jawboneAI(npc)
local d = npc:GetData()
	if not d.init then
		d.init = true
		npc.SpriteOffset = Vector(0, -5)
		--npc.SplatColor = Color(0.15, 0, 0, 1, 25 / 255, 25 / 255, 25 / 255)
		npc:AddEntityFlags(EntityFlag.FLAG_NO_BLOOD_SPLASH)
	end

	if npc:IsDead() then
		mod.spawnent(npc, npc.Position, nilvector, mod.FF.JawboneCorpse.ID, mod.FF.JawboneCorpse.Var)
	end
end

function mod:corpseAI(npc)
	local room = game:GetRoom()
	local sprite = npc:GetSprite();
	local d = npc:GetData()
	if not d.init then
		npc:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
		npc:AddEntityFlags(EntityFlag.FLAG_NO_TARGET)
		npc.SpriteOffset = Vector(0, -17)
		--npc.SplatColor = Color(0.15, 0, 0, 1, 25 / 255, 25 / 255, 25 / 255)
		npc:AddEntityFlags(EntityFlag.FLAG_NO_BLOOD_SPLASH)
		d.init = true
	end

	npc.Velocity = npc.Velocity * 0.7
	mod:spritePlay(sprite, "Die")

	if npc.State == 5 then
		local beam = Isaac.Spawn(1000,7010, 0, npc.Position, nilvector, npc):ToEffect()
		local bsprite = beam:GetSprite()
		  if mod.isBackdrop("Mausoleum") then
			bsprite:ReplaceSpritesheet(0, "gfx/enemies/skeleton bats/ribbone_mausoleum.png")
			bsprite:ReplaceSpritesheet(1, "gfx/enemies/skeleton bats/ribbone_mausoleum.png")
			bsprite:LoadGraphics()
		  end

		beam:Update()
		local bat = Isaac.Spawn(mod.FF.Jawbone.ID,mod.FF.Jawbone.Var, 0, npc.Position, nilvector, npc):ToEffect()
		npc:Remove()
	end

	if room:IsClear() and not mod.FindClosestEntity(npc.Position,99999,258,961) then
		npc:Kill()
	end
end

function mod:BattyBloodBeam(e)
e.SpriteOffset = Vector(0, -20)
e.RenderZOffset = -5000
end

mod:AddCallback(ModCallbacks.MC_POST_EFFECT_UPDATE, mod.BattyBloodBeam, 7010)


function mod:friedAI(npc)
	local sprite = npc:GetSprite()
	local d = npc:GetData()

	npc.RenderZOffset = -10000

	--Isaac.ConsoleOutput(npc.SpriteRotation .. "\n")

	if not d.init then
		d.state = "idle"
		d.init = true
		npc.StateFrame = 60
	end

	if d.state == "idle" then
		if npc.State == 8 then
			d.state = "attackstart"
			npc.State = 5
		else
			npc.State = 4
		end
	elseif d.state == "attackstart" then
		if sprite:IsFinished("AttackStart") then
			d.state = "attack"
			npc:PlaySound(mod.Sounds.FriedLoop,1,0,true,1)
			npc.StateFrame = 100
		elseif sprite:GetFrame() == 7 then
			npc:PlaySound(mod.Sounds.FriedStart,1,0,false,1)
		else
			mod:spritePlay(sprite, "AttackStart")
		end
	elseif d.state == "attack" then
		npc.State = 4
		if npc.StateFrame < 1 then
			d.state = "idle"
			npc.StateFrame = 60
		elseif npc.StateFrame == 10 then
			sfx:Stop(mod.Sounds.FriedLoop)
			npc:PlaySound(mod.Sounds.FriedEnd,1,0,false,1)
		elseif npc.StateFrame > 10 then
			if not sfx:IsPlaying(mod.Sounds.FriedLoop) then
				sfx:Play(mod.Sounds.FriedLoop, 1, 0, true, 1)
			end
		end
		if npc.Velocity:Length() > 3 then
			npc.Velocity = npc.Velocity:Resized(3)
		end

		local offset = nilvector
		if npc.SpriteRotation == 0 then
			offset = Vector(0, -20)
		elseif npc.SpriteRotation == 90 then
			offset = Vector(20,-15)
		elseif npc.SpriteRotation == -90 then
			offset = Vector(-20,-15)
		elseif npc.SpriteRotation == 180 then
			offset = Vector(0,20)
		end

		local fire = Isaac.Spawn(1000,7005, 0, npc.Position + offset, Vector(0,8):Rotated(-15 + math.random(30) + npc.SpriteRotation), npc):ToEffect()
		fire:SetColor(Color(1,1,1,1,-100 / 255,70 / 255,455 / 255),10,1,true,false)
		fire:GetData().flamethrower = true
		fire:GetData().timer = 17
		fire:GetData().gridcoll = 0
		fire:Update()

		if npc.FrameCount % 2 == 0 then
			local emberParticle = Isaac.Spawn(1000,66, 0, npc.Position + offset, Vector(0,math.random(4,7)):Rotated(-35 + math.random(70) + npc.SpriteRotation), npc):ToEffect()
			emberParticle:Update()

			local smoke = Isaac.Spawn(1000, EffectVariant.DARK_BALL_SMOKE_PARTICLE, 0, npc.Position + offset, Vector(0,math.random(4,7)):Rotated(-35 + math.random(70) + npc.SpriteRotation), npc):ToEffect()
			smoke.SpriteRotation = math.random(360)
			smoke.Color = Color(1,1,1,0.3,75 / 255,70 / 255,50 / 255)
			--smoke.SpriteScale = Vector(2,2)
			smoke.SpriteOffset = Vector(0, 3):Rotated(npc.SpriteRotation)
			smoke.RenderZOffset = 300
			smoke:Update()
		end

		if npc.Velocity:Length() < 1 then
			sprite:SetFrame("AttackLoop", npc.FrameCount % 4)
		else
			sprite:SetFrame("AttackWalk", npc.FrameCount % 8)
		end
	end

	if npc:IsDead() then
		sfx:Stop(mod.Sounds.FriedLoop)
	end
end

function mod:ogreCreepAI(npc)
	local sprite = npc:GetSprite()
	local d = npc:GetData()
	local target = npc:GetPlayerTarget()

	--Isaac.ConsoleOutput(npc.SpriteRotation .. "\n")

	if not d.init then
		d.state = "idle"
		d.init = true
		npc.StateFrame = 15
	end

	if d.state == "idle" then
		if npc.State == 8 then
			d.state = "attackstart"
			npc.State = 5
		else
			npc.State = 4
		end
	elseif d.state == "attackstart" then
		if sprite:IsFinished("Attack") then
			d.state = "idle"
			npc.StateFrame = 15
		elseif sprite:IsEventTriggered("Shoot") then
			npc:PlaySound(SoundEffect.SOUND_BLOODSHOOT,1,2,false,math.random(9,11)/10)
			local projectile = Isaac.Spawn(9, 4, 0, npc.Position, Vector(0,8):Rotated(npc.SpriteRotation), npc):ToProjectile();
			local dist = npc.Position:Distance(target.Position)
			projectile.FallingSpeed = dist * -0.1
			projectile.FallingAccel = 1
			projectile.Scale = 2
			projectile.Color = mod.ColorWebWhite
			projectile:GetData().projType = "ogreCreep"
			projectile:Update()
		else
			mod:spritePlay(sprite, "Attack")
		end
	end
end

function mod:reheatedCreep1AI(npc)
	local sprite = npc:GetSprite()
	local d = npc:GetData()
	local target = npc:GetPlayerTarget()

	if not d.init then
		d.state = "idle"
		d.init = true
		npc.StateFrame = 15
		local ipecolor = Color(1,1,1,1,0,0,0)
		ipecolor:SetColorize(0.7, 2, 0.7, 1)
		npc.SplatColor = ipecolor
	end

	if d.state == "idle" then
		if npc.State == 8 then
			d.state = "attackstart"
			npc.State = 5
		else
			npc.State = 4
		end
	elseif d.state == "attackstart" then
		if sprite:IsFinished("Attack") then
			d.state = "idle"
			npc.StateFrame = 30
		elseif sprite:IsEventTriggered("Blam") then
			local projectile = Isaac.Spawn(9, 0, 0, npc.Position, Vector(0,8):Rotated(npc.SpriteRotation), npc):ToProjectile();
			local dist = npc.Position:Distance(target.Position)
			projectile.FallingSpeed = dist * -0.1
			projectile.FallingAccel = 1
			projectile.Scale = 2
			local ipecolor = Color(1,1,1,1,0,0,0)
			ipecolor:SetColorize(0.7, 2, 0.7, 1)
			projectile.Color = ipecolor
			projectile.ProjectileFlags = ProjectileFlags.EXPLODE
			projectile:Update()
		else
			mod:spritePlay(sprite, "Attack")
		end
	end
end

function mod:reheatedCreep2AI(npc)
	local sprite = npc:GetSprite()
	local d = npc:GetData()
	local target = npc:GetPlayerTarget()

	if not d.init then
		d.state = "idle"
		d.init = true
		npc.StateFrame = 15
	end

	if d.state == "idle" then
		if npc.State == 8 then
			d.state = "attackstart"
			npc.State = 5
		else
			npc.State = 4
		end
	elseif d.state == "attackstart" then
		if sprite:IsFinished("Attack") then
			d.state = "idle"
			npc.StateFrame = 30
		elseif sprite:IsEventTriggered("Blam") then
			local laser = Isaac.Spawn(7,2,0,npc.Position, nilvector, npc):ToLaser()
			--laser.PositionOffset = Vector(0, -26)
			laser.SpawnerEntity = npc
			laser.Parent = npc
			laser.Angle = npc.SpriteRotation + 90
			laser:SetTimeout(5)
			laser:Update()
		else
			mod:spritePlay(sprite, "Attack")
		end
	end
end

mod.snaggerPickupTable = {
["10 | 1"] = {Type = "Heart", Multiplier = 1},
["10 | 2"] = {Type = "Heart", Multiplier = 0.5},
["10 | 3"] = {Type = "Heart", Multiplier = 1},
["10 | 4"] = {Type = "Heart", Multiplier = 2},
["10 | 5"] = {Type = "Heart", Multiplier = 2},
["10 | 6"] = {Type = "Heart", Multiplier = 1},
["10 | 7"] = {Type = "Heart", Multiplier = 1},
["10 | 8"] = {Type = "Heart", Multiplier = 0.5},
["10 | 9"] = {Type = "Heart", Multiplier = 1},
["10 | 10"] = {Type = "Heart", Multiplier = 1},
["10 | 11"] = {Type = "Heart", Multiplier = 1},
["10 | 12"] = {Type = "Heart", Multiplier = 1},
["10 | 12"] = {Type = "Heart", Multiplier = 1},
["1022 | 0"] = {Type = "Heart", Multiplier = 0.5},
["1023 | 0"] = {Type = "Heart", Multiplier = 1},
["1024 | 0"] = {Type = "Heart", Multiplier = 1},
["1025 | 0"] = {Type = "Heart", Multiplier = 0.5},
["1026 | 0"] = {Type = "Heart", Multiplier = 1},

["20 | 1"] = {Anim = "EatCoin", State = "attacking", Sprite = "coins/penny.png", Type = "Coin", Count = 1},
["20 | 2"] = {Anim = "EatCoin", State = "attacking", Sprite = "coins/nickel.png", Type = "Coin", Count = 5},
["20 | 3"] = {Anim = "EatCoin", State = "attacking", Sprite = "coins/dime.png", Type = "Coin", Count = 10},
["20 | 4"] = {Anim = "EatCoin", State = "attacking", Sprite = "coins/penny_double.png", Type = "Coin", Count = 2},
["20 | 5"] = {Anim = "EatCoin", State = "attacking", Sprite = "coins/penny.png", Type = "Coin", Count = 1},
["20 | 7"] = {Anim = "EatCoin", State = "attacking", Sprite = "coins/penny_golden.png", Type = "Coin", Count = 1, Special = "goldenpenny"},
["20 | 213"] = {Anim = "EatCoin", State = "attacking", Sprite = "coins/penny_cursed.png", Type = "Coin", Count = 0, Hurts = true},
["20 | 214"] = {Anim = "EatCoin", State = "attacking", Sprite = "coins/penny_haunted.png", Type = "Coin", Count = 1, Special = "wisp"},
["20 | 215"] = {Anim = "EatCoin", State = "attacking", Sprite = "coins/penny_honey.png", Type = "Coin", Count = 1, Special = "honey"},
["20 | 216"] = {Anim = "EatCoin", State = "attacking", Sprite = "coins/penny_goldencursed.png", Type = "Coin", Count = 0, Special = "goldenpennycursed", Hurts = true},

["30 | 1"] = {Anim = "Key", State = "attacking", Sprite = "keys/key.png", Type = "Key", Count = 1},
["30 | 2"] = {Anim = "Key", State = "attacking", Sprite = "keys/key_golden.png", Type = "Key", Count = 1, Special="golden"},
["30 | 3"] = {Anim = "Key", State = "attacking", Sprite = "keys/key_double.png", Type = "Key", Count = 2},
["30 | 4"] = {Anim = "KeyCharge", State = "attacking", Sprite = "keys/key.png", Type = "Key", Count = 1, Special="charged"},
["30 | 4"] = {Anim = "KeyCharge", State = "attacking", Sprite = "keys/key.png", Type = "Key", Count = 1, Special="charged"},
["30 | 179"] = {Anim = "Key", State = "attacking", Sprite = "keys/key_spicy2.png", Type = "Key", Count = 2, Hurts = true},
["30 | 180"] = {Anim = "Key", State = "attacking", Sprite = "keys/key_spicy3.png", Type = "Key", Count = 3, Hurts = true},
["30 | 181"] = {Anim = "KeyCharge", State = "attacking", Sprite = "keys/key_spicy2.png", Type = "Key", Special="charged", Count = 2, Hurts = true},
["30 | 182"] = {Anim = "Key", State = "attacking", Sprite = "keys/key_spicy2.png", Type = "Key", Count = 2, Hurts = true},
["30 | 183"] = {Anim = "Key", State = "attacking", Sprite = "keys/key_spicy3.png", Type = "Key", Count = 3, Hurts = true},
["30 | 184"] = {Anim = "KeyCharge", State = "attacking", Sprite = "keys/key_spicy2.png", Type = "Key", Special="charged", Count = 2, Hurts = true},
["30 | 185"] = {Anim = "Key", State = "attacking", Sprite = "keys/key_spicy2.png", Type = "Key", Count = 2, Hurts = true},
["30 | 186"] = {Anim = "Key", State = "attacking", Sprite = "keys/key_spicy3.png", Type = "Key", Count = 3, Hurts = true},
["30 | 187"] = {Anim = "KeyCharge", State = "attacking", Sprite = "keys/key_spicy2.png", Type = "Key", Special="charged", Count = 2, Hurts = true},

["40 | 1"] = {Anim = "Bomb", State = "attacking", Sprite = "bombs/bomb.png", Type = "Bomb"},
["40 | 2"] = {Anim = "Bomb", State = "attacking", Sprite = "bombs/bomb_double.png", Type = "Bomb", Special="double"},
["40 | 4"] = {Anim = "Bomb", State = "attacking", Sprite = "bombs/bomb_golden.png", Type = "Bomb", Special="golden"},
["40 | 7"] = {Anim = "GigaBomb", State = "crush", Type = "GigaBomb"},
["41 | 0"] = {Anim = "Bomb", State = "attacking", Sprite = "bombs/bomb_red.png", Type = "Bomb", Special="red"},
["40 | 923"] = {Anim = "Bomb", State = "attacking", Sprite = "bombs/bomb_copper.png", Type = "Bomb", Special="copper"},

["42 | 0"] = {Anim = "EatCoin", State = "attacking", Sprite = "bombs/poop_small.png", Type = "Poop"},
["42 | 1"] = {Anim = "EatCoin", State = "attacking", Sprite = "bombs/poop_big.png", Type = "Poop", Special="bigfart"},

["50 | 1"] = {Type = "Chest"},
["52 | 1"] = {Type = "Chest", Hurts = true},
["54 | 1"] = {Type = "Chest"},
["56 | 1"] = {Type = "Chest"},
["58 | 1"] = {Type = "Chest"},

["300 | " .. Card.SMALL_CONTRABAND] = {Type = "Contraband", Sprite = "keys/contraband_small.png",},
["100 | " .. CollectibleType.COLLECTIBLE_CONTRABAND] = {Type = "ContrabandBig", Sprite = "keys/contraband_item.png"},

["360 | 1"] = {Type = "Chest"},

["69 | 1"] = {Type = "Sack"},
["69 | 2"] = {Type = "Sack"},

["90 | 1"] = {Type = "Battery", Duration = "300"},
["90 | 2"] = {Type = "Battery", Duration = "150"},
["90 | 3"] = {Type = "Battery", Duration = "600"},
["90 | 4"] = {Type = "Battery", Duration = "600"},

["666 | 0"] = {Type = "PlayerSack"},
["666 | 10"] = {Type = "PlayerSack"},

["710 | 0"] = {Type = "PlayerChest"},
["712 | 0"] = {Type = "PlayerChest"},

["1873 | 1"] = {Type = "Heart"},
["1873 | 2"] = {Anim = "Key", State = "attacking", Type = "Key"},
["1873 | 3"] = {Anim = "Bomb", State = "attacking", Type = "Bomb"},
["1873 | 6"] = {Type = "Battery"},
["1873 | 7"] = {Type = "Heart"},
["1873 | 8"] = {Anim = "Key", State = "attacking", Type = "Key"},
["1873 | 9"] = {Anim = "Bomb", State = "attacking", Type = "Bomb"},
}

mod.snaggerPickupsHighVal = {
	[10] = true,
	[20] = true,
	[50] = true,
	[52] = true,
	[54] = true,
	[69] = true,
	[90] = true,
	[360] = true,
	[666] = true,
}

mod.snaggerCoinAngles = {
[1] = {StartOff = 0, AddVal = 0},
[2] = {StartOff = -30, AddVal = 60},
[3] = {StartOff = -45, AddVal = 45},
[4] = {StartOff = -40, AddVal = 26.6333},
[5] = {StartOff = -60, AddVal = 30},

}

function mod:snaggerAI(npc)
	local d = npc:GetData()
	local r = npc:GetDropRNG()
	local sprite = npc:GetSprite()
	local target = npc:GetPlayerTarget()
	local room = game:GetRoom()

	if not d.init then
		d.state = "searching"
		d.init = true
		d.batteried = 0
		d.honeybuff = 0
		if d.spawned_by_buck then
			mod:spritePlay(sprite, "AppearBuck")
		end
	else
		npc.StateFrame = npc.StateFrame + 1
		d.batteried = d.batteried - 1
	end

	if d.batteried > 0 then
		if npc.StateFrame > 1 then
			d.interpolationframe = true
		end
		mod:spriteOverlayPlay(sprite, "Charged")
	elseif d.batteried == 0 then
		sprite:RemoveOverlay()
	end
	if d.honeybuff and d.honeybuff > 0 then
		d.honeybuff = d.honeybuff - 1
		if npc.FrameCount % 3 == 0 then
			local honeycolor = Color(1,1,1,1,0,0,0)
			honeycolor:SetColorize(5.5, 3.5, 1, 1)
			local creep = Isaac.Spawn(1000, EffectVariant.CREEP_BROWN, 0, npc.Position, nilvector, npc):ToEffect()
			creep:SetTimeout(120)
			creep:Update()
			creep:GetSprite().Color = honeycolor
		end
	end

	if npc.HitPoints > npc.MaxHitPoints then
		local increase = math.ceil(npc.HitPoints - npc.MaxHitPoints)
		npc:SetColor(Color(1,1,1,1,(increase * 5) / 255,0,0),15,1,true,false)
	end

	if d.state == "searching" then
		if d.spawned_by_buck and npc.FrameCount == 2 then
			local poof = Isaac.Spawn(1000, 15, 0, npc.Position, nilvector, nil):ToEffect()
			d.poofd = true
		end
		if (not sprite:IsPlaying("Spawn")) and (not sprite:IsPlaying("AppearBuck")) then
			if d.monching then
				mod:spritePlay(sprite, "FloatDown02")
				if sprite:IsEventTriggered("crunch") then
					npc:PlaySound(mod.Sounds.CronchyWorms, 1, 0, false, math.random(115,125)/100)
				end
			else
				mod:spritePlay(sprite, "FloatDown")
			end
		end
		local tPickup

		--Movement
		local pickups = Isaac.FindByType(5, -1, -1, false, false)
		local dist = 999999
		local isCoins
		for _, pickup in pairs(pickups) do
			if mod.snaggerPickupTable[pickup.Variant .. " | " .. pickup.SubType] then
				local isValuable = mod.snaggerPickupsHighVal[pickup.Variant]
				if d.monching and isValuable then
					if pickup.Variant == 20 then
						isCoins = true
					end
					if tPickup and not mod.snaggerPickupsHighVal[tPickup.Variant] then
						tPickup = pickup
						dist = pickup.Position:Distance(npc.Position)
					end
				end
				local newdist = pickup.Position:Distance(npc.Position)
				if newdist < dist and ((not isCoins) or pickup.Variant == 20 or pickup.Variant == 10) then
					tPickup = pickup
					dist = newdist
				end
			end
		end

		local targetVelocity = nilvector
		local snagspeed = 3.2 * math.random(8,10) / 10
		local cBomb = mod.FindNearbyBombs(npc.Position, 100)
		if mod:isScare(npc) then
			targetVelocity = (target.Position - npc.Position):Resized(-snagspeed)
		elseif mod:isConfuse(npc) then
			targetVelocity = (mod:confusePos(npc, target.Position) - npc.Position):Resized(snagspeed)
		elseif cBomb then
			targetVelocity = (npc.Position - cBomb.Position):Resized(snagspeed)
		elseif d.monching and ((not tPickup) or (not mod.snaggerPickupsHighVal[tPickup.Variant])) then
			targetVelocity = (target.Position - npc.Position):Resized(snagspeed)
		elseif tPickup and (not d.frozen_by_buck) then
			targetVelocity = (tPickup.Position - npc.Position):Resized(snagspeed)
		elseif not d.frozen_by_buck then
			targetVelocity = (target.Position - npc.Position):Resized(snagspeed)
		end
		npc.Velocity = mod:Lerp(npc.Velocity, targetVelocity,0.2)
		if npc.Velocity.X < 0 then
			sprite.FlipX = true
		else
			sprite.FlipX = false
		end

		if (not mod:isScareOrConfuse(npc)) and d.monching and (((not tPickup) or (not mod.snaggerPickupsHighVal[tPickup.Variant])) or npc.Position:Distance(target.Position) < npc.Position:Distance(tPickup.Position) or d.monching >= 10) then
			if npc.Position:Distance(target.Position) < 300 and room:CheckLine(npc.Position, target.Position, 3, 0, false, false) then
				d.state = "blarghe"
			end
		elseif tPickup and tPickup:Exists() and not mod:isScareOrConfuse(npc) then
			if npc.StateFrame > 10 and npc.Position:Distance(tPickup.Position) < 15 and tPickup.EntityCollisionClass ~= EntityCollisionClass.ENTCOLL_NONE then
				npc.StateFrame = 0
				tPickup:ToPickup():PlayPickupSound()
				local choice = mod.snaggerPickupTable[tPickup.Variant .. " | " .. tPickup.SubType]
				d.sState = nil
				d.hurts = nil
				if choice.Anim then
					d.anim = choice.Anim
					mod:spritePlay(sprite, d.anim)
					sprite.FlipX = false
				end
				if choice.State then
					d.state = choice.State
				end
				if choice.Count then
					d.count = choice.Count
				end
				if choice.Hurts then
					d.hurts = choice.Hurts
				end
				if choice.Special then
					d.special = choice.Special
				else
					d.special = nil
				end
				local spritesheet
				if choice.Sprite then
					spritesheet = "gfx/enemies/snagger/pickups/"..choice.Sprite
				end
				if choice.Type then
					if choice.Type == "Heart" then
						npc.HitPoints = npc.HitPoints + (npc.MaxHitPoints * choice.Multiplier)
						if npc.HitPoints > npc.MaxHitPoints * 3 then
							npc.HitPoints = npc.MaxHitPoints * 3
						end
						local poof = Isaac.Spawn(1000, 49, 0, npc.Position, nilvector, npc):ToEffect()
						poof.SpriteOffset = Vector(0,-40)
						poof:FollowParent(npc)
						poof:Update()
						if tPickup.Variant == 1022 or tPickup.Variant == 1023 then
							sfx:Play(SoundEffect.SOUND_UNHOLY)
						elseif tPickup.Variant >= 1024 and tPickup.Variant <= 1026 then
							sfx:Play(mod.Sounds.FiendHeartPickup)
						end
					elseif choice.Type == "Contraband" then
						d.state = "contrabandFleeing"
						d.anim = "Contraband"
						sprite:ReplaceSpritesheet(1, spritesheet)
						sprite:ReplaceSpritesheet(2, spritesheet)
						sprite:LoadGraphics()
					elseif choice.Type == "ContrabandBig" then
						d.state = "contrabandFleeing"
						d.anim = "ContrabandItem"
						sprite:ReplaceSpritesheet(1, spritesheet)
						sprite:ReplaceSpritesheet(2, spritesheet)
						sprite:LoadGraphics()
					elseif choice.Type == "GigaBomb" then
						d.state = "gigabomb"
					elseif choice.Type == "Poop" then
						d.state = "poop"
						sprite:ReplaceSpritesheet(1, spritesheet)
						sprite:LoadGraphics()
					elseif choice.Type == "Chest" then
						tPickup:ToPickup():TryOpenChest()
						if choice.Hurts then
							npc:TakeDamage(5, 0, EntityRef(tPickup), 0)
						end
						if tPickup.Variant == PickupVariant.PICKUP_HAUNTEDCHEST then
							local polty = Isaac.Spawn(816,0,0,tPickup.Position,Vector.Zero,npc)
							polty:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
						end
					elseif choice.Type == "Sack" then
						local num = math.random(2,3)

						for i = 1, num do
							local num2 = math.random(5)
							if num2 == 5 then num2 = 9 end
							num2 = num2 * 10
							Isaac.Spawn(5, num2, 0, tPickup.Position, RandomVector()*math.random(1,5), nil)
						end
					elseif choice.Type == "Battery" then
						d.batteried = d.batteried + (choice.Duration or 300)
						npc:PlaySound(SoundEffect.SOUND_BATTERYCHARGE, 1, 0, false, 1)
						local poof = Isaac.Spawn(1000, 49, 1, npc.Position, nilvector, npc):ToEffect()
						poof.SpriteOffset = Vector(0,-40)
						poof:FollowParent(npc)
						poof:Update()
						if choice.Hurts then
							npc:TakeDamage(5, 0, EntityRef(tPickup), 0)
						end
					elseif choice.Type == "PlayerSack" then
						if tPickup.Variant == 666 then
							mod:bloodsackburst(tPickup, true)
						end
					elseif choice.Type == "PlayerChest" then
						if tPickup.Variant == 710 then
							tPickup:GetData().Opened = true
							tPickup:GetSprite():Play("Open")
							sfx:Play(SoundEffect.SOUND_CHEST_OPEN, 1, 0, false, 1)
						elseif tPickup.Variant == 712 then
							mod:FFDireChestOpening(tPickup:ToPickup(), npc)
						end
					else
						if choice.Type == "Coin" then
							if npc:GetDropRNG():RandomInt(10) < 9 then
								if d.special == "goldenpenny" then
									local gold = Isaac.Spawn(5, 20, 7, mod:FindRandomFreePos(tPickup), Vector.Zero, tPickup)
									gold:GetSprite():Play("Reappear", true)
								elseif d.special == "goldenpennycursed" then
									local gold = Isaac.Spawn(5, 20, 216, mod:FindRandomFreePos(tPickup), Vector.Zero, tPickup)
									gold:GetSprite():Play("Reappear", true)
								end
							end
							if tPickup.SubType == CoinSubType.COIN_HAUNTEDPENNY then
								sfx:Play(SoundEffect.SOUND_SOUL_PICKUP, 1.3, 0, false, 1)
							elseif tPickup.SubType == CoinSubType.COIN_HONEYPENNY then
								sfx:Play(SoundEffect.SOUND_ANIMAL_SQUISH, 1.3, 0, false, 1)
								sfx:Play(SoundEffect.SOUND_PENNYPICKUP, 1, 0, false, 1)
							end
						elseif choice.Type == "Key" then
							if choice.Hurts then
								npc:TakeDamage(5, 0, EntityRef(tPickup), 0)
								sfx:Play(SoundEffect.SOUND_FIREDEATH_HISS)
							end
						elseif choice.Type == "Bomb" then
							if d.special == "copper" then
								sfx:Play(FiendFolio.Sounds.CopperBombPickup, 0.2, 0, false, 1)
								sfx:Play(SoundEffect.SOUND_FETUS_FEET, 2, 0, false, 1)
							end
						end
						if spritesheet then
							local layers = {}
							if choice.Type == "Coin" then
								layers = {1}
							elseif choice.Type == "Bomb" then
								layers = {2,4}
							elseif choice.Type == "Key" then
								layers = {5,6}
							end
							for _, layer in pairs(layers) do
								sprite:ReplaceSpritesheet(layer, spritesheet)
							end
							sprite:LoadGraphics()
						end
						d.aType = choice.Type
					end
				end

				d.shotsFired = 0

				if tPickup.Variant == 10 or tPickup.Variant == 69 or tPickup.Variant == 90 or (tPickup.Variant >= 1022 and tPickup.Variant <= 1026) then
					local effect = Isaac.Spawn(1000,7000,0,tPickup.Position,nilvector,nil)
					local efsprite = effect:GetSprite()
					efsprite:Load(tPickup:GetSprite():GetFilename(),true)
					efsprite:Play("Collect")
					effect:GetData().HeartCollect = true
				end
				if choice.Type ~= "Chest" and choice.Type ~= "PlayerChest" then
					tPickup:Remove()
				end
				tPickup:Update()
			end
		end

		if --[[npc.SpawnerEntity and--]] (d.frozen_by_buck or (d.spawned_by_buck and npc.FrameCount < 60)) --[[and d.state == "searching"--]] then
			local v = mod.FindClosestEntity(npc.Position,50,9,1,0)
			if v and (v:GetData().projType == "buckbomb") --[[and v:ToProjectile().Height > -40]] then
				--print("foundBomb")
				v:Remove()
				d.state = "attacking"
				d.anim = "Bomb"
				d.aType = "Bomb"
				d.shotsFired = 0
				sfx:Play(SoundEffect.SOUND_FETUS_FEET, 0.8, 0, false, 1.2)
			end
		else
			d.frozen_by_buck = false
		end

	elseif d.state == "attacking" then
		npc.Velocity = npc.Velocity * 0.7
		if not d.sState then
			d.sState = "PreSpawn"
			mod:spritePlay(sprite, d.anim)
		elseif d.sState == "PreSpawn" then
			if sprite:IsFinished(d.anim) then
				if d.aType == "Bomb" then
					npc:PlaySound(SoundEffect.SOUND_SHELLGAME,1,2,false,1)
					local slot = mod.FindClosestEntity(npc.Position, 99999, 6)
					local schest = mod.FindClosestEntity(npc.Position, 99999, 5, 51, 1)
					local gchest = mod.FindClosestEntity(npc.Position, 99999, 5, 713, 0)
					local sNick = mod.FindClosestEntity(npc.Position, 99999, 5, 20, 6)
					if slot and not slot:GetSprite():IsPlaying("Broken") then
						target = slot
					elseif schest then
						target = schest
					elseif gchest then
						target = gchest
					elseif sNick then
						target = sNick
					end
					local thrownum, throwang = 1, 45
					if d.special == "double" then
						throwang = 30
						thrownum = 2
					end

					for i = 1, thrownum do
						local vel = ((target.Position - npc.Position) / 30):Rotated(-45 + throwang * i)
						if vel:Length() > 13 then
							vel = vel:Resized(13)
						end
						local rand = r:RandomFloat()
						local bombshot = Isaac.Spawn(EntityType.ENTITY_PROJECTILE, ProjectileVariant.PROJECTILE_BONE, 0, npc.Position, vel + npc.Velocity, npc):ToProjectile()
						local bombd = bombshot:GetData()
						bombshot.SpawnerEntity = npc
						--Isaac.ConsoleOutput(bombshot.SpawnerEntity.Type)
						bombd.projType = "thrownbomb"
						if d.special == "golden" then bombd.projTypeS = true end
						if d.special == "red" then bombd.pinkBomb = true end
						if d.special == "copper" then bombd.copperBomb = true end
						bombshot.FallingSpeed = -20
						bombshot.FallingAccel = 1.2
						bombshot.Scale = 1
					end
				elseif d.aType == "Key" then
					npc:PlaySound(SoundEffect.SOUND_SHELLGAME,1,2,false,1)
					local Echest = mod.FindClosestEntity(npc.Position, 99999, 5, 53, 1)
					local Ochest = mod.FindClosestEntity(npc.Position, 99999, 5, 55, 1)
					local Mchest = mod.FindClosestEntity(npc.Position, 99999, 5, 57, 1)
					local Gchest = mod.FindClosestEntity(npc.Position, 99999, 5, 60, 1)
					local Schest = mod.FindClosestEntity(npc.Position, 99999, 5, 711, 0)
					local GLchest = mod.FindClosestEntity(npc.Position, 99999, 5, 713, 0)
					if Echest or Gchest or Schest or GLchest or Ochest or Mchest then
						if Echest then
							target = Echest
						elseif Gchest then
							target = Gchest
						elseif GLchest then
							target = GLchest
						elseif Ochest then
							target = Ochest
						elseif Mchest then
							target = Mchest
						elseif Schest then
							target = Schest
						end
					end
					local thrownum, throwang, keysubt, keyspeed = d.count, 45, 0, 11
					if d.special == "golden" then
						keysubt = 10
					elseif d.special == "charged" then
						keysubt = 20
						keyspeed = 15
						d.batteried = d.batteried + 200
						npc:PlaySound(SoundEffect.SOUND_BATTERYCHARGE, 1, 0, false, 1)
						local poof = Isaac.Spawn(1000, 49, 1, npc.Position, nilvector, npc):ToEffect()
						poof.SpriteOffset = Vector(0,-40)
						poof:FollowParent(npc)
						poof:Update()
						if d.hurts then
							keysubt = 40
						end
					elseif d.hurts then
						keysubt = 30
					end
					if d.count == 2 then
						throwang = 30
					elseif d.count == 3 then
						throwang = 22.5
					end
					for i = 1, thrownum do
						local vel = (target.Position - npc.Position):Resized(keyspeed):Rotated(-45 + throwang * i)
						local key = Isaac.Spawn(mod.FF.KeyProjectile.ID, mod.FF.KeyProjectile.Var, keysubt, npc.Position, vel, npc)
						key.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYERONLY
						key:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
						key:GetData().speed = keyspeed
						key:Update()
					end
				end

				d.shotsFired = d.shotsFired + 1
				if (d.special == "golden") and d.shotsFired < 4 then
					sprite:Play(d.anim, true)
				else
					if d.aType == "Coin" then
						d.monching = d.monching or 0
						d.monching = d.monching + d.count
						mod:spritePlay(sprite, "FloatDown02")
					else
						mod:spritePlay(sprite, "Spawn")
					end
					d.state = "searching"
				end
			elseif d.aType == "Coin" and sprite:IsEventTriggered("crunch") then
				npc:PlaySound(mod.Sounds.Monch,1,0,false,math.random(115,135)/100)
				if d.hurts then
					sfx:Play(mod.Sounds.CursedPennyNegative, 1, 0, false, 1)
					Isaac.Explode(npc.Position, npc, 10)
					npc:Kill()
					if d.monching and d.monching > 1 then
						for i = 1, d.monching do
							local vel = RandomVector() * math.random(1,6)
							Isaac.Spawn(5, 20, 1, npc.Position, vel, npc)
						end
					end
				end
				if d.special then
					if d.special == "wisp" then
						local wisp = Isaac.Spawn(808,0,0,npc.Position+(RandomVector()*20),Vector.Zero,npc)
						wisp:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
						wisp:GetSprite():Load("gfx/enemies/snagger/willo_blue.anm2", true)
						wisp:GetData().IsBlueWillo = true
					elseif d.special == "honey" then
						d.honeybuff = 450
					end
				end
			else
				mod:spritePlay(sprite, d.anim)
			end
		end
	elseif d.state == "blarghe" then
		npc.Velocity = npc.Velocity * 0.7
		if sprite:IsFinished("ShootFull") then
			d.state = "searching"
		elseif sprite:IsEventTriggered("shoot") then
			npc:PlaySound(SoundEffect.SOUND_LITTLE_SPIT,1,2,false,1.3)
			local coins = math.min(d.monching, 5)
			local angHelper = mod.snaggerCoinAngles[coins]

			local params = ProjectileParams()
			params.Variant = mod.FF.BetterCoinProjectile.Var
			local vec = (target.Position - npc.Position):Resized(10):Rotated(angHelper.StartOff)
			for i = 1, coins do
				npc:FireProjectiles(npc.Position, vec:Rotated(angHelper.AddVal * (i - 1)), 0, params)
			end
			d.monching = d.monching - coins
			if d.monching < 1 then
				d.monching = nil
			end
		else
			mod:spritePlay(sprite, "ShootFull")
		end
	elseif d.state == "contrabandFleeing" then
		if not sprite:IsPlaying("Contraband") and d.anim =="Contraband" then
			sprite:Play("Contraband",false)
		end

		if not sprite:IsPlaying("ContrabandItem") and d.anim =="ContrabandItem" then
			sprite:Play("ContrabandItem",false)
		end
		npc.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_NONE
		d.vec = d.vec or RandomVector()*15
		npc.Velocity = mod:Lerp(npc.Velocity, d.vec, 0.03)
		npc.SpriteOffset = mod:Lerp(npc.SpriteOffset, Vector(0, -100), 0.02)
		d.ColorVal = d.ColorVal or 1
		d.ColorVal = mod:Lerp(d.ColorVal, 0, 0.02)
		npc.Color = Color(d.ColorVal,d.ColorVal,d.ColorVal,1,0,0,0)
		npc.Scale = mod:Lerp(npc.Scale, 2, 0.005)
		if npc.Position.X < -100 or npc.Position.X > room:GetGridWidth()*40+100 or npc.Position.Y > room:GetGridHeight()*40+300 or npc.Position.Y < -300 then
			npc:Remove()
		end
		if npc.StateFrame > 10 then
			npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
			npc.CanShutDoors = false
		end
	elseif d.state == "gigabomb" then
		npc.Velocity = npc.Velocity * 0.7
		if sprite:IsFinished(d.anim) then
			local bomb = Isaac.Spawn(4,17,0,npc.Position,npc.Velocity,npc)
			bomb:GetSprite():Play("Pulse")
			npc:Kill()
		end
	elseif d.state == "poop" then
		npc.Velocity = npc.Velocity * 0.7
		if sprite:IsFinished("EatCoin") then
			d.anim = "Fart"
			sprite:Play("Fart")
		elseif sprite:IsFinished("Fart") then
			d.state = "searching"
		else
			mod:spritePlay(sprite, d.anim)
		end
		if sprite:IsEventTriggered("shoot") then
			if d.special == "bigfart" then
				Isaac.Spawn(245, 0, 0, npc.Position, Vector.Zero, npc)
				game:ButterBeanFart(npc.Position, 170, npc, true)
			else
				game:ButterBeanFart(npc.Position, 85, npc, true)
			end
		elseif sprite:IsEventTriggered("crunch") then
			npc:PlaySound(mod.Sounds.Monch,1,0,false,math.random(115,135)/100)
		end
	end
end

function mod:snaggerKeyAI(npc)
	local d = npc:GetData()
	local sprite = npc:GetSprite()
	local subt = npc.SubType

	local title = "Key"
	if subt > 39 then
		title = "SpicyCharge"
	elseif subt > 29 then
		title = "Spicy"
	elseif subt > 19 then
		title = "Charge"
	elseif subt > 9 then
		title = "Gold"
	end

	if subt % 10 == 0 then
		mod:spritePlay(sprite, title .. "Launch")

		local Gchest = mod.FindClosestEntity(npc.Position, 15, 5, 60, 1)
		local Echest = mod.FindClosestEntity(npc.Position, 15, 5, 53, 1)
		local Schest = mod.FindClosestEntity(npc.Position, 99999, 5, 711, 0)
		if Gchest or Echest or Schest then
			if Echest then
				Echest:ToPickup():TryOpenChest()
			elseif Gchest then
				Gchest:ToPickup():TryOpenChest()
			elseif Schest then
				Schest:GetSprite():Play("Open")
				Schest.SubType = mod.shopChestStates.Opening
				sfx:Play(SoundEffect.SOUND_CHEST_OPEN, 1, 0, false, 1)
				sfx:Play(SoundEffect.SOUND_UNLOCK00, 1, 0, false, 1)
			end
			mod:snaggerKeyGib(npc, subt, true)
			npc:Remove()
		end
	else
		if subt % 10 == 1 then
			mod:spritePlay(sprite, title .. "Head")
		elseif subt % 10 == 2 then
			mod:spritePlay(sprite, title .. "Body")
		end
	end

	npc.FallingAccel = -0.1
	npc.SpriteRotation = npc.Velocity:GetAngleDegrees()
end

mod:AddCallback(ModCallbacks.MC_POST_PROJECTILE_UPDATE, mod.snaggerKeyAI, mod.FF.KeyProjectile.Var)

function mod:snaggerKeyBreak(npc)
	if npc.Variant == mod.FF.KeyProjectile.Var then
		local d = npc:GetData()
		local sprite = npc:GetSprite()
		local subt = npc.SubType

		if npc.SubType % 10 == 0 then
			for i = -25, 25, 50 do
				local keysubt = 1 + subt
				if i > 0 then
					keysubt = 2 + subt
				end
				local vel = npc.Velocity:Rotated(180 + i):Resized(d.speed)
				local key = Isaac.Spawn(mod.FF.KeyProjectile.ID, mod.FF.KeyProjectile.Var, keysubt, npc.Position, vel, npc)
				key.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYERONLY
				key:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
				key:Update()
			end
		end
		mod:snaggerKeyGib(npc, subt, (npc.SubType % 10 == 0))
	end
end

mod:AddCallback(ModCallbacks.MC_POST_ENTITY_REMOVE, mod.snaggerKeyBreak, mod.FF.KeyProjectile.ID)

function mod:snaggerKeyGib(npc, subt, justSmoke)
	sfx:Play(SoundEffect.SOUND_POT_BREAK,0.7,0,false,1.8)
	for k = 0, 360, 45 do
		local vec = Vector(math.random(3,7),0):Rotated(k - 10 + math.random(20))
		local smoke = Isaac.Spawn(1000, EffectVariant.DARK_BALL_SMOKE_PARTICLE, 0, npc.Position + vec:Resized(15), Vector(math.random(3,7),0):Rotated(k - 10 + math.random(20)), npc):ToEffect()
		smoke.SpriteRotation = math.random(360)
		smoke.Color = Color(1,1,1,0.2,0,0,0)
		smoke.SpriteOffset = Vector(0, -16)
		smoke.RenderZOffset = 300
		smoke:Update()
	end
	if not justSmoke then
		for k = 1, 4 do
			local vec = RandomVector() * mod:RandomInt(1,3)
			local gib = Isaac.Spawn(1000, 86, 0, npc.Position + vec:Resized(15), Vector(math.random(3,7),0):Rotated(k - 10 + math.random(20)), npc):ToEffect()
			if subt then
				if subt > 9 and subt < 20 then
					gib.Color = Color(1,1,1,1,100 / 255,50 / 255,-50 / 255)
				elseif subt > 29 and subt < 50 then
					gib.Color = Color(1,1,1,1,150 / 255,50 / 255,20 / 255)
				end
			end
			gib.FallingAcceleration = 1.3
			gib.FallingSpeed = -1
			--gib.PositionOffset = Vector(vec.X, math.abs(vec.Y) * -1)
			gib:Update()
		end
	end
end

function mod:oldsnaggerAI(npc)
	local d = npc:GetData()
	local r = npc:GetDropRNG()
	local p = npc.Position
	local s = npc:GetSprite()

	local snagspeed = 3.2 * math.random(8,10) / 10

	--Initialisation
	if not d.collection then
		d.collection = 0
		d.ammo = {}
		d.frozen_by_buck = false
	end



	--Spawn Attack
	if s:IsFinished("PreSpawn") or s:IsFinished("PreSpawn401") or s:IsFinished("PreSpawn402") or s:IsFinished("PreSpawn404") then
		d.collection = d.collection - 1
		if not s:IsPlaying("Spawn") then
			s:Play("Spawn",false)
		end
		--FIRE
		local ammovar = d.ammo[1][1]
		local ammosub = d.ammo[1][2]
		local target = npc:GetPlayerTarget()
		--Hearts

		--[[if ammovar == 10 then
			local vec = RandomVector()
			for i = 120, 360, 120 do
			mod.cheekyspawn(npc.Position + vec:Rotated(i) * 30, npc, npc.Position + vec:Rotated(i) * 100, 18, 0, 0)
			end]]

		--Coins
		if ammovar == 20 then
		local shotspeed = (target.Position - npc.Position)*0.03
		--fire the projectile
		local projectile = Isaac.Spawn(EntityType.ENTITY_PROJECTILE, 7, 0, npc.Position, shotspeed, npc):ToProjectile();
		projectile.FallingSpeed = -30;
		projectile.FallingAccel = 1;

		--Keys
		elseif ammovar == 30 then

		--Bombs
		elseif ammovar == 40 then
			local slot = mod.FindClosestEntity(target.Position, 99999, 6)
			if slot then
				target = slot
			end
			local throwang
			if ammosub == 2 then
				throwang = 30
				thrownum = 2
			else
				throwang = 45
				thrownum = 1
			end

			for i = 1, thrownum do
				local vel = ((target.Position - npc.Position) / 30):Rotated(-45 + throwang * i)
				if vel:Length() > 13 then
					vel = vel:Resized(13)
				end
				local rand = r:RandomFloat()
				local bombshot = Isaac.Spawn(EntityType.ENTITY_PROJECTILE, ProjectileVariant.PROJECTILE_BONE, 0, npc.Position, vel + npc.Velocity, npc):ToProjectile()
				local bombd = bombshot:GetData()
				bombshot.SpawnerEntity = npc
				--Isaac.ConsoleOutput(bombshot.SpawnerEntity.Type)
				bombd.projType = "thrownbomb"
				if ammosub == 4 then bombd.projTypeS = true end
				bombshot.FallingSpeed = -20
				bombshot.FallingAccel = 1.2
				bombshot.Scale = 1
			end
		end
		table.remove(d.ammo,1)



	end
	if s:IsFinished("Spawn") then
		s:Play("FloatDown",false)
	end

	local target = mod:findPickup(npc.Position, 10000, true, npc.InitSeed)
	if d.ammo[1] then
		if d.ammo[1][1] == 40 then target = nil end
	end
	if target ~= nil then
		local td = target:GetData()
		if not td.bumtargeteer then
			td.bumtargeteer = npc.InitSeed
		end
		if not s:IsPlaying("Spawn") then
			s:Play("FloatDown",false)
		end
		d.personalDistance = 30
		if p:Distance(target.Position) < 15 then
			local sprite = target:GetSprite()
			if td.collected == nil then
				td.collected = true
				if target.Variant == 10 then
					npc.HitPoints = npc.HitPoints + npc.MaxHitPoints
					if npc.HitPoints == npc.MaxHitPoints * 5 then
						npc.HitPoints = npc.MaxHitPoints * 5
					end
				elseif target.Variant == 40 and target.SubType == 4 then
					for i = 1, 4 do
					table.insert(d.ammo, 1, {target.Variant, target.SubType})
					end
					d.collection = d.collection+4
				elseif td.projType == "buckbomb" then
					table.insert(d.ammo, 1, {40, 0})
					d.collection = d.collection+1
				else
					table.insert(d.ammo, 1, {target.Variant, target.SubType})
					d.collection = d.collection+1
				end
				local effect = Isaac.Spawn(1000,7000,0,target.Position,nilvector,nil)
				local efsprite = effect:GetSprite()
				efsprite:Load(sprite:GetFilename(),true)
				efsprite:Play("Collect",true)
				target:Remove()
				sprite:Play("Collect",true)
				target:ToPickup():PlayPickupSound()
			end
		end
	else
		target = npc:GetPlayerTarget()
		if d.ammo[1] then
			if d.ammo[1][1] == 40 then
			d.personalDistance = 9999
			else
			d.personalDistance = 250
			end

			if p:Distance(target.Position) < d.personalDistance then
			target = nil
				if not s:IsPlaying("Spawn") then
					if d.ammo[1][1] == 40 then
						s:Play("PreSpawn" .. d.ammo[1][1] .. d.ammo[1][2],false)
					else
						s:Play("PreSpawn",false)
					end
				end
			end
		end
	end

	local targetVelocity = nilvector
	if d.frozen_by_buck == false then
		if target then
			targetVelocity = (target.Position - p):Normalized()*snagspeed
		end
	else
		npc.Velocity = mod:Lerp(npc.Velocity, targetVelocity,0.5) --lerp harder
	end
	npc.Velocity = mod:Lerp(npc.Velocity, targetVelocity,0.2)
end

FiendFolio.WackierWeavers = true
function mod:weaverAI(npc, variant)
	local sprite = npc:GetSprite()
	local d = npc:GetData()
	local target = npc:GetPlayerTarget()
	local subt = npc.SubType
	local room = game:GetRoom()

	if target.Parent and target.Parent.InitSeed == npc.InitSeed then
		target = Isaac.GetPlayer(0)
	end

	if variant == 10 then
		d.numbutts = 25
		d.numtails = 1
		d.groundtime = 15
	elseif variant == 2 then
		d.numbutts = 2
		d.numtails = 1
		d.groundtime = 50
	elseif variant == 3 then
		d.numbutts = 2
		d.numtails = 1
		d.groundtime = 30
	elseif variant == mod.FF.Archer.Var then
		d.numbutts = 2
		d.numtails = 1
		d.groundtime = 30
	else
		d.numbutts = 1
		d.numtails = 1
		d.groundtime = 10
	end

	local butttime = 3
	local tailtime = 3
	local holeoffset = -0

	local weavespeed = 8
	local curvar = 1
	local curframe = 13
	local curlerp = 0.05
	if variant == 2 or variant == mod.FF.Archer.Var then
		weavespeed = 8
		curvar = 1.7
		curframe = 25
		curlerp = 0.09
	elseif variant ~= 1 then
		weavespeed = 6
		curvar = 1.3
		curframe = 19
		curlerp = 0.07
	end

	if subt == 0 or subt > 3 then
		if not d.init then
			if variant == mod.FF.Archer.Var then
				if npc.SubType == 4 then
					mod.makeWaitFerr(npc, npc.Type, npc.Variant, 0, 30)
				else
					d.state = "wait"
					if mod:CheckStage("Dross", {45}) then
						d.TearVar = 3
					elseif mod:CheckStage("Corpse", {34,43,44}) then
						d.TearVar = 0
					else
						d.TearVar = 4
					end
					npc.Visible = false
					npc.StateFrame = mod:RandomInt(-30,30)
					npc:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
					npc:AddEntityFlags(EntityFlag.FLAG_NO_KNOCKBACK | EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK | EntityFlag.FLAG_NO_TARGET | EntityFlag.FLAG_HIDE_HP_BAR)
					npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
				end
				d.Index = room:GetGridIndex(npc.Position)
				if room:GetFrameCount() <= 1 then
					room:SpawnGridEntity(d.Index, GridEntityType.GRID_PIT, 0, 0, 0)
					mod:UpdatePits()
				end
			else
				npc.StateFrame = -10
				d.state = "underground"
			end
			d.init = true
			d.prevpositions = {{npc.Position, d.state}}

		else
			npc.StateFrame = npc.StateFrame + 1
		end

		if d.slowdown then
			d.slowdown = d.slowdown - 1
			if d.slowdown < 1 then
				d.slowdown = nil
			end
			weavespeed = weavespeed * 0.1
		end

		local targpos = mod:confusePos(npc, target.Position)

		-- if there are multiple weavers, orbit the player
		if FiendFolio.WackierWeavers then
			local weavers = Isaac.FindByType(npc.Type, -1, -1, false, false)
			local sumOff = 0
			local first = true
			local useWeaves = {}
			for i, weave in ipairs(weavers) do
				if weave.SubType == 0 or weave.SubType > 3 then
					useWeaves[#useWeaves + 1] = weave
					sumOff = sumOff + (weave.InitSeed % 360)
					if first then
						sumOff = sumOff + (weave.FrameCount % 360)
						first = false
					end
				end
			end

			if #useWeaves > 1 then
				for i, weave in ipairs(useWeaves) do
					if i ~= 1 and GetPtrHash(weave) == GetPtrHash(npc) then
						local off = (360 / (#useWeaves - 1)) * (i - 1)
						local dist = 65
						if d.state ~= "underground" then
							dist = 30
						end

						targpos = targpos + Vector(dist, 0):Rotated(off + sumOff)
					end
				end
			end
		end

		local targvel = mod:reverseIfFear(npc, (targpos - npc.Position):Resized(weavespeed))
		npc.Velocity = mod:Lerp(npc.Velocity, targvel, curlerp)
		if d.state == "wait" then
			npc.Velocity = Vector.Zero
			if not d.stasis then
				npc.StateFrame = npc.StateFrame + 1
			end
			if npc.StateFrame >= 60 then
				d.state = "archerEmerge"
				npc.SpriteOffset = Vector(0,0)
				npc.Color = Color(npc.Color.R, npc.Color.G, npc.Color.B, 1, npc.Color.RO, npc.Color.GO, npc.Color.BO)
				npc.Visible = true
				d.dontStuck = false
				npc.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_WALLS
				mod:FlipSprite(sprite, npc.Position, targpos)
			else
				npc.Visible = false
			end
		elseif d.state == "archerEmerge" then
			npc.Velocity = Vector.Zero
			if sprite:IsFinished("ShootEmerge") then
				d.state = "archerIdle"
				npc.StateFrame = mod:RandomInt(0,20)
			elseif sprite:IsEventTriggered("Emerge") then
				npc:ClearEntityFlags(EntityFlag.FLAG_NO_TARGET | EntityFlag.FLAG_HIDE_HP_BAR)
				npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_ALL
				Isaac.Spawn(1000,132,0,npc.Position+Vector(0,10),Vector.Zero,npc)
				npc:PlaySound(mod.Sounds.SplashLargePlonkless,0.8,0,false,1.2)
			else
				mod:spritePlay(sprite, "ShootEmerge")
			end
		elseif d.state == "archerIdle" then
			npc.Velocity = Vector.Zero
			npc.StateFrame = npc.StateFrame + 1
			if npc.StateFrame > 60 then
				npc.StateFrame = 0
				d.state = "shoot"
			else
				mod:spritePlay(sprite, "ShootIdle")
			end
		elseif d.state == "shoot" then
			npc.Velocity = Vector.Zero
			if sprite:IsEventTriggered("JumpStart") then
				npc:ClearEntityFlags(EntityFlag.FLAG_NO_KNOCKBACK | EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK)
				d.state = "surface"
				npc:PlaySound(SoundEffect.SOUND_BOSS2_DIVE, 0.7, 0, false, 1.2)
				Isaac.Spawn(1000,132,0,npc.Position+Vector(0,10),Vector.Zero,npc)
				npc.Velocity = mod:reverseIfFear(npc, (targpos - npc.Position):Resized(weavespeed - 2))
				d.killButt = nil
				d.lastcreepleft = nil
				d.spawndbutt = false
				d.spawndtail = false
				d.headnum = 1
				npc.StateFrame = 0
				mod.OccupiedGrids[d.Index] = "Open"
			elseif sprite:IsEventTriggered("Shoot") then
				mod:FlipSprite(sprite, npc.Position, targpos)
				local params = ProjectileParams()
				params.Variant = d.TearVar
				params.FallingAccelModifier = 0.8
				params.HeightModifier = -25
				for i = 1, mod:RandomInt(5,8) do
					params.Scale = 0.1 * mod:RandomInt(6, 12)
					params.FallingSpeedModifier = mod:RandomInt(-10,-5)
					npc:FireProjectiles(npc.Position, (target.Position - npc.Position):Resized(mod:RandomInt(6,10)):Rotated(mod:RandomInt(-30,30)), 0, params)
				end
				npc:PlaySound(SoundEffect.SOUND_BOSS_LITE_HISS, 0.7, 0, false, 1.2)
			end
			mod:spritePlay(sprite, "Shoot")
		elseif d.state == "underground" then
			npc.Visible = false
			mod:spritePlay(sprite, "Empty")
			npc.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_WALLS
			if variant == 2 --[[and room:GetGridCollisionAtPos(npc.Position) ~= GridCollisionClass.COLLISION_PIT]] then
				npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYERONLY
			else
				npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
			end

			d.lastcreepleft = d.lastcreepleft or npc.Position + Vector(0,20)
			if d.lastcreepleft:Distance(npc.Position) > 15 and npc.FrameCount > 0 then
				if variant == 2 then
					npc:PlaySound(SoundEffect.SOUND_ROCK_CRUMBLE,0.3,0,false,math.random(90,110)/100)
					local crack = Isaac.Spawn(1000, 62, 0, npc.Position, nilvector, npc):ToEffect()
					crack.Color = Color(0.5,0.5,0.5,1,0,0,0)
					crack:Update()
					mod:DestroyNearbyGrid(npc, 30)
				else
					local pile = Isaac.Spawn(1000, 26, 7002, npc.Position, nilvector, npc):ToEffect()
					--pile.Scale = 0.8 + math.random(40) / 100
					local backdrop = game:GetRoom():GetBackdropType()
					if backdrop == 10 or backdrop == 11 or backdrop == 12 then
						pile.Color = Color(1,1,1,1,60 / 255,-20 / 255,-20 / 255)
					elseif backdrop == 14 then
						pile.Color = Color(0.5,0.5,0.5,1,0,0,0)
					end
					--pile:GetSprite().Rotation = -10 + math.random(20)
					pile:Update()
				end
				d.lastcreepleft = npc.Position
			end

			if npc.StateFrame > d.groundtime then
				if room:GetGridCollisionAtPos(npc.Position) == GridCollisionClass.COLLISION_NONE then
					npc:PlaySound(SoundEffect.SOUND_MAGGOT_BURST_OUT,0.3,0,false,1.3 + math.random(3)/10)
					d.state = "surface"
					d.killButt = nil
					local pile = Isaac.Spawn(1000, 146, 0, npc.Position, nilvector, npc):ToEffect()
					--[[local backdrop = game:GetRoom():GetBackdropType()
					if backdrop == 10 or backdrop == 11 or backdrop == 12 then
						pile.Color = Color(1,1,1,1,60 / 255,-20 / 255,-20 / 255)
					elseif backdrop == 14 then
						pile.Color = Color(0.5,0.5,0.5,1,0,0,0)
					end]]
					local dirt = pile:GetSprite()
					dirt:Load("gfx/enemies/weaver/weaver.anm2", true)
					pile:GetData().WeaverPile = true
					pile:Update()
					d.lastcreepleft = nil
					d.spawndbutt = false
					d.spawndtail = false
					if variant == 1 then
						if npc.Position:Distance(target.Position) < 140 then
							d.headnum = 2
						else
							d.headnum = 1
						end
					else
						if math.random(15) == 1 then
							d.headnum = 2
						else
							d.headnum = 1
						end
					end
					npc.StateFrame = 0
				end
			end
		elseif d.state == "surface" then
			npc.Visible = true
			if npc.Velocity.Y < 0 then
				mod:spritePlay(sprite, "HeadUp" .. d.headnum)
			else
				mod:spritePlay(sprite, "HeadDown" .. d.headnum)
			end
			if npc.Velocity.X < 0 then
				sprite.FlipX = true
			else
				sprite.FlipX = false
			end
			if d.descending then
				npc.Velocity = npc.Velocity * 0.7
				npc.SpriteOffset = Vector(0, npc.SpriteOffset.Y + 2.5)
				if npc.SpriteOffset.Y > 20 then
					d.state = "wait"
					npc.Velocity = Vector.Zero
					npc.Position = room:GetGridPosition(room:GetGridIndex(npc.Position))
					npc.Visible = false
					d.descending = false
				else
					npc.Color = Color(npc.Color.R, npc.Color.G, npc.Color.B, npc.Color.A - 0.2, npc.Color.RO, npc.Color.GO, npc.Color.BO)
				end
			else
				local curve = 0 - math.sin(0.2 * npc.StateFrame / curvar) * 20
				local coll = room:GetGridCollisionAtPos(npc.Position)
				if npc.StateFrame > curframe and (coll ~= GridCollisionClass.COLLISION_NONE and coll ~= GridCollisionClass.COLLISION_PIT and variant ~= 2) then
					npc.StateFrame = curframe
					d.staystill = true
				end
				if variant == mod.FF.Archer.Var then
					curve = curve * 2
				end
				npc.SpriteOffset = Vector(0, curve)
				if curve <= -25 then
					npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
				else
					npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_ALL
				end
			end
			if npc.StateFrame > curframe + 2 then
				--[[if coll == GridCollisionClass.COLLISION_PIT and room:HasWaterPits() then
					npc:PlaySound(mod.Sounds.SplashLargePlonkless,3,0,false,1)
					local effect = Isaac.Spawn(1000,7002,0,npc.Position,nilvector,nil)
				else
					local pile = Isaac.Spawn(1000, 26, 7003, npc.Position, nilvector, npc):ToEffect()
				end]]

				--[[local backdrop = game:GetRoom():GetBackdropType()
				if backdrop == 10 or backdrop == 11 or backdrop == 12 then
					pile.Color = Color(1,1,1,1,60 / 255,-20 / 255,-20 / 255)
				elseif backdrop == 14 then
					pile.Color = Color(0.5,0.5,0.5,1,0,0,0)
				end]]
				if variant == mod.FF.Archer.Var then
					d.stasis = true
					npc.StateFrame = mod:RandomInt(0,30)
					d.Index = mod:GetUnoccupiedPit(d.Index)
					mod.OccupiedGrids[d.Index] = "Closed"
					npc:AddEntityFlags(EntityFlag.FLAG_NO_KNOCKBACK | EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK | EntityFlag.FLAG_NO_TARGET | EntityFlag.FLAG_HIDE_HP_BAR)
					npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
					if mod:CheckIndexForGrid(room:GetGridIndex(npc.Position), GridEntityType.GRID_PIT, GridCollisionClass.COLLISION_PIT) then
						npc.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_PITSONLY
						Isaac.Spawn(1000,132,0,npc.Position+Vector(0,10),Vector.Zero,npc)
						npc:PlaySound(mod.Sounds.SplashLarge,0.8,0,false,1.2)
						d.descending = true
						d.dontStuck = true
					else
						npc.Velocity = Vector.Zero
						npc.Visible = false
						d.state = "wait"
					end
				else
					local pile = Isaac.Spawn(1000, 146, 0, npc.Position, nilvector, npc):ToEffect()
					local dirt = pile:GetSprite()
					dirt:Load("gfx/enemies/weaver/weaver.anm2", true)
					pile:GetData().WeaverPile = true
					pile:Update()
					npc:PlaySound(SoundEffect.SOUND_MAGGOT_ENTER_GROUND,0.3,0,false,1.3 + math.random(3)/10)
					d.state = "underground"
				end
				if npc.Variant == 3 then
					d.slowdown = 10
				end
				npc.StateFrame = 0
			end
		end
		local offsetextra = 0
		if not d.staystill then
			offsetextra = (npc.StateFrame - 7.5) * -0.5
		end

		table.insert(d.prevpositions, 1, {
			state = d.state,
			pos = npc.Position,
			offset = npc.SpriteOffset.Y,
			offsete = offsetextra,
			velocity = npc.Velocity,
			color = npc.Color,
		})
		local totalbutts = butttime * d.numbutts
		local totalmore = totalbutts + tailtime * d.numtails
		if #d.prevpositions > totalmore + 1 then
			table.remove(d.prevpositions, #d.prevpositions)
		end
		d.statstill = false

		--[[
		if d.prevpositions[butttime] then
			if d.prevpositions[butttime].state == "surface" and not d.spawndbutt then
				local butt = mod.spawnent(npc,d.prevpositions[butttime].pos, d.prevpositions[butttime].velocity, mod.FF.Weaver.ID, 0, 1)
				butt.Parent = npc
				npc.Child = butt
				butt:Update()
				d.spawndbutt = true
			end
		end
		if d.prevpositions[tailtime] then
			if d.prevpositions[tailtime].state == "surface" and not d.spawndtail then
				local butt = mod.spawnent(npc,d.prevpositions[tailtime].pos, d.prevpositions[tailtime].velocity, mod.FF.Weaver.ID, 0, 2)
				butt.Parent = npc
				if npc.Child then
					butt.Child = npc.Child
					npc.Child.Child = butt
				end
				npc.Parent = butt
				butt:Update()
				d.spawndtail = true
			end
		end]]

		for i = 1, d.numbutts do
			local timehere = butttime * i
			if d.prevpositions[timehere] then
				if d.prevpositions[timehere].state == "surface" and (d.prevpositions[timehere + 1].state == "underground" or d.prevpositions[timehere + 1].state == "shoot") then
					local butt = mod.spawnent(npc,d.prevpositions[timehere].pos, d.prevpositions[timehere].velocity, mod.FF.Weaver.ID, variant, 1)
					butt.Parent = npc
					butt:GetData().timeset = timehere
					butt:GetData().queuepos = i
					--butt:AddEntityFlags(EntityFlag.FLAG_NO_STATUS_EFFECTS)
					butt.HitPoints = npc.HitPoints
					mod:copyFFStatusEffects(npc, butt)
					butt.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_WALLS
					butt.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS
					butt:Update()
				end
			end
		end
		for i = 1, d.numtails do
			local timehere = tailtime * i + totalbutts
			if d.prevpositions[timehere] then
				if d.prevpositions[timehere].state == "surface" and (d.prevpositions[timehere + 1].state == "underground" or d.prevpositions[timehere + 1].state == "shoot") then
					local tail = mod.spawnent(npc,d.prevpositions[timehere].pos, d.prevpositions[timehere].velocity, mod.FF.Weaver.ID, variant, 2)
					tail.Parent = npc
					tail:GetData().timeset = timehere
					--tail:AddEntityFlags(EntityFlag.FLAG_NO_STATUS_EFFECTS)
					tail.HitPoints = npc.HitPoints
					mod:copyFFStatusEffects(npc, tail)
					tail.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_WALLS
					tail.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS
					tail:Update()
				end
			end
		end

	--Butts
	elseif subt == 1 or subt == 2 then
		local timetime = d.timeset
		if subt == 2 then
			if npc.Parent then
				if npc.Parent:GetData().killButt then
					npc.Parent:GetData().killButt = nil
					npc.Visible = false
					npc:Remove()
				else
					if variant == mod.FF.Archer.Var then
						mod:FlipSprite(sprite, npc.Parent.Position, npc.Position)
					end
				end
			end
			mod:spritePlay(sprite, "BodyTail")
			if variant == 2 and npc:IsDead() and not (npc.Parent and mod:isStatusCorpse(npc.Parent)) then
				for i = 90, 360, 90 do
					npc:FireProjectiles(npc.Position, Vector(0,13):Rotated(i), 0, ProjectileParams())
				end
			end
		else
			if (variant == 2 or variant == 3 or variant == 4) and d.queuepos == 2 then
				mod:spritePlay(sprite, "BodyMiddle2")
				if npc:IsDead() and not (npc.Parent and mod:isStatusCorpse(npc.Parent)) then
					for i = 90, 360, 90 do
						npc:FireProjectiles(npc.Position, Vector(0,13):Rotated(i + 45), 0, ProjectileParams())
					end
				end
			else
				mod:spritePlay(sprite, "BodyMiddle")
			end
		end
		npc.StateFrame = npc.StateFrame + 1
		if npc.Parent and not mod:isStatusCorpse(npc.Parent) then
			--npc.Color = npc.Parent:GetColor()
			if npc.Parent:IsDead() and not mod:isStatusCorpse(npc.Parent) then
				if variant == 2 then
					if subt == 2 then
						for i = 90, 360, 90 do
							npc:FireProjectiles(npc.Position, Vector(0,10):Rotated(i), 0, ProjectileParams())
						end
					elseif d.queuepos == 2 then
						for i = 90, 360, 90 do
							npc:FireProjectiles(npc.Position, Vector(0,10):Rotated(i + 45), 0, ProjectileParams())
						end
					end
				end
				npc:Kill()
			end
			local pd = npc.Parent:GetData()
			if pd.prevpositions then
				if pd.prevpositions[timetime] then
					local check = ((pd.prevpositions[timetime].state == "underground" or pd.prevpositions[timetime].state == "wait") or (pd.prevpositions[timetime].color.A <= 0))
					if check then
						--Isaac.ConsoleOutput("Removed")
						if ((variant == 3 and d.queuepos == 2) or (variant == mod.FF.Archer.Var and d.queuepos == 1)) and subt == 1 and not npc.Parent:GetData().dontStuck then
							npc.SubType = 3
							if variant == mod.FF.Archer.Var then
								mod:FlipSprite(sprite, npc.Position, npc.Position + npc.Velocity)
								mod:spritePlay(sprite, "TailStuck")
								npc.SpriteOffset = Vector(0,0)
								local params = ProjectileParams()
								params.Variant = npc.Parent:GetData().TearVar
								npc:FireProjectiles(npc.Position, Vector(8,0), 6, params)
								Isaac.Spawn(mod.FF.LargeWaterRipple.ID,mod.FF.LargeWaterRipple.Var,mod.FF.LargeWaterRipple.Sub,npc.Position,Vector.Zero,npc)
							else
								if math.random(2) == 1 then
									sprite.FlipX = true
								else
									sprite.FlipX = false
								end
							end
							npc:AddEntityFlags(EntityFlag.FLAG_NO_KNOCKBACK | EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK)
							npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_ALL
							sfx:Play(mod.Sounds.GravediggerDig, 0.5, 0, false, math.random(14,16)/10)
							npc.Parent:GetData().killButt = true
							npc.Parent:Update()
						else
							npc.Visible = false
							npc:Remove()
						end
					else
						local offset
						if variant == mod.FF.Archer.Var then
							if subt == 2 then
								timetime = timetime - 2
								offset = (pd.prevpositions[timetime].offset + pd.prevpositions[timetime].offsete * subt) - 10
								npc.SpriteOffset = Vector(0, offset)
								if npc.Parent and npc.Parent:GetData().state ~= "underground" then
									local rot = 90 + (Vector(npc.Parent.Position.X, npc.Parent.Position.Y + npc.Parent.SpriteOffset.Y) - Vector(npc.Position.X, npc.Position.Y + npc.SpriteOffset.Y)):GetAngleDegrees()
									if sprite.FlipX then
										rot = -rot
									end
									sprite.Rotation = rot
								end
								d.prev = offset
							else
								offset = pd.prevpositions[timetime].offset + pd.prevpositions[timetime].offsete * subt
								npc.SpriteOffset = Vector(0, offset) --* 1.3
							end
						else
							offset = pd.prevpositions[timetime].offset + pd.prevpositions[timetime].offsete * subt
							npc.SpriteOffset = Vector(0, offset) --* 1.3
						end
						if offset <= -25 or offset > 0 then
							npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
						else
							npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS
						end
						npc.Position = pd.prevpositions[timetime].pos
						npc.Velocity = pd.prevpositions[timetime].velocity
						npc.Color = pd.prevpositions[timetime].color
						--mod:PrintColor(npc.Color)
					end
				end
			end
		else
			npc:Kill()
		end
	elseif subt == 3 then
		npc.Velocity = nilvector
		if variant == mod.FF.Thread.Var then
			if sprite:IsFinished("TailStuck") then
				--npc:PlaySound(SoundEffect.SOUND_PLOP,1,2,false,1.2)
				npc:Remove()
			elseif (sprite:IsEventTriggered("SprayR") and not sprite.FlipX) or (sprite:IsEventTriggered("SprayL") and sprite.FlipX) then
				npc:PlaySound(SoundEffect.SOUND_HEARTOUT, 0.4, 0, false, 1.3)
				for i = -30, 30, 30 do
					local params = ProjectileParams()
					params.FallingSpeedModifier = -15 - math.random(10)/10
					params.FallingAccelModifier = 1.4 + math.random(2)/10
					npc:FireProjectiles(npc.Position, Vector(5, 0):Rotated(i) * math.random(7,10)/10, 0, params)
				end
			elseif(sprite:IsEventTriggered("SprayL") and not sprite.FlipX) or (sprite:IsEventTriggered("SprayR") and sprite.FlipX) then
				npc:PlaySound(SoundEffect.SOUND_HEARTOUT, 0.4, 0, false, 1.3)
				for i = -30, 30, 30 do
					local params = ProjectileParams()
					params.FallingSpeedModifier = -15 - math.random(10)/10
					params.FallingAccelModifier = 1.4 + math.random(2)/10
					npc:FireProjectiles(npc.Position, Vector(-5, 0):Rotated(i), 0, params)
				end
			elseif sprite:IsEventTriggered("Explosion") then
				npc:PlaySound(SoundEffect.SOUND_PLOP,1,2,false,0.7)
			else
				mod:spritePlay(sprite, "TailStuck")
			end
			if npc.Parent and (npc.Parent:IsDead() or mod:isStatusCorpse(npc.Parent)) then
				npc:Kill()
			end
		elseif variant == mod.FF.Archer.Var then
			if sprite:IsFinished("TailStuck") then
				sprite:Play("TailStuckLoop")
				npc.StateFrame = 0
			elseif sprite:IsPlaying("TailStuckLoop") and npc.StateFrame > 30 then
				sprite:Play("TailStuckEnd")
			elseif sprite:IsFinished("TailStuckEnd") then
				npc:Remove()
				npc.Parent:GetData().stasis = false
				npc.Parent.Position = room:GetGridPosition(npc.Parent:GetData().Index)
			end
			npc.StateFrame = npc.StateFrame + 1
			if npc.Parent and (npc.Parent:IsDead() or mod:isStatusCorpse(npc.Parent)) then
				npc:Kill()
			end
		end
	end
end

function mod:weaverDirtPileAI(effect)
	effect.Variant = 7000
	local sprite = effect:GetSprite()
	mod:spritePlay(sprite, "Another")
	if sprite:IsFinished("Another") then
		effect:Remove()
	end
end
function mod:weaverDirtPileOpeningAI(effect)
	--effect.Variant = 7000
	local sprite = effect:GetSprite()
	mod:spritePlay(sprite, "Ground")
	if sprite:IsFinished("Ground") then
		effect:Remove()
	end
end
function mod:kingpinDirtPileAI(effect)
	local sprite = effect:GetSprite()
	if not effect:GetData().Init then
		sprite:Play("Enter", true)
		effect:GetData().Init = true
	end
	--effect.Variant = 7000
	effect.Timeout = 100
	if sprite:IsFinished("Leave") then
		effect:Remove()
	elseif not sprite:IsPlaying("Leave") then
		if effect:GetData().Timeout and effect.FrameCount > effect:GetData().Timeout then
			sprite:Play("Leave", true)
		elseif not sprite:IsFinished("Enter") and not sprite:IsPlaying("Enter") then
			sprite:Play("Enter", true)
		end
	end
	if not effect:GetData().didIt then
		effect.SpriteScale = Vector(math.random(85,115)/100,math.random(85,115)/100)
		effect.SpriteRotation = -10 + math.random(20)
		if math.random(2) == 1 then
			effect:GetSprite().FlipX = true
		end
		effect:GetData().didIt = true
	end
end

function mod:checkWeaverRender(npc, offset)
	if npc.Variant == mod.FF.Archer.Var and npc.SubType == 2 then --This logic is completely backwards but it justs works lol!
		local room = game:GetRoom()
		if room:HasWater() then
			if room:GetRenderMode() == RenderMode.RENDER_WATER_REFLECT then --Sprite rotation on the Archer tail breaks reflections completely, so just don't bother reflecting
				npc.Visible = true
			else
				npc.Visible = false
			end
		else
			npc.Visible = true
		end
	end
end
mod:AddCallback(ModCallbacks.MC_POST_NPC_RENDER, mod.checkWeaverRender, mod.FF.Weaver.ID)

function mod:checkWeaverCollision(npc1, npc2, mysteryBoolean)
  local d = npc1:ToNPC():GetData()
	if npc1.Parent and npc1.Parent.InitSeed == npc2.InitSeed then -- Prevent selfdamage from charm/bait
		return true
	elseif npc2.Parent and npc2.Parent.InitSeed == npc1.InitSeed then
		return true
	elseif npc1.Parent and npc2.Parent and npc1.Parent.InitSeed == npc2.Parent.InitSeed then
		return true
	end
end
mod:AddCallback(ModCallbacks.MC_PRE_NPC_COLLISION, mod.checkWeaverCollision, mod.FF.Weaver.ID)

function mod:checkWeaverHurt(npc, damage, flag, source, countdown)
	--if npc.Variant == 3 then
	--	if npc.SubType == 2 or npc.SubType == 3 then
	--		if npc.Parent then
	--			npc.Parent:TakeDamage(damage, flag | DamageFlag.DAMAGE_CLONES, EntityRef(npc), 0)
	--		end
	--	elseif flag ~= flag | DamageFlag.DAMAGE_CLONES then
	--		return false
	--	end
	--end
	--if flag & DamageFlag.DAMAGE_CLONES == 0 then
	--	if npc.Parent then
	--		npc.Parent:TakeDamage(damage, flag & DamageFlag.DAMAGE_CLONES, EntityRef(npc), 0)
	--	end
	--	if npc.Child then
	--		npc.Child:TakeDamage(damage, flag & DamageFlag.DAMAGE_CLONES, EntityRef(npc), 0)
	--	end
	--end

	local data = npc:GetData()

	if npc.SubType ~= 0 and npc.Parent and npc.Parent:GetData().eternalFlickerspirited then
		return false
	end

	if flag == flag | DamageFlag.DAMAGE_POISON_BURN then -- Keep Poison/Burn Synced to once per 40 frames
		data.FFLastPoisonProc = data.FFLastPoisonProc or 0
		if Isaac.GetFrameCount() - data.FFLastPoisonProc < 40 then
			return false
		end
		data.FFLastPoisonProc = Isaac.GetFrameCount()
	end

	if npc.Variant == 3 and npc.SubType ~= 2 and npc.SubType ~= 3 and flag ~= flag | DamageFlag.DAMAGE_CLONES and flag ~= flag | DamageFlag.DAMAGE_POISON_BURN then
		return false
	elseif npc.SubType == 0 then
		local butts = Isaac.FindByType(npc.Type, npc.Variant)
		for _, butt in ipairs(butts) do
			if butt.Parent and butt.Parent.InitSeed == npc.InitSeed then
				butt:TakeDamage(damage, flag | DamageFlag.DAMAGE_CLONES, source, 0)
			end
		end
	elseif flag ~= flag | DamageFlag.DAMAGE_CLONES then
		if npc.SubType ~= 0 then
			if npc.Parent then
				data.IgnorePassedDamage = true
				npc.Parent:TakeDamage(damage, flag | DamageFlag.DAMAGE_CLONES, source, 0)
				data.IgnorePassedDamage = false
			end
		end
	elseif data.IgnorePassedDamage then
		return false
	end
end
mod:AddCallback(ModCallbacks.MC_ENTITY_TAKE_DMG, mod.checkWeaverHurt, mod.FF.Weaver.ID)

--CauldronAI
function mod:cursedGrimaceAI(npc)
local d = npc:GetData()
local r = npc:GetDropRNG()
local sprite = npc:GetSprite();
local target = npc:GetPlayerTarget()
local cursedGrimaceTargets = {}

npc:AddEntityFlags(EntityFlag.FLAG_NO_TARGET | EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK)
npc.Velocity = Vector(0,0)

	if npc.State ~= 16 then
	npc.State = 0
	d.started = true

		if not d.init then
			d.npcstate = "idle"
			d.init = true
			mod.cursedGrimaceClones = 0
			d.CurrentTarget = nil
			npc.StateFrame = 50
		else
			npc.StateFrame = npc.StateFrame - 1
		end

		--Isaac.ConsoleOutput(d.clones .. "\n")

		if d.npcstate == "idle" then
			mod:spritePlay(sprite, "Idle")
			--[[if d.clones > 9 then
			npc.State = 16
			end]]
			if not d.CurrentTarget or mod:isStatusCorpse(d.CurrentTarget) then
				local enmies = mod.AreThereEntitiesButNotThisOne(0, false)
				if enmies ~= false then
					if enmies < 10 then
						if npc.StateFrame < 0 then
							d.npcstate = "findtarget"
						end
					end
				end
			else
				--npc.StateFrame = 0
			end

		--Change to an "IsEventTriggered" when animations are added
		elseif d.npcstate == "findtarget" then
			for i, v in ipairs(Isaac.GetRoomEntities()) do
				if v:IsVulnerableEnemy() and (npc.FrameCount < 45 or v.FrameCount > 45) and not v:IsBoss() and not (v.Type == npc.Type) and not mod:isStatusCorpse(v) and not mod:isFriend(v) then
					local cloneable = true
					for _, k in ipairs(mod.Cloneless) do
						if k[3] then
							if v.Type == k[1] and v.Variant == k[2] and v.SubType == k[3] then
								cloneable = false
							end
						elseif k[2] then
							if v.Type == k[1] and v.Variant == k[2] then
								cloneable = false
							end
						else
							if v.Type == k[1] then
								cloneable = false
							end
						end
					end
					if not v:GetData().CursedGrimaceTarget == true and cloneable then
						table.insert(cursedGrimaceTargets, v)
					end
				end
			end

			if #cursedGrimaceTargets == 0 then
				d.npcState = "idle"
			else
				newtarget = cursedGrimaceTargets[r:RandomInt(#cursedGrimaceTargets)+1]
				d.CurrentTarget = newtarget
				newtarget:GetData().CursedGrimaceTarget = true
				local curseIcon = Isaac.Spawn(1000, 7001, mod.cursedGrimaceClones, newtarget.Position, nilvector, npc):ToEffect()
				curseIcon.SpawnerEntity = npc
				curseIcon:FollowParent(newtarget)
				curseIcon.SpriteOffset = Vector(0, -newtarget.Size*3)
				d.npcstate = "foundtarget"
				mod:spritePlay(sprite, "TargetStart")
			end
			npc.StateFrame = 30

		elseif d.npcstate == "foundtarget" then
			if sprite:IsFinished("TargetStart") then
				d.npcstate = "target"
			end

		elseif d.npcstate == "target" then
			mod:spritePlay(sprite, "Target")

		elseif d.npcstate == "BOOM" then
			if sprite:IsFinished("Duplicate") then
				mod.cursedGrimaceClones = mod.cursedGrimaceClones + 1
				if mod:isFriend(npc) then
					d.friendclones = d.friendclones or 0
					d.friendclones = d.friendclones + 1
					if d.friendclones > 5 then
						npc:Kill()
					end
				end
				d.npcstate = "idle"
				d.CloneHP = d.CloneHP or 15
				npc.StateFrame = math.floor((15 + (d.CloneHP * 1.5)) * (mod.cursedGrimaceClones * 0.5))
			elseif sprite:IsEventTriggered("Fire") then

				if d.CurrentTarget then
					if not d.CurrentTarget:IsDead() and not mod:isStatusCorpse(d.CurrentTarget) then
						npc:PlaySound(SoundEffect.SOUND_SUMMONSOUND,0.6,1,false,1)
						Isaac.Spawn(1000, 7010, 1, d.CurrentTarget.Position, nilvector, e):ToEffect()
						local vecran = RandomVector()*3
						local spawnEternal
						if d.CurrentTarget:GetData().eternalFlickerspirited then
							spawnEternal = true
						end
						for i = 1, 2 do
							local enmy = mod.spawnent(npc, d.CurrentTarget.Position + vecran:Rotated(i*180), nilvector, d.CurrentTarget.Type, d.CurrentTarget.Variant, d.CurrentTarget.SubType, d.CurrentTarget.HitPoints)
								enmy:GetData().memories = d.CurrentTarget:GetData().memories
								enmy:GetData().personalityTraits = d.CurrentTarget:GetData().personalityTraits
							if spawnEternal then
								local ef = mod.spawnent(npc, d.CurrentTarget.Position + vecran:Rotated(i*180), nilvector, mod.FF.EternalFlickerspirit.ID, mod.FF.EternalFlickerspirit.Var, 0)
							end
							local poof = Isaac.Spawn(1000, 15, 0, enmy.Position + vecran:Rotated(i*180), nilvector, enmy):ToEffect()
							poof.Color = Color(2,1,2,1,0,0,0)
							poof:Update()
						end
						d.CloneHP = d.CurrentTarget.MaxHitPoints
						d.CurrentTarget:Remove()
					end
				end

				d.CurrentTarget = nil
			else
				mod:spritePlay(sprite, "Duplicate")
			end
		end
	elseif npc.State == 16 then
		if d.started then
			sprite:Play("CloseEyes", true)
			d.started = nil
		end
		if sprite:IsFinished("CloseEyes") then
			sprite:Play("ClosedEyes", true)
		end
	end
end

function mod:cursedGrimaceChoose(e)
	e.RenderZOffset = 100
	if e.SpawnerEntity == nil then
		if e.Parent ~= nil then
			e.Parent:GetData().CursedGrimaceTarget = false
		end
		e:Remove()
	elseif e.Parent == nil or mod:isStatusCorpse(e.Parent) then
		e.SpawnerEntity:GetData().CurrentTarget = nil
		if e.SpawnerEntity:GetData().npcstate ~= "BOOM" or e.SpawnerEntity:GetSprite():GetFrame() < 11 then
			e.SpawnerEntity:GetData().npcstate = "idle"
			e.SpawnerEntity:ToNPC().StateFrame = 0
		end
		e:Remove()
	elseif e.SpawnerEntity and e.Parent then
		if e.FrameCount > 30 + e.SubType * 5 then
			e.SpawnerEntity:GetData().npcstate = "BOOM"
		end
	end
end
mod:AddCallback(ModCallbacks.MC_POST_EFFECT_UPDATE, mod.cursedGrimaceChoose, 7001)

function mod:cursedGrimaceProj(e)
	e.RenderZOffset = 100
	e.Velocity = nilvector
end
mod:AddCallback(ModCallbacks.MC_POST_EFFECT_UPDATE, mod.cursedGrimaceProj, 7007)

function mod:craterFaceAI(npc)
local d = npc:GetData()
local sprite = npc:GetSprite();
local target = npc:GetPlayerTarget()

	if not d.init then
		d.init = true
		d.npcstate = 1
		d.framecount = 0
		d.delay = -55 + math.random(15)
		sprite:Play("Walk",true)
		d.targetvelocity = ((target.Position - npc.Position):Normalized()*2):Rotated(-50+math.random(100))
	elseif d.init then
		d.orbit = math.sin((d.framecount) / 5)
		npc.StateFrame = npc.StateFrame + 1
		d.framecount = d.framecount + 1
		local targvec = mod:runIfFear(npc, d.targetvelocity, d.targetvelocity:Length())
		npc.Velocity = (targvec * 0.3) + (npc.Velocity * 0.7)
		d.targetvelocity = d.targetvelocity * 0.99
	end

	if npc.State == 17 then
		npc.Velocity = nilvector
		if sprite:IsFinished("Death") then
			npc:Kill()
		elseif not sprite:IsPlaying("Death") then
			sprite:Play("Death", true)
		end
	else
		npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_ALL
		if d.npcstate == 1 then
			if sprite:IsFinished("AttackStart") then
				npc.StateFrame = 0
				d.framecount = 0
				d.npcstate = 2
			elseif not (sprite:IsPlaying("AttackStart") or sprite:IsPlaying("Walk")) then
				sprite:Play("Walk",true)
			end
			if sprite:IsPlaying("AttackStart") and sprite:GetFrame() == 1 then
				npc:PlaySound(SoundEffect.SOUND_MOUTH_FULL,0.7,0,false,math.random(120,140)/100)
			elseif sprite:IsPlaying("AttackStart") and sprite:GetFrame() == 13 then
				--npc:PlaySound(SoundEffect.SOUND_MONSTER_YELL_B,0.7,0,false,1)
			end
			if npc.Velocity.X <	0 then
				sprite.FlipX = true
			else
				sprite.FlipX = false
			end
			if npc.StateFrame > 54 + d.delay and not mod:isScareOrConfuse(npc) then
				--npc:PlaySound(SoundEffect.SOUND_RAGMAN_3,0.7,2,false,1.3)
				mod:spritePlay(sprite ,"AttackStart")
			end
		elseif d.npcstate == 2 then
			if not sprite:IsPlaying("AttackLoop") then
				sprite:Play("AttackLoop",true)
			end
			if npc.StateFrame % 3 == 0 then
			local offset
			local dir
			local vecshoot
				if sprite.FlipX then
					offset = 59
					dir = -1
					vecshoot = Vector(-2,-15)
				else
					offset = 32
					dir = 1
					vecshoot = Vector(2,-15)
				end
				local projectile = Isaac.Spawn(9, 0, 0, npc.Position+vecshoot, Vector(0,5), npc):ToProjectile();
				local projdata = projectile:GetData();
				projectile.FallingSpeed = 0
				projectile.FallingAccel = -0.1
				projectile.ProjectileFlags = projectile.ProjectileFlags | ProjectileFlags.GHOST
				projdata.projType = "craterorbital"
				npc:PlaySound(SoundEffect.SOUND_BLOODSHOOT,1,2,false,1)
				projdata.frameOffset = offset
				projdata.direction = dir
				projectile.Parent = npc
			end

			if npc.StateFrame == 54 or mod:isScareOrConfuse(npc) then
				sprite:Play("AttackRelease",true)
				npc.StateFrame = 0
				d.npcstate = 3
			end
		elseif d.npcstate == 3 then
			if sprite:IsEventTriggered("Shoot") then
				npc:PlaySound(SoundEffect.SOUND_MONSTER_YELL_A,0.7,0,false,1)
				--npc:PlaySound(SoundEffect.SOUND_RAGMAN_2,0.7,2,false,1.2)
				npc.StateFrame = 0
				d.npcstate = 4
			end
		elseif d.npcstate == 4 then
			if sprite:IsFinished("AttackRelease") then
				sprite:Play("Walk",true)
				d.targetvelocity = ((target.Position - npc.Position):Normalized()*2):Rotated(-50+math.random(100))
				npc.StateFrame = 0
				d.delay = math.random(15)
				d.npcstate = 1
			end
		end
	end
end

function mod:craterFaceHurt(npc, damage)
local variant = npc.Variant
	if variant == 666 then --Blazer
		return false
	--elseif variant == 69 then --Muk, Drooler
	--	if npc.HitPoints - damage <= 10 then
	--		if not (npc:HasEntityFlags(EntityFlag.FLAG_FREEZE) or npc:HasEntityFlags(EntityFlag.FLAG_MIDAS_FREEZE)) then
	--			npc.Velocity = nilvector
	--			npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
	--			npc.HitPoints = 0
	--			npc:ToNPC().State = 11
	--			return false
	--		end
	--	end
	elseif variant == 69 then --Muk, Drooler
		if npc:ToNPC().State == 11 then
			return false
		end
	--else --Craterface
	--	if npc.HitPoints - damage <= 0 then
	--		if not (npc:HasEntityFlags(EntityFlag.FLAG_FREEZE) or npc:HasEntityFlags(EntityFlag.FLAG_MIDAS_FREEZE)) then
	--			npc.Velocity = nilvector
	--			npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
	--			npc.HitPoints = 0
	--			npc:ToNPC().State = 11
	--			return false
	--		end
	--	end
	else --Craterface
		if npc:ToNPC().State == 17 then
			return false
		end
	end
end
mod:AddCallback(ModCallbacks.MC_ENTITY_TAKE_DMG, mod.craterFaceHurt, mod.FF.Drooler.ID)

local function getcirclepoint(radius, degree)
	return Vector(radius * math.sin(degree), radius * math.cos(degree))
end

function mod.orbitalprojupdate(v,d)
	if d.projType == "craterorbital" then
	v.Color = mod.ColorNormal
	v.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_NONE

		if v.Parent then
			local pd = v.Parent:GetData()
			if v.Parent:IsDead() or mod:isStatusCorpse(v.Parent) then
				d.targetvelocity = v.Velocity*2
				d.projType = "craterorbital2"
			elseif pd.npcstate < 4 then
				local target = v.Parent.Position
				local frame = v.FrameCount + d.frameOffset

				local xvel = math.cos(((frame * d.direction) / 8.5) + math.pi) * (50 + pd.orbit * 15)
				local yvel = math.sin(((frame * d.direction) / 8.5) + math.pi) * (50 + pd.orbit * 15)

				local direction = Vector(target.X - xvel, target.Y - yvel) - v.Position

				if direction:Length() > 50 then
					direction:Resize(50)
				end

				v.Velocity = direction
			elseif pd.npcstate == 4 then
				d.targetvelocity = v.Velocity*1.5
				d.projType = "craterorbital2"
			end
		else
			d.targetvelocity = v.Velocity*1.5
			d.projType = "craterorbital2"
		end
	elseif d.projType == "craterorbital2" then
		v.Color = mod.ColorNormal
		v.Velocity = (d.targetvelocity * 0.3) + (v.Velocity * 0.7)
		--v.FallingAccel = 0
		if not d.FrameCount then
			d.FrameCount = 0
		else
			d.FrameCount = d.FrameCount + 1
			if d.FrameCount > 300 then
				v:Remove()
			end
		end
		local grid = game:GetRoom():GetGridEntityFromPos(v.Position + v.Velocity)
		if grid then
			if grid:GetType() == GridEntityType.GRID_PILLAR then
				v:Die()
			end
		end
	elseif d.projType == "mutantorbital" then
		d.radiusMod = d.radiusMod or 0
		v.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_NONE

		if v.Parent and not (v.Parent:IsDead() or mod:isStatusCorpse(v.Parent)) then
			v.Height = -35
			v.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_NONE

			local pd = v.Parent:GetData()

			if pd.radius then

				local vel = getcirclepoint(pd.radius + math.sin(d.radiusMod) * 9, d.offset)
				local target = v.Parent.Position
				--local frame = v.FrameCount --+ d.frameOffset

				--local xvel = math.cos(((frame + d.offset) / 8.5) + math.pi) * pd.radius
				--local yvel = math.sin(((frame + d.offset) / 8.5) + math.pi) * pd.radius
				--print(tostring(xvel)..", "..tostring(yvel))

				local direction = Vector(target.X - vel.X, target.Y - vel.Y) - v.Position

				if direction:Length() > 50 then
					direction:Resize(50)
				end

				v.Velocity = direction

				if d.offset >= 360 then d.offset = 0 else d.offset = d.offset + 0.1 end
				d.radiusMod = d.radiusMod + math.pi/math.random(3,12)

				if v.Parent:GetSprite():IsPlaying("Attack") or v.Parent:GetSprite():IsPlaying("Attack2") or v.Parent:GetSprite():IsPlaying("DoubleAttack") then
					v.Velocity = v.Velocity / 2
				end
			end
		else
			v.Velocity = v.Velocity * 0.9
			v.FallingAccel = 0.1
		end
	elseif d.projType == "foeorbital" then
		v.Color = mod.ColorNormal
		v.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_NONE
		if not v.Parent or v.Parent:IsDead() or mod:isStatusCorpse(v.Parent) then
			v.Velocity = v.Velocity * 0.9
			v.FallingAccel = 0.1
		end
	end
end

mod.mukbloodoffset = Vector(13,0)

--DroolerAI
function mod:mukAI(npc)
local d = npc:GetData()
local sprite = npc:GetSprite();
local target = npc:GetPlayerTarget()

	if not d.init then
		d.init = true
		d.npcstate = "idlemove"
	else
		npc.StateFrame = npc.StateFrame + 1
	end

	if npc.State == 11 then
		if sprite:IsFinished("Death") then
			npc:Kill()
		elseif sprite:IsEventTriggered("bloodstart") then
			d.bleeding = true
		elseif not sprite:IsPlaying("Death") then
			sprite:Play("Death", true)
		end
		if d.bleeding then
			if npc.FrameCount % 2 == 0 then
			local blood = Isaac.Spawn(1000, 5, 0, npc.Position, RandomVector()*3, npc):ToEffect();
			blood:Update()

			local bloo2 = Isaac.Spawn(1000, 2, 0, npc.Position, RandomVector()*3, npc):ToEffect();
			bloo2.SpriteScale = Vector(1,1)
			bloo2.SpriteOffset = Vector(-3+math.random(14), -45+math.random(40))
			bloo2:Update()

			npc:PlaySound(SoundEffect.SOUND_MEAT_JUMPS,0.2,0,false,0.8)
			end
		end
	else
		npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_ALL
		d.bleeding = false

		if npc.Velocity.X > 0 then
			sprite.FlipX = true
		else
			sprite.FlipX = false
		end

		if d.npcstate == "idlemove" then
			if not sprite:IsPlaying("Walk") then
				sprite:Play("Walk", true)
			end
			if npc.FrameCount % 3 == 1 then
				local bloodoff = mod.mukbloodoffset
				if sprite.FlipX then
					bloodoff = mod.mukbloodoffset * -1
				end

				local blood = Isaac.Spawn(1000, 7, 0, npc.Position-bloodoff, nilvector, npc)
				blood.SpriteScale = Vector(0.4,0.4)
				blood:Update()
			end
			local targetpos = mod:confusePos(npc, target.Position, 30)
			local vel = mod:reverseIfFear(npc, ((targetpos + target.Velocity*50) - npc.Position):Resized(3))
			npc.Velocity = mod:Lerp(npc.Velocity,vel,0.1)
			if npc.Position:Distance(target.Position) < 200 and npc.StateFrame > 60 and not mod:isScareOrConfuse(npc) then
				d.chargecount = 0
				d.chargestate = 1
				d.playerhit = false
				npc.StateFrame = 0
				sprite:Play("ChargeStart", true)
				d.npcstate = "charge!!!!!"
				npc:PlaySound(mod.Sounds.MukChargeUp,0.6,1,false,0.7)
			end
		elseif d.npcstate == "charge!!!!!" then
			local blood = Isaac.Spawn(1000, 7, 0, npc.Position, nilvector, npc)
			blood.SpriteScale = Vector(0.4,0.4)
			blood:Update()
			if d.chargestate == 1 then
				if sprite:IsFinished("ChargeStart") then
				d.chargestate = 2
				end
			elseif d.chargestate == 2 then
				npc.Velocity = (target.Position - npc.Position):Resized(17)
				if target.Position.Y < npc.Position.Y then
					d.fireangle = "Up"
				else
					d.fireangle = "Down"
				end
				sprite:Play("Charge" .. d.fireangle .. "Loop", true)
				local sfxpitch = math.random(100,120) / 100
				npc:PlaySound(mod.Sounds.MukCharge,1,1,false,sfxpitch)
				d.chargecount = d.chargecount+1
				npc.StateFrame = 0
				d.chargestate = 3
			elseif d.chargestate == 3 then
				npc.Velocity = npc.Velocity * 0.95
				if npc.StateFrame > 20 then
					npc.Velocity = npc.Velocity * 0.8
					if sprite:IsFinished("Charge" .. d.fireangle .. "Miss") then
						if d.playerhit == true then
							d.npcstate = "laugh"
						elseif d.chargecount > 2 or mod:isScareOrConfuse(npc) then
							d.npcstate = "barf"
						else
							npc.StateFrame = 0
							d.chargestate = 2
						end
					else
						mod:spritePlay(sprite,"Charge" .. d.fireangle .. "Miss")
					end
				end
			end
		elseif d.npcstate == "barf" then
			npc.Velocity = npc.Velocity * 0.8
			if sprite:IsFinished("Barf") then
				d.npcstate = "idlemove"
			elseif sprite:IsEventTriggered("horksfx") then
				npc:PlaySound(SoundEffect.SOUND_DEATH_BURST_SMALL,1,0,false,0.7)
			elseif sprite:IsEventTriggered("vomsfx") then
				npc:PlaySound(mod.Sounds.MukVomit,1,1,false,1)
			elseif sprite:IsEventTriggered("creep") then
				d.Vomming = true
				npc.StateFrame = 1
			elseif not sprite:IsPlaying("Barf") then
				sprite:Play("Barf", true)
			end

			if d.Vomming then
				local creep = Isaac.Spawn(1000, 22, 0, npc.Position, nilvector, npc):ToEffect()
				creep.SpriteScale = Vector(4.5, 3.5);
				creep.Parent = npc
				creep.Scale = npc.StateFrame / 6
				creep.SpawnerEntity = npc
				creep:GetData().Pool = true
				if npc.StateFrame > 5 then
					d.Vomming = false
				end
				creep:Update()
			end


		elseif d.npcstate == "laugh" then
			npc.Velocity = npc.Velocity * 0.8
			if sprite:IsFinished("ChargeHit") then
				d.npcstate = "idlemove"
			elseif sprite:IsEventTriggered("laughing sound") then
				npc:PlaySound(mod.Sounds.MukLaugh,1,1,false,1)
			else
				mod:spritePlay(sprite,"ChargeHit")
			end
		end
	end
end

function mod.mukDeathAnim(npc)
	local onCustomDeath = function(npc, deathAnim)
		deathAnim.State = 11
	end
	mod.genericCustomDeathAnim(npc, nil, nil, onCustomDeath)
end

--Blazer
function mod:blazerAI(npc)
local room = game:GetRoom()
local d = npc:GetData()
local sprite = npc:GetSprite();
local target = npc:GetPlayerTarget()

	if not d.init then
		d.init = true
		npc:AddEntityFlags(EntityFlag.FLAG_NO_TARGET | EntityFlag.FLAG_NO_STATUS_EFFECTS | EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK | EntityFlag.FLAG_NO_BLOOD_SPLASH)
		d.npcstate = "idlemove"
		d.targetVelocity = Vector(1, 1):Resized(5)
	else
		npc.StateFrame = npc.StateFrame + 1
	end

	if room:IsClear() and npc.State ~= 11 then
		npc.State = 11
		npc:PlaySound(SoundEffect.SOUND_DEVILROOM_DEAL,1,1,false,1)
		npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
	end

	if npc.State == 11 then
		npc.Velocity = nilvector
		if sprite:IsFinished("Death") then
			npc:Kill()
		elseif not sprite:IsPlaying("Death") then
			sprite:Play("Death", true)
		end
	else
		npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_ALL

		if d.npcstate == "idlemove" then
			if not sprite:IsPlaying("Idle") then
				sprite:Play("Idle", true)
			end

			if npc.Velocity.X < 0 then
				sprite.FlipX = true
			else
				sprite.FlipX = false
			end

			--[[if npc:CollidesWithGrid() == true then
			d.targetVelocity = mod.bounceOffWall(npc.Position, d.targetVelocity)
			end]]
			--npc.Velocity = (d.targetVelocity * 0.3) + (npc.Velocity * 0.6)
			mod:diagonalMove(npc, 2.5)

			if npc.Position:Distance(target.Position) < 200 and npc.StateFrame > 60 then
				d.prevvel = npc.Velocity
				d.chargecount = 0
				d.chargestate = 1
				d.playerhit = false
				npc.StateFrame = 0

				local targvec = target.Position - npc.Position
				if math.abs(targvec.X) > math.abs(targvec.Y) then
					d.fireangle = "Side"
				else
					d.fireangle = "Front"
				end
				sprite:Play("Charge" .. d.fireangle .. "Start", true)
				d.npcstate = "charge!!!!!"
				local sfxpitch = math.random(9,11) / 10
				npc:PlaySound(mod.Sounds.EpicTwinkle,1,1,false,sfxpitch)
			end
		elseif d.npcstate == "charge!!!!!" then

			if d.chargestate == 1 then
				if target.Position.X < npc.Position.X then
					sprite.FlipX = true
				else
					sprite.FlipX = false
				end
			else
				if npc.Velocity.X < 0 then
					sprite.FlipX = true
				else
					sprite.FlipX = false
				end
			end


			if d.chargestate == 1 then
				npc.Velocity = npc.Velocity * 0.9
				if sprite:IsFinished("Charge" .. d.fireangle .. "Start") then
				d.chargestate = 2
				end
			elseif d.chargestate == 2 then
				npc.Velocity = (target.Position - npc.Position):Resized(19.5)
				sprite:Play("Charge" .. d.fireangle, true)
				local sfxpitch = math.random(90,105) / 100
				npc:PlaySound(SoundEffect.SOUND_MONSTER_YELL_A,1,1,false,sfxpitch)
				d.chargecount = d.chargecount+1
				npc.StateFrame = 0
				d.chargestate = 3

				local fire = Isaac.Spawn(1000,7005, 2, npc.Position, nilvector, npc):ToEffect()
				fire:Update()

			elseif d.chargestate == 3 then
				npc.Velocity = npc.Velocity * 0.95
				if npc.StateFrame > 20 then
					npc.Velocity = npc.Velocity * 0.8
					if d.chargecount > 0 then
						d.npcstate = "idlemove"
						local xvalue
						local yvalue
						if npc.Velocity.X > 0 then
							xvalue = 1
						else
							xvalue = -1
						end
						if npc.Velocity.Y > 0 then
							yvalue = 1
						else
							yvalue = -1
						end
						d.targetVelocity = Vector(xvalue, yvalue):Resized(5)
					else
						npc.StateFrame = 0
						d.chargestate = 2
						local targvec = target.Position - npc.Position
						if math.abs(targvec.X) > math.abs(targvec.Y) then
							d.fireangle = "Side"
						else
							d.fireangle = "Front"
						end
					end
				elseif npc.StateFrame < 16 then
					if npc.StateFrame % 2 == 0 then
					local fire = Isaac.Spawn(1000,7005, 2, npc.Position, nilvector, npc)
					fire:Update()
					end
				end
			end
		end
	end
end

function mod:mukCollision(npc, player, mysteryBoolean)
  local d = npc:ToNPC():GetData()

  if npc.Variant == 69 and player.Type == 1 then
	if d.chargestate == 2 or d.chargestate == 3 then
		d.playerhit = true
	end
  end

end
mod:AddCallback(ModCallbacks.MC_PRE_NPC_COLLISION , mod.mukCollision, mod.FF.Drooler.ID)

function mod:spinneretchAI(npc)
local d = npc:GetData()
local r = npc:GetDropRNG()
local target = npc:GetPlayerTarget()
local sprite = npc:GetSprite()

--Isaac.ConsoleOutput(npc.State .. "/" .. npc.StateFrame .. " ")

	if npc.State == 4 then
		if npc.StateFrame == 22 then
			npc.State = 5
			d.state = "idle"
		end
	elseif npc.State == 5 then
		if d.state == "idle" then
			if npc.StateFrame == 30 and not mod:isScareOrConfuse(npc) then
				local rando = r:RandomInt(11)
				--local rando = 10
				 if rando > 7 then
					d.state = "Shoot"
					d.part = 1
					npc.StateFrame = 0
					mod:spritePlay(sprite, "ShootStart")
				 elseif rando > 2 then
					local shootinstead = nil
					if mod.GetEntityCount(mod.FF.SpiderEgg.ID, mod.FF.SpiderEgg.Var, mod.FF.SpiderEgg.Sub) < 5 then
						local egg = mod.FindClosestEntity(npc.Position, 99999, mod.FF.SpiderEgg.ID, mod.FF.SpiderEgg.Var, mod.FF.SpiderEgg.Sub)
						if egg then
							if egg.Position:Distance(npc.Position) > 30 then
								d.state = "Cough"
							else
								shootinstead = true
							end
						else
							d.state = "Cough"
						end
					else
						shootinstead = true
					end
					if shootinstead then
						d.state = "Shoot"
						d.part = 1
						npc.StateFrame = 0
						mod:spritePlay(sprite, "ShootStart")
					end
				end
			elseif npc.StateFrame > 30 then
				if sprite:IsFinished("HopPrep") then
					npc.State = 3
					sprite:Play("Hop")
				else
					mod:spritePlay(sprite, "HopPrep")
				end
			end
		elseif d.state == "Cough" then
			if sprite:IsFinished("SpawnEgg") then
				d.state = "idle"
			elseif sprite:IsEventTriggered("Spawn") then
				npc:PlaySound(SoundEffect.SOUND_WHEEZY_COUGH,1,0,false,1)
				local egg = Isaac.Spawn(mod.FF.SpiderEgg.ID, mod.FF.SpiderEgg.Var, mod.FF.SpiderEgg.Sub, npc.Position + Vector(0,10), nilvector, npc)
				egg.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS
			else
				mod:spritePlay(sprite, "SpawnEgg")
			end
		elseif d.state == "Shoot" then
			if d.shooting then
				if npc.FrameCount % 2 == 0 then
					npc:PlaySound(SoundEffect.SOUND_BLOODSHOOT,0.5,2,false,math.random(12,15)/10)
					local shotspeed = (target.Position - npc.Position):Resized(9):Rotated(-10+math.random(20))
					local params = ProjectileParams()
					params.Scale = math.random(2, 8) / 10
					--params.FallingSpeedModifier = -15 + math.random(10);
					params.FallingAccelModifier = 0.13
					params.HeightModifier = 0
					params.Variant = 4
					params.Color = mod.ColorWebWhite
					npc:FireProjectiles(npc.Position, shotspeed, 0, params)
				end
			end
			if d.part == 1 then
				if sprite:IsFinished("ShootStart") then
					mod:spritePlay(sprite, "ShootLoop")
					d.part = 2
				elseif sprite:IsEventTriggered("Shoot") then
					d.shooting = true
				end
			elseif d.part == 2 then
				mod:spritePlay(sprite, "ShootLoop")
				if (npc.StateFrame > 30 and r:RandomInt(5) == 0) or mod:isScareOrConfuse(npc) then
					d.part = 3
					d.shooting = false
					mod:spritePlay(sprite, "ShootEnd")
				end
			elseif d.part == 3 then
				if sprite:IsFinished("ShootEnd") then
					d.state = "idle"
				else
					mod:spritePlay(sprite, "ShootEnd")
				end
			end
		end
	end
end

function mod:bombmuncherAI(npc)
local d = npc:GetData()
local r = npc:GetDropRNG()
local target = npc:GetPlayerTarget()
local sprite = npc:GetSprite()

	if npc.State == 3 and npc.StateFrame == 0 then
	npc.State = 5
	d.state = "starteridle"
	sprite:Play("Idle")
	end
	if npc.State == 4 then --In the air
		if npc.StateFrame == 22 then
			npc.State = 5
			d.state = "idle"
			sprite:Play("Idle")
		end
	elseif npc.State == 5 then --postjump
		if npc.StateFrame == 1 then
			sprite:Play("Idle")
		end
		local waitingFrames = 60
		if d.state == "starteridle" then
			waitingFrames = 30
		end
		if d.state == "idle" or d.state == "starteridle" then
			if npc.StateFrame == waitingFrames and not mod:isScareOrConfuse(npc) then
				local rando = r:RandomInt(11)
			elseif npc.StateFrame > waitingFrames then
				if sprite:IsFinished("HopPrep") then
					npc.State = 3
					sprite:Play("Hop")
					local bomb = Isaac.Spawn(4, 0, 0, npc.Position, nilvector, npc):ToBomb()
					bomb.ExplosionDamage = 20
					local poof = Isaac.Spawn(1000, 15, 1, npc.Position, nilvector, nil)
					mod:PlaySound(SoundEffect.SOUND_WHEEZY_COUGH, npc, 1.5, 0.8)
				else
					mod:spritePlay(sprite, "HopPrep")
				end
			end
		end
	end
end

function mod:spitroastAI(npc)
	npc.SplatColor = mod.ColorFireJuicy
	local target = npc:GetPlayerTarget()
	local targetpos = target.Position

	if npc.Velocity:Length() > 2 and npc.Variant == mod.FF.Spitroast.Var then
		npc.Velocity = npc.Velocity:Resized(2)
	end

	if npc.FrameCount % 25 == 15 and npc.Variant == mod.FF.Spitfire.Var then
		local numberofflames = 5
		for i = 1, numberofflames do
			local vec = Vector(6,0):Rotated((360/numberofflames) * i)
			local fire = Isaac.Spawn(1000,7005, 1, npc.Position, Vector(6,0):Rotated((360/numberofflames) * i), npc)
			fire:Update()
		end
	end

	if npc:IsDead() then
		if npc.Variant == mod.FF.Spitfire.Var then
			--spitfire
			npc:PlaySound(mod.Sounds.FireFizzle, 1.2, 0, false, 1)
			local numberofflames = math.random(12, 15)
			for i = 1, numberofflames do
				local vec = Vector(6,0):Rotated((360/numberofflames) * i)
				local fire = Isaac.Spawn(1000,7005, 1, npc.Position, Vector(math.random(6, 16),0):Rotated((360/numberofflames) * i), npc)
				fire:Update()
			end
		else
			--spitroast
			npc:PlaySound(mod.Sounds.FireFizzle, 0.4, 0, false, 1.3)
			local numberofflames = 10
			for i = 1, numberofflames do
				local fire = Isaac.Spawn(1000,7005, 1, npc.Position, Vector(8,0):Rotated((360/numberofflames) * i), npc)
				fire:Update()
			end
		end
	end
end

function mod:powderkegAI(npc)
local d = npc:GetData()
local sprite = npc:GetSprite();
local path = npc.Pathfinder
local target = npc:GetPlayerTarget()
local targetpos = target.Position

	if not d.init then
		d.lastpos = npc.Position
		d.init = true
	else
		npc.State = 4
	end

	if d.lastpos:Distance(npc.Position) > 20 then
		mod.SpawnGunpowder(npc,npc.Position)
		d.lastpos = npc.Position
	end

	if npc:IsDead() then
		local fire = Isaac.Spawn(1000,7005, 0, npc.Position, nilvector, npc):ToEffect()
		for i = 60, 360, 60 do
			mod.SpawnGunpowder(npc,npc.Position + Vector(25, 0):Rotated(i), 1, 30)
		end
		Isaac.Explode(npc.Position, npc, 10)
	end
end

function mod:gunpowderCreepAI(e)
	local d = e:GetData()
	local burntime = d.burntime or 20
	local spreaddist = d.spreaddist or 50
	if d.flaming and not d.spawndfire then
		if e.SpawnerEntity and e.SpawnerEntity.Type == 1 then
			local fire = Isaac.Spawn(1000,51,960, e.Position, nilvector, e.SpawnerEntity):ToEffect()
			fire:GetData().timer = burntime
			fire:Update()
		else
			local fire = Isaac.Spawn(1000,7005, 0, e.Position, nilvector, e.SpawnerEntity):ToEffect()
			if e.SpawnerEntity then
				e.Parent = e.SpawnerEntity
			end
			fire:GetData().timer = burntime
			if d.uniqueColor then
				fire.Color = d.uniqueColor
			end
			if d.uniqueSpritesheet then
				fire:GetSprite():ReplaceSpritesheet(0, d.uniqueSpritesheet)
				fire:GetSprite():LoadGraphics()
			end
			fire:Update()
		end
		d.spawndfire = true
		d.StateFrame = 0
	elseif not d.flaming then
		local fire
		if e.Variant == 45 then
			fire = mod.FindClosestFire(e.Position, 99999, true)
		else
			fire = mod.FindClosestFire(e.Position, 99999)
		end
		if fire then
			if e.Position:Distance(fire.Position) < spreaddist then
				d.flaming = true
			end
		end
	end
	if d.spawndfire then
		d.StateFrame = d.StateFrame + 1
		if d.StateFrame > burntime + 10 then
			e:Remove()
		elseif d.StateFrame > burntime then
			e.SpriteScale = Vector(1,1) * (1 - ((d.StateFrame - burntime)/10))
		end
	end
end

function mod:pipeAI(npc, variant, subtype)
	local room = game:GetRoom()
	local sprite = npc:GetSprite()
	local d = npc:GetData()

	npc.State = 0
	npc.Velocity = nilvector

	local creeptype = 22
	local bloodcol = mod.ColorNormal

	local timer = math.floor((FiendFolio.GetBits(subtype, 1, 4) + 1) * 12.5) -- default 100
	local offset = math.floor(FiendFolio.GetBits(subtype, 5, 4) * 12.5) -- default 0
	local creepTimeout = math.floor((FiendFolio.GetBits(subtype, 9, 4) + 1) * 12.5) -- default 50

	if variant == 1710 then	--Green
		creeptype = 23
		bloodcol = Color(1,1,1,1,-150 / 255,100 / 255,0)
	elseif variant == 1711 then	--Shit
		creeptype = 94
		bloodcol = Color(0,0,0,1,145 / 255,115 / 255,30 / 255)
	elseif variant == 1712 then	--Black
		creeptype = 26
		bloodcol = mod.ColorDankBlackReal
	elseif variant == 1713 then
		creeptype = 24
		bloodcol = Color(0,0,0,1,180 / 255,180 / 255,30 / 255)
	elseif variant == 1714 then
		creeptype = 24
		bloodcol = Color(0,0,0,1,180 / 255,180 / 255,30 / 255)
	end

	local varhori = FiendFolio.GetBits(subtype, 0, 1) == 1

	if not d.init then
		npc:AddEntityFlags(EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK | EntityFlag.FLAG_NO_STATUS_EFFECTS | EntityFlag.FLAG_NO_TARGET)
		if varhori then
			local Rpos = room:GetClampedPosition(npc.Position + Vector(40, 0), 0)
			local Lpos = room:GetClampedPosition(npc.Position + Vector(-40, 0), 0)

			local Rdist =  npc.Position:Distance(Rpos)
			local Ldist =  npc.Position:Distance(Lpos)

			if Rdist > Ldist then
				npc.Position = Lpos + Vector(-10, 0)
				npc.SpriteRotation = 270
				d.vec = 1
			else
				npc.Position = Rpos + Vector(10, 0)
				npc.SpriteRotation = 90
				d.vec = -1
			end
		else
			local abovepos = room:GetClampedPosition(npc.Position + Vector(0,-40), 0)
			local belowpos = room:GetClampedPosition(npc.Position + Vector(0,40), 0)

			local abovedist =  npc.Position:Distance(abovepos)
			local belowdist =  npc.Position:Distance(belowpos)

			if abovedist > belowdist then
				npc.Position = belowpos + Vector(0, 10)
				npc.SpriteRotation = 180
				d.vec = -1
			else
				npc.Position = abovepos + Vector(0, -10)
				d.vec = 1
			end
		end

		npc.StateFrame = offset

		if (room:HasTriggerPressurePlates() and room:IsClear()) then
			d.state = "closed"
		else
			d.state = "idle"
		end

		d.init = true
	else
		npc.StateFrame = npc.StateFrame + 1
	end

	if d.state == "idle" then
		mod:spritePlay(sprite, "Idle")

		if npc.StateFrame > timer then
			d.state = "shoot"
			npc.StateFrame = 0
			if not d.shoot or d.shoot == 2 then
				d.shoot = 1
			else
				d.shoot = 2
			end
		end

		if (room:HasTriggerPressurePlates() and room:IsClear()) then
			d.state = "close"
		end

	elseif d.state == "shoot" then
		if variant == 1714 then
			if sprite:IsFinished("Shoot0" .. d.shoot) then
				d.state = "idle"
				npc.StateFrame = sprite:GetFrame()
			elseif sprite:GetFrame() == 8 then
				d.shooting = true
				d.count = 0
			else
				mod:spritePlay(sprite, "Shoot0" .. d.shoot)
			end
		else
			if sprite:IsFinished("Shoot") then
				d.state = "idle"
				npc.StateFrame = sprite:GetFrame()
			elseif sprite:GetFrame() == 8 then
				d.shooting = true
				d.count = 0
			else
				mod:spritePlay(sprite, "Shoot")
			end
		end
	elseif d.state == "close" then
		if sprite:IsFinished("Clog") then
			d.state = "closed"
		else
			mod:spritePlay(sprite, "Clog")
		end
	elseif d.state == "closed" then
		sprite:SetFrame("Clog", 16)
	end

	if d.shooting then
		d.count = d.count + 1
		if d.count % 3 == 0 then
			local shootdist = 20 + (10 * d.count)
			local vec
			if varhori then
				vec = Vector(shootdist, 0) * d.vec
			else
				vec = Vector(0, shootdist) * d.vec
			end
			if variant == 1714 then
				if d.shoot == 1 then
					vec = vec:Rotated(45)
				else
					vec = vec:Rotated(-45)
				end
			end

			if d.count == 3 then
				local creep = Isaac.Spawn(1000, creeptype, 0, npc.Position + vec:Resized(15), nilvector, npc):ToEffect()
				creep:SetTimeout(creepTimeout)
				creep:Update()
			end

			local timetostop
			if d.gratelast then
				timetostop = true
			else
				for _, grate in pairs(Isaac.FindByType(mod.FF.Graterhole.ID, mod.FF.Graterhole.Var, -1, false, false)) do
					local distgrate = grate.Position:Distance(npc.Position + vec)
					if distgrate < 20 then
						d.gratelast = true
					end
				end
			end
			if room:GetGridCollisionAtPos(npc.Position + vec) == GridCollisionClass.COLLISION_NONE and not timetostop then
				local creep = Isaac.Spawn(1000, creeptype, 0, npc.Position + vec, nilvector, npc):ToEffect()
				creep:SetTimeout(creepTimeout)
				creep:Update()
				local blood = Isaac.Spawn(1000, 2, 960, npc.Position + vec, nilvector, npc):ToEffect()
				blood.Color = bloodcol
				blood.Scale = 0.5
				blood:Update()
			else
				d.shooting = false
				d.count = 0
				d.gratelast = nil
			end
		end
		if d.count > 50 then
			d.shooting = false
			d.count = 0
		end
	end
end

function mod:checkBloodExplosion(e)
	if e.SubType == 960 then
		local sprite = e:GetSprite()
		if sprite:IsFinished("Poof") or sprite:IsFinished("Poof_Small") or sprite:IsFinished("Poof_Large1") or sprite:IsFinished("Poof_Large2") then
			e:Remove()
		end
	end

end
mod:AddCallback(ModCallbacks.MC_POST_EFFECT_UPDATE, mod.checkBloodExplosion, 2)


--FERRIUM LEFTOVERS

--[[  Just a test to see if I could make event rocks that spawn. It works, but shouldn't be used.

function mod:rockspawnerAI(npc)
	local data = npc:GetData()

	if not data.init then
		npc:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
		Isaac.Spawn(1000, 177, 1, npc.Position, Vector.Zero, npc)
		npc:Remove()
		data.init = true
	else
		npc:Remove()
	end
end]]

-- concept enemy, too similar to Technician. Guess I'll leave it in for someone to datamine.
--[[function mod:boreAI(npc)
	local sprite = npc:GetSprite()
	local data = npc:GetData()
	local target = npc:GetPlayerTarget()
	local rand = npc:GetDropRNG()
	if not data.init then
		npc:AddEntityFlags(EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK | EntityFlag.FLAG_NO_KNOCKBACK)
		data.state = "Idle"
		data.init = true
	else
		npc.StateFrame = npc.StateFrame+1
	end
	npc.Velocity = npc.Velocity*0.4

	if data.state == "Idle" then
		if npc.StateFrame > 70 and rand:RandomInt(15) == 0 then
			sprite:Play("Attack")
			data.state = "Attack"
		else
			mod:spritePlay(sprite, "Idle")
		end
	elseif data.state == "Attack" then
		if sprite:IsEventTriggered("Shoot") then
			npc:PlaySound(SoundEffect.SOUND_MAGGOT_BURST_OUT, 0.6, 0, false, 1)
			local sDir = (target.Position-npc.Position)*0.03
			local projectile = Isaac.Spawn(9, 9, 0, npc.Position, sDir, npc):ToProjectile()
			projectile.Scale = 2.5
			projectile.FallingSpeed = -45
			projectile.FallingAccel = 0.8
			projectile:GetData().bore = true
			projectile:GetData().tPos = target.Position
			projectile:Update()
		elseif sprite:IsFinished("Attack") then
			npc.StateFrame = 0
			data.state = "Idle"
		end
	end
end

function mod.boreProj(v, d)
	if d.bore == true then
		--local target = v.SpawnerEntity:ToNPC():GetPlayerTarget()
		--mod:Lerp(v.Velocity, (target.Position-v.Position):Resized(5), 0.3)
		v.Velocity = mod:Lerp(v.Velocity, (d.tPos-v.Position):Resized(6), 0.3)
		if (d.tPos-v.Position):Length() < 5 then
			local sDir = RandomVector():Resized(7)
			SFXManager():Play(SoundEffect.SOUND_ROCK_CRUMBLE, 1, 0, false, math.random(8,12)/10)
			for i=0,3 do
				local AAAA = Isaac.Spawn(1000, 88, 0, v.Position, RandomVector():Resized(2), v):ToEffect()
				AAAA.SpriteOffset = Vector(0, v.Height)
				AAAA:Update()
			end
			for i=0,10 do
				local projectile = Isaac.Spawn(9, 0, 0, v.Position, sDir:Rotated(i*36), v):ToProjectile()
				projectile.Height = v.Height
				projectile.FallingSpeed = 20
				projectile.FallingAccel = 2
				projectile:Update()
			end
			v:Remove()
		end
	end
end]]

--For charmed projectiles, otherwise they just hit the enemy that fired it immediately.
mod:AddCallback(ModCallbacks.MC_PRE_PROJECTILE_COLLISION, function(_,proj,coll,low)
	if proj.FrameCount < 3 then
		if (proj:GetData().projType or proj:GetData().special) and proj.SpawnerEntity then
			if proj.SpawnerType == coll.Type and proj.SpawnerVariant == coll.Variant then
				return false
			end
		end
	end
end)

--FERRIUM END

--SBODY START

	--hi

--SBODY END

mod.ValidPlayerEnums = {
	PlayerType.PLAYER_ISAAC,
	PlayerType.PLAYER_MAGDALENA,
	PlayerType.PLAYER_CAIN,
	PlayerType.PLAYER_JUDAS,
	PlayerType.PLAYER_XXX,
	PlayerType.PLAYER_EVE,
	PlayerType.PLAYER_SAMSON,
	PlayerType.PLAYER_AZAZEL,
	PlayerType.PLAYER_LAZARUS,
	PlayerType.PLAYER_EDEN,
	PlayerType.PLAYER_THELOST,
	PlayerType.PLAYER_LILITH,
	PlayerType.PLAYER_KEEPER,
	PlayerType.PLAYER_APOLLYON,
	PlayerType.PLAYER_THEFORGOTTEN,
	PlayerType.PLAYER_BETHANY,
	PlayerType.PLAYER_JACOB,
	FiendFolio.PLAYER.FIEND,
	FiendFolio.PLAYER.GOLEM,
}

mod.ValidPlayerBEnums = {
	PlayerType.PLAYER_ISAAC_B,
	PlayerType.PLAYER_MAGDALENA_B,
	PlayerType.PLAYER_CAIN_B,
	PlayerType.PLAYER_JUDAS_B,
	PlayerType.PLAYER_XXX_B,
	PlayerType.PLAYER_EVE_B,
	PlayerType.PLAYER_SAMSON_B,
	PlayerType.PLAYER_AZAZEL_B,
	PlayerType.PLAYER_LAZARUS_B,
	PlayerType.PLAYER_EDEN_B,
	PlayerType.PLAYER_THELOST_B,
	PlayerType.PLAYER_LILITH_B,
	PlayerType.PLAYER_KEEPER_B,
	PlayerType.PLAYER_APOLLYON_B,
	PlayerType.PLAYER_THEFORGOTTEN_B,
	PlayerType.PLAYER_BETHANY_B,
	PlayerType.PLAYER_JACOB_B,
	FiendFolio.PLAYER.BIEND,
	FiendFolio.PLAYER.BOLEM,
}

function mod.fiendishLogic()
	--mod.Fiendish = true
	if not mod.Fiendish then
		mod.FiendishEffects = nil
		return
	end
	mod.FiendishEffects = mod.FiendishEffects or {}
	mod.FiendishEffectTimer = mod.FiendishEffectTimer or 30

	local evP
	for key, val in pairs(mod.FiendishEffects) do
		if mod.FiendishEffects[key] then
			mod.FiendishEffects[key] = mod.FiendishEffects[key] + 1
			if val > mod.FiendishEffectTimer then
				mod.FiendishEffects[key] = nil
				evP = true
			end
		end
	end

	if evP then
		for i = 1, game:GetNumPlayers() do
			local player = Isaac.GetPlayer(i - 1)
			player:AddCacheFlags(CacheFlag.CACHE_ALL)
			player:EvaluateItems()
		end
	end

	if mod.FiendishEffects.GoWackyWithSound then
		local sound = math.random(SoundEffect.NUM_SOUND_EFFECTS - 1 + #mod.Sounds)
		if sound >= SoundEffect.NUM_SOUND_EFFECTS then
			sfx:Play(mod.Sounds[sound - 472],1,2,false,1)
		else
			sfx:Play(sound - 1,1,2,false,math.random(10,200)/100)
		end
	end
	if mod.FiendishEffects.funnySoundReplace then
		--print("hmm")
		for i = 1, SoundEffect.NUM_SOUND_EFFECTS do
			if sfx:IsPlaying(i) and i ~= mod.ChosenFunnySoundReplace then
				sfx:Stop(i)
				sfx:Play(mod.ChosenFunnySoundReplace, 1, 0, false, math.random(75,125)/100)
			end
		end
	end
	if mod.FiendishEffects.SpeedyTimeCounter then
		game.TimeCounter = game.TimeCounter + math.random(10000)
	end
	if mod.FiendishEffects.UnhappyTimeCounter then
		game.TimeCounter = game.TimeCounter + math.random(10000) - 5000
	end
	if mod.FiendishEffects.ReverseTimeCounter then
		game.TimeCounter = game.TimeCounter - math.random(10000)
	end

	mod.MorselTimer = mod.MorselTimer or 0
	local level = game:GetLevel()
	local stage = level:GetStage()
	local room = game:GetRoom()
	local player = Isaac.GetPlayer(0)
	if stage > 6 and not mod.cheatModeOn then
		Isaac.Spawn(mod.FF.Freezer.ID, mod.FF.Freezer.Var, 0, room:GetRandomPosition(1), nilvector, nil)
	elseif stage > 4 and not mod.cheatModeOn then
		MusicManager():Pause()
		MusicManager():Disable()
		if not sfx:IsPlaying(mod.Sounds.Circus) then
			sfx:Play(mod.Sounds.Circus, 1, 0, false, 1)
		end
		mod.MorselTimer = mod.MorselTimer + 1
		local morselsub = math.floor((mod.MorselTimer - 200) / 100)
		if mod.MorselTimer > 300 and mod.MorselTimer % 10 == 0 then
			local blood = Isaac.Spawn(mod.FF.Morsel.ID, mod.FF.Morsel.Var, morselsub, room:GetRandomPosition(1), nilvector, npc):ToNPC()
			blood.CanShutDoors = false
			blood:Update()
			sfx:Play(SoundEffect.SOUND_SUMMONSOUND, 0.6, 0, false, 1)
		end
	elseif stage > 2 or mod.cheatModeOn then
		game:GetLevel():AddCurse(LevelCurse.CURSE_OF_MAZE)
		local randomchance = 500
		if mod.cheatModeOn then
			randomchance = 60
		elseif stage > 3 then
			randomchance = 200
		end
		if math.random(randomchance) == 1 then
			mod.FiendishEffectTimer = math.random(20,150)
			local r = math.random(120)
			if r < 7 then
				for _, e in pairs(Isaac.GetRoomEntities()) do
					e.Velocity = e.Velocity * -5
				end
			elseif r < 9 then
				local entities = Isaac.GetRoomEntities()
				for i = 1, #Isaac.GetRoomEntities() do
					if entities[i - 1] then
						entities[i].Position = entities[i - 1].Position
					end
				end
			elseif r < 12 then
				game:ShakeScreen(100)
			elseif r < 13 then
				player:UseActiveItem(285, false, true, true, false)
			elseif r < 14 then
				player:UseActiveItem(406, false, true, true, false)
			elseif r < 19 then
				for _, e in pairs(Isaac.GetRoomEntities()) do
					e.Color = Color(math.random(100)/50, math.random(100)/50, math.random(100)/50, 1, math.random(), math.random(), math.random())
				end
			elseif r < 22 then
				for _, e in pairs(Isaac.GetRoomEntities()) do
					if e.Type == 5 or e.Type == 2 or e.Type == 3 or e.Type == 4 then
						Isaac.Explode(e.Position, e, 10)
						e:Remove()
					end
				end
			elseif r < 23 then
				player:UseCard(45)
			elseif r < 24 then
				player:UseCard(1)
			elseif r < 25 then
				player:UseCard(5)
			elseif r < 27 then
				player:UseCard(3)
			elseif r < 37 then
				for _, e in pairs(Isaac.GetRoomEntities()) do
					e.Velocity = e.Velocity:Rotated(math.random(360)) * math.random(10)
				end
			elseif r < 38 then
				for _, e in pairs(Isaac.GetRoomEntities()) do
					e.Position = room:GetRandomPosition(1)
				end
			elseif r < 39 then
				mod.FiendishEffects.RunRound = 0
			elseif r < 40 then
				mod.FiendishEffects.ZipZoop = 0
			elseif r < 41 then
				mod.FiendishEffects.Nyoom = 0
			elseif r < 42 then
				mod.FiendishEffects.SlowDown = 0
			elseif r < 43 then
				mod.FiendishEffects.Funny = 0
			elseif r < 44 then
				for _, e in pairs(Isaac.GetRoomEntities()) do
					e.Velocity = Vector(e.Velocity.X * e.Velocity.X, e.Velocity.Y * e.Velocity.Y)
				end
			elseif r < 45 then
				mod.FiendishEffects.Twirly = 0
			elseif r < 48 then
				for _, e in pairs(Isaac.GetRoomEntities()) do
					if e.Type == 5 then
						Isaac.Spawn(mod.FF.Snagger.ID, mod.FF.Snagger.Var, 0, e.Position, nilvector, nil)
					end
				end
			elseif r < 49 then
				mod.FiendishEffects.Spunky = 0
			elseif r < 50 then
				mod.FiendishEffects.Spindigo = 0
			elseif r < 53 then
				local sound = math.random(472 + #mod.Sounds)
				if sound > 472 then
					sfx:Play(mod.Sounds[sound - 472],1,2,false,1)
				else
					sfx:Play(sound - 1,1,2,false,math.random(1,20)/10)
				end
			elseif r < 54 then
				mod.FiendishEffects.Homer = 0
			elseif r < 55 then
				mod.FiendishEffects.Scared = 0
			elseif r < 56 then
				for _, e in pairs(Isaac.GetRoomEntities()) do
					if e:IsEnemy() and math.random(3) == 1 then
						Isaac.Spawn(mod.FF.EternalFlickerspirit.ID, mod.FF.EternalFlickerspirit.Var, 0, e.Position, nilvector, nil)
					end
				end
			elseif r < 57 then
				for _, e in pairs(Isaac.GetRoomEntities()) do
					if e:IsEnemy() and math.random(3) == 1 then
						Isaac.Spawn(mod.FF.Harletwin.ID, mod.FF.Harletwin.Var, 0, e.Position, nilvector, nil)
					end
				end
			elseif r < 60 then
				for _, e in pairs(Isaac.GetRoomEntities()) do
					if e:IsEnemy() then
						mod.ShootBubble(e, nil, e.Position, (e:ToNPC():GetPlayerTarget().Position - e.Position):Resized(math.random(5)))
					end
				end
			elseif r < 61 then
				mod.FiendishEffects.SPEED = 0
			elseif r < 62 then
				for _, e in pairs(Isaac.GetRoomEntities()) do
					if e.Type ~= 1 then
						e.SpriteOffset = RandomVector() * math.random(50)
					end
				end
			elseif r < 63 then
				for _, e in pairs(Isaac.GetRoomEntities()) do
					if e.Type ~= 1 then
						e:Die()
					end
				end
			elseif r < 64 then
				mod.FiendishEffects.FunnyPickup = 0
			elseif r < 68 then
				mod.FiendishEffects.FunnyProjectiles = 0
			elseif r < 70 then
				local cardChoice = math.random(62)
				if cardChoice ~= 46 then
					player:UseCard(cardChoice)
				end
			elseif r < 72 then
				player:UsePill(math.random(47) - 1, math.random(14) - 1)
			elseif r < 74 then
				player:UseActiveItem(488, true, true, true, true)
			elseif r < 75 then
				mod.FiendishEffects.GoWackyWithSound = 0
			elseif r < 76 then
				mod.FiendishEffects.SizeRandomizer = 0
			elseif r < 78 then
				for _, e in pairs(Isaac.GetRoomEntities()) do
					game:ButterBeanFart(e.Position, 250, e, 1, true)
				end
			elseif r < 79 then
				mod.FiendishEffects.SpeedyTimeCounter = 0
			elseif r < 80 then
				mod.FiendishEffects.UnhappyTimeCounter = 0
			elseif r < 81 then
				mod.FiendishEffects.ReverseTimeCounter = 0
			elseif r < 82 then
				mod.FiendishEffects.Pendulum = 0
			elseif r < 83 then
				mod.FiendishEffects.SpeedSpinUp = 0
			elseif r < 84 then
				player:UseActiveItem(386, true, true, true, true)
			elseif r < 85 then
				local room = Game():GetRoom()
				local size = room:GetGridSize()
				for i=0, size do
					if not room:GetGridEntity(i) then
						local gridpos = room:GetGridPosition(i)
						Isaac.Spawn(85, 962, 0, gridpos, nilvector, nil)
					end
				end
			elseif r < 86 then
				local room = Game():GetRoom()
				local size = room:GetGridSize()
				for i=0, size do
					if not room:GetGridEntity(i) then
						local gridpos = room:GetGridPosition(i)
						Isaac.Spawn(5, 0, 0, gridpos, nilvector, nil)
					end
				end
			elseif r < 87 then
				mod.FiendishEffects.RollItems = 0
			elseif r < 88 then
				mod.FiendishEffects.RollHealth = 0
			elseif r < 90 then
				mod.FiendishEffects.GetSpeedy = 0
			elseif r < 92 then
				mod.FiendishEffects.GetShooty = 0
			elseif r < 94 then
				mod.FiendishEffects.GetHurty = 0
			elseif r < 96 then
				mod.FiendishEffects.GetShootSpeedy = 0
			elseif r < 97 then
				Isaac.GetPlayer(0):GetData().drawnSwallowedM90 = true
			elseif r < 100 then
				for i = 1, game:GetNumPlayers() do
					local player = Isaac.GetPlayer(i - 1)
					local choice = mod.ValidPlayerEnums[math.random(#mod.ValidPlayerEnums)]
					if math.random(5) == 1 then
						choice = mod.ValidPlayerBEnums[math.random(#mod.ValidPlayerBEnums)]
					end
					if math.random(10) == 1 and i == 1 then
						Isaac.ExecuteCommand('addplayer ' .. choice .. ' ' .. player.ControllerIndex)
					else
						player:ChangePlayerType(choice)
					end
				end
			elseif r < 102 then
				mod.FiendishEffects.LessHurty = 0
			elseif r < 103 then
				sfx:Play(SoundEffect.SOUND_BOSS2INTRO_ERRORBUZZ,2, 0, false, 0.75)
				local middle = room:GetCenterPos()
				--Isaac.Spawn(6, 12, 0, middle, nilvector, nil)
				Isaac.GridSpawn(GridEntityType.GRID_PRESSURE_PLATE, 0, middle, true)
				Isaac.GetPlayer(0).Position = middle + Vector(0, -80)
				for i = 45, 315, 45 do
					Isaac.Spawn(160,1717,0, middle + Vector(0, -80):Rotated(i), nilvector, nil)
				end
			elseif r < 104 then
				mod.FiendishEffects.funnySoundReplace = 0
				mod.ChosenFunnySoundReplace = math.random(SoundEffect.NUM_SOUND_EFFECTS)
			elseif r < 105 then
				Isaac.Spawn(4,17,0, Isaac.GetPlayer().Position, nilvector, nil)
			elseif r < 106 then
				Isaac.Spawn(4,18,0, Isaac.GetPlayer().Position, nilvector, nil)
			elseif r < 107 then
				local middle = room:GetCenterPos()
				local esau = Isaac.Spawn(866, 0, 0, middle, nilvector, nil)
				esau:Update()
				mod.scheduleForUpdate(function()
					if esau then
						esau:Kill()
					end
				end, math.random(200,3000))
			elseif r < 110 then
			elseif r < 115 then
				if not mod.FiendishKeyTimer then
					mod.FiendishKeyTimer = math.random(2,15) * 60
					if math.random(2) == 1 then
						mod.FiendishKeyToPress = math.random(#mod.ValidFunnyKeys)
					else
						mod.FiendishActionToDo = math.random(#mod.ValidFunnyActions)
					end
				end
			else
				game:Fart(player.Position, 40, player, 1, 0)
			end
		end
	end
end

function mod:waitingSpiderAI(npc, subt)
	local sprite = npc:GetSprite()
	local d = npc:GetData()
	local target = npc:GetPlayerTarget()

	if not d.init then
		npc:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
		npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
		npc:AddEntityFlags(EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK | EntityFlag.FLAG_NO_KNOCKBACK | EntityFlag.FLAG_NO_STATUS_EFFECTS)
		npc.Visible = false

		d.state = "waiting"

		d.init = true
	elseif d.init then
		npc.StateFrame = npc.StateFrame + 1
	end

	if d.state == "waiting" then
		if mod.CanIComeOutYet() then
			if npc.StateFrame > 15 then
				if mod.farFromAllPlayers(npc.Position, 60) then
					d.state = "emerge"
					npc:ClearEntityFlags(EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK | EntityFlag.FLAG_NO_KNOCKBACK | EntityFlag.FLAG_NO_STATUS_EFFECTS)
					mod:spritePlay(sprite, "Drop")
					npc.Visible = true
				end
			end
		else
			npc.StateFrame = 0
		end
	elseif d.state == "emerge" then
		npc.Velocity = nilvector
		if sprite:IsFinished("Drop") then
			if subt == 1 then
				npc:Morph(250, 0, 95, -1)
			elseif subt == 2 then
				npc:Morph(206, 0, 95, -1)
			elseif subt == 3 then
				npc:Morph(206, 1, 95, -1)
			elseif subt == 4 then
				npc:Morph(207, 0, 95, -1)
			elseif subt == 5 then
				npc:Morph(207, 1, 95, -1)
			elseif subt == 6 then
				npc:Morph(215, 710, 95, -1)
			else
				npc:Morph(215, 0, 95, -1)
			end
		elseif sprite:IsEventTriggered("DMG") then
			npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_ALL
			--npc:ClearEntityFlags(EntityFlag.FLAG_NO_STATUS_EFFECTS)
		else
			mod:spritePlay(sprite, "Drop")
		end
	end

	if npc:IsDead() then
		if subt == 1 then
			Isaac.Explode(npc.Position, npc, 20)
		elseif subt == 6 then
			local vec = RandomVector():Resized(8)
			for i = 60, 360, 60 do
				npc:FireProjectiles(npc.Position, vec:Rotated(i) + nilvector, 0, ProjectileParams())
			end
		end
	end
end

mod.garyVars = {
[0] = {1, false},
[1] = {2, false},
[2] = {3, false},
[3] = {2, true}
}

function mod:SetGaryHoleSprite(effect)
	local backdroptype = game:GetRoom():GetBackdropType()
	local suffix

	if mod.roomBackdrop == 10 then	
		suffix = "morbus"
	elseif backdroptype == 15 then
		suffix = "cathedral"
	elseif backdroptype == 17 then
		suffix = "chest"
	elseif backdroptype == 10 then
		suffix = "womb"
	elseif backdroptype == 11 then
		suffix = "utero"
	elseif backdroptype == 12 then
		suffix = "scarred_womb"
	elseif backdroptype == 34 then
		suffix = "corpse_1"
	elseif backdroptype == 43 then
		suffix = "corpse_2"
	elseif backdroptype == 44 then
		suffix = "corpse_3"
	end

	if suffix then
		local sprite = effect:GetSprite()
		local path = "gfx/enemies/gary/garry_fillup_"..suffix..".png"
		sprite:ReplaceSpritesheet(0, path)
		sprite:ReplaceSpritesheet(1, path)
		sprite:LoadGraphics()
	end
end

mod:AddCallback(ModCallbacks.MC_POST_EFFECT_UPDATE, function(_, eff)
	local data = eff:GetData()
	if not data.RenderTo then return end

	local sprite = eff:GetSprite()
	if sprite:IsFinished('FillUp') and sprite:GetFrame() > 0 then
		sprite:Play('IdleClosed', true)
		eff:AddEntityFlags(data.RenderTo)
	end
end, 1733)

function mod:garyAI(npc)
	local room = game:GetRoom()
	local sprite = npc:GetSprite()
	local d = npc:GetData()
	local target = npc:GetPlayerTarget()

	if not d.init then
		npc:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
		npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
		npc.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_NONE
		npc:AddEntityFlags(EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK | EntityFlag.FLAG_NO_KNOCKBACK)
		npc.Visible = false
		d.comeOutTime = math.random(200) + 50
		if npc.SubType == 1716 then
			sprite:ReplaceSpritesheet(0, 'gfx/enemies/gary/idpdvan.png')
			sprite:ReplaceSpritesheet(1, 'gfx/enemies/gary/idpdvan.png')
			sprite:ReplaceSpritesheet(2, 'gfx/enemies/gary/idpdvan.png')
			sprite:ReplaceSpritesheet(7, 'gfx/enemies/gary/idpdvan.png')
			sprite:LoadGraphics()
		end

		d.rot = 0
		for i = 0, 3 do
			local nextgrid = npc.Position + Vector(0, -40):Rotated(i * 90)
			if room:GetGridCollisionAtPos(nextgrid) == GridCollisionClass.COLLISION_WALL then
				d.rot = i
			end
		end

		--sprite.Rotation = 90 * d.rot
		sprite.FlipX = mod.garyVars[d.rot][2]

		npc.Position = npc.Position + Vector(0, -8):Rotated(90 * d.rot)

		d.state = "waiting"

		d.init = true
	elseif d.init then
		npc.StateFrame = npc.StateFrame + 1
	end

	if npc.State == 11 then
		if sprite:IsFinished("Exit0" .. mod.garyVars[d.rot][1]) then
			npc:BloodExplode()
			npc:Remove()

			if npc.SubType ~= 1716 then
				for i = 1, 2 do
					local wall = Isaac.Spawn(1000, 1733, 0, npc.Position + Vector(0, -4):Rotated(90 * d.rot), nilvector, npc):ToEffect()
					local wsprite = wall:GetSprite()
					local wdata = wall:GetData()
					if npc.SubType == 1716 then
						wsprite:ReplaceSpritesheet(0, 'gfx/enemies/gary/idpdvan.png')
						wsprite:LoadGraphics()
					else
						mod:SetGaryHoleSprite(wall)
					end


					wsprite.Rotation = 90 * d.rot
					if i == 1 then
						wdata.RenderTo = EntityFlag.FLAG_RENDER_WALL
					else
						wdata.RenderTo = EntityFlag.FLAG_RENDER_FLOOR
					end
					wsprite:Play('FillUp', true)
				end
			end

		elseif sprite:IsEventTriggered("StopBlood") then
			d.nobleed = true
		else
			mod:spritePlay(sprite, "Exit0" .. mod.garyVars[d.rot][1])
			if npc.FrameCount % 3 == 0 and not d.nobleed then
				local blood = Isaac.Spawn(1000, 2, 1, npc.Position + Vector(0,1), nilvector, nil)
				blood.SpriteOffset = Vector(0, 5):Rotated(d.rot * 90) + RandomVector()*math.random(20)
				npc:PlaySound(SoundEffect.SOUND_MEAT_JUMPS,0.2,0,false,0.8)
			end
		end
	else
		if d.state == "waiting" then
			if (npc.SubType == 0 and npc.StateFrame > d.comeOutTime) or mod.CanIComeOutYet() then
				if npc.SubType == 1716 or mod.farFromAllPlayers(npc.Position, 60) then
					d.state = "emerge"
					sprite:Play("Emerge0" .. mod.garyVars[d.rot][1], true)
					npc.Visible = true
					if npc.SubType == 1716 then
						-- skip to the fun part
						for i = 1, 40 do
							sprite:Update()
						end
					end
				end
			end
		elseif d.state == "emerge" then
			npc.Velocity = nilvector
			if sprite:IsFinished("Emerge0" .. mod.garyVars[d.rot][1]) then
				d.state = "startspawn"
			elseif sprite:IsEventTriggered("ScreenShake") then
				game:ShakeScreen(10)
				npc:PlaySound(SoundEffect.SOUND_HELLBOSS_GROUNDPOUND,0.3,0,false,math.random(110,120)/100)
			elseif sprite:IsEventTriggered("HoleAppear") then
				for i = 1, 2 do
					local wall = Isaac.Spawn(1000, 1733, 0, npc.Position + Vector(0, -4):Rotated(90 * d.rot), nilvector, npc):ToEffect()
					local wsprite = wall:GetSprite()
					local wdata = wall:GetData()
					if npc.SubType == 1716 then
						wsprite:ReplaceSpritesheet(0, 'gfx/enemies/gary/idpdvan.png')
						wsprite:LoadGraphics()
					else
						mod:SetGaryHoleSprite(wall)
					end


					wsprite.Rotation = 90 * d.rot
					if i == 1 then
						wall:AddEntityFlags(EntityFlag.FLAG_RENDER_WALL)
					else
						wall:AddEntityFlags(EntityFlag.FLAG_RENDER_FLOOR)
					end
					wsprite:SetFrame("FillUp", 0)
				end
			elseif sprite:IsEventTriggered("RockGibs") then
				game:ShakeScreen(20)
				npc:PlaySound(SoundEffect.SOUND_HELLBOSS_GROUNDPOUND,1,0,false,1)
				npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS
			else
				mod:spritePlay(sprite, "Emerge0" .. mod.garyVars[d.rot][1])
			end
		elseif d.state == "startspawn" then
			npc.Velocity = nilvector
			if sprite:IsFinished("SpawnStart0" .. mod.garyVars[d.rot][1]) then
				d.state = "spawnloop"
			elseif sprite:IsEventTriggered("StartSpawn") then
				d.spawning = true
				npc.StateFrame = 0
				npc:PlaySound(mod.Sounds.TemperAnger,1,0,false,1.2)
			else
				mod:spritePlay(sprite, "SpawnStart0" .. mod.garyVars[d.rot][1])
			end
		elseif d.state == "spawnloop" then
			npc.Velocity = nilvector
			mod:spritePlay(sprite, "SpawnLoop0" .. mod.garyVars[d.rot][1])
		elseif d.state == "endspawn" then
			npc.Velocity = nilvector
			if sprite:IsFinished("SpawnEnd0" .. mod.garyVars[d.rot][1]) then
				d.state = "idle"
				npc.StateFrame = 0
			elseif sprite:IsEventTriggered("EndSpawn") then
				d.spawning = false
			else
				mod:spritePlay(sprite, "SpawnEnd0" .. mod.garyVars[d.rot][1])
			end
		elseif d.state == "idle" then
			npc.Velocity = nilvector
			mod:spritePlay(sprite, "Idle0" .. mod.garyVars[d.rot][1])

			local count = 0
			if npc.SubType == 1716 then
				count = mod.GetEntityCount(mod.FF.FishNuclearThrone.ID, mod.FF.FishNuclearThrone.Var, 0)
			else
				count = mod.GetMaggotCount()
			end
			d.randwait = d.randwait or 0
			local diff = d.maxspawns - count
			if npc.StateFrame >= 150 + d.randwait and count < d.maxspawns + 2 then
			--if count < d.maxspawns then
				d.state = "startspawn"
				d.numspawns = math.max(1, diff)
			end
		elseif d.state == "hole" then
			npc.Velocity = nilvector
			mod:spritePlay(sprite, "Hole")
		end

		if d.spawning then
			if npc.StateFrame % 15 == 1 then
				local extravec = Vector(0, 10):Rotated(90 * d.rot)
				local chosenpos = npc.Position + extravec:Resized(5):Rotated(-50 + math.random(100))

				local maggot
				if npc.SubType == 1716 then
					maggot = Isaac.Spawn(mod.FF.FishNuclearThrone.ID, mod.FF.FishNuclearThrone.Var, 0, chosenpos, extravec, npc):ToNPC()
				else
					maggot = Isaac.Spawn(mod.maggots[math.random(#mod.maggots)], 0, 0, chosenpos, extravec, npc):ToNPC()
				end
				maggot:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
				maggot:SetColor(Color(0.2,0.2,0.2,1,0,0,0),15,1,true,false)
				maggot:Update()

				d.spawncount = (d.spawncount or 0) + 1

				local spawnsmoke = Isaac.Spawn(1000, 15, 0, chosenpos, nilvector, npc):ToEffect()
				spawnsmoke.Color = Color(1,1,1,0.2,0,0,0)
				spawnsmoke:Update()

				npc:PlaySound(SoundEffect.SOUND_SKIN_PULL,0.6,0,false,math.random(11,13)/10)

			end

			if not d.maxspawns then
				if npc.SubType == 1716 then
					d.maxspawns = 6
				else
					d.maxspawns = 3
				end
			end

			d.spawncount = d.spawncount or 0
			d.numspawns = d.numspawns or d.maxspawns
			if d.spawncount > d.numspawns - 1 then
				d.state = "endspawn"
				d.spawncount = 0
				d.randwait = mod:RandomInt(20,50)
			end
		end
	end
end

mod.maggots = {21, 21, 21, 23, 23, 31, 31, 243}

function mod:BASCOBLAST(e)
e:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
mod:spritePlay(e:GetSprite(), "Okay")
	if not e:GetData().no then
		e:GetData().no = true
		e.RenderZOffset = 20000
		sfx:Play(mod.Sounds.BascoBlast, 1, 0, false, 1)
	end
end
mod:AddCallback(ModCallbacks.MC_POST_EFFECT_UPDATE, mod.BASCOBLAST, 1732)

function mod:amnioticAI(npc, subt)
local room = game:GetRoom()
local d = npc:GetData()
local sprite = npc:GetSprite();
local target = npc:GetPlayerTarget()
	if not d.init then
		if math.random(2) == 1 then
			sprite.FlipX = true
		end
		npc:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
		npc:AddEntityFlags(EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK | EntityFlag.FLAG_NO_KNOCKBACK | EntityFlag.FLAG_NO_STATUS_EFFECTS)
		d.init = true
		local room = game:GetRoom()

		local roomDat = FiendFolio.getFieldInit(FiendFolio.savedata, 'run', 'level', 'amnioticSackData', tostring(game:GetLevel():GetCurrentRoomDesc().ListIndex), {})
		if roomDat[tostring(room:GetGridIndex(npc.Position))] then
			sprite:SetFrame("Blown", 0)
			npc:AddEntityFlags(EntityFlag.FLAG_RENDER_FLOOR)
			return
		end
	end

	if npc.Variant == mod.FF.Miscarriage.Var then
		d.Miscarriage = true
		if subt == 1 then
			mod:spritePlay(sprite, "Wrinkly")
		elseif subt == 2 then
			mod:spritePlay(sprite, "Unborn")
		elseif subt == 3 then
			mod:spritePlay(sprite, "Maggots")
		else
			mod:spritePlay(sprite, "Empty")
		end
	else
		if subt == 1 then
			mod:spritePlay(sprite, "Random")
		elseif subt == 2 then
			mod:spritePlay(sprite, "Neonate")
		elseif subt == 3 then
			mod:spritePlay(sprite, "Baby")
		elseif subt == 4 then
			mod:spritePlay(sprite, "Embryo")
		else
			mod:spritePlay(sprite, "Empty")
		end
	end
	npc.Velocity = nilvector

	if npc:HasMortalDamage() then
		if not game:GetRoom():HasWater() then
			if d.Miscarriage then
				local creep = Isaac.Spawn(1000, 22, 0, npc.Position, nilvector, npc):ToEffect()
				creep.SpriteScale = creep.SpriteScale * 1.5
				creep:Update()
			else
				local creep = Isaac.Spawn(1000, 24, 0, npc.Position, nilvector, npc):ToEffect()
				creep.SpriteScale = creep.SpriteScale * 1.5
				creep:SetColor(Color(0,0,0,1,180 / 255,180 / 255,30 / 255), 0, 99999, true, false)
				creep:Update()
			end
		end

		--[[for i = 30, 360, 30 do
			local proj = Isaac.Spawn(9, 0, 0, npc.Position, Vector(math.random(25,35)/10, 0):Rotated(i), npc):ToProjectile()
			proj.Scale = math.random(8,10)/10
			proj.Color = mod.ColorPiss
			proj.FallingSpeed = -20 + math.random(10)
			proj.FallingAccel = 1.5
			local pd = proj:GetData()
			pd.projType = "acidic piss"
		end]]
		if subt > 0 then
			local babspawn
			if d.Miscarriage then
				if subt == 1 then
					babspawn = {38, 3}
				elseif subt == 2 then
					babspawn = {EntityType.ENTITY_UNBORN, 0}
				elseif subt == 3 then
					for i = 1, math.random(4, 5) do
						mod.ThrowMaggot(npc.Position, RandomVector() * math.random(2, 5), -14, math.random(-15, -10), npc)
					end
				end
			else
				if subt == 1 then
					subt = math.random(3) + 1
				end
				if subt == 2 then
					babspawn = {mod.FF.Neonate.ID, mod.FF.Neonate.Var}
				elseif subt == 3 then
					babspawn = {38, 0}
				elseif subt == 4 then
					babspawn = {77, 0}
				end
			end

			if babspawn then
				local bab = Isaac.Spawn(babspawn[1],babspawn[2],0,npc.Position,nilvector,npc)
				bab:Update()
			end
		end
		sprite:SetFrame("Blown", 0)
		local sploshEffect = Isaac.Spawn(1000, 1738, 0, npc.Position, nilvector, npc):ToEffect()
		sploshEffect.SpriteOffset = npc.SpriteOffset
		sploshEffect:GetSprite():Load(sprite:GetFilename(),true)
		sploshEffect:Update()

		local roomDat = FiendFolio.getFieldInit(FiendFolio.savedata, 'run', 'level', 'amnioticSackData', tostring(game:GetLevel():GetCurrentRoomDesc().ListIndex), {})
		roomDat[tostring(room:GetGridIndex(npc.Position))] = true
		npc:AddEntityFlags(EntityFlag.FLAG_RENDER_FLOOR)
	end
end

mod:AddCallback(ModCallbacks.MC_POST_EFFECT_UPDATE, function(_, eff)
	if eff.Timeout and eff.Timeout <= 0 and (not eff.Timeout == 0) then
		eff:Remove()
	end
end, EffectVariant.SMOKE_CLOUD)

function mod:fuegoAI(npc)
	if npc.FrameCount < 2 then
		npc.SplatColor = mod.ColorFireJuicy
	end
	if npc.V1.X == -5 then
		--[[for _, fire in pairs(Isaac.FindByType(33, 10, 0, false, false)) do
			if fire.Position:Distance(npc.Position) < 5 then
				fire:Remove()
			end
		end
		local fire = Isaac.Spawn(33, 10, 0, npc.Position, nilvector, npc)
		fire.HitPoints = 2
		fire:Update()]]

		local fire = Isaac.Spawn(1000,7005, 0, npc.Position, nilvector, npc):ToEffect()
		fire:GetData().timer = 30
		fire:GetData().scale = 0.75
		fire:GetData().flamethrower = true
		fire:Update()
		fire.Parent = npc
		sfx:Stop(SoundEffect.SOUND_SPLATTER)
		npc:PlaySound(SoundEffect.SOUND_FIREDEATH_HISS, 0.18, 0, false, 2)
	end
	local d = npc:GetData()
	if npc.Velocity.X > 0 then
		if not d.flippedSprite then
			local sprite = npc:GetSprite()
			sprite:ReplaceSpritesheet(0, "gfx/enemies/fuego/monster_fuego_flippedHead.png")
			sprite:ReplaceSpritesheet(1, "gfx/enemies/fuego/monster_fuego_glow_flippedHead.png")
			sprite:LoadGraphics()
			d.flippedSprite = true
		end
	else
		if d.flippedSprite then
			local sprite = npc:GetSprite()
			sprite:ReplaceSpritesheet(0, "gfx/enemies/fuego/monster_fuego.png")
			sprite:ReplaceSpritesheet(1, "gfx/enemies/fuego/monster_fuego_glow.png")
			sprite:LoadGraphics()
			d.flippedSprite = false
		end
	end
end

function mod:checkFissure(npc)
local d = npc:GetData()
local room = game:GetRoom()
	if npc.Variant == 0 and not d.init then
		d.init = true
		if mod.fuegoSpawnPoints and mod.fuegoSpawnPoints[room:GetGridIndex(npc.Position)] then
			if room:HasWater() then
				npc:Remove()
			else
				npc:Morph(npc.Type, 960, npc.SubType, -1)
			end
		end
	end

	if npc.Variant == 960 then
		mod:fuegoAI(npc)
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkFissure, 815)

mod:AddCallback(ModCallbacks.MC_POST_EFFECT_INIT, function(_, effect)
	local room = game:GetRoom()
	if mod.fuegoSpawnPoints and mod.fuegoSpawnPoints[room:GetGridIndex(effect.Position)] then
		if not room:HasWater() then
			Isaac.Spawn(1000,16,66,effect.Position,Vector.Zero,nil)
		end
		effect.Visible = false
		effect:Remove()
	end
end, EffectVariant.WATER_RIPPLE)

function mod:checkFissureHurt(npc, damage, flag, source)
	if npc.Variant == 960 then
		if flag & DamageFlag.DAMAGE_FIRE ~= 0 and source.Type ~= 1 then
			return false
		end
	end
end

mod:AddCallback(ModCallbacks.MC_ENTITY_TAKE_DMG, mod.checkFissureHurt, 815)

--ERFLYAI END--

--Guillotine21 ENEMIES

-- Honey eye AI
function mod:honeyeyeAI(npc)

  local sprite = npc:GetSprite()
  local data = npc:GetData()
  local target = npc:GetPlayerTarget()
  --[[local room = game:GetRoom()
  room:CheckLine(npc.Position, target.Position, 3, 1, false, false)]]

	if not data.Appeared then
		data.States = "Move"
		data.Appeared = true
		local randomposition = mod:FindRandomFreePosAirNoGrids(target.Position, 50, 200)
		data.targetvel = (randomposition - npc.Position):Resized(3)
	else
		npc.StateFrame = npc.StateFrame + 1
	end

	if data.States == "Move" then
		sprite:Play("Fly")
		if npc.Position:Distance(target.Position) <= 50 and not npc:HasEntityFlags(EntityFlag.FLAG_CONFUSION) then
			data.targetvel = (target.Position - npc.Position):Resized(-6)
			data.Run = true
		else
			if npc.StateFrame % 30 == 0 or data.Run then
				local randomposition = mod:FindRandomFreePosAirNoGrids(target.Position, 50, 200)
				data.targetvel = (randomposition - npc.Position):Resized(4.5)
				data.Run = false
			end
		end
		npc.Velocity = mod:Lerp(npc.Velocity, data.targetvel, 0.075)
		  if npc.Position:Distance(target.Position) <= 285 and npc.StateFrame >= 85 and not (npc:HasEntityFlags(EntityFlag.FLAG_FEAR) or npc:HasEntityFlags(EntityFlag.FLAG_CONFUSION)) then
		   data.States = "Attack"
		  end
	elseif data.States == "Attack" then
		npc.Velocity = npc.Velocity * 0.95
		sprite:Play("Shoot")
		   if sprite:IsEventTriggered("Shoot") then
			local shotspeed = (target.Position - npc.Position)*0.05
			if shotspeed:Length() > 10 then
				shotspeed = shotspeed:Resized(10)
			end
			npc:PlaySound(SoundEffect.SOUND_BLOODSHOOT,1,2,false,1)
			local projectile = Isaac.Spawn(9, 0, 0, npc.Position, shotspeed, npc):ToProjectile()
			projectile.FallingSpeed = -25
			projectile.FallingAccel = 1.5
			projectile.Scale = projectile.Scale * 2
			projectile:GetData().projType = "HoneyCreep"
			projectile.SplatColor = FiendFolio.ColorHoneyYellow
			projectile.Color = FiendFolio.ColorHoneyYellow
			projectile:Update()
		   end
		if sprite:IsFinished("Shoot") then
		 data.States = "Move"
		 npc.StateFrame = 0
		end
	end

end

-- Smogger AI
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, function(_, npc)
	if npc.Variant == mod.FF.Smogger.Var then

		local target = npc:GetPlayerTarget()
		local sprite = npc:GetSprite()
		local angle = (target.Position - npc.Position):GetAngleDegrees()
		local data = npc:GetData()
		local room = game:GetRoom()
		local path = npc.Pathfinder

		if not data.init then
			npc.SplatColor = mod.ColorCharred
			npc.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_NOPITS
			npc.V1 = Vector(30, npc.V1.Y)
			npc.SpriteOffset = Vector(0, -2)
			data.Burning = 0
			data.init = true
		end


		if npc.FrameCount > 1 then
			if data.Burning > 0 and npc.State ~= 25 then
				npc.Velocity = nilvector
				npc.State = 25
			end

		-- Idle State
			if npc.State == 4 or npc.State == 8 then
				sprite:Play("WalkBody")
				if npc.State ~= 8 then
					sprite:PlayOverlay("HeadWalk")
				end
				local fire
				fire = mod.FindClosestFire(npc.Position, 99999)
				if fire then
					if npc.Position:Distance(fire.Position) <= npc.Size * 2 then
						data.Burning = 1
					end
				end
			end

		-- Attack State
			if sprite:IsOverlayPlaying("HeadAttack") and sprite:GetOverlayFrame() < 1 then
				npc.V1 = Vector(math.random(130, 150), npc.V1.Y)
			end

		-- Burning State
			if data.Burning > 0 then
				npc.V1 = Vector(140, npc.V1.Y)
			end

			if npc.State == 25 then
				if data.Burning == 2 then

					sprite:PlayOverlay("HeadFlame")
					npc:AnimWalkFrame("WalkFlame","WalkFlame",0)
					if sprite:GetAnimation() == "WalkFlame" then
						sprite:Play("WalkFlame")
					end

					local targetpos = mod:confusePos(npc, target.Position)
					data.targetvelocity = mod:reverseIfFear(npc, (targetpos - npc.Position):Resized(4.5))
					npc.Velocity = mod:Lerp(data.targetvelocity, npc.Velocity, 0.8)
					--[[if room:CheckLine(npc.Position,targetpos,0,1,false,false) or mod:isScare(npc) then
						data.targetvelocity = mod:reverseIfFear(npc, (targetpos - npc.Position):Resized(5.25))
						npc.Velocity = mod:Lerp(data.targetvelocity, npc.Velocity, 0.8)
					else
						 mod:CatheryPathFinding(npc, targetpos, {
							Speed = 5.25,
							Accel = 0.2,
							GiveUp = true
						 })
					end]]
					if npc.FrameCount % 5 == 0 then
						local fire = Isaac.Spawn(1000,7005, 20, npc.Position, Vector.Zero, npc):ToEffect()
						fire:GetData().timer = 10
						fire:GetData().gridcoll = 0
						fire:GetData().scale = 0.5
						fire.Parent = npc
						fire:Update()
					end
				elseif data.Burning == 1 then
					sprite:Play("Burning")
					sprite:RemoveOverlay()
					if sprite:IsEventTriggered("Burning") then
						npc.SplatColor = mod.ColorFireJuicy
						npc.HitPoints = npc.HitPoints * 1.25
						npc.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_WALLS
						sfx:Play(SoundEffect.SOUND_FLAMETHROWER_END, 1, 0, false, 1)
							if npc:GetChampionColorIdx() == 19 or npc:GetChampionColorIdx() == 23 then
							npc.CollisionDamage = 4
							elseif npc:IsChampion() then
							npc.CollisionDamage = 2
							else
							npc.CollisionDamage = 1
							end
						data.flaming = true
					end
					if sprite:IsFinished("Burning") then
						data.Burning = 2
						sprite:SetOverlayFrame("HeadFlame",0)
					end
				end
			end
		end

		-- Death
		if npc:IsDead() then
			if data.flaming then
				data.Burning = 2
				Isaac.Spawn(33, 10, 0, npc.Position, nilvector, npc)
			else
				local smoke = Isaac.Spawn(1000, EffectVariant.DARK_BALL_SMOKE_PARTICLE, 0, npc.Position, nilvector, npc)
				smoke.SpriteScale = Vector(3,3)
				smoke.SpriteOffset = Vector(0, -25)
				smoke:Update()
				local vec = (RandomVector()*20)
				for i = 1, 3 do
					mod.SpawnGunpowder(npc,npc.Position + vec:Rotated(360/3 * i - 15 + math.random(30)):Resized(math.random(5,20)), 300, 150)
				end
				for i = 1, 5 do
					mod.SpawnGunpowder(npc,npc.Position + vec:Rotated(360/5 * i - 15 + math.random(30)):Resized(math.random(25,50)), 300, 150)
				end
			end
		end

	end
end, mod.FF.Smogger.ID)

mod:AddCallback(ModCallbacks.MC_ENTITY_TAKE_DMG, function(_, npc, damage, flag, source)
	if npc.Variant == mod.FF.Smogger.Var then
		if flag & DamageFlag.DAMAGE_FIRE ~= 0 and source.Type ~= 1 then
			if npc:GetData().Burning == 0 then
				npc:GetData().Burning = 1
			end
			return false
		end
	end
end, mod.FF.Smogger.ID)

mod:AddCallback(ModCallbacks.MC_PRE_NPC_COLLISION, function(_, npc, collider)
	if npc.Variant == mod.FF.Smogger.Var then
		if collider.Type == EntityType.ENTITY_LITTLE_HORN and collider.Variant == 1 then
			return true
		end
	end
end, mod.FF.Smogger.ID)

mod:AddCallback(ModCallbacks.MC_POST_NPC_INIT, function(_, npc) -- Remove or replace leeches
	if npc.SpawnerType == mod.FF.Smogger.ID and npc.SpawnerVariant == mod.FF.Smogger.Var then
		if npc.SpawnerEntity:IsDead() then
			npc:Remove()
		else
			npc:Morph(EntityType.ENTITY_LITTLE_HORN, 1, 0, -1)
			npc.MaxHitPoints = npc.MaxHitPoints / 2
			npc.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_WALLS
		end
	end
end, EntityType.ENTITY_SMALL_LEECH)

-- Champion Bosses

function mod:checkFistula(npc)
	if (npc.Type == EntityType.ENTITY_FISTULA_BIG or npc.Type == EntityType.ENTITY_FISTULA_MEDIUM or npc.Type == EntityType.ENTITY_FISTULA_SMALL) and npc.Variant == 0 and npc.SubType == (mod.FF.BeehiveFistulaBig.Sub or mod.FF.BeehiveFistulaMedium.Sub or mod.FF.BeehiveFistulaSmall.Sub) then
		mod:BeeHiveFistula(npc)
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkFistula)

-- Beehive Fistula
function mod:BeeHiveFistula(npc)
	npc.Velocity = npc.Velocity * 0.985
	local data = npc:GetData()
	local sprite = npc:GetSprite()
	if not data.init then
		--sprite:ReplaceSpritesheet(0, "gfx/bosses/champions/boss_fistula_beehive.png")
		--sprite:LoadGraphics()
		data.init = true
	end
	if npc:IsDead() then
		local honeycolor = Color(1,1,1,1,0,0,0)
		honeycolor:SetColorize(5.5, 3.5, 1, 1)
			local creep = Isaac.Spawn(1000, EffectVariant.CREEP_BROWN, 0, npc.Position, Vector(0,0), npc):ToEffect()
				if npc.Type == EntityType.ENTITY_FISTULA_BIG then
					local BeehiveFistulaCheck = false
					for _, MediumFistula in ipairs(Isaac.FindByType(EntityType.ENTITY_FISTULA_MEDIUM, 0, mod.FF.BeehiveFistulaMedium.Sub, false, false)) do
						if MediumFistula.SpawnerType == EntityType.ENTITY_FISTULA_BIG and MediumFistula.SpawnerVariant == 0 and MediumFistula.Position:Distance(npc.Position) < 30 and MediumFistula.FrameCount < 1 and BeehiveFistulaCheck == false then
							MediumFistula:Remove()
							BeehiveFistulaCheck = true
						end
					end
					creep.SpriteScale = Vector(4, 3.5)
				elseif npc.Type == EntityType.ENTITY_FISTULA_MEDIUM then
					creep.SpriteScale = Vector(2, 1.25)
					creep.Scale = creep.Scale * 1.35
				elseif npc.Type == EntityType.ENTITY_FISTULA_SMALL then
					creep.SpriteScale = Vector(1.25, 1)
					creep.Scale = creep.Scale * 1.35
				end
			creep:SetTimeout(creep.Timeout + 95)
			creep:Update()
			creep:GetSprite().Color = honeycolor
	end
end


--Mini - AI

--function for poopy enemies occasionaly spawning flies
function mod:rancid(npc, lowerbound, upperbound, tablemax, flytable)
	if flytime == nil then
		flytime = math.random(lowerbound,upperbound)
	elseif flytime <= 0 then
		local flycheck = math.random(1,tablemax);
		Isaac.Spawn(EntityType.ENTITY_EFFECT, flytable[flycheck], 0, npc.Position, Vector(0,0), npc);
		flytime = math.random(lowerbound,upperbound)
	end
	flytime = flytime - 1;
end

--splattering behavior for soft serve
function mod:softservesplatter(npc, dipnumber)
	local isDross = mod:CheckStage("Dross", {45})
	npc:PlaySound(SoundEffect.SOUND_PLOP,1,1,false,math.random(6, 9) / 10)
	--spawn dips
	dipnumber = dipnumber or math.random(1,2);
	for i = 1, dipnumber, 1 do
		local id = 217
		local var = 2
		if isDross then
			id = 870
			var = 0
		end
		--mod.cheekyspawn(npc.Position, npc, (npc.Position) + (RandomVector()*20), 217, 2, 0, mod.ColorBrowniePoop);
		local dip = mod.spawnent(npc, npc.Position, RandomVector()*2, id, var)
		if isDross then
			local sprite = dip:GetSprite()
			sprite:ReplaceSpritesheet(0, "gfx/monsters/repentance/floater_turdlet.png")
			sprite:LoadGraphics()
		end
	end
	--big ol puddle of creep
	local creep = Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.CREEP_SLIPPERY_BROWN, 0, npc.Position, Vector(0,0), npc):ToEffect();
	creep.SpriteScale = Vector(5, 4);
	creep:Update();
	--spawn tears
	local tearnumber = math.random(4,8);
	for I = 1, tearnumber, 1 do
		local corncheck = math.random(1,5);
		if corncheck ~= 5 or isDross then
			--normal tear
			--note : WE CAN DEAL WITH THE FUCKIN SPLAT BEING RED LATER BECAUSE I HAVE NO IDEA HOW THE F U C K REV GOT IT WORKING
			local projectile = Isaac.Spawn(EntityType.ENTITY_PROJECTILE, ProjectileVariant.PROJECTILE_PUKE, 0, npc.Position, (RandomVector()*(math.random()+math.random(5,12))), npc):ToProjectile();
			local projdata = projectile:GetData();
			projectile.FallingSpeed = -(math.random(6,15));
			projectile.FallingAccel = math.random(7,13)/10;
			projdata.creeptype = "brown";
			projdata.creepsize = Vector(0.6,0.5);
			projectile:GetSprite():LoadGraphics();
			projectile.SplatColor = mod.ColorBrowniePoop;
		else
			--corn tear, for funsies
			local projectile = Isaac.Spawn(EntityType.ENTITY_PROJECTILE, ProjectileVariant.PROJECTILE_CORN, 0, npc.Position, (RandomVector()*(math.random()+math.random(3,8))), npc):ToProjectile();
			local projdata = projectile:GetData();
			projectile.FallingSpeed = -(math.random(12,20));
			projectile.FallingAccel = math.random(7,10)/10;
			projdata.creeptype = "brown";
			projdata.wormchance = Vector(1,4);
			projdata.wormchecknumber = 2;
			projdata.flychance = Vector(1,2);
		end
	end
	--insects
	local bugnumber = math.random(1,3);
	for I = 1, bugnumber, 1 do
		local bugcheck = math.random(1,6);
		Isaac.Spawn(EntityType.ENTITY_EFFECT, mod.bugtable[bugcheck], 0, npc.Position, (RandomVector()*(math.random()+math.random(5,12))), npc);
	end
	--worms
	bugnumber = math.random(1,2);
	for I = 1, bugnumber, 1 do
		Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.WORM, 0, npc.Position, Vector(0,0), npc);
	end
end

--npc:HasEntityFlags(EntityFlag.FLAG_FEAR) or npc:HasEntityFlags(EntityFlag.FLAG_CONFUSION)

--soft serve ai - an ice cream cone of poo that runs towards the player, breaking apart as it goes on
function mod:softServeAI(npc,sprite,npcdata, var)

--Initialisation
	if not npcdata.initcomplete then
		if not npcdata.scoopnumber then
			npcdata.scoopnumber = 3
		end
		npcdata.running = false
		npc.SplatColor = mod.ColorBrowniePoop
		npcdata.initcomplete = true
		npcdata.confuseangle = math.random(360)
		sprite:Play("appear" .. npcdata.scoopnumber, true);
	end

	npcdata.confuseangle = npcdata.confuseangle + math.random(-30, 30)

--Constants
	if npcdata.initcomplete then
		mod:rancid(npc, 90, 240, 8, mod.rancidtable)
		if npc.FrameCount % (#mod.creepSpawnerCount * 4 - 1) == 0 then
			local creep = Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.CREEP_SLIPPERY_BROWN, 0, npc.Position, Vector(0,0), npc):ToEffect();
			creep:Update();
		end
	end

--Splattering / weight
	if npc:IsDead() then
		if npcdata.scoopnumber ~= 0 then
			mod:softservesplatter(npc)
		end
	elseif ((var == 0 or var > 2) and npc.HitPoints <= (npc.MaxHitPoints/3)) or (var == 1 and npc.HitPoints <= (npc.MaxHitPoints/2)) then					-- If below 1/3 health
		if npcdata.scoopnumber == 3 or npcdata.scoopnumber == 2 then
			mod:softservesplatter(npc);
			npcdata.playpop = 2
			npcdata.running = false
			npcdata.appeareded = true
		end
		npcdata.scoopnumber = 1
		npc.Mass = 14
		npcdata.velocitymax = 9
	elseif (var == 0 or var > 2) and npc.HitPoints <= (npc.MaxHitPoints*(2/3)) then				-- If below 2/3 health
		if npcdata.scoopnumber == 3 then
			mod:softservesplatter(npc);
			npcdata.playpop = 3
			npcdata.running = false
			npcdata.appeareded = true
		end
		npcdata.scoopnumber = 2
		npc.Mass = 17
		npcdata.velocitymax = 7
	else	-- If full health
		if var == 2 then
			npcdata.scoopnumber = 1
			npc.Mass = 14
			npcdata.velocitymax = 9
		elseif var == 1 then
			npcdata.scoopnumber = 2
			npc.Mass = 17
			npcdata.velocitymax = 7
		else
			npcdata.scoopnumber = 3
			npc.Mass = 20
			npcdata.velocitymax = 5
		end
	end

--Movement

	if npcdata.running then

	targetpos = mod:randomConfuse(npc, targetpos)

	--Chase target
		if npc:HasEntityFlags(EntityFlag.FLAG_FEAR) or npc:HasEntityFlags(EntityFlag.FLAG_CONFUSION) then
			local targetvelocity = (targetpos - npc.Position):Normalized() * npcdata.velocitymax
			if npc:HasEntityFlags(EntityFlag.FLAG_FEAR) then
				targetvelocity = targetvelocity * -1
			end
			local lerpy = 0.05
			if npc:HasEntityFlags(EntityFlag.FLAG_CONFUSION) then
				targetvelocity = Vector(npcdata.velocitymax, 0):Rotated(npcdata.confuseangle)
				--lerpy = 0.3
			end
			npc.Velocity = mod:Lerp(npc.Velocity, targetvelocity, lerpy)
		else
			mod:CatheryPathFinding(npc, targetpos, {
			Speed = npcdata.velocitymax,
			Accel = 0.05,
			GiveUp = true
			})
		end

	end
	--Animate

	if npcdata.appeareded then
		if npcdata.playpop then

			if sprite:IsFinished("pop2") or sprite:IsFinished("pop3") then
				npcdata.playpop = false
				npcdata.running = true
			elseif npcdata.playpop == 2 then
				mod:spritePlay(sprite, "pop2")
			elseif npcdata.playpop == 3 then
				mod:spritePlay(sprite, "pop3")
			end

		elseif npcdata.running then
			if npc.Velocity:Length() > 0.1 then
			mod:spritePlay(sprite, "move" .. npcdata.scoopnumber)
			else
				mod:spritePlay(sprite, "idle" .. npcdata.scoopnumber)
			end
		else
			if not sprite:IsPlaying("idle" .. npcdata.scoopnumber) then
				sprite:Play("idle" .. npcdata.scoopnumber, true);
			end
		end
	else
		if sprite:IsFinished("appear" .. npcdata.scoopnumber) then
			npcdata.appeareded = true
		else
			if not sprite:IsPlaying("appear" .. npcdata.scoopnumber) then
				sprite:Play("appear" .. npcdata.scoopnumber, true);
			end
		end
	end
	--Target Selection
	local target = npc:GetPlayerTarget()
	if target and not npcdata.playpop and npcdata.appeareded then
		targetpos = target.Position
		npcdata.running = true
	else
		targetpos = npc.Position
		npcdata.running = false
	end
end

--npc:HasEntityFlags(EntityFlag.FLAG_FEAR) or npc:HasEntityFlags(EntityFlag.FLAG_CONFUSION)

--load ai - a massive pile of poo that spits an ipecac-esque turdball at isaac
function mod:loadai(npc, sprite, npcdata, var)
	--aesthetics
	mod:rancid(npc, 60, 180, 8, mod.rancidtable)
	--movement code
	local target = npc:GetPlayerTarget().Position;
	--initialize variables
	if not npcdata.init then
		npcdata.angle = math.atan((target.Y-npc.Position.Y)/(target.X-npc.Position.X));
		npcdata.anglevel = 0;
		npcdata.state = "move";
		npcdata.heavytimer = 0;
		npcdata.heavyangle = math.random(0,359);
		npcdata.heavypositionlast = npc.Position;
			if var == 11 then
			npcdata.shotdelay = math.random(0,60);
			else
			npcdata.shotdelay = math.random(0,120);
			end
		npcdata.npcstate = "slide";
		npcdata.init = true
		if npc.State ~= 11 then
			npc.State = 4
		end
		if var == mod.FF.CornLoad.Var then
			npc.SplatColor = mod.ColorBrowniePoop
		else
			npc.SplatColor = mod.ColorPoop
		end
		npcdata.StateFrame = 0
		npcdata.waitwhat = 0
		if npc.Variant == 10 then
			npc:SetSize(24, Vector(1, 0.75), 36);
		end
	end
	--event handling
	if (sprite:IsEventTriggered("splurchnoise")) then
		npc:PlaySound(SoundEffect.SOUND_MEAT_JUMPS,1,2,false,0.7)
	end
	if (sprite:IsEventTriggered("vomit")) then
		npc:PlaySound(SoundEffect.SOUND_BOSS_SPIT_BLOB_BARF,1,2,false,1.3)
		local constant = 0.025
		local shotspeed = Vector(target.X-npc.Position.X, target.Y-npc.Position.Y)*constant
		--fire the projectile
		local projvar
		if var == 11 then projvar = 5 else projvar = 3 end
		local projectile = Isaac.Spawn(EntityType.ENTITY_PROJECTILE, projvar, 0, npc.Position, shotspeed, npc):ToProjectile();
		local projdata = projectile:GetData();
		projectile.FallingSpeed = -45;
		projectile.FallingAccel = 1.5;
		projectile.Scale = 2;
		projdata.special = "loadshot";
		if var == 11 then
			projectile.Scale = 2
			projdata.special2 = true
		end
		--spawn some flies for funsies
		local flynumber = math.random(3,5);
		for i=1, flynumber, 1 do
			Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.TINY_FLY, 0, npc.Position, Vector((math.random()+math.random(3,5)),0):Rotated(math.random(0,359)), npc);
		end

	end

	if npc:IsDead() then
		npc.State = 17
	end

	if npc.State == 17 then
		npc.Velocity = nilvector;
		if sprite:IsFinished("death") then
			for i = 1, 15 do
				local bugcheck = math.random(1,6);
				Isaac.Spawn(EntityType.ENTITY_EFFECT, mod.bugtable[bugcheck], 0, npc.Position, (RandomVector()*(math.random()+math.random(5,12))), npc);
			end
			npc:Kill()
		elseif not sprite:IsPlaying("death") then
		sprite:Play("death", true);
		end
	elseif npc.State == 4 then
		npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_ALL
		if npcdata.npcstate == "slide" then
			npcdata.StateFrame = npcdata.StateFrame + 1
			if npc:HasEntityFlags(EntityFlag.FLAG_FEAR) or npc:HasEntityFlags(EntityFlag.FLAG_CONFUSION) then
				npcdata.StateFrame = npcdata.StateFrame - 1
			end
			if var == 11 then
				mod:heavymovement(npc, npcdata, 2, 0.01, 30, 90)
			else
				mod:heavymovement(npc, npcdata, 0.75, 0.05, 60, 180);
			end

			if npc:HasEntityFlags(EntityFlag.FLAG_FEAR) then
				local vec = (target - npc.Position + RandomVector():Resized(1.5)):Resized(-2.5)
				npc.Velocity = mod:Lerp(npc.Velocity, vec, 0.2)
			end

			if npcdata.StateFrame > npcdata.waitwhat + npcdata.shotdelay then
				npcdata.npcstate = "fire";
				npcdata.waitwhat = 60
				if var == 11 then
					npcdata.shotdelay = math.random(0,60);
				else
					npcdata.shotdelay = math.random(0,60);
				end
			end
			if not sprite:IsPlaying("idle") then
				sprite:Play("idle", true);
			end
		elseif npcdata.npcstate == "fire" then
			if sprite:IsFinished("fire") then
					npcdata.npcstate = "slide";
					npcdata.StateFrame = 0
					sprite:SetFrame("idle", 1);
			elseif not sprite:IsPlaying("fire") then
				sprite:Play("fire", true);
			end
			--slow down!
			if var == 11 then
				npc.Velocity = npc.Velocity * 0.8
			else
				npc.Velocity = npc.Velocity * 0.33;
			end
		end
	end
	if var == 11 then
	npc.Friction = 1.2
	if npc.FrameCount % (#mod.creepSpawnerCount * 5 + 5) == 1 then
		local creep = Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.CREEP_SLIPPERY_BROWN, 0, npc.Position, nilvector, npc):ToEffect();
			creep.SpriteScale = Vector(2, 1.5);
			creep:Update()
		end
	end
end

function mod:baroai(npc, sprite, d)
local target = npc:GetPlayerTarget()
	if not d.init then
		d.npcstate = "idle"
		--npc.SplatColor = Color(0,0,0,1,20 / 255,10 / 255,10 / 255);
		npc.SplatColor = Color(0.7,0.7,0.7)
		d.extrawait = mod:RandomInt(-80,-40)
		d.init = true
		d.targetvelocity = ((target.Position - npc.Position):Normalized()*2):Rotated(-50+math.random(100))
	elseif d.init then
		npc.Velocity = (d.targetvelocity * 0.3) + (npc.Velocity * 0.7)
		d.targetvelocity = d.targetvelocity * 0.99
	end


	if npc.State == 17 then
		npc.Velocity = nilvector
		if sprite:IsFinished("Death") then
			npc:Kill()
			--mod.spawnent(npc, npc.Position, nilvector, 281, 0)
			Isaac.Spawn(281, 0, 0, npc.Position, nilvector, npc);
			for i = 1, 10 do
				local bugcheck = math.random(1,6)
				Isaac.Spawn(EntityType.ENTITY_EFFECT, mod.bugtable[bugcheck], 0, npc.Position, (RandomVector()*(math.random()+math.random(5,12))), npc);
			end
		elseif not sprite:IsPlaying("Death") then
			sprite:Play("Death", true)
		end
	else
		npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_ALL
		if d.npcstate == "idle" then
			if not sprite:IsPlaying("Idle")
				then sprite:Play("Idle")
			end
			if npc.StateFrame > 80 + d.extrawait and not mod:isScareOrConfuse(npc) then
				if mod.GetEntityCount(281) + mod.GetEntityCount(222) > 10 then
					npc.StateFrame = 40
					d.targetvelocity = mod:reverseIfFear(npc, ((mod:confusePos(npc, target.Position) - npc.Position):Normalized()*2):Rotated(-50+math.random(100)))
				elseif not mod:isScareOrConfuse(npc) then
					sprite:Play("Shoot")
					npc:PlaySound(SoundEffect.SOUND_RAGMAN_3 ,1,2,false,0.9)
					d.npcstate = "attack"
				end
			end

		elseif d.npcstate == "attack" then
			if sprite:IsEventTriggered("shoot") then
				npc:PlaySound(SoundEffect.SOUND_MONSTER_ROAR_0,1,2,false,0.8)
				for i = 1, 15 do
					local bugcheck = math.random(1,6);
					Isaac.Spawn(EntityType.ENTITY_EFFECT, mod.bugtable[bugcheck], 0, npc.Position, (RandomVector()*(math.random()+math.random(5,12))), npc);
				end
				local targcoord = mod:intercept(npc, target, 50)
				local shootvec = targcoord:Normalized() * 13
				--mod.cheekyspawn(npc.Position + shootvec:Resized(10), npc, npc.Position + shootvec:Resized(13), 950, 2, 0)
				if math.random(3) == 1 then
					local flyball = mod.spawnent(npc, npc.Position + shootvec:Resized(10), shootvec, mod.FF.FlyBundle.ID, mod.FF.FlyBundle.Var, mod.FF.FlyBundleRing.Sub)
					flyball:GetSprite():Load("gfx/projectiles/flyball_ring.anm2",true)
					flyball:GetData().Vel = shootvec
				else
					local flyball = mod.spawnent(npc, npc.Position + shootvec:Resized(10), shootvec, mod.FF.FlyBundle.ID, mod.FF.FlyBundle.Var)
					flyball:GetSprite():Load("gfx/projectiles/flyball_swarm.anm2",true)
					flyball:GetData().Vel = shootvec
				end
			end
			if sprite:IsFinished("Shoot") then
				d.npcstate = "idle"
				d.targetvelocity = mod:reverseIfFear(npc, ((mod:confusePos(npc, target.Position) - npc.Position):Normalized()*2):Rotated(-50+math.random(100)))
				npc.StateFrame = 0
				d.extrawait = mod:RandomInt(30,60)
			end
		end
	end
	npc.StateFrame = npc.StateFrame + 1
end

--mod.baronum = {2, 2, 2, 3, 3, 3, 3}
mod.baronum = {3, 3, 3, 4, 4, 5}
mod.flakflies = {}

--flyballAI
function mod.flakCannonFlyAI(v)
	local d = v:GetData()
	local sprite = v:GetSprite()
	local target = v:GetPlayerTarget()
	v.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_WALLS
	v.Velocity = d.Vel or v.Velocity
	if v.State == 11 then
	local vec = RandomVector()
	local ran = math.random(#mod.baronum)
	local num = mod.baronum[ran]
		for i = 1, num do
			local g = math.random(30)
			local spawnVar = 281
			if v.SubType == 1 then
				spawnVar = 222
			end
			local fly = mod.cheekyspawn(v.Position + vec:Rotated((360 / num) * i - 15 + g) * 15, v, v.Position + vec:Rotated((360 / num) * i + g) * 100, spawnVar, 0, 0)
			fly.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS
		end
	v:Kill()
	elseif target then
		if not sprite:IsPlaying("Idle") then
			sprite:Play("Idle")
		end
		local speed = 13 - 0.03 * v.FrameCount
		v.Velocity = v.Velocity:Resized(math.max(0.2,speed))
		if v.FrameCount > 50 or v:CollidesWithGrid() then v:TakeDamage(1, 0, EntityRef(target), 0) end
	else
		v:TakeDamage(1, 0, EntityRef(target), 0)
	end

end

--bone worm ai - round worm alt that shoots in a + then x
--npc:HasEntityFlags(EntityFlag.FLAG_FEAR) or npc:HasEntityFlags(EntityFlag.FLAG_CONFUSION)
function mod:bonewormai(npc, sprite, npcdata)
	if not npcdata.Init then
		npc:AddEntityFlags(EntityFlag.FLAG_NO_BLOOD_SPLASH)
		npcdata.Init = true
	end
	if npc:HasEntityFlags(EntityFlag.FLAG_FEAR) or npc:HasEntityFlags(EntityFlag.FLAG_CONFUSION) then
		if sprite:IsPlaying("DigOut") and sprite:GetFrame() == 32 then
			mod:spritePlay(sprite, "DigIn")
			npc.State = 6
		end
	end
	--print(tostring(npc.State))
	if sprite:IsEventTriggered("shootplus") then
		npc:PlaySound(SoundEffect.SOUND_BOIL_HATCH,0.7,0,false,1)
		local params = ProjectileParams()
		params.Variant = ProjectileVariant.PROJECTILE_BONE
		npc:FireProjectiles(npc.Position, Vector(10,0), 6, params)
	end
	if sprite:IsEventTriggered("shootx") then
		npc:PlaySound(SoundEffect.SOUND_BOIL_HATCH,1,0,false,1)
		local params = ProjectileParams()
		params.Variant = ProjectileVariant.PROJECTILE_BONE
		npc:FireProjectiles(npc.Position, Vector(10,0), 7, params)
	end
end

--wetstone ai - spits bubbles around in a consstant stream
--bubble grimace
function mod:wetstoneai(npc, sprite, npcdata)
	--stay in place
	npc:AddEntityFlags(EntityFlag.FLAG_NO_TARGET | EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK)
	npc.Velocity = nilvector

	--Isaac.ConsoleOutput(npc.State .. "\n")

	if npc.State ~= 16 then
		npc.State = 0
		npcdata.started = true
		--if active and bubbling, shoot bubbles
		if sprite:IsPlaying("bubble") then
			if not npcdata.bubbletimerset then
				npcdata.bubbletimer = math.random(20,30)
				npcdata.closeeyestimer = 18
				npcdata.bubbletimerset = true
			else
				npcdata.bubbletimer = npcdata.bubbletimer - 1;
			end
			if npcdata.bubbletimer <= 0 then
				--[[local bubblenumber = math.random(1,5)
				local randangle = 0
				--if bubblenumber >= 3 then
					for i = 1, bubblenumber-2, 1 do
						randangle = math.random(0,359)
						mod.ShootBubble(npc, -1, npc.Position + Vector(5,0):Rotated(randangle),Vector((math.random(20,40)/25),0):Rotated(randangle))
					end
				else
					randangle = math.random(0,359)
					mod.ShootBubble(npc, -1, npc.Position + Vector(5,0):Rotated(randangle),Vector((math.random(20,40)/100),0):Rotated(randangle))
				end]]
				randangle = math.random(0,359)
				mod.ShootBubble(npc, -1, npc.Position + Vector(5,0):Rotated(randangle),Vector((math.random(20,40)/25),0):Rotated(randangle))
				npcdata.bubbletimer = math.random(20,30)
			end
		end
		--shut down on room clear
		if not sprite:IsPlaying("bubble")then
			sprite:Play("bubble", true);
		end
	elseif npc.State == 16 then
		if npcdata.started then
		sprite:Play("CloseEyes", true)
		npcdata.started = nil
		end
		if sprite:IsFinished("CloseEyes") then
		sprite:Play("ClosedEyes", true)
		end
	end
end

--cistern ai - hive but bubbles. We all know what's up.
function mod:cisternai(npc, sprite, npcdata)
local overlayFrame = sprite:GetOverlayFrame()
local target = npc:GetPlayerTarget()
local r = npc:GetDropRNG()
local room = game:GetRoom()
Isaac.DebugString(npc.State)
Isaac.DebugString(npc.FrameCount)
	npcdata.fuckoff = true

	--attack cooldown
		if sprite:IsOverlayPlaying("HeadAttack") and sprite:GetOverlayFrame() < 1 then
			npc.V1 = Vector(130, npc.V1.Y)
		end
	--despawn all flies
	for _, entity in ipairs(Isaac.GetRoomEntities()) do
		if entity.SpawnerType == npc.Type and entity.SpawnerVariant == npc.Variant then
			if entity.Type == EntityType.ENTITY_FLY or entity.Type == EntityType.ENTITY_ATTACKFLY or entity.Type == EntityType.ENTITY_POOTER then
				entity:Remove()
			end
		end
	end
	if npc.State == NpcState.STATE_ATTACK then
		if overlayFrame == 0 then
			if sfx:IsPlaying(SoundEffect.SOUND_WHEEZY_COUGH) then
				sfx:Stop(SoundEffect.SOUND_WHEEZY_COUGH)
				npc:PlaySound(mod.Sounds.CisternAttack, 1, 0, false, math.random(90,110)/100)
			end
		elseif overlayFrame == 5 then
			local vec = (target.Position - npc.Position):Normalized()
				if (#Isaac.FindByType(mod.FF.BubbleFly.ID, mod.FF.BubbleFly.Var, mod.FF.BubbleFly.Sub, false, false)
				+ #Isaac.FindByType(mod.FF.BubbleSpider.ID, mod.FF.BubbleSpider.Var, mod.FF.BubbleSpider.Sub, false, false)
				+ #Isaac.FindByType(EntityType.ENTITY_ATTACKFLY, 0, 0, false, false)
				+ #Isaac.FindByType(EntityType.ENTITY_SPIDER, 0, 0, false, false)
				) >= 6 then
					mod.ShootBubble(npc, 3, npc.Position+vec*5, vec*(math.random(55,75)/20))
				else
					mod.ShootBubble(npc, 3+math.random(2), npc.Position+vec*5, vec*(math.random(55,75)/20))
				end
			for i = 1, 2 do
				mod.ShootBubble(npc, math.random(2)-1, npc.Position+vec:Rotated(-30+i*20)*5, vec:Rotated(-15+i*10)*(math.random(55,75)/20))
			end
		end
	end

	--bubble on death
	if npc:IsDead() then
		local bubblenumber = math.random (5,9)
		local randangle = 0
		for i=1, bubblenumber, 1 do
			randangle = math.random(0,359)
			mod.ShootBubble(npc, -1, npc.Position + Vector(5,0):Rotated(randangle),Vector((math.random(20,40)/20),0):Rotated(randangle))
		end
	end

	if sfx:IsPlaying(SoundEffect.SOUND_SCARED_WHIMPER) then
		sfx:Stop(SoundEffect.SOUND_SCARED_WHIMPER)
		npc:PlaySound(mod.Sounds.CisternWhimper, 1, 0, false, math.random(90,110)/100)
	end
end

--drowned hive don''t fucking replace my men
function mod:drownedhivedontnt(npc, npcdata)
	if npcdata.fuckoff then
		npc:Morph(22, 666, 0, -1);
	end
end

--takin a stab at this
function mod:weaverminiAI(npc,sprite,npcdata)
	if npcdata.init == false then
		npcdata.groundstate = "under"
		npcdata.timeaboveground = 0
		npcdata.init = true
	end
	--if underground, go towards the target and jump out when velocity high enough to intersect while leaping and in a generally good angle, LEAP
	if npcdata.groundstate == "under" then
		local target = npc:GetPlayerTarget()
		lustymove(npc, npcdata, target, 0.5, 3)
		--the hard part: checkin if hes actually gonna leap
		local velocityangle = 0;
		if npc.Velocity.X == 0 then
			velocityangle = 0;
		else
			velocityangle = math.atan((npc.Velocity.Y)/(npc.Velocity.X));
			velocityangle = math.deg(velocityangle);
		end
		local playerangle = GetAngleDegrees(npc.Position, target)
		local distanceplayer = Distance(npc.Position, target)
		local velocitytotal = math.sqrt(((npc.Velocity.X)^2)+((npc.Velocity.Y)^2));
		if (velocityangle <= playerangle - 15) and (velocityangle >= playerangle - 15) and (distanceplayer <= velocitytotal * 50) then
			npcdata.groundstate = "over"
		end
	--leap following a parabolic arc
	elseif npcdata.groundstate == "over" then
		npcdata.timeaboveground = npcdata.timeaboveground + 1
		--npc.SpriteOffset = Vector(0, (-0.048((npcdata.timeaboveground) - 25)) + 30)
		if npc.SpriteOffset <= 0 then
			npcdata.groundstate = "under"
			npcdata.timeaboveground = 0
		end
	end
end

--weh... tubbyai
function mod:wehai(npc, sprite, npcdata)
	local target = npc:GetPlayerTarget()
	local randangle = 0
	Isaac.DebugString(npc.State)
	if npcdata.stomps == nil then
		npcdata.stomps = 0
	end
	if sprite:IsEventTriggered("Shoot") then
		local bubblenumber = math.random(3,6)
		for i = 1, bubblenumber, 1 do
			randangle = math.random(0,359)
			mod.ShootBubble(npc, -1, npc.Position + Vector(5,0):Rotated(randangle),Vector((math.random(30,40)/10),0):Rotated(randangle))
		end
	elseif (sprite:IsEventTriggered("StompLeft") and not sprite.FlipX) or (sprite:IsEventTriggered("StompRight") and sprite.FlipX) then
	local effect = Isaac.Spawn(1000,7002,0,npc.Position+Vector(-26,-5),nilvector,nil)
	npc:PlaySound(mod.Sounds.SplashSmall,2.5,0,false,1)
		local tearnumber = math.random(3,6)
		for i = 1, tearnumber, 1 do
			randangle = math.random(60) - 30
			rotval = ((360 / tearnumber) * i) + randangle
			local projectile = Isaac.Spawn(EntityType.ENTITY_PROJECTILE, 4, 0, npc.Position+Vector(-23,0), Vector(math.random() * math.random(5,7), 0):Rotated(rotval), npc):ToProjectile();
			local projdata = projectile:GetData();
			projectile.FallingSpeed = -(math.random(6,15));
			projectile.FallingAccel = math.random(7,13)/10;
		end
	elseif (sprite:IsEventTriggered("StompLeft") and sprite.FlipX) or (sprite:IsEventTriggered("StompRight") and not sprite.FlipX) then
		local effect = Isaac.Spawn(1000,7002,0,npc.Position+Vector(24,-5),nilvector,nil)
		npc:PlaySound(mod.Sounds.SplashSmall,2.5,0,false,1)
		local tearnumber = math.random(3,6)
		for i = 1, tearnumber, 1 do
			randangle = math.random(60) - 30
			rotval = ((360 / tearnumber) * i) + randangle
			local projectile = Isaac.Spawn(EntityType.ENTITY_PROJECTILE, 4, 0, npc.Position+Vector(23,0), Vector(math.random(20, 100)/100 * math.random(5,7), 0):Rotated(rotval), npc):ToProjectile();
			local projdata = projectile:GetData();
			projectile.FallingSpeed = -(math.random(6,15));
			projectile.FallingAccel = math.random(7,13)/10;
		end
	end
	--Not needed??
	--[[if sprite:GetFrame() == 1 and ( sprite:IsPlaying("AttackVert") or sprite:IsPlaying("AttackHori") ) then
		local randnum = math.random(1,3)
		if randnum == 1 then
			sprite:Play("StompStart", 1)
		end
	end]]
	if npc.State == 4 then
		local targdist = npc.Position:Distance(target.Position)
		--Isaac.DebugString(targdist)
		local ranval = math.max(2, math.ceil(targdist / 3))
		if targdist < 120 and math.random(ranval) == 1 and not mod:isScareOrConfuse(npc) then
			npc.State = 8
			sprite:Play("StompStart", 1)
		end
	end
	if sprite:IsEventTriggered("stompendloopcheck") then
		local randnum = math.random(1,3)
		if (randnum + npcdata.stomps) >= 4 then
			npcdata.stomps = 0
			npc.State = 4
		else
			npcdata.stomps = npcdata.stomps + 1
			sprite:Play("StompLoop", 1)
		end
	end
end

--chorister: sing man
function mod:choristerai(npc,sprite,npcdata)
	local room = game:GetRoom()
	local path = npc.Pathfinder
	local target = npc:GetPlayerTarget()
	local targetpos = mod:confusePos(npc, target.Position)
	npc.SplatColor = Color(0,0,0,1,91 / 255,229 / 255,220 / 255);
	--init
	if not npcdata.trueinit then
		--spawn the godhead aura
		--local aura = mod.spawnent(npc, (npc.Position + Vector(0, -10)), npc.Velocity, 1000, 666, 0):ToEffect()
		--[[local aura = Isaac.Spawn(1000, 666, 0, npc.Position + Vector(0, -10), nilvector, npc):ToEffect()
		aura:FollowParent(npc)
		aura:Update()]]
		npcdata.trueinit = true
	end
	if not npcdata.init then
		npcdata.state = "move"
		npcdata.countdown = math.random (60, 180)
		npcdata.init = true
		npcdata.loopanim = false
	else
		npc.StateFrame = npc.StateFrame + 1
	end
	--main ai
	if npcdata.state == "move" then
		--set target for pathfinding
		--if you dont check this the game crashes
		if npc.FrameCount > 25 and not room:CheckLine(npc.Position,targetpos,0,1,false,false) then
			path:FindGridPath(targetpos, 0.5, 900, true)
		else
			npcdata.targetvelocity = mod:reverseIfFear(npc, (targetpos - npc.Position):Resized(3))
			npc.Velocity = mod:Lerp(npc.Velocity, npcdata.targetvelocity, 0.2)
		end
		--play animations
		if npc.Velocity:Length() > 0.1 then
			if math.abs(npc.Velocity.X) > math.abs(npc.Velocity.Y) then
				if npc.Velocity.X > 0 then
					mod:spritePlay(sprite, "WalkHori")
				else
					mod:spritePlay(sprite, "WalkHoriFlip")
				end
			else
				mod:spritePlay(sprite, "WalkVert")
			end
		else
			sprite:SetFrame("WalkVert", 0)
		end
		--countdown for sing
		if npcdata.countdown > 0 then
			npcdata.countdown = npcdata.countdown - 1
		else
			if (not mod:isScareOrConfuse(npc)) and (npc.Position - targetpos):LengthSquared() <= 120 ^ 2 then
				npcdata.state = "singprep"
			end
		end
	elseif npcdata.state == "singprep" then
		--slow down
		npc.Velocity = npc.Velocity * 0.8
		--sprite logic
		mod:spritePlay(sprite, "SingStart")
		if sprite:IsEventTriggered("singstart") then
			npcdata.state = "sing"
		end
	elseif npcdata.state == "sing" then
		--makesure man dont FLY
		npc.Velocity = npc.Velocity * 0.8
		--check if start on the loop
		if sprite:IsEventTriggered("singloopstart") then
			npc:PlaySound(SoundEffect.SOUND_UNHOLY, 1.4, 0, false, math.random(110,130)/100)
			npcdata.loopanim = true
			npcdata.shootOuts = 0
			npc.StateFrame = 0
		end
		--sprite logic
		if npcdata.loopanim then
			mod:spritePlay(sprite, "SingLoop")
			if npc.StateFrame % 10 == 1 and npcdata.shootOuts < 3 then
				for i = 90, 360, 90 do
					local pos = npc.Position + Vector(25 + 25 * npcdata.shootOuts, 0):Rotated(i + 45 * npcdata.shootOuts)
					local beam = Isaac.Spawn(1000, 19, 0, pos, nilvector, npc):ToEffect()
					beam.Parent = npc
					beam.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYERONLY
					beam:Update()
				end
				npcdata.shootOuts = npcdata.shootOuts + 1
			end

			if npc.StateFrame > 40 then
				npcdata.state = "singend"
			end
		else
			mod:spritePlay(sprite, "SingStart")
		end
	elseif npcdata.state == "singend" then
		--makesure man dont FLY
		npc.Velocity = npc.Velocity * 0.8
		mod:spritePlay(sprite, "SingEnd")
		if sprite:IsEventTriggered("gobacktowalk") then
			npcdata.state = "move"
			npcdata.init = false
		end
	end
end

--choriseter's woobly aura
function mod:choristerauraai(npc)
	local sprite = npc:GetSprite();
	local parentsprite = npc.Parent:GetSprite();
	local npcdata = npc:GetData();
	local parentnpcdata = npc.Parent:GetData();
	if not npcdata.init then
		npcdata.bigness = 0
		npcdata.init = true
		npc.SpriteScale = nilvector
		npcdata.sizeupcounter = 0
		npcdata.sizedowncounter = 0
		npc.Color = Color(1,1,1,0.6,0,0,0)
	end
	if npc.Parent:IsDead() then
		npc:Remove()
	else
		--handle how big the
		if parentsprite:IsPlaying("WalkHori") or parentsprite:IsPlaying("WalkVert") then
			npcdata.bigness = 0
		end
		if parentsprite:IsEventTriggered("singstart") then
			npcdata.sizeupcounter = 8
		elseif parentsprite:IsEventTriggered("singend") then
			npcdata.sizedowncounter = 20
		end
		if npcdata.sizeupcounter > 0 then
			npcdata.bigness = npcdata.bigness + 0.625
			npcdata.sizeupcounter = npcdata.sizeupcounter - 1
		end
		if npcdata.sizedowncounter > 0 then
			npcdata.bigness = npcdata.bigness - 0.25
			npcdata.sizedowncounter = npcdata.sizedowncounter - 1
		end
		mod:spritePlay(sprite, "idle")
		npc.SpriteScale = Vector(npcdata.bigness, npcdata.bigness)
		--handle damage
		for i = 1, game:GetNumPlayers() do
			local player = Isaac.GetPlayer(i - 1)
			if (npc.Position - player.Position):LengthSquared() <= (npcdata.bigness * 20) ^ 2 then
				player:TakeDamage(1, 0, EntityRef(player), 0)
			end
		end
		--todo: add special case if charmed
	end
end

function mod:HijackedChoristerAura(effect)
	if effect.SubType == 170 then
		mod:blackMoonAura(effect)
	elseif effect.SubType == 171 then
		mod:blackMoonMiddle(effect)
	else
		mod:choristerauraai(effect)
	end
end

mod:AddCallback(ModCallbacks.MC_POST_EFFECT_UPDATE, mod.HijackedChoristerAura, 666)

function mod:nimbusai(npc, sprite, npcdata)
	local target = npc:GetPlayerTarget()
	--walk anim init
	if npcdata.horicheck == nil then
		npcdata.horicheck = true
		npcdata.walkleft = false
		npcdata.walkframe = 0
		npcdata.firing = "none"
		npcdata.cloudtimer = math.random(60, 120)
	end
	--check walking direction
	if npcdata.horicheck == true then
		if sprite:IsPlaying("Move Hori") then
			if npc.Velocity.X < 0 then
				npcdata.walkleft = true
			end
		end
		npcdata.horicheck = false
	end
	--play the fucking walk anim aaaaaaaaa
	if npcdata.walkleft == true then
		sprite:SetFrame("Move Hori 2", npc.FrameCount % 22)
		npcdata.walkframe = npcdata.walkframe + 0
		if npcdata.walkframe >= 22 then
			npcdata.walkframe = 0
		end
	end
	if not (sprite:IsPlaying("Move Hori") or sprite:IsPlaying("Move Hori 2")) then
		npcdata.horicheck = true
		npcdata.walkframe = 0
		npcdata.walkleft = false
	end
	--handle angle
	local anglebetween = (target.Position - npc.Position):GetAngleDegrees()
	if anglebetween <= -175 or anglebetween >= 175 then
		npcdata.anglecheck = 180
	elseif anglebetween <= 95 and anglebetween >= 85 then
		npcdata.anglecheck = 270
	elseif anglebetween <= 5 and anglebetween >= -5 then
		npcdata.anglecheck = 0
	elseif anglebetween <= -85 and anglebetween >= -95 then
		npcdata.anglecheck = 90
	else
		npcdata.anglecheck = 666
	end
	--get it to fire the
	local distancebetween = (target.Position - npc.Position):Length()
	local maxdistance = 150
	npcdata.cloudtimer = npcdata.cloudtimer - 1
	if npc.State == 4 then
		if npcdata.cloudtimer <= 0 and not (npc:HasEntityFlags(EntityFlag.FLAG_FEAR) or npc:HasEntityFlags(EntityFlag.FLAG_CONFUSION)) then
			if sprite:IsPlaying("Move Down") then
				if npcdata.anglecheck == 270 then
					npcdata.firing = "down"
					npc.State = 10
					npc.Velocity = Vector(0,0)
				elseif distancebetween <= maxdistance then
					if npcdata.anglecheck == 0 then
						npcdata.firing = "right"
						npc.State = 10
						npc.Velocity = Vector(0,0)
					elseif npcdata.anglecheck == 180 then
						npcdata.firing = "left"
						npc.State = 10
						npc.Velocity = Vector(0,0)
					end
				end
			elseif sprite:IsPlaying("Move Up") then
				if npcdata.anglecheck == 90 then
					npcdata.firing = "up"
					npc.State = 10
					npc.Velocity = Vector(0,0)
				elseif distancebetween <= maxdistance then
					if npcdata.anglecheck == 0 then
						npcdata.firing = "right"
						npc.State = 10
						npc.Velocity = Vector(0,0)
					elseif npcdata.anglecheck == 180 then
						npcdata.firing = "left"
						npc.State = 10
						npc.Velocity = Vector(0,0)
					end
				end
			elseif sprite:IsPlaying("Move Hori") then
				if npcdata.anglecheck == 0 then
					npcdata.firing = "right"
					npc.State = 10
					npc.Velocity = Vector(0,0)
				elseif distancebetween <= maxdistance then
					if npcdata.anglecheck == 270 then
						npcdata.firing = "down"
						npc.State = 10
						npc.Velocity = Vector(0,0)
					elseif npcdata.anglecheck == 90 then
						npcdata.firing = "up"
						npc.State = 10
						npc.Velocity = Vector(0,0)
					end
				end
			end
			if npc.Velocity.X < 0 then
				if math.abs(npc.Velocity.X) > math.abs(npc.Velocity.Y) then
					if npcdata.anglecheck == 180 then
						npcdata.firing = "left"
						npc.State = 10
						npc.Velocity = Vector(0,0)
					elseif distancebetween <= maxdistance then
						if npcdata.anglecheck == 270 then
							npcdata.firing = "down"
							npc.State = 10
							npc.Velocity = Vector(0,0)
						elseif npcdata.anglecheck == 90 then
							npcdata.firing = "up"
							npc.State = 10
							npc.Velocity = Vector(0,0)
						end
					end
				end
			end
		end
	end
	--play the anim
	if npc.State == 10 then
		npc.Velocity = mod:Lerp(npc.Velocity, Vector(0,0), 0.2)
		if npcdata.firing == "down" then
		mod:spritePlay(sprite, "Shoot Down")
		elseif npcdata.firing == "up" then
		mod:spritePlay(sprite, "Shoot Up")
		elseif npcdata.firing == "right" then
		mod:spritePlay(sprite, "Shoot Hori")
		sprite.FlipX = false
		elseif npcdata.firing == "left" then
		mod:spritePlay(sprite, "Shoot Hori 2")
		sprite.FlipX = true
		end
	end
	if sprite:IsEventTriggered("back") then
		npc.State = 4
		npcdata.cloudtimer = math.random(60, 120)
	end
	--spawn cloud
	local cloudvelocity = nilvector
	local velnum = 2.5
	if sprite:IsEventTriggered("clouddown") then
		npc:PlaySound(mod.Sounds.NimbusShoot,3,0,false,(math.random(10,12))*0.1)
		cloud = mod.spawnent(npc, npc.Position, cloudvelocity, mod.FF.NimbusCloud.ID, mod.FF.NimbusCloud.Var, npc.SubType, 0):ToNPC()
		cloud.Velocity = Vector(0, velnum)
		cloud:GetSprite().Offset = Vector(0, 75)
		cloud:Update()
	elseif sprite:IsEventTriggered("cloudup") then
		npc:PlaySound(mod.Sounds.NimbusShoot,3,0,false,(math.random(10,12))*0.1)
		cloud = mod.spawnent(npc, npc.Position, cloudvelocity, mod.FF.NimbusCloud.ID, mod.FF.NimbusCloud.Var, npc.SubType, 0):ToNPC()
		cloud.Velocity = Vector(0, -velnum)
		cloud:GetSprite().Offset = Vector(0, 75)
		cloud:Update()
	elseif sprite:IsEventTriggered("cloudright") then
		npc:PlaySound(mod.Sounds.NimbusShoot,3,0,false,(math.random(10,12))*0.1)
		cloud = mod.spawnent(npc, npc.Position, cloudvelocity, mod.FF.NimbusCloud.ID, mod.FF.NimbusCloud.Var, npc.SubType, 0):ToNPC()
		cloud.Velocity = Vector(velnum, 0)
		cloud:GetSprite().Offset = Vector(0, 75)
		cloud:Update()
	elseif sprite:IsEventTriggered("cloudleft") then
		npc:PlaySound(mod.Sounds.NimbusShoot,3,0,false,(math.random(10,12))*0.1)
		cloud = mod.spawnent(npc, npc.Position, cloudvelocity, mod.FF.NimbusCloud.ID, mod.FF.NimbusCloud.Var, npc.SubType, 0):ToNPC()
		cloud.Velocity = Vector(-velnum, 0)
		cloud:GetSprite().Offset = Vector(0, 75)
		cloud:Update()
	end
	--play idle sound
	if npcdata.soundplay == nil then
		npcdata.soundplay = math.random(60, 90)
	end
	npcdata.soundplay = npcdata.soundplay - 1
	if npcdata.soundplay <= 0 then
		if npc.State == 4 then
			npc:PlaySound(mod.Sounds.NimbusSigh,10,0,false,(math.random(7,10))*0.1)
		end
		npcdata.soundplay = math.random(90, 360)
	end
	rooments = Isaac.GetRoomEntities()
	roomentlength = #rooments
	for othernpc = 1, 0 do
		if othernpc.Type == 21 and othernpc.Variant == 666 then
			if othernpc.npcdata.soundplay <= 0 then
				if othernpc.State == 4 then
					npcdata.soundplay = math.random(90, 360)
				end
			end
		end
	end
end

function mod:nimbuscloudai(npc, subt)

	local tear_spawn_delay = 10
	local sprite = npc:GetSprite();
	local npcdata = npc:GetData();
	--init the thing
	if npcdata.raincount == nil then
		npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
		npcdata.raincount = math.random(tear_spawn_delay - 5, tear_spawn_delay + 5)
		npcdata.dissapear = false
		npcdata.theframe = 0
		if subt == 1 then
			npc.Color = Color(0.7,1.5,0.7,1,0,0,0)
		end
	end
	--basic shit
	npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
	if npc.FrameCount <= 18 then
		sprite.Offset = Vector(0, -(((75/324)*(npc.FrameCount)^2)*0.73)-20)
		sprite:SetFrame("Appear", npc.FrameCount)
	elseif npcdata.dissapear == true then
		mod:spritePlay(sprite, "Disappear")
		--sprite:SetFrame("Disappear", npc.FrameCount - npcdata.theframe)
	elseif npcdata.dissapear == false then
		sprite.Offset = Vector(0, (-75 + math.sin((npc.FrameCount+ 1)*0.2)))
		mod:spritePlay(sprite, "Walk")
	end
	--rain
	npcdata.raincount = npcdata.raincount - 1
	if npcdata.raincount <= 0 then
		if sprite:IsPlaying("Walk") then
			local x_radius = 2
			local y_radius = 1
			local angle = math.random(0,359)

			--[[local params = ProjectileParams()
			params.FallingAccelModifier = 0.7
			params.Scale = math.random (7, 12) * 0.1
			params.HeightModifier = sprite.Offset.Y
			params.Variant = 4
			params.BulletFlags = params.BulletFlags & ~ProjectileFlags.ANY_HEIGHT_ENTITY_HIT]]
			local spawn_x = 0
			local spawn_y = 0
			--local projspawnposition = npc.Position + Vector(math.random(0,50) - 25,math.random(0, 8) - 8)
			if angle < 270 and angle > 90 then
				spawn_x = ((x_radius * y_radius)/math.sqrt(y_radius^2 + x_radius^2 * math.tan(math.rad(angle))^2))
				spawn_y = ((x_radius * y_radius * math.tan(math.rad(angle)))/math.sqrt(y_radius^2 + x_radius^2 * math.tan(math.rad(angle))^2))
			else
				spawn_x = -((x_radius * y_radius)/math.sqrt(y_radius^2 + x_radius^2 * math.tan(math.rad(angle))^2))
				spawn_y = -((x_radius * y_radius * math.tan(math.rad(angle)))/math.sqrt(y_radius^2 + x_radius^2 * math.tan(math.rad(angle))^2))
			end
			local projspawnposition = npc.Position + (npc.Velocity * 3) + Vector(spawn_x,spawn_y) * 15

			--npc:FireProjectiles(projspawnposition, Vector(0,0), 0, params)
			local drop = Isaac.Spawn(9, 4, 0, projspawnposition, nilvector, npc):ToProjectile();
			drop.FallingAccel = 0.7
			drop.Scale = math.random (7, 12) * 0.1
			drop.Height = sprite.Offset.Y - 30
			if npc.SubType == 1 then
				drop.ProjectileFlags = drop.ProjectileFlags | ProjectileFlags.EXPLODE
				drop.Scale = 1.5
				local ipecaccy = Color(1,1,1,1,0,0,0)
				ipecaccy:SetColorize(0.3, 0.9, 0.3, 1)
				drop.Color = ipecaccy
			end
			drop:Update()
			end
		npcdata.raincount = math.random(tear_spawn_delay - 5, tear_spawn_delay + 5)
	end
	--dissapear
	if npc:CollidesWithGrid() then
		npcdata.dissapear = true
		npcdata.theframe = npc.FrameCount
	end
	if sprite:IsEventTriggered("CloudDisappear") then
		npc:Remove()
	end
end

--foamy: charges baty, Foamy, FoamyAI

function mod:rabidbatai(npc, sprite, npcdata)
	local target = npc:GetPlayerTarget()
	local targetpos = target.Position
	sprite.Offset = Vector(0,-15)
	--init
	if npcdata.init == nil then
		npcdata.init = true
		npcdata.twitchangle = math.random(0,360)
		npcdata.state = "flap"
		npcdata.twitchtimer = math.random(30,60)
		npcdata.wallbounceleft = 3
		npcdata.statetimer = math.random(120, 240)
		if npcdata.quickcharge then
			npcdata.statetimer = npcdata.statetimer / 2
		end

		npcdata.lastvelocity = Vector(0,0)
	end
	--actually do shit
	if npcdata.state == "flap" then
		--twitch
		if npcdata.twitchtimer == 0 then
			npc:PlaySound(SoundEffect.SOUND_MONSTER_GRUNT_0,1,1,false,2)
			npcdata.twitchtimer = math.random(30,60)
			sprite:Play("Twitch", false)
			npcdata.twitchangle = math.random (0,360)
			if npc:HasEntityFlags(EntityFlag.FLAG_FEAR) then
				npcdata.twitchangle = (npc.Position - targetpos):GetAngleDegrees()
			end
			npcdata.anglebetween = (npc.Position - targetpos):GetAngleDegrees()
		else
			--MOVE WHEN NOT TWITCHING STAY STILL WHEN
			if not sprite:IsPlaying("Twitch") then
				mod:spritePlay(sprite, "Idle")
				--STOP GET ONTO THE WALL
				if npc:CollidesWithGrid() then
					npcdata.twitchangle = npc.Velocity:GetAngleDegrees()
				end
				npcdata.targetvelocity = Vector(2.25,0):Rotated(npcdata.twitchangle)
				npc.Velocity = mod:Lerp(npc.Velocity, npcdata.targetvelocity, 0.2)
				npcdata.twitchtimer = npcdata.twitchtimer - 1
			else
				npc.Velocity = mod:Lerp(npc.Velocity, Vector(0,0), 0.1)
			end
		end
		--change state sometime
		npcdata.statetimer = npcdata.statetimer - 1
		if npc:HasEntityFlags(EntityFlag.FLAG_FEAR) or npc:HasEntityFlags(EntityFlag.FLAG_CONFUSION) then
			npcdata.statetimer = npcdata.statetimer + 1
		end
		if npcdata.statetimer <= 0 then
			npc:PlaySound(SoundEffect.SOUND_MONSTER_YELL_B,1,1,false,1.7)
			npcdata.state = "charge"
			sprite:Play("DashStart", false)
			npcdata.wallbounceleft = 3
		end
	--charge - bounce off 3 wall and bulket
	elseif npcdata.state == "charge" then
		if sprite:IsPlaying("DashStart") then
			npc.Velocity = mod:Lerp(npc.Velocity, Vector(0,0), 0.5)
		elseif sprite:IsFinished("DashStart") then
			npcdata.twitchangle = (targetpos - npc.Position):GetAngleDegrees()
			npc.Velocity = Vector(15, 0):Rotated(npcdata.twitchangle)
			mod:spritePlay(sprite, "Dash")
		elseif sprite:IsPlaying("Dash") then
			npc.Velocity = mod:Lerp(npc.Velocity, npc.Velocity:Resized(10), 0.2)
			--ACTUALLY BOUNCE OFF THE FUCKING WALL FOR ONCE IN YOUR LIFE YOU USELESS SACK OF SHIT
			if npc:CollidesWithGrid() == true then
				npc:PlaySound(SoundEffect.SOUND_FETUS_LAND,5,1,false,1.7)
				npcdata.twitchangle = npc.Velocity:GetAngleDegrees()
				npc.Velocity = Vector(10,0):Rotated(npcdata.twitchangle)
				npcdata.wallbounceleft = npcdata.wallbounceleft - 1
				--shoot
				local params = ProjectileParams()
				local shootnum = math.random(3, 6)
				params.HeightModifier = sprite.Offset.Y
				for i = 0, shootnum, 1 do
					if math.random(1,7) == 7 then
						params.Variant = 1
					else
						params.Variant = 0
					end
					npc:FireProjectiles(npc.Position, Vector(math.random(8,10),0):Rotated(math.random(1,360)), 0, params)
				end
			end
			if npcdata.wallbounceleft <= 0 then
				sprite:Play("DashEnd", false)
			else
				mod:spritePlay(sprite, "Dash")
			end
		elseif sprite:IsPlaying("DashEnd") then
			npc.Velocity = mod:Lerp(npc.Velocity, Vector(0,0), 0.2)
		elseif sprite:IsFinished("DashEnd") then
			npcdata.twitchangle = math.random(0,360)
			npcdata.state = "flap"
			npcdata.twitchtimer = math.random(30,60)
			npcdata.statetimer = math.random(120, 360)
		end
	end
end

--fathead - farts dfies

function mod:fatheadai (npc, sprite, npcdata)
	local room = game:GetRoom()
	if not npcdata.confuseangle then
		npcdata.confuseangle = math.random(360)
	end
	npcdata.confuseangle = npcdata.confuseangle + math.random(-30, 30)
	--the dying is the farting baby
	if npc:IsDead() == true then
		game:ButterBeanFart(npc.Position, 140, npc, true, false)
	end
	local target = npc:GetPlayerTarget()
	local targetpos = target.Position
	targetpos = mod:randomConfuse(npc, targetpos)
	local path = npc.Pathfinder
	--we gotta get a move on here lets get a move on here
	if room:CheckLine(npc.Position,targetpos,0,1,false,false) or npc:HasEntityFlags(EntityFlag.FLAG_FEAR) or npc:HasEntityFlags(EntityFlag.FLAG_CONFUSION) then
		local targetvelocity = (targetpos - npc.Position):Normalized() * 3.5
		if npc:HasEntityFlags(EntityFlag.FLAG_FEAR) then
			targetvelocity = targetvelocity * -1
		elseif npc:HasEntityFlags(EntityFlag.FLAG_CONFUSION) then
			targetvelocity = Vector(3.5, 0):Rotated(npcdata.confuseangle)
		end
		local lerpy = 0.1
		if npc:HasEntityFlags(EntityFlag.FLAG_CONFUSION) then
			lerpy = 0.3
		end
		npc.Velocity = mod:Lerp(npc.Velocity, targetvelocity, lerpy)
	else
		path:FindGridPath(targetpos, 0.5, 900, true)
	end
	--anim
	sprite.FlipX = false
	if npc.Velocity:Length() < 0.25 then
		sprite:SetFrame("Appear", 20)
	elseif math.abs(npc.Velocity.X) >= math.abs(npc.Velocity.Y) then
		sprite:SetFrame("WalkHori", npc.FrameCount % 22)
		if npc.Velocity.X < 0 then
			sprite.FlipX = true
		end
	else
		sprite:SetFrame("WalkVert", npc.FrameCount % 22)
	end
end

--FAKE FART: butter bean fart that doesnt damage enemies, for litterbug, composter, fathead, ect...
--a grim reminder
function mod:fakefartLEGACY(position, radius, force, forcelerp, npc, playerforcemult)
	playerforcemult = playerforcemult or 0.5
	--[[game:ButterBeanFart(position, 0, npc, 1, 0)
	for _, farttarget in ipairs(Isaac.FindInRadius(position, radius, EntityPartition.ENEMY + EntityPartition.PLAYER + EntityPartition.PICKUP)) do
		local d = radius/position:Distance(farttarget.Position)
		local maxd = radius/20
		d = math.min(d*3/maxd,1)
		local f = mod:Lerp(force, force*d, forcelerp)
		if farttarget.Type == 1 then
			--print(d)
			f = mod:Lerp(force, force*d*0.66, forcelerp)*playerforcemult
			--print(f)
		elseif farttarget.Type ~= 5 then
			farttarget:AddEntityFlags(EntityFlag.FLAG_KNOCKED_BACK)
		end
		local a = (farttarget.Position - position):GetAngleDegrees()
		farttarget.Velocity = farttarget.Velocity + Vector(f, 0):Rotated(a)
	end]]--
	game:ButterBeanFart(position, radius, npc, 1, 0)
	for _, farttarget in ipairs(Isaac.FindInRadius(position, radius, EntityPartition.ENEMY)) do
		farttarget:ClearEntityFlags(EntityFlag.FLAG_APPLY_IMPACT_DAMAGE)
	end
end

--crepitus - crazy bony

function mod:crepitusai (npc, sprite, npcdata)
	local target = npc:GetPlayerTarget()
	local targetpos = target.Position
	npc:AddEntityFlags(EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK)
	npc.Velocity = npc.Velocity * 0.75
	if npc.State == 8 then
		npc.State = 4
	end
	if npc.State == 4 then
		--set anim
		if math.abs(npc.Velocity.X) > math.abs(npc.Velocity.Y) then
			mod:spritePlay(sprite, "WalkHori")
			if npc.Velocity.X < 0 then
				sprite.FlipX = true
			else
					sprite.FlipX = false
			end
		else
			if npc.Velocity.Y < 0 then
				mod:spritePlay(sprite, "WalkUp")
			else
				mod:spritePlay(sprite, "WalkDown")
			end
		end
		if (npc.Position - targetpos):Length() <= 100 and not sprite:IsPlaying("Appear") and not (npc:HasEntityFlags(EntityFlag.FLAG_FEAR) or npc:HasEntityFlags(EntityFlag.FLAG_CONFUSION)) then
			npc.State = 9
			mod:spritePlay(sprite, "Attack")
		end
	end
	if npc.State == 9 then
		npc.Velocity = mod:Lerp(npc.Velocity, Vector(0,0), 0.2)
		if not sprite:IsPlaying("Attack") then
			mod:spritePlay(sprite, "Attack")
		end
	end
	if sprite:IsEventTriggered("boneshower") then
		local bonesnumber = math.random(7, 15)
		local params = ProjectileParams()
		params.Variant = 1
		for i = 1, bonesnumber, 1 do
			params.FallingSpeedModifier = math.random(5, 25) * - 1
			params.FallingAccelModifier = 0.5
			npc:FireProjectiles(npc.Position, Vector(math.random(8,50) * 0.1,0):Rotated(math.random(1,360)), 0, params)
		end

		sfx:Play(SoundEffect.SOUND_BONE_HEART, 1, 0, false, 1)
	end
	if sprite:IsFinished("Attack") then
		npc.State = 4
	end
end



function mod:skuzzai(npc, sprite, npcdata)
	if not npcdata.init then
		npcdata.init = true
		sprite.Offset = Vector(0, 0)
		npcdata.jumpytimer = npcdata.jumpytimer or math.random(45, 90)
		npcdata.state = "idle"
		npcdata.stateframe = 0
		npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS
		npc.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_GROUND
		npcdata.bursting = 0
		--check bursting
		for _, player in ipairs(Isaac.FindByType(1, -1, -1, false, false)) do
			player = player:ToPlayer()
			if player:HasCollectible(377) then
				npc.CollisionDamage = 0
				npcdata.bursting = 1
			end
		end
	end
	if npcdata.state == "idle" then
		--set bursting
		if npcdata.bursting == 1 then
			sprite:Load("gfx/enemies/skuzzball/skuzzgriend.anm2",true)
			mod:spritePlay(sprite, "Appear")
			npcdata.bursting = 2
		end
		if not sprite:IsPlaying("land") then
			mod:spritePlay(sprite, "idle")
			npc.Velocity = mod:Lerp(npc.Velocity, Vector(0,0), 0.75)
		elseif sprite:IsFinished("land") then
			mod:spritePlay(sprite, "idle")
		else
			npc.Velocity = mod:Lerp(npc.Velocity, Vector(0,0), 0.4)
		end
		--just in case
		if not npcdata.jumpytimer then
			npcdata.jumpytimer = 250
		end
		if npcdata.jumpytimer <= 0 then
			npcdata.state = "hop"
			npc:PlaySound(SoundEffect.SOUND_FETUS_LAND,0.6,1,false,2.7)
			mod:spritePlay(sprite, "hopstart")
			npcdata.stateframe = 0;
			local feard = 0
			if npc:HasEntityFlags(EntityFlag.FLAG_FEAR) then
				feard = 50
			end
			local targetpos = mod:chooserandomlocationforskuzz(npc, 150 + (feard / 2), 50 + feard, not (npc:HasEntityFlags(EntityFlag.FLAG_FEAR) or npc:HasEntityFlags(EntityFlag.FLAG_CONFUSION)))
			local lengthto = targetpos - npc.Position
			npc.Velocity = Vector(lengthto.X / 15 , lengthto.Y / 15) * 0.90
			npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
			npc.GridCollisionClass = GridCollisionClass.COLLISION_NONE
		else
			npcdata.jumpytimer = npcdata.jumpytimer - 1
		end
	elseif npcdata.state == "hop" then
		if not sprite:IsPlaying("hopstart") then
			mod:spritePlay(sprite, "hop")
		elseif sprite:IsFinished("hopstart") then
			mod:spritePlay(sprite, "hop")
		end
		if npcdata.slingerOverride then
			npc.SpriteOffset = npc.SpriteOffset + Vector(0, npcdata.stateframe / 4 - 6)
		else
			sprite.Offset = Vector(0, -2 * (-0.025 * ((npcdata.stateframe - 30)^2) + 29.5))
		end
		if sprite.Offset.Y > 0 then
			sprite.Offset = Vector(0,0)
			npcdata.state = "idle"
			mod:spritePlay(sprite, "land")
			npc:PlaySound(SoundEffect.SOUND_FETUS_LAND,0.6,1,false,1.7)
			npcdata.jumpytimer = math.random(75, 120)
			npcdata.slingerOverride = false
			npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS
			npc.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_GROUND
		else
		npcdata.stateframe = npcdata.stateframe + 4
		end
	else
		npcdata.state = "idle"
	end
end

function mod:chooserandomlocationforskuzz(npc, rangespidhop, rangenpc, reallytargetplayer, isFamiliar)
	local room = game:GetRoom()
	--(npc:HasEntityFlags(EntityFlag.FLAG_FEAR) or npc:HasEntityFlags(EntityFlag.FLAG_CONFUSION))
	if reallytargetplayer == nil then
		targetplayer = true
	else
		targetplayer = reallytargetplayer
	end
	local target = nil
	local targetpos
	if isFamiliar then
		target = mod.FindClosestEnemy(npc.Position, rangespidhop)
		if target then
			targetpos = target.Position
		else
			targetpos = npc.Position + (npc.Player.Position - npc.Position):Resized(80)
		end
	else
		if targetplayer == true then
			target = npc:GetPlayerTarget()
			targetpos = target.Position
		else
			targetpos = Vector(-1000,-1000)
			if npc:HasEntityFlags(EntityFlag.FLAG_FEAR) then
				target = npc:GetPlayerTarget()
				targetpos = target.Position
				targetplayer = true
			end
		end
	end
	local npcinrange = false
	local position = Vector(0 , 0)
	local tablelength = 1
	if targetpos:Distance(npc.Position) < rangespidhop then
		npcinrange = true
	end
	local size = room:GetGridSize()
	local validpositions = {}
	for i=0, size do
		local gridEntity = room:GetGridEntity(i)
		if (room:GetGridPosition(i):Distance(npc.Position) < rangespidhop) then
			if ( (not gridEntity) or (room:GetGridCollision(i) == GridCollisionClass.COLLISION_NONE and (gridEntity:GetType() ~= GridEntityType.GRID_SPIKES and gridEntity:GetType() ~ GridEntityType.GRID_SPIKES_ONOFF) or gridEntity:GetType() == GridEntityType.GRID_SPIDERWEB)) and room:IsPositionInRoom(room:GetGridPosition(i), 15) then
				--Isaac.ConsoleOutput(tostring(npcinrange == true))
				if targetplayer and npcinrange == true then
					if room:GetGridPosition(i):Distance(targetpos) < rangenpc and not npc:HasEntityFlags(EntityFlag.FLAG_FEAR) then
						table.insert(validpositions, i)
						tablelength = tablelength + 1
					elseif room:GetGridPosition(i):Distance(targetpos) > rangenpc and npc:HasEntityFlags(EntityFlag.FLAG_FEAR) then
						table.insert(validpositions, i)
						tablelength = tablelength + 1
					end
				else
					table.insert(validpositions, i)
					tablelength = tablelength + 1
				end
			end
		end
	end
	if tablelength == 1 then
		return npc.Position
	else
		return room:GetGridPosition(validpositions[math.random(1, tablelength - 1)])
	end
end

function mod:skuzzballai(npc, sprite, npcdata)
	if not npcdata.init then
		npcdata.init = true
		sprite.Offset = Vector(0, 0)
		npcdata.jumpytimer = math.random(40, 80)
		npcdata.state = "idle"
		npcdata.stateframe = 0
		npcdata.lookdown = "not"
		npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS
		npc.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_GROUND
		npcdata.spidernumber = 6
		npcdata.spiderlist = {0, 6, 12, 18, 24, 30}
		npcdata.size = "big"
		npcdata.jumpsize = "big"
		npcdata.jumpstartdone = false
		npcdata.isCorpse = mod:CheckStage("Corpse", {34,43,44})
		--check bursting
		for _, player in ipairs(Isaac.FindByType(1, -1, -1, false, false)) do
			player = player:ToPlayer()
			if player:HasCollectible(377) then
				npc.CollisionDamage = 0
				npcdata.bursting = 1
			end
		end
	end
	local isCorpse = npcdata.isCorpse
	if npcdata.state == "idle" then
		npcdata.stateframe = npcdata.stateframe + 1;
		mod:spritePlay(sprite, "idle")
		if npcdata.stateframe >= npcdata.jumpytimer then
			npcdata.state = "jumpprep"
			npcdata.stateframe = 0
			mod:spritePlay(sprite, "jumpprep")
		end
		npc.Velocity = mod:Lerp(npc.Velocity, Vector(0,0), 0.8)
	elseif npcdata.state == "jumpprep" then
		mod:spritePlay(sprite, "jumpprep")
		npc.Velocity = mod:Lerp(npc.Velocity, Vector(0,0), 0.9)
	elseif npcdata.state == "jump" then
		if npcdata.jumpsize == "big" then
		npcdata.stateframe = npcdata.stateframe + 4;
		sprite.Offset = Vector(0, -2 * (-0.01 * ((npcdata.stateframe - 60)^2) + 45))
		else
		npcdata.stateframe = npcdata.stateframe + 5;
		sprite.Offset = Vector(0, -1.5 * (-0.01 * ((npcdata.stateframe - 60)^2) + 45))
		end
		if npcdata.stateframe <= 60  then
			if npcdata.jumpstartdone then
				mod:spritePlay(sprite, "jumpup")
			else
				mod:spritePlay(sprite, "jumpstart")
				if sprite:IsFinished("jumpstart") then
					npcdata.jumpstartdone = true
				end
			end
		elseif npcdata.lookdown == "not" or npcdata.lookdown == "shift" then
			npcdata.lookdown = "shift"
			mod:spritePlay(sprite, "jumpshift")
		else
			mod:spritePlay(sprite, "jumpdown")
			npcdata.lookdown = "yes"
		end
		if sprite:IsFinished("jumpshift") then
			npcdata.lookdown = "yes"
		end
		if sprite.Offset.Y >= 0 then
			npcdata.state = "land"
			npc:PlaySound(SoundEffect.SOUND_MEAT_IMPACTS,1,2,false,1.3)
			npcdata.stateframe = 0
			sprite.Offset = Vector(0, 0)
			npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS
			npc.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_GROUND
			mod:spritePlay(sprite, "land")
			npcdata.lookdown = "not"
		end
	elseif npcdata.state == "land" then
		mod:spritePlay(sprite, "land")
		npc.Velocity = mod:Lerp(npc.Velocity, Vector(0,0), 0.5)
	end
	if sprite:IsFinished("jumpprep") then
		npcdata.state = "jump"
		npc:PlaySound(SoundEffect.SOUND_MEAT_JUMPS,1,2,false,1.4)
		npcdata.stateframe = 0;
		local feard = 0
		if npc:HasEntityFlags(EntityFlag.FLAG_FEAR) then
			feard = 50
		end
		local targetpos = mod:chooserandomlocationforskuzz(npc, 150 + (feard / 2), 50 + feard, not (npc:HasEntityFlags(EntityFlag.FLAG_FEAR) or npc:HasEntityFlags(EntityFlag.FLAG_CONFUSION)))
		local lengthto = targetpos - npc.Position
		npcdata.jumpsize = npcdata.size
		if npcdata.jumpsize == "big" then
			npc.Velocity = Vector(lengthto.X / 30 , lengthto.Y / 30) * 0.90
		else
			npc.Velocity = Vector(lengthto.X / 18 , lengthto.Y / 18) * 0.90
		end
		npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
		npc.GridCollisionClass = GridCollisionClass.COLLISION_NONE
	end
	if sprite:IsFinished("land") then
		npcdata.stateframe = 0
		npcdata.state = "idle"
		if npcdata.jumpsize == "big" then
			npcdata.jumpytimer = math.random(45, 70)
		else
			npcdata.jumpytimer = math.random(30, 45)
		end
	end
	--spider logic
	if npc:IsDead() then
		for i = npcdata.spidernumber, 1, -1 do
			EntityNPC.ThrowSpider(npc.Position, npc, mod:chooserandomlocationforskuzz(npc, 100, 50), false, 0)
		end
		mod.spawnent(npc, npc.Position, Vector(0,0), 666, 60, 0)
		for i = 1, math.random(4, 7), 1 do
			local gibs = Isaac.Spawn(1000, 5, 0, npc.Position, RandomVector()*(math.random(4, 7)), npc):ToEffect();
			gibs:GetSprite():Load("gfx/enemies/skuzzball/skuzzgib.anm2",true)
			if isCorpse then
				gibs:GetSprite():ReplaceSpritesheet(0, "gfx/enemies/skuzzball/skuzzgib_corpse.png")
			else
				gibs:GetSprite():ReplaceSpritesheet(0, "gfx/enemies/skuzzball/skuzzgib.png")
			end
			gibs:GetSprite():LoadGraphics()
			gibs:Update()
		end
		for i = 1, 2, 1 do
			local gibs = Isaac.Spawn(1000, 5, 3, npc.Position, RandomVector()*(math.random(3, 7)), npc):ToEffect();
			gibs:GetSprite():Load("gfx/enemies/skuzzball/skuzzgib.anm2",true)
			if isCorpse then
				gibs:GetSprite():ReplaceSpritesheet(0, "gfx/enemies/skuzzball/skuzzgib_corpse.png")
			else
				gibs:GetSprite():ReplaceSpritesheet(0, "gfx/enemies/skuzzball/skuzzgib.png")
			end
			gibs:GetSprite():LoadGraphics()
			gibs:Update()
		end
	else
		for i = npcdata.spidernumber, 1, -1 do
			if npc.HitPoints < npcdata.spiderlist[i] then
				npcdata.spidernumber = npcdata.spidernumber - 1
				EntityNPC.ThrowSpider(npc.Position, npc, mod:chooserandomlocationforskuzz(npc, 100, 50), false, 0)
				for _ = 1, math.random(2, 4), 1 do
					local gibs = Isaac.Spawn(1000, 5, 0, npc.Position, RandomVector()*(math.random(3, 6)), npc):ToEffect();
					gibs:GetSprite():Load("gfx/enemies/skuzzball/skuzzgib.anm2",true)
					if isCorpse then
						gibs:GetSprite():ReplaceSpritesheet(0, "gfx/enemies/skuzzball/skuzzgib_corpse.png")
					else
						gibs:GetSprite():ReplaceSpritesheet(0, "gfx/enemies/skuzzball/skuzzgib.png")
					end
					gibs:GetSprite():LoadGraphics()
					gibs:Update()
				end
			end
		end
	end
	--size logic
	if npc.HitPoints <= (npc.MaxHitPoints / 2) and npcdata.size == "big" then
		npcdata.size = "small"
		sprite:Load("gfx/enemies/skuzzball/skuzzballsmall.anm2",true)
		if isCorpse then
			mod:ReplaceEnemySpritesheet(npc, "gfx/enemies/skuzzball/skuzzballsmall_corpse", 0)
		else
			mod:ReplaceEnemySpritesheet(npc, "gfx/enemies/skuzzball/skuzzballsmall", 0)
		end
		if not npcdata.state == "jump" then
			npcdata.state = "land"
			mod:spritePlay(sprite, "land")
		end
		for i = 1, math.random(4, 7), 1 do
			local gibs = Isaac.Spawn(1000, 5, 0, npc.Position, RandomVector()*(math.random(4, 7)), npc):ToEffect();
			gibs:GetSprite():Load("gfx/enemies/skuzzball/skuzzgib.anm2",true)
			if isCorpse then
				gibs:GetSprite():ReplaceSpritesheet(0, "gfx/enemies/skuzzball/skuzzgib_corpse.png")
			else
				gibs:GetSprite():ReplaceSpritesheet(0, "gfx/enemies/skuzzball/skuzzgib.png")
			end
			gibs:GetSprite():LoadGraphics()
			gibs:Update()
		end
	end
end

mod.ransackedtable = {
--Sackboy (Weight 20)
{mod.FF.Sackboy.ID, mod.FF.Sackboy.Var, 20},
--Bony (weight 30)
{227, 0, 30},
--Dweller (weight 30)
{mod.FF.Dweller.ID, mod.FF.Dweller.Var, 30}
}

function mod:ransackedRandomSelection()
	local sum = 0

	for _,i in ipairs(mod.ransackedtable) do
		sum = sum + i[3]
	end

	local randy = math.random(0, sum-1)

	for _,i in ipairs(mod.ransackedtable) do
		if randy < i[3] then
			return i
		end
		randy = randy - i[3]
	end
	return 1;
end

function mod:ransackedai(npc, sprite, npcdata)
	npc:AddEntityFlags(EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK | EntityFlag.FLAG_NO_KNOCKBACK)
	if (npcdata.init == nil) then
		npcdata.framesuntilquiver = math.random(70, 85)
		npcdata.lastframesuntilquiver = npcdata.framesuntilquiver
		npcdata.state = "idle"
		npc.SplatColor = mod.ColorPureWhite
		npcdata.init = true
	end
	npc.Velocity = mod:Lerp(npc.Velocity, Vector(0,0), 0.8)
	if npcdata.state == "idle" then
		mod:spritePlay(sprite, "idle")
		npcdata.framesuntilquiver = npcdata.framesuntilquiver - 1
		if npcdata.framesuntilquiver <= 0 then
			npcdata.state = "quiver"
			mod:spritePlay(sprite, "quiver")
			npcdata.framesuntilquiver = npcdata.lastframesuntilquiver - math.random(7, 10)
			npcdata.lastframesuntilquiver = npcdata.framesuntilquiver
			if npcdata.framesuntilquiver <= 0 then
				npcdata.state = "hatch"
			end
		end
	elseif npcdata.state == "quiver" then
		if sprite:IsFinished("quiver") then
			npcdata.state = "idle"
		end
	elseif npcdata.state == "hatch" then
		mod:spritePlay(sprite, "hatch")
	end
	if sprite:IsEventTriggered("hatch") then
		--hantch
		local sack = mod:ransackedRandomSelection()
		if npc.SubType == 0 then
			local spawned = Isaac.Spawn(sack[1], sack[2], 0, npc.Position, Vector(0,0), npc):ToNPC()
			spawned:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
		end
		Isaac.Spawn(1000, 667, 0, npc.Position + Vector (0,-8), Vector(0,0), npc)
		npc:Kill();
	end
end

function mod:ransackedwebai(npc)
	mod:spritePlay(npc:GetSprite(), "webcorpse")
	npc.DepthOffset = 1
	npc:GetSprite().Offset = Vector(0, 0)
end
mod:AddCallback(ModCallbacks.MC_POST_EFFECT_UPDATE, mod.ransackedwebai, 667)

function mod:fiendflashai(npc)
	npcdata = npc:GetData()
	if npcdata.parent then
		npc.Position = npcdata.parent.Position + npcdata.parent.Velocity
	else
		npc:Remove()
	end
	mod:spritePlay(npc:GetSprite(), "flash")
	if npc.SubType == 0 then
		npc.DepthOffset = 1000
	end
	if npc:GetSprite():IsFinished("flash") then
		npc:Remove()
	end
end
mod:AddCallback(ModCallbacks.MC_POST_EFFECT_UPDATE, mod.fiendflashai, 668)

--spitum monstro ai, spitummonstro. spitumonstro
function mod:monstrospitumai(npc, sprite, npcdata)
	local spitumnum = 0
	local target = npc:GetPlayerTarget().Position
	npcdata.launchspitum = false

	if not npcdata.init then
		--sprite:ReplaceSpritesheet(0, "gfx/bosses/champions/boss_monstro_mucus.png")
		--sprite:LoadGraphics()
		npcdata.init = true;
		npcdata.creeptimer = math.random(30, 45)
		npcdata.creepslam = 0
		npcdata.creepslamtimer = 10
		npc.SplatColor = mod.ColorSpittyGreen
		npcdata.mustspitum = false
	end
	if npc.EntityCollisionClass == EntityCollisionClass.ENTCOLL_ALL then
		if npcdata.creeptimer == -666 then
			local creep = Isaac.Spawn(1000, EffectVariant.CREEP_GREEN, 0, npc.Position, Vector(0,0), npc):ToEffect();
			creep.SpriteScale = Vector(4, 3.5)
			npcdata.creeptimer = math.random(30, 45)
			creep:SetTimeout(45)
			creep:SetColor(Color(0, 0, 0, 1, 99 / 255, 56 / 255, 74 / 255), 60, 99999, true, false)
			creep:Update()
		elseif npcdata.creeptimer <= 0 then
			local creep = Isaac.Spawn(1000, EffectVariant.CREEP_GREEN, 0, npc.Position, Vector(0,0), npc):ToEffect();
			creep.SpriteScale = Vector(3, 2.5)
			npcdata.creeptimer = math.random(30, 45)
			creep:SetTimeout(45)
			creep:SetColor(Color(0, 0, 0, 1, 99 / 255, 56 / 255, 74 / 255), 60, 99999, true, false)
			creep:Update()
		else
			npcdata.creeptimer = npcdata.creeptimer - 1;
		end
	else
		npcdata.creeptimer = -666
	end
	--slam attack
	if sprite:IsPlaying("JumpDown") and sprite:GetFrame() == 33 then
		npcdata.creepslam = math.random(3, 5)
		npcdata.creepslamtimer = math.random(3, 5)
	end
	if npcdata.creepslam > 0 then
		if npcdata.creepslamtimer <= 0 then
			npcdata.creepslam = npcdata.creepslam - 1
			npcdata.creepslamtimer = math.random(3, 5)
			local creep = Isaac.Spawn(1000, EffectVariant.CREEP_GREEN, 0, npc.Position + RandomVector():Resized(math.random(10,25)) , Vector(0,0), npc):ToEffect();
			creep.SpriteScale = Vector(4, 3.5)
			creep:SetTimeout(math.floor(creep.Timeout * 1))
			creep:SetColor(Color(0, 0, 0, 1, 99 / 255, 56 / 255, 74 / 255), 60, 99999, true, false)
			creep:Update()
		else
			npcdata.creepslamtimer = npcdata.creepslamtimer - 1
		end
	end
	--entity loops
	for _, spitmaybe in ipairs(Isaac.GetRoomEntities()) do
		if spitmaybe.Type == Isaac.GetEntityTypeByName("Spitum") and spitmaybe.Variant == Isaac.GetEntityVariantByName("Spitum") then
			spitumnum = spitumnum + 1
		end
	end
	if spitumnum < 2 and sprite:IsPlaying("Taunt") and ((sprite:GetFrame() == 24 and npcdata.mustspitum == false) or (sprite:GetFrame() == 25 and npcdata.mustspitum == true)) and (math.random(1, spitumnum + 2) == 1 or npcdata.mustspitum == true) then
		npcdata.launchspitum = true;
	end
	for _, tearmaybe in ipairs(Isaac.GetRoomEntities()) do
	   if tearmaybe.SpawnerEntity then
		  if tearmaybe.SpawnerEntity.Type == 20 and tearmaybe.SpawnerEntity.Variant == 0 and tearmaybe.SpawnerEntity.SubType == mod.FF.MucusMonstro.Sub and tearmaybe.Type == EntityType.ENTITY_PROJECTILE and not tearmaybe:GetData().creeptype then
			if (sprite:IsPlaying("JumpDown") and tearmaybe.FrameCount == 0) or (npcdata.launchspitum == true) or (npcdata.mustspitum == true) then
			  tearmaybe:Remove()
			end
			  teardata = tearmaybe:GetData()
			  teardata.projType = "acidic splot"
			  teardata.creepTimer = 30
			  tearmaybe.Color = mod.ColorSpittyGreen
			  tearmaybe:GetSprite():LoadGraphics()
		  end
	   end
	end
	--spitum attack
	if sprite:GetFrame() == 0 and ((npc.State == 6  and math.random(1, spitumnum + 3) == 1) or (npc.State == 4  and math.random(1, (spitumnum * 2) + 4) == 1)) and spitumnum < 2 then
		npc.State = 8
		npc.StateFrame = 0
		mod:spritePlay(sprite, "Taunt")
		npcdata.mustspitum = true
	end
	if npcdata.launchspitum == true then
		local spitum = Isaac.Spawn(Isaac.GetEntityTypeByName("Spitum"), Isaac.GetEntityVariantByName("Spitum"), 0, npc.Position, Vector(0,0), npc):ToNPC()
		spitum:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
		spitum.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
		spitum.GridCollisionClass = GridCollisionClass.COLLISION_NONE
		spitum:GetData().state = "airtime"
		spitum:GetData().init = true
		spitum.Velocity = (Vector(target.X - npc.Position.X, target.Y - npc.Position.Y) * 0.035) + RandomVector():Resized(math.random(50, 100) *  0.0005)
		spitum.MaxHitPoints = spitum.MaxHitPoints * 0.5
		spitum.HitPoints = spitum.MaxHitPoints
		spitum.SpriteScale = spitum.SpriteScale * 0.75
		spitum.SplatColor = mod.ColorSpittyGreen
		npcdata.mustspitum = false
	end
end

function mod:monstrochamp(npc)
	local subtype = npc.SubType
	local sprite = npc:GetSprite();
	local npcdata = npc:GetData();
	if subtype == mod.FF.MucusMonstro.Sub then
		mod:monstrospitumai(npc, sprite, npcdata)
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.monstrochamp, 20)

function mod:boilerai(npc, sprite, npcdata)
	if not npcdata.init then
		npcdata.init = true
		npcdata.state = "idle"
		npcdata.shoottimer = math.random(68, 76)
		npcdata.blotprep = false
		npcdata.blotsfed = 0
	end
	if npcdata.state == "idle" then
		mod:spritePlay(sprite, "idle")
		if npc:HasEntityFlags(EntityFlag.FLAG_FEAR) then
			if sprite:GetFrame() == 24 then
				local target = npc:GetPlayerTarget().Position
				npc.Velocity = (npc.Position - target):Normalized() * 8.5
			end
			if sprite:GetFrame() < 23 and sprite:GetFrame() > 29 then
				npc.Velocity = mod:Lerp(npc.Velocity, Vector(0,0), 0.2)
			else
				npc.Velocity = mod:Lerp(npc.Velocity, Vector(0,0), 0.8)
			end
		else
			npc.Velocity = mod:Lerp(npc.Velocity, Vector(0,0), 0.8)
		end
		if npcdata.shoottimer <= 0 then
			npcdata.state = "shoot"
		end
		npcdata.blotprep = false
		for _, blotmaybe in ipairs(Isaac.GetRoomEntities()) do
			if blotmaybe.Type == Isaac.GetEntityTypeByName("Blot") and blotmaybe.Variant == Isaac.GetEntityVariantByName("Blot") and ((blotmaybe.Position - npc.Position):Length() <= 100) then
				npcdata.blotprep = true
			end
		end
		if npcdata.blotsfed >= 3 then
			npcdata.blotprep = false
		end
		if npc:HasEntityFlags(EntityFlag.FLAG_FEAR) or npc:HasEntityFlags(EntityFlag.FLAG_CONFUSION) then
			npcdata.blotprep = false
			npcdata.shoottimer = npcdata.shoottimer + 1
		end

		if npcdata.blotprep == false then
			npcdata.shoottimer = npcdata.shoottimer - 1
		else
			for _, blotmaybe in ipairs(Isaac.GetRoomEntities()) do
				if blotmaybe.Type == Isaac.GetEntityTypeByName("Blot") and blotmaybe.Variant == Isaac.GetEntityVariantByName("Blot") and ((blotmaybe.Position - npc.Position):Length() <= 15) and blotmaybe:GetSprite().Offset.Y > - 25 and blotmaybe:GetData().downvelocity > 0 then
					npcdata.state = "rileup"
					npcdata.blotprep = false
					blotmaybe:Remove()
					npcdata.blotsfed = npcdata.blotsfed + 1
					npc.HitPoints = npc.HitPoints + 10
					local effect = Isaac.Spawn(1000,16,4,npc.Position+Vector(0,-20),Vector.Zero,npc)
					effect.Color = mod.ColorDankBlackReal
					effect.SpriteScale = Vector(0.7,0.7)
					break
				end
			end
		end
	elseif npcdata.state == "shoot" then
		npcdata.blotprep = false
		mod:spritePlay(sprite, "shoot")
		npc.Velocity = mod:Lerp(npc.Velocity, Vector(0,0), 0.6)
		if sprite:IsFinished("shoot") then
			npcdata.state = "idle"
			mod:boilersetshottimer(npcdata)
		end
	elseif npcdata.state == "rileup" then
		npcdata.blotprep = false
		mod:spritePlay(sprite, "rileup")
		npc.Velocity = mod:Lerp(npc.Velocity, Vector(0,0), 0.75)
		if sprite:IsFinished("rileup") then
			npcdata.shoottimer = 0
			npcdata.state = "wait"
		end
	elseif npcdata.state == "wait" then
		mod:spritePlay(sprite, "idle")
		npc.Velocity = mod:Lerp(npc.Velocity, Vector(0,0), 0.8)
		local isboiler = false
		for _, otherboilermaybe in ipairs(Isaac.GetRoomEntities()) do
			if otherboilermaybe.Type == Isaac.GetEntityTypeByName("Boiler") and otherboilermaybe.Variant == Isaac.GetEntityVariantByName("Boiler") and (not otherboilermaybe == npc) then
				isboiler = true
				if otherboilermaybe:GetData().shoottimer ~= nil and otherboilermaybe:GetData().shoottimer == 0 then
					npcdata.state = "idle"
					npcdata.shoottimer = math.random(3, 7)
				end
			end
		end
		if not isboiler then
			npcdata.state = "idle"
			npcdata.shoottimer = math.random(3, 7)
		end
	end
	if sprite:IsEventTriggered("shoot") then
		npc:PlaySound(SoundEffect.SOUND_SLOTSPAWN,0.7,0,false, 1.5)
		for i = 0, 315, 45 do
			local projectile = Isaac.Spawn(9, 0, 0, npc.Position, Vector(5,0):Rotated(i), npc):ToProjectile();
				projectile.FallingSpeed = -0.1
				projectile.FallingAccel = -0.1
				projectile.Color = mod.ColorDankBlackReal
			if i % 90 == 0 then
				projectile.Scale = 1.75
				projectile.Velocity = Vector(7.5, 0):Rotated(i)
			else
				projectile.Scale = 1
			end
		end
	end
	if sprite:IsEventTriggered("whistle") then
		npc:PlaySound(mod.Sounds.SteamTrainWhistle,0.4,0,false, 1.5)
	end
	if sprite:IsEventTriggered("land") then
		npc:PlaySound(SoundEffect.SOUND_SLOTSPAWN,0.4,0,false, 1)
	end
	if npc:IsDead() then
		for i = 0, 315, 45 do
			local projectile = Isaac.Spawn(9, 0, 0, npc.Position, Vector(5,0):Rotated(i), npc):ToProjectile();
				projectile.FallingSpeed = -0.1
				projectile.FallingAccel = -0.1
				projectile.Color = mod.ColorDankBlackReal
			if not (i % 90 == 0) then
				projectile.Scale = 1.75
				projectile.Velocity = Vector(7.5, 0):Rotated(i)
			else
				projectile.Scale = 1
			end
		end
		Isaac.Explode(npc.Position, npc, 5)
	end
end

function mod:boilersetshottimer(npcdata)
	local normal = 72
	local actual = normal - (npcdata.blotsfed * 22)
	npcdata.shoottimer = math.random(actual - (1 + npcdata.blotsfed), actual + (1 + npcdata.blotsfed))
end

function mod:drinkwormai(npc, sprite, npcdata)
	if not npcdata.init then
		npc:AddEntityFlags(EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK)
		npcdata.state = "idle"
		npcdata.idletimer = math.random(15, 30)
		npcdata.burrowedtimer = 0
		npcdata.init = true
		npcdata.firstdig = false
		npcdata.burrowcheck = false
	end
	npc.Velocity = Vector(0,0)
	if npcdata.state == "idle" then
		if npcdata.idletimer > 0 then
			npcdata.idletimer = npcdata.idletimer - 1
			mod:spritePlay(sprite, "idle")
		else
			if npcdata.projectile == nil then
				if npcdata.firstdig then
					mod:spritePlay(sprite, "diginspit")
				else
					mod:spritePlay(sprite, "diginspitless")
					npcdata.firstdig = true
					npcdata.extraVariableToFixABug = true
				end
				npcdata.state = "burrow"
			else
				npc:PlaySound(SoundEffect.SOUND_MAGGOTCHARGE,1,1,false,1.5)
				mod:spritePlay(sprite, "startsuckinboy")
				npcdata.state = "suck"
			end
		end
	elseif npcdata.state == "burrow" then
		if sprite:IsFinished("diginspit") or sprite:IsFinished("diginspitless") then
			npcdata.burrowedtimer = math.random(15,30)
			npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
			mod:spritePlay(sprite, "burrowed")
		elseif sprite:IsFinished("digout") then
			mod:spritePlay(sprite, "idle")
			npcdata.idletimer = math.random(20, 40)
			npcdata.state = "idle"
		elseif not (sprite:IsPlaying("diginspit") or sprite:IsPlaying("digout") or sprite:IsPlaying("diginspitless")) then
			if npcdata.burrowedtimer <= 0 then
				mod:spritePlay(sprite, "digout")
				npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_ALL
				if npcdata.extraVariableToFixABug then
					npc.Position = mod:FindRandomValidPathPosition(npc, 2, 120)
					npcdata.extraVariableToFixABug = false
				else
					npc.Position = mod:drinkwormfindpos(npc, npcdata)
				end
				if npcdata.projectile ~= nil then
					if sprite.FlipX and npcdata.projectile.Position.X < npc.Position.X then
						sprite.FlipX = false
					elseif npcdata.projectile.Position.X > npc.Position.X then
						sprite.FlipX = true
					end
				end
			else
				npcdata.burrowcheck = true
				npcdata.burrowedtimer = npcdata.burrowedtimer - 1
				for _, i in ipairs(Isaac.FindByType(666, 100, -1, false, false)) do
					if npcdata.burrowedtimer == i:GetData().burrowedtimer and GetPtrHash(i) ~= GetPtrHash(npc) and npcdata.burrowcheck == false then
						npcdata.burrowedtimer = npcdata.burrowedtimer + math.random(1, 3)
						--print(npcdata.burrowedtimer)
						--print(i:GetData().burrowedtimer)
					end
				end
				npcdata.burrowcheck = false
			end
		end
	elseif npcdata.state == "suck" then
		if sprite:IsFinished("startsuckinboy") then
			mod:spritePlay(sprite, "suck")
		elseif sprite:IsFinished("stopsuck") then
			mod:spritePlay(sprite, "idle")
			npcdata.idletimer = math.random(30, 45)
			npcdata.state = "idle"
		elseif sprite:IsFinished("catchbullet") then
			mod:spritePlay(sprite, "diginspit")
			npcdata.state = "burrow"
		elseif (npcdata.projectile ~= nil) then
			if (npc.Position - npcdata.projectile.Position):Length() <= 10 then
				npcdata.projectile:Remove()
				mod:spritePlay(sprite, "catchbullet")
				npc:PlaySound(SoundEffect.SOUND_LITTLE_SPIT,0.75,0,false,3)
			else
				local anglebetween = (npc.Position - npcdata.projectile.Position):GetAngleDegrees()
				npcdata.projectile.Velocity = mod:Lerp(npcdata.projectile.Velocity, Vector(15, 0):Rotated(anglebetween), 0.075)
			end
		elseif not sprite:IsPlaying("catchbullet") then
			mod:spritePlay(sprite, "stopsuck")
		end
	end
	--projectiley shit
	if sprite:IsEventTriggered("spit") then
		npc:PlaySound(SoundEffect.SOUND_PLOP,1,1,false,2)
		npcdata.projectile = Isaac.Spawn(9, 0, 0, npc.Position, Vector(0,0), npc):ToProjectile();
		npcdata.projectile.FallingSpeed = -3
		npcdata.projectile.FallingAccel = 0.15
		--npcdata.projectile:AddHeight(-5)
	end
	if npcdata.projectile then
		if npcdata.projectile.FallingAccel >= 0.15 and npcdata.projectile.FallingSpeed >= 0 and not (npc:HasEntityFlags(EntityFlag.FLAG_FEAR) or npc:HasEntityFlags(EntityFlag.FLAG_CONFUSION)) then
			npcdata.projectile.FallingSpeed = -0
			npcdata.projectile.FallingAccel = -0.1
		end
		if npcdata.projectile:CollidesWithGrid() or npcdata.projectile:IsDead() then
			npcdata.projectile = nil
		end
		if (npc:IsDead() or npc:HasEntityFlags(EntityFlag.FLAG_FEAR) or npc:HasEntityFlags(EntityFlag.FLAG_CONFUSION) or mod:isLeavingStatusCorpse(npc)) and npcdata.projectile ~= nil then
			npcdata.projectile.FallingAccel = 1
		end
	end
end

function mod:drinkwormfindpos(npc, npcdata)
	local room = game:GetRoom()
	local target = npc:GetPlayerTarget()
	local targetpos = target.Position
	local vptablelength = 1
	local validpositions = {}
	local size = room:GetGridSize()
	for i = 0, size do
		local grident = room:GetGridEntity(i)
		if ((not gridEntity) or (room:GetGridCollision(i) == GridCollisionClass.COLLISION_NONE and (gridEntity:GetType() ~= GridEntityType.GRID_SPIKES and gridEntity:GetType() ~ GridEntityType.GRID_SPIKES_ONOFF) or gridEntity:GetType() == GridEntityType.GRID_SPIDERWEB)) and room:IsPositionInRoom(room:GetGridPosition(i), 15) then
			if (mod:checkposdistancefroment(room:GetGridPosition(i), 1, -1, 100) 
			and mod:checkposdistancefroment(room:GetGridPosition(i), 666, 100, 40) 
			and (npcdata.projectile == nil or (room:CheckLine(room:GetGridPosition(i),npcdata.projectile.Position,3,1,false,false)) 
			and (room:GetGridPosition(i) - npcdata.projectile.Position):Length() > 80)) 
			and not mod:IsCampfireWithinRadius(room:GetGridPosition(i), 40)
			then
				table.insert(validpositions, i)
				vptablelength = vptablelength + 1
			end
		end
	end
	if vptablelength == 1 then
		return npc.Position
	else
		return room:GetGridPosition(validpositions[math.random(1, vptablelength - 1)])
	end
end

function mod:doProjectilesLoveMe(npc, returnCount)
	local entitycount = {}
	for index,proj in ipairs(Isaac.FindByType(9, -1, -1, EntityPartition.BULLET, true)) do
		if proj.SpawnerEntity and (proj.SpawnerEntity.InitSeed == npc.InitSeed) then
			table.insert(entitycount, proj)
		end
	end
	if returnCount then
		return #entitycount
	else
		if #entitycount > 0 then
			return true
		else
			return false
		end
	end
end

function mod:drunkwormai(npc, sprite, d)
	if not d.init then
		d.state = "idle"
		d.init = true
		npc:AddEntityFlags(EntityFlag.FLAG_NO_KNOCKBACK)
		npc.TargetPosition = npc.Position
	else
		npc.StateFrame = npc.StateFrame + 1
	end

	if d.state == "idle" then
		mod:spritePlay(sprite, "idle")
		d.KillAllBabies = true
		if (npc.StateFrame > 5 and math.random(10) == 1) or npc.StateFrame > 30 then
			d.state = "spitout"
			d.vec = RandomVector()
			d.ang = 0
			d.KillAllBabies = nil
		end
	elseif d.state == "spitout" then
		if sprite:IsFinished("spitfull") then
			d.state = "diggyhole"
		elseif sprite:IsEventTriggered("spit") then
			d.vec = d.vec or RandomVector()
			local vec = d.vec:Resized(math.random(9, 12)):Rotated(d.ang * 120)
			local proj = Isaac.Spawn(9,0,0,npc.Position, vec, npc):ToProjectile()
			proj:GetData().projType = "drunkworm"
			proj:AddProjectileFlags(ProjectileFlags.BOUNCE)
			proj.SpawnerEntity = npc
			proj:AddScale(1)
			proj.Height = -50
			proj.SpriteOffset = Vector(0, -30)
			proj.FallingAccel = 0
			proj.FallingSpeed = 0
			proj:Update()
			d.ang = d.ang + 1

			npc:PlaySound(SoundEffect.SOUND_LITTLE_SPIT,0.75,0,false,math.random(70,80)/100)
			for i = -60, 60, 30 do
				local smoke = Isaac.Spawn(1000, EffectVariant.DARK_BALL_SMOKE_PARTICLE, 0, npc.Position, Vector(0, -5):Rotated(i - 10 + math.random(20)), npc):ToEffect()
				smoke.SpriteRotation = math.random(360)
				smoke.Color = Color(1,1,1,0.5,0.7,0,0)
				smoke.SpriteScale = smoke.SpriteScale * math.random(70,100)/100
				smoke.SpriteOffset = Vector(0, -50)
				smoke.RenderZOffset = 500
				smoke:Update()
			end
			local poof = Isaac.Spawn(1000, 16, 960, npc.Position, nilvector, npc):ToEffect()
			if sprite.FlipX then
				poof:GetSprite().FlipX = true
			end
			poof.Color = Color(1,1,1,0.3,0,0,0)
			poof.RenderZOffset = 100
			poof.SpriteOffset = Vector(0, -55)
			poof.SpriteScale = Vector(0.5,0.5)
			poof:FollowParent(npc)
			poof:Update()
		else
			mod:spritePlay(sprite, "spitfull")
		end
	elseif d.state == "diggyhole" then
		if sprite:IsFinished("digin") then
			d.state = "comeOut"
			npc.StateFrame = 0
			d.spawned = false
			npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
		elseif sprite:IsEventTriggered("dig1") then

		elseif sprite:IsEventTriggered("dig2") then
			npc.CollisionDamage = 0
		else
			mod:spritePlay(sprite, "digin")
		end
	elseif d.state == "comeOut" then
		if d.spawned then
			if sprite:IsFinished("digout") then
				npc.CollisionDamage = 1
				d.askingforadvice = false
				if mod:doProjectilesLoveMe(npc) then
					d.state = "suck"
					d.suckAttempts = 0
				else
					d.state = "idle"
				end
				npc.StateFrame = 0
			elseif sprite:IsEventTriggered("dig1") then
				npc.CollisionDamage = 1
			else
				mod:spritePlay(sprite, "digout")
			end
		else
			if (npc.StateFrame >= 15 and math.random(15) == 1) or npc.StateFrame > 45 then
				local pos = mod:FindRandomFreePos(npc, 120, false, true, true)
				npc.Position = pos
				npc.TargetPosition = npc.Position
				d.askingforadvice = true
				d.spawned = true
				npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_ALL
			end
		end
	elseif d.state == "suck" then
		mod:spritePlay(sprite, "suck")
		if sprite:IsEventTriggered("suck") then
			d.sucking = true
			d.suckAttempts = d.suckAttempts + 1
			npc:PlaySound(SoundEffect.SOUND_PORTAL_SPAWN,0.3,0,false,math.random(190,210)/100)
		elseif sprite:IsEventTriggered("stop") then
			d.sucking = false
		end
		if d.sucking then
			local vec = Vector(-40, 20)
			if sprite.FlipX then
				vec = Vector(vec.X * -1, vec.Y)
			end
			vec = vec:Rotated(-30 + math.random(60))
			local smoke = Isaac.Spawn(1000, EffectVariant.DARK_BALL_SMOKE_PARTICLE, 960, npc.Position + vec, vec:Resized(-7), npc):ToEffect()
			smoke.SpriteRotation = math.random(360)
			smoke.Color = Color(1,1,1,0.1,0.5,0.5,0.5)
			smoke.SpriteScale = smoke.SpriteScale * math.random(70,100)/100
			smoke.SpriteOffset = Vector(0, -25)
			smoke.RenderZOffset = 500
			smoke:GetData().shrink = 0.95
			smoke:Update()
	else
			if not mod:doProjectilesLoveMe(npc) or d.suckAttempts > 4 then
				d.state = "idle"
				npc.StateFrame = 0
				d.KillAllBabies = true
			end
		end
	end
	if npc.TargetPosition then
		npc.Position = npc.TargetPosition
		npc.Velocity = nilvector
	end
end

function mod.drunkwormProj(v,d)
	if d.projType == "drunkworm" then
		v.SpriteOffset = mod:Lerp(v.SpriteOffset, nilvector, 0.1)
		if v.SpawnerEntity and v.SpawnerEntity:Exists() and not mod:isStatusCorpse(v.SpawnerEntity) then
			local vd = v.SpawnerEntity:GetData()
			v.FallingAccel = -0.1
			v.FallingSpeed = 0
			if v.Height < -20 then
				v.Height = v.Height + 1
			end
			v.SpriteOffset = mod:Lerp(v.SpriteOffset, nilvector, 0.1)
			if vd.sucking then
				v.Velocity = mod:Lerp(v.Velocity, (v.SpawnerEntity.Position - v.Position):Resized(11), 0.1)
			else
				if vd.state == "suck" then
					v.Velocity = v.Velocity * 0.9
				else
					v.Velocity = v.Velocity * 0.93
				end
			end
			if v.SpawnerEntity.Position:Distance(v.Position) < 10 and vd.state == "suck" then
				v:Die()
			end
			if vd.askingforadvice then
				if v.Position.X > v.SpawnerEntity.Position.X then
					v.SpawnerEntity:GetSprite().FlipX = true
				else
					v.SpawnerEntity:GetSprite().FlipX = false
				end
				vd.askingforadvice = nil
			end
			if vd.KillAllBabies then
				v.SpawnerEntity = nil
				v.FallingAccel = 0.5
			end
		else
			v.FallingAccel = 0.5
		end
	end
end

function mod:checkposdistancefroment(pos, typeoguy, variant, distance)
	--put variant as -1 to just find any
	local ents = Isaac.FindByType(typeoguy, variant, -1, false, false)
	for _, i in ipairs(ents) do
		if (pos - i.Position):Length() < distance then
			return false
		elseif typeoguy == 1 and (pos - (i.Position + (i.Velocity * 8))):Length() < distance then
			return false
		end
	end
	return true;
end

function mod:wobblesai(npc, sprite, npcdata)
	local target = npc:GetPlayerTarget()
	local targetpos = target.Position

	if not npcdata.init then
		npcdata.init = true;
		npcdata.state = "idle";
		npcdata.paddling = false;
		npcdata.statetimer = math.random(20, 30);
		npcdata.paddletarget = npc.Position;
		npcdata.inflated = false;
		npcdata.inflatecount = math.random(1, 3);
		npcdata.confvector = nil
		--npc.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_WALLS
		npcdata.radius = 13;

		if (targetpos.X >= npc.Position.X) then
			sprite.FlipX = true;
		else
			sprite.FlipX = false;
		end
	end



	if npcdata.state == "idle" then
		mod:spritePlay(sprite, "idle");
		npcdata.statetimer = npcdata.statetimer - 1;
		if (npc:HasEntityFlags(EntityFlag.FLAG_FEAR) or npc:HasEntityFlags(EntityFlag.FLAG_CONFUSION)) then
			npcdata.statetimer = npcdata.statetimer - 1;
		end
		if npcdata.statetimer <= 0 then
			if npcdata.inflatecount <= 0 and not npc:HasEntityFlags(EntityFlag.FLAG_FEAR) then
				npcdata.state = "inflatepaddle"
				npcdata.paddletarget = targetpos;

				npcdata.confvector = RandomVector()

				if (targetpos.X >= npc.Position.X) then
					sprite.FlipX = true;
				else
					sprite.FlipX = false;
				end
			else
				npcdata.state = "paddle"
				npcdata.paddletarget = targetpos;

				npcdata.confvector = RandomVector()
				if npc:HasEntityFlags(EntityFlag.FLAG_CONFUSION) then
					targetpos = npcdata.confvector
				end

				if (targetpos.X >= npc.Position.X) then
					sprite.FlipX = true;
				else
					sprite.FlipX = false;
				end

				if npc:HasEntityFlags(EntityFlag.FLAG_FEAR) then
					sprite.FlipX = not sprite.FlipX
				end

			end
		end
	elseif npcdata.state == "paddle" then
		mod:spritePlay(sprite, "paddle");
		if sprite:IsFinished("paddle") then
			mod:spritePlay(sprite, "idle");
			npcdata.state = "idle";
			npcdata.statetimer = math.random(20, 30);
			npcdata.inflatecount = npcdata.inflatecount - 1;
		end
	elseif npcdata.state == "inflatepaddle" then
		mod:spritePlay(sprite, "inflatepaddle");
		if sprite:IsFinished("inflatepaddle") then
			npcdata.state = "inflated";
			npcdata.statetimer = math.random(45, 60);
			npcdata.inflatecount = npcdata.inflatecount - 1;
		end
	elseif npcdata.state == "inflated" then

		if npc.Velocity.X > 0 then
			sprite.FlipX = true;
		else
			sprite.FlipX = false;
		end

		if npcdata.statetimer > 0 then
			mod:spritePlay(sprite, "inflatedidle")
			npcdata.statetimer = npcdata.statetimer - 1;
			if (npc:HasEntityFlags(EntityFlag.FLAG_FEAR) or npc:HasEntityFlags(EntityFlag.FLAG_CONFUSION)) then
				npcdata.statetimer = npcdata.statetimer - 3;
			end
		else
			mod:spritePlay(sprite, "deflate");
			if sprite:IsFinished("deflate") then
				npcdata.state = "idle";
				npcdata.statetimer = math.random(30, 40);
				npcdata.inflatecount = math.random(1, 3);
			end
		end
	end

	if npcdata.inflated == true then
		npc.Velocity = mod:Lerp(npc.Velocity, npc.Velocity:Resized(0.5), 0.05)
	elseif npcdata.paddling == true then
		npc.Velocity = mod:Lerp(npc.Velocity, npc.Velocity:Resized(0.25), 0.075)
	else
		npc.Velocity = mod:Lerp(npc.Velocity, npc.Velocity:Resized(0.25), 0.15)
	end

	if sprite:IsEventTriggered("paddle") then
		npc.Velocity = (npcdata.paddletarget - npc.Position):Resized(math.random(10, 12));
		if npc:HasEntityFlags(EntityFlag.FLAG_FEAR) then
			npc.Velocity = npc.Velocity * -1
		elseif npc:HasEntityFlags(EntityFlag.FLAG_CONFUSION) then
			if npcdata.confvector then
				npc.Velocity = npcdata.confvector:Resized(npc.Velocity:Length())
			end
		end
		npcdata.paddling = true;
		npc:PlaySound(SoundEffect.SOUND_BLOBBY_WIGGLE, 0.5, 0, false, math.random(15, 20)/10);
		if npc.Velocity.X > 0 then
			sprite.FlipX = true;
		else
			sprite.FlipX = false;
		end
	elseif sprite:IsEventTriggered("paddleend") then
		npcdata.paddling = false;
	elseif sprite:IsEventTriggered("collision32") then
		npc:SetSize(32, Vector(1, 0.5), 15);
		npcdata.radius = 32;
	elseif sprite:IsEventTriggered("collision26") then
		npc:SetSize(26, Vector(1, 0.75), 18);
		npcdata.radius = 26;
		if sprite:IsPlaying("deflate") then
			npc:PlaySound(mod.Sounds.BaloonBounce, 1.5, 0, false, 1.5);
		end
	elseif sprite:IsEventTriggered("inflate") then
		npc.Velocity = (npcdata.paddletarget - npc.Position):Resized(math.random(10, 15));
		if npc:HasEntityFlags(EntityFlag.FLAG_CONFUSION) then
			if npcdata.confvector then
				npc.Velocity = npcdata.confvector:Resized(npc.Velocity:Length())
			end
		end
		if npc.Velocity.X > 0 then
			sprite.FlipX = true;
		else
			sprite.FlipX = false;
		end

		npcdata.inflated = true;
		npc:PlaySound(mod.Sounds.Baloon, 1.5, 0, false, 3);
	elseif sprite:IsEventTriggered("deflate") then
		npcdata.inflated = false;
		npc:SetSize(13, Vector(1, 1), 12);
		npcdata.radius = 13;
	end

end

--length 27
mod.bloodbaghearttable = {
	2,	--half
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	1,	--full
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	5,	--double
	5,
	5,
	5,
	10, --blended
	9, --scared
	9,
	9,
	11 --bone
}

--length 9
mod.bloodbaggibtable = {
	0,	--normal
	0,
	0,
	0,
	2,	--guts
	2,
	2,
	1,	--bone
	1
}

--52 Deck Table
mod.decksacktable = {
	Card.JACK_OF_DIAMONDS,
	Card.JACK_OF_CLUBS,
	Card.JACK_OF_HEARTS,
	Card.JACK_OF_SPADES,--Jacks
	Card.THREE_OF_CLUBS,
	Card.THREE_OF_DIAMOND,
	Card.THREE_OF_SPADES,
	Card.THREE_OF_HEARTS,--Threes
	Card.QUEEN_OF_CLUBS,
	Card.QUEEN_OF_SPADES,
	Card.CARD_QUEEN_OF_HEARTS,
	Card.QUEEN_OF_DIAMONDS,--Queens
	Card.KING_OF_CLUBS,
	Card.KING_OF_DIAMONDS,--Kings
	Card.CARD_CLUBS_2,
	Card.CARD_DIAMONDS_2,
	Card.CARD_SPADES_2,
	Card.CARD_HEARTS_2,
	Card.CARD_DIAMONDS_2,
	Card.CARD_SPADES_2,
	Card.CARD_HEARTS_2,
	Card.CARD_ACE_OF_CLUBS,
	Card.CARD_ACE_OF_DIAMONDS,
	Card.CARD_ACE_OF_SPADES,
	Card.CARD_ACE_OF_HEARTS,
	Card.CARD_JOKER,
	Card.CARD_SUICIDE_KING
}

function mod:bloodsackupdate(pickup)
--Price Adjustment for Sacks
	if pickup:GetSprite():IsPlaying("Collect") then
		--[[if pickup:GetSprite():GetFrame() == 2 then
			pickup:GetData().dummysack:Remove()
			for _, pickupmaybe in ipairs(Isaac.FindByType(5, -1, -1, false, false)) do
				if (pickupmaybe:GetData().bloodsackspawned == nil or pickupmaybe:GetData().bloodsackspawned == false) and (pickupmaybe:GetSprite():IsPlaying("Appear") and (pickupmaybe:GetSprite():GetFrame() < 3)) and math.abs((pickupmaybe.Position - pickup.Position):Length()) < 25 then
					pickupmaybe:Remove()
				end
			end
		end
		if pickup:GetData().soundcancel == nil and sfx:IsPlaying(252) then
			sfx:Stop(252)
			--pickup:GetData().soundcancel = true
		end]]
	end
	if pickup:GetSprite():IsFinished("Collect") then
		pickup:Remove();
	elseif pickup:GetSprite():IsEventTriggered("DropSound") then
		if pickup.SubType == 10 then
			sfx:Play(SoundEffect.SOUND_MUSHROOM_POOF, 1, 0, false, 2);
		elseif pickup.SubType == 0 then
			sfx:Play(SoundEffect.SOUND_DEATH_BURST_SMALL, 1, 0, false, 2);
		elseif pickup.SubType == 11 then
			sfx:Play(SoundEffect.SOUND_SCAMPER, 1, 0, false, 2);
		end
	end
end

mod:AddCallback(ModCallbacks.MC_POST_PICKUP_UPDATE, mod.bloodsackupdate, 666)


function mod:bloodsacktouch(pickup, collider)
	if collider.Type == 1 then
		collider = collider:ToPlayer()
		if pickup:IsShopItem() and pickup.Price > collider:GetNumCoins() then
			return true
		else
			if pickup:GetSprite():WasEventTriggered("DropSound") or pickup:GetSprite():IsPlaying("Idle") then
				mod:bloodsackontouch(pickup)
				for _, playermaybe in ipairs(Isaac.FindByType(1, -1, -1, false, false)) do
					playermaybe:Update()
				end

				pickup.EntityCollisionClass = 0

				if pickup:IsShopItem() then
					collider:AddCoins(-1 * pickup.Price)
				end

				if pickup.OptionsPickupIndex ~= 0 then
					local pickups = Isaac.FindByType(EntityType.ENTITY_PICKUP)
					for _, entity in ipairs(pickups) do
						if entity:ToPickup().OptionsPickupIndex == pickup.OptionsPickupIndex and
						   (entity.Index ~= pickup.Index or entity.InitSeed ~= pickup.InitSeed)
						then
							Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.POOF01, 0, entity.Position, nilvector, nil)
							entity:Remove()
						end
					end
				end
			end
			return pickup:GetSprite():IsPlaying("Collect") or pickup:IsShopItem()
		end
	else
		return false
	end
end

function mod:bloodsackontouch(pickup, collider)
	mod:bloodsackburst(pickup, false, collider)
	--[[if Game():GetRoom():GetType() == RoomType.ROOM_CHALLENGE then
		pickup:GetData().dummysack = Isaac.Spawn(5, 69, 0, pickup.Position, Vector(0,0), pickup):ToPickup()
		pickup:GetData().dummysack:GetData().bloodsackspawned = false
		pickup:GetData().dummysack.Visible = false
		for i = 0, 25, 1 do
			pickup:GetData().dummysack:Update()
		end
	end]]
end

mod:AddCallback(ModCallbacks.MC_PRE_PICKUP_COLLISION, mod.bloodsacktouch, 666)

mod.KeysToSpice = {KeySubType.KEY_NORMAL, KeySubType.KEY_CHARGED, KeySubType.KEY_DOUBLEPACK, KeySubType.KEY_SPICY_BOX, KeySubType.KEY_SUPERSPICY_BOX, KeySubType.KEY_CHARGEDSPICY_BOX}
mod.KeysToRevert = {KeySubType.KEY_SPICY, KeySubType.KEY_SUPERSPICY, KeySubType.KEY_CHARGEDSPICY, KeySubType.KEY_SPICY_BOX, KeySubType.KEY_SUPERSPICY_BOX, KeySubType.KEY_CHARGEDSPICY_BOX}
mod.KeysToSpiceBox = {KeySubType.KEY_NORMAL, KeySubType.KEY_CHARGED, KeySubType.KEY_DOUBLEPACK, KeySubType.KEY_SPICY, KeySubType.KEY_SUPERSPICY, KeySubType.KEY_CHARGEDSPICY}
mod.KeysToRevertBox = {KeySubType.KEY_SPICY_BOX, KeySubType.KEY_SUPERSPICY_BOX, KeySubType.KEY_CHARGEDSPICY_BOX}
mod.KeysToSpicePutty = {KeySubType.KEY_NORMAL, KeySubType.KEY_CHARGED, KeySubType.KEY_DOUBLEPACK}

--CollectibleType.COLLECTIBLE_MOMS_BOX

function mod:MakeSpicy(entity, shouldPoof)
	if shouldPoof then
		poof = Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.FART, 0, entity.Position, Vector(0,0), entity):ToEffect()
		fartcolor = Color(1, 1, 1, 1, 0, 0, 0)
		fartcolor:SetColorize(1.0, 0.2, 0.2, 1)
		poof:GetSprite().Color = fartcolor
		sfx:Stop(SoundEffect.SOUND_FART)
	end

	morphmap = {
		[KeySubType.KEY_NORMAL] = KeySubType.KEY_SPICY, [KeySubType.KEY_CHARGED] = KeySubType.KEY_CHARGEDSPICY,
		[KeySubType.KEY_DOUBLEPACK] = KeySubType.KEY_SUPERSPICY, [KeySubType.KEY_SPICY] = KeySubType.KEY_NORMAL,
		[KeySubType.KEY_SUPERSPICY] = KeySubType.KEY_DOUBLEPACK, [KeySubType.KEY_CHARGEDSPICY] = KeySubType.KEY_CHARGED,
		[KeySubType.KEY_SPICY_BOX] = KeySubType.KEY_SPICY, [KeySubType.KEY_SUPERSPICY_BOX] = KeySubType.KEY_SUPERSPICY, [KeySubType.KEY_CHARGEDSPICY_BOX] = KeySubType.KEY_CHARGEDSPICY
	}

	if mod.anyPlayerHas(TrinketType.TRINKET_CHILI_POWDER, true) and mod.getTrinketMultiplierAcrossAllPlayers(TrinketType.TRINKET_CHILI_POWDER) > 1 then
		morphmap = {
			[KeySubType.KEY_NORMAL] = KeySubType.KEY_SPICY_BOX, [KeySubType.KEY_CHARGED] = KeySubType.KEY_CHARGEDSPICY_BOX,
			[KeySubType.KEY_DOUBLEPACK] = KeySubType.KEY_SUPERSPICY_BOX, [KeySubType.KEY_SPICY] = KeySubType.KEY_NORMAL,
			[KeySubType.KEY_SUPERSPICY] = KeySubType.KEY_DOUBLEPACK, [KeySubType.KEY_CHARGEDSPICY] = KeySubType.KEY_CHARGED,
			[KeySubType.KEY_SPICY_BOX] = KeySubType.KEY_NORMAL, [KeySubType.KEY_SUPERSPICY_BOX] = KeySubType.KEY_DOUBLEPACK, [KeySubType.KEY_CHARGEDSPICY_BOX] = KeySubType.KEY_CHARGED
		}
	end

	entity:ToPickup():Morph(5, 30, morphmap[entity.SubType], true)
end

mod:AddCallback(ModCallbacks.MC_POST_PICKUP_INIT, function(_, pickup)
	--[[if mod.anyPlayerHas(TrinketType.TRINKET_CHILI_POWDER, true) then
		for _, subtype in pairs(mod.KeysToSpice) do
			if pickup.SubType == subtype then
				--mod:MakeSpicy(pickup, false)
			end
		end
	end]]--

	if pickup.Type == EntityType.ENTITY_PICKUP and pickup.Variant == PickupVariant.PICKUP_KEY and pickup:GetSprite():IsPlaying("Appear") and mod.anyPlayerHas(CollectibleType.COLLECTIBLE_EVIL_STICKER, false) then
		for _, subtype in pairs(mod.KeysToSpicePutty) do
			if pickup.SubType == subtype then
				local rng = RNG()
				rng:SetSeed(pickup.InitSeed, 0)

				if rng:RandomFloat() < 0.2 then
					poof = Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.FART, 0, pickup.Position, Vector(0,0), pickup):ToEffect()
					fartcolor = Color(1, 1, 1, 1, 0, 0, 0)
					fartcolor:SetColorize(1.0, 0.2, 0.2, 1)
					poof:GetSprite().Color = fartcolor
					sfx:Stop(SoundEffect.SOUND_FART)

					morphmap = {
						[KeySubType.KEY_NORMAL] = KeySubType.KEY_SPICY_PERM, [KeySubType.KEY_CHARGED] = KeySubType.KEY_CHARGEDSPICY_PERM,
						[KeySubType.KEY_DOUBLEPACK] = KeySubType.KEY_SUPERSPICY_PERM
					}

					pickup:ToPickup():Morph(5, 30, morphmap[pickup.SubType], true)
				end
			end
		end
	end
end, PickupVariant.PICKUP_KEY)

--forgive me for what i must do............
mod:AddCallback(ModCallbacks.MC_POST_UPDATE, function() -- eugh
	if mod.anyPlayerHas(TrinketType.TRINKET_CHILI_POWDER, true) then
		if mod.getTrinketMultiplierAcrossAllPlayers(TrinketType.TRINKET_CHILI_POWDER) > 1 then
			keytable = mod.KeysToSpiceBox
		else
			keytable = mod.KeysToSpice
		end
	else
		keytable = mod.KeysToRevert
	end
	for _, entity in ipairs(Isaac.GetRoomEntities()) do
		if entity.Type == EntityType.ENTITY_PICKUP and entity.Variant == PickupVariant.PICKUP_KEY then
			for _, subtype in pairs(keytable) do
				if entity.SubType == subtype then
					mod:MakeSpicy(entity, true)
				end
			end
		end
	end
end)

--thank you to Piber20 for this code!
function mod.GetBoneSwingPickupPlayer(pickup)
	--try to get a player from bone club swings
	if pickup:IsShopItem() then return nil end

	for _, knife in pairs(Isaac.FindByType(EntityType.ENTITY_KNIFE, -1, 4, false, false)) do
		if knife.FrameCount > 0 and knife.Parent then
			local parent = knife.Parent
			if parent:ToPlayer() then
				local player = parent:ToPlayer()

				--find the center of the swing object
				knife = knife:ToKnife()
				local position = knife.Position
				local scale = 30
				if knife.Variant == 2 then --knife + bone
					scale = 42
				end
				scale = scale * knife.SpriteScale.X
				local offset = Vector(scale,0)
				offset = offset:Rotated(knife.Rotation)
				position = position + offset

				--do player checks
				if (position - pickup.Position):Length() < pickup.Size + scale and (not pickup:GetSprite():IsPlaying("Collect")) then --check if the player is touching it
					return player
				end
			end
		end
	end

	return nil
end

function mod:bloodsackstep(pickup)
	if mod.GetBoneSwingPickupPlayer(pickup) then
		mod:bloodsackontouch(pickup)
		--touchy feely
	end
end

mod:AddCallback(ModCallbacks.MC_POST_PICKUP_UPDATE, mod.bloodsackstep, 666)

mod.TrashBagMiscs = {
Hearts = {2, 2, 8, 8, 10, 11, 12, 12},
Worms = {9, 10, 11, 12, 26, 27, 64, 65, 66, 96, TrinketType.TRINKET_FORTUNE_WORM, TrinketType.TRINKET_TRINITY_WORM},
Pickups = {49, 50, Card.GLASS_D6, Card.GLASS_D4, Card.GLASS_D8, Card.GLASS_D100, Card.GLASS_D10, Card.GLASS_D20, Card.GLASS_D12, Card.GLASS_SPINDOWN, Card.GLASS_AZURITE_SPINDOWN, Card.PUZZLE_PIECE}
}

function mod:makeFliesNice()
	--Add later
end

function mod:bloodsackburst(pickup, isSnagger, collider)

	-- EPIPHANY PICKUP FIX --
	if collider -- is defined
	and collider:ToPlayer() -- is a player
	and Epiphany -- is installed
	and collider:ToPlayer():GetPlayerType() == Epiphany.table_type_id["KEEPER"] -- player is Tarnished Keeper
	and pickup.Price -- is defined
	and not (pickup.Price > 0)
	and not pickup.Touched
	then return end -- do not open the pickup
	-- END --

	--Isaac.ConsoleOutput("blooud")
	local subt = pickup.SubType
	if subt == 10 then
	--Trash Bag
		sfx:Play(SoundEffect.SOUND_MUSHROOM_POOF, 2, 0, false, 1.5);
		pickup:GetSprite():Play("Collect")
		local r = pickup:GetDropRNG()
		--Flies
		local randohelper = math.random(6)
		if randohelper < 4 then
			local randExtras = r:RandomInt(4)
			if isSnagger then
				randExtras = randExtras - 2
			end
			for i = 1, (3 + randExtras) do
				if isSnagger then
					local afly = Isaac.Spawn(18, 0, 0, pickup.Position, RandomVector()*math.random(1,5), pickup)
					afly:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
					afly.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS
					afly:Update()

					mod.scheduleForUpdate(function()
						afly.EntityCollisionClass = EntityCollisionClass.ENTCOLL_ALL
					end, 10)
				else
					local afly = Isaac.Spawn(3, 43, 0, pickup.Position, nilvector, pickup)
					afly:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
					afly:Update()
				end
			end
		--Spiders
		elseif randohelper < 6 then
			local randExtras = r:RandomInt(3)
			if isSnagger then
				randExtras = randExtras - 2
			end
			for i = 1, (2 + randExtras) do
				--[[local afly = Isaac.Spawn(3, 73, 0, pickup.Position, RandomVector()*1, pickup)
				afly:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
				afly:Update()]]
				if isSnagger then
					EntityNPC.ThrowSpider(pickup.Position, pickup, pickup.Position+RandomVector()*25, false, 0)
				else
					Isaac.GetPlayer(0):ThrowBlueSpider(pickup.Position, pickup.Position+RandomVector()*25)
				end
			end
		--Skuzzes
		else
			local randExtras = r:RandomInt(3)
			if isSnagger then
				randExtras = randExtras - 2
			end
			for i = 1, (2 + randExtras) do
				if isSnagger then
					local skuzz = Isaac.Spawn(666, 60, 0, pickup.Position, nilvector, pickup)
					skuzz.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS
					skuzz:GetData().jumpytimer = 0
					skuzz:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
					skuzz:Update()
				else
					Isaac.Spawn(3, FamiliarVariant.ATTACK_SKUZZ, 0, pickup.Position, nilvector, pickup)
				end
			end
		end
		--Heart - 33%
		if r:RandomInt(3) == 0 then
			local randHeart = r:RandomInt(#mod.TrashBagMiscs.Hearts) + 1
			local picky = Isaac.Spawn(5, 10, mod.TrashBagMiscs.Hearts[randHeart], pickup.Position, RandomVector()*1, pickup)
			picky:GetData().bloodsackspawned = true
		end
		--Consumable/Trinket - 25%
		if r:RandomInt(4) == 0 then
			if r:RandomInt(3) == 0 then
				local randPicky = r:RandomInt(#mod.TrashBagMiscs.Pickups) + 1
				local picky = Isaac.Spawn(5, 300, mod.TrashBagMiscs.Pickups[randPicky], pickup.Position, RandomVector()*1	, pickup)
				picky:GetData().bloodsackspawned = true
			else
				local randWorm = r:RandomInt(#mod.TrashBagMiscs.Worms) + 1
				local picky = Isaac.Spawn(5, 350, mod.TrashBagMiscs.Worms[randWorm], pickup.Position, RandomVector()*1, pickup)
				picky:GetData().bloodsackspawned = true
			end
		end
	elseif subt == 0 then
	--Blood Sack
		sfx:Play(SoundEffect.SOUND_DEATH_BURST_SMALL, 2, 0, false, 1.5);
		pickup:GetSprite():Play("Collect")
		for i = 1, math.random(2, 3), 1 do
			local heart = Isaac.Spawn(5, 10, mod.bloodbaghearttable[math.random(1, #mod.bloodbaghearttable)], pickup.Position, Vector(math.random(4, 7), 0):Rotated(math.random(359)), pickup):ToPickup()
			heart:GetData().bloodsackspawned = true
		end

		for i = 1, math.random(4, 6), 1 do
			Isaac.Spawn(1000, 5, mod.bloodbaggibtable[math.random(1, #mod.bloodbaggibtable)], pickup.Position, RandomVector()*(math.random(3, 6)), pickup)
		end

		for i = 1, math.random(4, 7), 1 do
			local bloodsplat = Isaac.Spawn(1000, 7, 0, pickup.Position + RandomVector() * math.random(2, 5), nilvector, pickup)
			bloodsplat.SpriteScale = Vector(math.random(20, 30)/10,math.random(15, 20)/10)
		end
	elseif subt == 11 then --52 Deck
		sfx:Play(SoundEffect.SOUND_SCAMPER)
		pickup:GetSprite():Play("Collect")

		local rng = RNG()
		rng:SetSeed(pickup.InitSeed, 46)

		local drops = 2 + rng:RandomInt(2)

		for i = 1, drops do
			local card = mod.GetWeightlessUnlockedCard(mod.decksacktable, rng, true, false, false)

			Isaac.Spawn(5, 300, card, pickup.Position, RandomVector():Resized(math.random(4, 7)), pickup)
		end
	end
end

function mod:sludgehostai(npc, sprite, npcdata)
	local target = npc:GetPlayerTarget()
	local targetpos = target.Position
	local targetangle = (targetpos - npc.Position):GetAngleDegrees()
	local targetdistance = (targetpos - npc.Position):Length()
	if npcdata.init == nil then
		npcdata.init = true
		npcdata.invul = true
		npcdata.spread = math.random(27, 40)
		npcdata.shooting = false
		npcdata.stateframe = 0;
		npcdata.damagedown = 0;
		npcdata.alreadybombed = false
		npc.SplatColor = mod.ColorDankBlackReal
		npc:AddEntityFlags(EntityFlag.FLAG_NO_TARGET)
	end

	--state stuff
	if sprite:IsFinished("Appear") or sprite:IsFinished("Shoot") then
		mod:spritePlay(sprite, "Idle")
	elseif sprite:IsPlaying("Idle") or sprite:IsFinished("Idle") then
		npcdata.stateframe = npcdata.stateframe + 1;
		if npcdata.stateframe >= 25 and targetdistance <= 175 then
			mod:spritePlay(sprite, "Shoot")
			npcdata.stateframe = 0;
		end
	elseif sprite:IsPlaying("Bombed") or sprite:IsFinished("Bombed") then
		npcdata.damagedown = 0;
		npcdata.stateframe = npcdata.stateframe + 1;
		if (npcdata.stateframe >= 90) then
			mod:spritePlay(sprite, "Idle")
			npcdata.stateframe = 0;
		end
	end

	--stay still!
	npc.Velocity = mod:Lerp(npc.Velocity, Vector(0,0), 0.4)

	--shooting start
	if sprite:IsEventTriggered("shoot") then
		--spawn blots
		if not mod:isScareOrConfuse(npc) then
			npc:PlaySound(SoundEffect.SOUND_GOODEATH,0.7,2,false,0.8)
			for i = npcdata.spread * -1, npcdata.spread, npcdata.spread * 2 do
				local blot = Isaac.Spawn(mod.FF.Blot.ID, mod.FF.Blot.Var, 0, npc.Position, Vector(math.min(0.03 * targetdistance * (math.random(8, 10) / 10), 3.5),0):Rotated(i + targetangle + math.random(-10, 10)), npc):ToNPC()
				local blotdata = blot:GetData()
				--print(blot.Velocity:Length())
				blotdata.downvelocity = -20;
				blotdata.downaccel = 2.5
				blot.Velocity = blot.Velocity * (math.random(12, 20)/7.5)
				blot.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
				blot.GridCollisionClass = GridCollisionClass.COLLISION_NONE
				blot:GetSprite().Offset = Vector(0, -1)
				blotdata.state = "air"
				blot:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
			end
		end
		--set shooting true
		npcdata.shooting = true
	elseif sprite:IsEventTriggered("vulnerable") then
		npc:PlaySound(SoundEffect.SOUND_ANIMAL_SQUISH,1,2,false,1)
		npcdata.invul = false
		npcdata.damagedown = 0;
		npc:ClearEntityFlags(EntityFlag.FLAG_NO_TARGET)
		npcdata.alreadybombed = false
	elseif sprite:IsEventTriggered("invulnerable") then
		npc:PlaySound(SoundEffect.SOUND_ANIMAL_SQUISH,1,2,false,0.9)
		npcdata.invul = true
		npc:AddEntityFlags(EntityFlag.FLAG_NO_TARGET)
		--look cool
		if not mod:isScareOrConfuse(npc) then
			local creep = Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.CREEP_BLACK, 0, npc.Position, Vector(0,0), npc):ToEffect();
			creep:Update();
			creep.Size = creep.Size * 2
			creep:GetSprite().Scale = creep:GetSprite().Scale * 2
			for i = 0, math.random(4, 6), 1 do
				local projectile = Isaac.Spawn(9, 0, 0, npc.Position, RandomVector()  *math.random(2, 5), npc):ToProjectile();
				projectile.FallingSpeed = -30;
				projectile.FallingAccel = 2.5
				projectile.Color = mod.ColorDankBlackReal
				local projdata = projectile:GetData();
				projdata.creeptype = "black"
			end
		end
	elseif sprite:IsEventTriggered("shootstop") then
		npcdata.shooting = false
		npcdata.spread = math.random(27, 40)
	end
	--shooting stuff
	if not mod:isScareOrConfuse(npc) then
		if npcdata.shooting == true then
			mod:Lerp(npcdata.spread, 10, 0.1)
			if npc.FrameCount % math.random(3, 4) == 1 then
				npc:PlaySound(SoundEffect.SOUND_BLOODSHOOT,1,2,false,1)
				local projectile = Isaac.Spawn(9, 0, 0, npc.Position, Vector(math.min(math.floor(0.075 * targetdistance * (math.random(8, 10) / 10)), 15),0):Rotated(targetangle + math.random(npcdata.spread * -1, npcdata.spread)), npc):ToProjectile();
				projectile.FallingSpeed = -30;
				projectile.FallingAccel = 2.5
				projectile.Color = mod.ColorDankBlackReal
				local projdata = projectile:GetData();
				projdata.creeptype = "black"
			end
		end
		if npc.FrameCount % 30 == 1 then
			local creep = Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.CREEP_BLACK, 0, npc.Position, Vector(0,0), npc):ToEffect()
			creep.SpriteScale = creep.SpriteScale * 1.5
			creep:Update()
		end
	end
end

mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, function(_, npc)
  if npc.Variant == 3 then
	local sprite = npc:GetSprite()
	if sprite:GetAnimation() == "Attack2" and sprite:GetFrame() == 8 then
	  mod:UpdatePits(game:GetRoom():GetGridIndex(npc.Position))
	end
  end
end, 62)

mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, function(_, npc)
  if npc.Variant == 0 then
	local sprite = npc:GetSprite()
	if sprite:GetAnimation() == "SuperBlast" and sprite:GetFrame() == 33 then
	  mod:UpdatePits(0)
	end
  end
end, 915)

local bombsEffectMap = {1,2,3,4,5,6,1,2,5,6}
mod.customBombs = {}  -- This data persists between rooms

function mod:setBombGFX(bomb, player)
  --local player = bomb.Parent:ToPlayer()
  if not mod.customBombs[bomb.InitSeed].flags then      --bomb is new
	mod.customBombs[bomb.InitSeed].flags = {}

	mod.customBombs[bomb.InitSeed].flags = {}
	--local flags = bomb:ToBomb().Flags
	local fHoming =  bomb:HasTearFlags(1<<2)
	mod.customBombs[bomb.InitSeed].flags[1] = fHoming
	local fPoison = bomb:HasTearFlags(1<<4)
	--mod.customBombs[bomb.InitSeed].flags[2] = fPoison
	local fFire = bomb:HasTearFlags(1<<22)
	mod.customBombs[bomb.InitSeed].flags[2] = fFire
	local fSad = bomb:HasTearFlags(1<<28)
	mod.customBombs[bomb.InitSeed].flags[3] = fSad
	local fButt = bomb:HasTearFlags(1<<29)
	mod.customBombs[bomb.InitSeed].flags[4] = fButt
	local fGlitter = bomb:HasTearFlags(1<<35)
	mod.customBombs[bomb.InitSeed].flags[5] = fGlitter
	local fFast = bomb:HasTearFlags(BitSet128(0,1<<(126-64)))
	mod.customBombs[bomb.InitSeed].flags[6] = fFast

	local body = -1
	if fPoison then body = 3
	elseif fSad and fButt then body = 9
	elseif fSad and not fButt then body = 7
	elseif fButt then body = 5
	else body = 1
	end
	if player:HasCollectible(CollectibleType.COLLECTIBLE_MR_MEGA) then body = body + 1 end

	mod.customBombs[bomb.InitSeed].body = body
  end

  local flags = mod.customBombs[bomb.InitSeed].flags
  local body = mod.customBombs[bomb.InitSeed].body
  local effect = bombsEffectMap[body]

  local sprite = bomb:GetSprite()
  sprite:Load("gfx/effects/ff_multibomb.anm2", false)
  sprite:ReplaceSpritesheet(0, "gfx/effects/nuggetbomb/body_" .. body .. ".png")
  if flags[1] then sprite:ReplaceSpritesheet(1, "gfx/effects/nuggetbomb/effects_" .. effect .. ".png") end    --Homing
  if flags[2] then sprite:ReplaceSpritesheet(6, "gfx/effects/nuggetbomb/effects_" .. effect .. ".png") end    --Fire
  if flags[3] then sprite:ReplaceSpritesheet(4, "gfx/effects/nuggetbomb/effects_" .. effect .. ".png") end    --Sad
  if flags[4] then sprite:ReplaceSpritesheet(3, "gfx/effects/nuggetbomb/effects_" .. effect .. ".png") end    --Butt
  if flags[5] then sprite:ReplaceSpritesheet(7, "gfx/effects/nuggetbomb/effects_" .. effect .. ".png") end    --Glitter
  if flags[6] then sprite:ReplaceSpritesheet(2, "gfx/effects/nuggetbomb/effects_" .. effect .. ".png") end    --Fast
  sprite:ReplaceSpritesheet(5, "gfx/effects/nuggetbomb/effects_" .. effect .. ".png")                         --Fly
  sprite:LoadGraphics()
end

function mod:SpawnNuggetFam(pos, flags, player, isDecoy, bSeed)
  if #Isaac.FindByType(3, -1, -1, false, false) ~= 64 then
	local spooter = Isaac.Spawn(EntityType.ENTITY_FAMILIAR, FamiliarVariant.BROWN_NUGGET_POOTER, 0, pos, Vector(0,0), player)
	local bFlags = {}
	local nullF = BitSet128(0,0)
	bFlags[0] = flags
	bFlags[1] = player:HasCollectible(CollectibleType.COLLECTIBLE_MR_MEGA)
	bFlags[2] = (flags & TearFlags.TEAR_HOMING) ~= nullF        -- Homing
	bFlags[3] = (flags & TearFlags.TEAR_POISON) ~= nullF        -- Poison
	bFlags[4] = (flags & TearFlags.TEAR_BURN) ~= nullF          -- Fire
	bFlags[5] = (flags & TearFlags.TEAR_SAD_BOMB) ~= nullF      -- Sad
	bFlags[6] = (flags & TearFlags.TEAR_BUTT_BOMB) ~= nullF     -- Butt
	bFlags[7] = (flags & TearFlags.TEAR_GLITTER_BOMB) ~= nullF  -- Glitter
	bFlags[8] = (flags & TearFlags.TEAR_STICKY) ~= nullF        -- Sticky
	bFlags[9] = (flags & TearFlags.TEAR_CROSS_BOMB) ~= nullF    -- Bomber boy
	bFlags[10] = (flags & TearFlags.TEAR_CREEP_TRAIL) ~= nullF  -- Bob's Bladder
	bFlags[11] = (flags & BitSet128(0,1<<(126-64))) ~= nullF    -- Fast bombs
	bFlags[12] = isDecoy                                        -- Best Friend
	bFlags[13] = (flags & BitSet128(0,1<<(72-64))) ~= nullF     -- Blood bombs
	bFlags[14] = (flags & BitSet128(0,1<<(75-64))) ~= nullF     -- Brimstone bombs
	bFlags[15] = (flags & BitSet128(0,1<<(78-64))) ~= nullF     -- Ghost bombs
	bFlags[16] = (flags & BitSet128(0,1<<(119-64))) ~= nullF    -- Giga bombs
	spooter:GetData().bFlags = bFlags
	--spooter:GetData().fastTearRate = (flags & BitSet128(0,1<<(126-64))) ~= nullF  -- Fast Bombs
	spooter:GetData().bSeed = bSeed
	return spooter
  end
end

--function mod:GetBombSpawner(bomb)
--  local mask = ~BitSet128(1<<36,0)
--	local bombs = Isaac.FindInRadius(bomb.Position, 100, 0xffffffff)
--	local nearest
--	local dist
--	for _, e in pairs(bombs) do
--		if e.Type == 4 and e:ToBomb():HasTearFlags(1<<36) and GetPtrHash(bomb) ~= GetPtrHash(e) and e:IsDead() and e:ToBomb().Flags and bomb:ToBomb().Flags == (e:ToBomb().Flags & mask) then
--      if not nearest then
--       		nearest = e
--       		dist = e.Position:Distance(bomb.Position)
--      else
--       		local distN = e.Position:Distance(bomb.Position)
--       		if distN < dist then
--         		nearest = e
--         		dist = distN
--       		end
--      end
--		end
--	end
--	return nearest
--end

mod:AddCallback(ModCallbacks.MC_POST_ENTITY_REMOVE, function(_, bomb)
  if bomb.Variant == 17 or bomb.Variant == 20 then mod:UpdatePits(0) end
  if bomb:GetData().isNugget then
	local mask = ~BitSet128(1<<36,0)
	ents = Isaac.FindInRadius(bomb.Position, 45, 0xffffffff)
	if not bomb:GetData().isDecoy then bomb:GetData().isDecoy = bomb.Type == 4 and bomb.Variant == 2 end
	if not bomb:GetData().isScatter then
	  for _, e in pairs(ents) do
		if e.FrameCount == 1 and e.Type == 4 and not e:ToBomb():HasTearFlags(1<<36) and GetPtrHash(bomb) ~= GetPtrHash(e) and (bomb:ToBomb().Flags & mask) == e:ToBomb().Flags then
		  mod.customBombs[e.InitSeed] = {}
		  mod.customBombs[e.InitSeed].flags = mod.customBombs[bomb.InitSeed].flags
		  mod.customBombs[e.InitSeed].body = mod.customBombs[bomb.InitSeed].body
		  mod.customBombs[e.InitSeed].isNugget = true
		  mod.customBombs[e.InitSeed].isScatter = true
		  mod.customBombs[e.InitSeed].isDecoy = bomb:GetData().isDecoy
		  e:GetData().isNugget = true
		  e:GetData().isScatter = true
		  e:GetData().isDecoy = bomb:GetData().isDecoy
		end
	  end
	end
--    local spooter = mod:SpawnNuggetFam(bomb.Position, bomb:ToBomb().Flags, bomb.SpawnerEntity:ToPlayer(), bomb:GetData().isDecoy)
--    if spooter and bomb:GetData().isScatter then
--      spooter:GetData().isBabySpooter = true
--      spooter.SpriteScale = Vector(0.5, 0.5)
--      spooter:SetSize(spooter.Size * 0.5, spooter.SizeMulti * 0.5, 12)
--      local sprite = spooter:GetSprite()
--      sprite:ReplaceSpritesheet(0, "gfx/familiar/babypooter.png")
--      sprite:ReplaceSpritesheet(1, "gfx/familiar/babypooter_spawn.png")
--      sprite:LoadGraphics()
--    end
--    mod.customBombs[bomb.InitSeed] = nil
  end
end, 4)

mod:AddCallback(ModCallbacks.MC_POST_BOMB_UPDATE, function(_, bomb)
  if bomb.FrameCount == 1 and bomb.Variant ~= 13 then    --bootleg MC_POST_BOMB_INIT
	local player
	if not mod.customBombs[bomb.InitSeed] then
	  if bomb.Variant ~= 2 and bomb.SpawnerType == 1 then
		player = bomb.SpawnerEntity:ToPlayer()
	  elseif bomb.Variant == 2 and bomb.Size == 16 then     -- Best Friend
		local nearest
		local dist
		players = Isaac.FindInRadius(bomb.Position, 10, 1<<5)
		for _, p in pairs(players) do
		  if not nearest then
			nearest = p
			dist = p.Position:Distance(bomb.Position)
		  else
			local distN = p.Position:Distance(bomb.Position)
			if distN < dist then
			  nearest = p
			  dist = distN
			end
		  end
		end
		if nearest then
		  player = nearest:ToPlayer()
		  bomb.SpawnerEntity = player
		end
	  end
	  if player then
		bomb:GetData().isNugget = player:HasCollectible(CollectibleType.COLLECTIBLE_NUGGET_BOMBS)
		bomb:GetData().isDecoy = bomb.Variant == 2
		mod.customBombs[bomb.InitSeed] = {}
		mod.customBombs[bomb.InitSeed].isNugget = bomb:GetData().isNugget
		mod.customBombs[bomb.InitSeed].isDecoy = bomb.Variant == 2
		if player:HasCollectible(CollectibleType.COLLECTIBLE_TELEBOMBS) then
			mod:handleTelebombBombInit(player, bomb)
		end
	  end
	else
	  bomb:GetData().isNugget = mod.customBombs[bomb.InitSeed].isNugget
	  bomb:GetData().isScatter = mod.customBombs[bomb.InitSeed].isScatter
	  bomb:GetData().isDecoy = mod.customBombs[bomb.InitSeed].isDecoy
	end

	if bomb:GetData().isNugget and not (REVEL and player:HasCollectible(REVEL.ITEM.SPONGE.id)) and bomb.Variant ~= 1 and bomb.Variant ~= 2 then
	  --mod:setBombGFX(bomb, player)
	  --if bomb.Variant == 3 then bomb:GetSprite():Play("Appear", true) end
	end
  end

  if bomb:GetData().isNugget and bomb:IsDead() then
	local spooter = mod:SpawnNuggetFam(bomb.Position, bomb:ToBomb().Flags, bomb.SpawnerEntity:ToPlayer(), bomb:GetData().isDecoy, bomb.InitSeed)

	if spooter and bomb.Variant == 17 then
	  spooter:GetData().isUltraSpooter = true
	  spooter:SetSize(20, spooter.SizeMulti, 12)
	  local sprite = spooter:GetSprite()
	  sprite:Load("gfx/familiar/nugget fly/ultra pooter.anm2", true)
	  sprite:Play("Appear", true)
	elseif spooter and bomb:GetData().isScatter then
	  spooter:GetData().isBabySpooter = true
	  --spooter.SpriteScale = Vector(0.5, 0.5)
	  spooter:SetSize(spooter.Size * 0.5, spooter.SizeMulti * 0.5, 12)
	  local sprite = spooter:GetSprite()
	  sprite:Load("gfx/familiar/nugget fly/pooter_0.anm2", true)
	  sprite:Play("Appear", true)
	  --sprite:ReplaceSpritesheet(1, "gfx/familiar/babypooter_spawn.png")
	  --sprite:LoadGraphics()
	end
	--mod.customBombs[bomb.InitSeed] = nil
  end
end)

--mod.fastNuggetFams = {}
mod:AddCallback(ModCallbacks.MC_FAMILIAR_UPDATE, function(_, fam)
	--if fam:GetData().fastTearRate and fam:GetSprite():IsPlaying("Attack") and fam:GetSprite():GetFrame() == 13 then table.insert(mod.fastNuggetFams, fam) end
	if fam.FireCooldown > 0 then fam.FireCooldown = fam.FireCooldown - 1 end

	if fam:GetData().bFlags and fam:GetData().bFlags[11] and fam:GetSprite():IsPlaying("Attack") and fam:GetSprite():GetFrame() == 0 then
	  fam.FireCooldown = 16
	end
	if fam.FireCooldown == 1 then
	  local pos = fam.Position
	  local enemies = Isaac.FindInRadius(pos, 150, EntityPartition.ENEMY)
	  local nearest
	  local dist
	  for _, e in pairs(enemies) do
		if dist and e:IsVulnerableEnemy() then
		  local distN = e.Position:Distance(pos)
		  if distN < dist then
			nearest = e
			dist = distN
		  end
		end
		if not nearest and e:IsVulnerableEnemy() then
		  nearest = e
		  dist = e.Position:Distance(pos)
		end
	  end
	  if nearest then
		fam:GetSprite():Play("Attack", true)
		local tear = Isaac.Spawn(EntityType.ENTITY_TEAR, TearVariant.BLOOD, 0, pos, (nearest.Position - pos):Normalized() * 10, fam)
		tear:ToTear().Scale = 0.8
		tear:GetData().nuggetFast = true
	  end
	end

	--if fam:GetData().isBabySpooter then
	--  fam.SpriteScale = Vector(0.5, 0.5)
	--end

	if fam.FrameCount == 6 and fam:GetData().bSeed then       -- dont ask
	  mod.customBombs[fam:GetData().bSeed] = nil
	end
end, FamiliarVariant.BROWN_NUGGET_POOTER)

--mod:AddCallback(ModCallbacks.MC_POST_UPDATE, function()
--    for _, fam in pairs(mod.fastNuggetFams) do
--      local spooter = mod:SpawnNuggetFam(fam.Position, fam.Player:GetBombFlags(), fam.Player)
--      for i=1, 14 do
--        spooter:Update()
--      end
--      fam:Remove()
--    end
--    mod.fastNuggetFams = {}
--end)

mod:AddCallback(ModCallbacks.MC_USE_ITEM, function()
  local player = mod:GetPlayerUsingItem()
  if player:HasCollectible(CollectibleType.COLLECTIBLE_NUGGET_BOMBS) then
	mod:SpawnNuggetFam(player.Position, player:GetBombFlags(), player, false, nil)
  end
  if player:HasCollectible(CollectibleType.COLLECTIBLE_TELEBOMBS) then
	mod:handleTelebombBombInit(player)
  end
end, CollectibleType.COLLECTIBLE_KAMIKAZE)

mod:AddCallback(ModCallbacks.MC_POST_EFFECT_UPDATE, function(_, eff)
  if eff.FrameCount == 1 and eff.SpawnerType == 1 then
	local player = Game():GetNearestPlayer(eff.Position)
	if player:HasCollectible(CollectibleType.COLLECTIBLE_NUGGET_BOMBS) and (player:HasWeaponType(WeaponType.WEAPON_ROCKETS) or player:GetEffects():HasCollectibleEffect(CollectibleType.COLLECTIBLE_DOCTORS_REMOTE)) then
	  eff:GetData().isNugget = true
	  eff:GetData().Player = player
	end
  end
end, EffectVariant.TARGET)

mod:AddCallback(ModCallbacks.MC_POST_ENTITY_REMOVE, function(_, eff)
	if eff.Variant == EffectVariant.TARGET and eff.FrameCount == 51 and eff:GetData().isNugget then
	  mod:SpawnNuggetFam(eff.Position, eff:GetData().Player:GetBombFlags(), eff:GetData().Player, false, nil)
	end
end, EntityType.ENTITY_EFFECT)

mod:AddCallback(ModCallbacks.MC_FAMILIAR_UPDATE, function(_, fam)
	if fam.Variant == FamiliarVariant.BOBS_BRAIN or fam.Variant == FamiliarVariant.BBF then
	  if not fam.Visible and not fam:GetData().blown then
		fam:GetData().blown = true
		local player = fam.Player
		if player:HasCollectible(CollectibleType.COLLECTIBLE_NUGGET_BOMBS) then
		  local bFlags = fam.Player:GetBombFlags()
		  if fam.Variant == FamiliarVariant.BOBS_BRAIN then bFlags = bFlags | TearFlags.TEAR_POISON end
		  mod:SpawnNuggetFam(fam.Position, bFlags, fam.Player, false, nil)
		end
	  elseif fam.Visible and fam:GetData().blown then
		fam:GetData().blown = nil
	  end
	end
end)

mod:AddCallback(ModCallbacks.MC_POST_LASER_UPDATE, function(_, laser)
	local var = laser.Variant
	if var == 4 or var == 7 or var == 8 or var == 13 then -- Pride, Tractor Beam, Circle of Protection and Beast Lasers
		return
	end

	if laser.SpawnerEntity and laser.SpawnerEntity.Type == EntityType.ENTITY_PLAYER and var == 2 and laser.SubType == 0 then
		local familiars = Isaac.FindInRadius(laser.Position, 0.000001, EntityPartition.FAMILIAR)
		for _,familiar in ipairs(familiars) do
			if familiar.Variant == FamiliarVariant.FINGER then
				return
			end
		end
	end

	local player = nil
	if laser.SpawnerEntity and laser.SpawnerEntity:ToPlayer() then
		player = laser.SpawnerEntity:ToPlayer()
	elseif laser.SpawnerEntity and laser.SpawnerEntity:ToFamiliar() and laser.SpawnerEntity:ToFamiliar().Player then
		local familiar = laser.SpawnerEntity:ToFamiliar()

		if familiar.Variant == FamiliarVariant.INCUBUS or familiar.Variant == FamiliarVariant.SPRINKLER or
		   familiar.Variant == FamiliarVariant.TWISTED_BABY or familiar.Variant == FamiliarVariant.BLOOD_BABY or
		   familiar.Variant == FamiliarVariant.UMBILICAL_BABY then
			player = familiar.Player
		else
			return
		end
	else
		return
	end

	local data = laser:GetData()
	local nuggetType = data.nuggetType
	if nuggetType and laser.Timeout > 0 then
		laser:GetSprite().Scale = Vector(0.25*nuggetType, 1)
		laser:SetSize(4*nuggetType, Vector.One, 0)
		--laser.Child:GetSprite().Scale = Vector(0.3125, 0.25)--*nuggetType
	end
	mod:erflyPostLaserUpdate(player, laser, data)
end)

local customPurgatorySouls = {}
function mod:nuggetFlyAttack(fam, vel, hex)

  local bFlags = fam:GetData().bFlags

  local dmgBonus = 1
  local scaleBonus = 1
  if bFlags[1] then
	dmgBonus = dmgBonus * 1.6
	scaleBonus = scaleBonus * 1.2
  end
  if bFlags[9] and math.random(4) == 1 then
	scaleBonus = scaleBonus * 1.1
  end
  if fam:GetData().isUltraSpooter then
	dmgBonus = dmgBonus * 2
  elseif fam:GetData().isBabySpooter then
	dmgBonus = dmgBonus * 0.5
	scaleBonus = scaleBonus * 0.5
  end

  local flags = BitSet128(0,0)
  local cNuggetFlags = {}
  local color
  local variant = 1
  if bFlags[2] then
	flags = flags | TearFlags.TEAR_HOMING
	variant = TearVariant.BLUE
	color = Color(0.4, 0.15, 0.38, 1, 71 / 255, 0, 116 / 255)
  end
  if bFlags[3] and math.random(15) == 1  then
	flags = flags | TearFlags.TEAR_POISON
	if variant ~= 0 then variant = TearVariant.BLUE end
	color = Color(0.196078, 1, 0.196078, 1, 0, 0, 0)
  end
  if bFlags[4] and math.random(15) == 1 then
	flags = flags | TearFlags.TEAR_BURN
	variant = TearVariant.FIRE_MIND
	color = Color(1, 148/255, 76/255, 1, 64/255, 48/255, 19/255)
  end
  if bFlags[6] and math.random(15) == 1 then
	flags = flags | TearFlags.TEAR_CONFUSION
	variant = TearVariant.BLUE
	color = Color(0.375, 0.25, 0, 1, 32 / 255, 0, 0)
  end
  if bFlags[7] and math.random(10) == 1 then
	flags = flags | TearFlags.TEAR_CHARM
	variant = TearVariant.BLUE
	color = Color(1, 0, 1, 1, 50 / 255, 0, 0)
  end
  if bFlags[8] and math.random(20) == 3 then
	flags = flags | TearFlags.TEAR_EGG
	variant = TearVariant.EGG
  end
  if bFlags[9] and math.random(4) == 1 then
	flags = flags | TearFlags.TEAR_QUADSPLIT
	cNuggetFlags.nuggetSplit = true
  end
  if bFlags[10] and math.random(8) == 1 then
	if variant == 0 or variant == 1 then variant = TearVariant.MYSTERIOUS end
	cNuggetFlags.nuggetBladder = true
  end
  if bFlags[12] and math.random(4) == 1 then
	flags = flags | BitSet128(0,1<<(67-64))
	color = Color(0.7, 0.14, 0.1, 1, 0.3, 0, 0)
  end
  if bFlags[13] and math.random(12) == 1 then
	if variant == 0 or variant == 1 then variant = TearVariant.BALLOON end
	cNuggetFlags.nuggetBlood = true
  end

  local w_rng = math.random(7)
  if w_rng == 6 and bFlags[15] then                     -- Pooter shoots ghost
	--if not (math.abs(color.B-0.38) < 0.0001) then soul:SetColor(color, 0, 0, false, false) end
	if color and (math.abs(color.B-0.38) < 0.0001) then color = nil end    -- homing color check
	if not color then
	  if cNuggetFlags.nuggetBladder then color = Color(19/255, 239/255, 0, 1, 0, 0, 0)
	  elseif variant == TearVariant.BALLOON then color = Color(237/255, 15/255, 0, 1, 0, 0, 0) end
	end
	if color then color:SetColorize(1, 1, 1, 0.3) else color = Color(1, 1, 1, 1, 0, 0, 0) end
	if fam:GetData().isUltraSpooter then
	  scaleBonus = scaleBonus * 1.25
	  for i=0, 3 do
		soul = Isaac.Spawn(1000, 189, 1, fam.Position, Vector.Zero, fam.SpawnerEntity):ToEffect()
		soul:SetColor(color, 0, 0, false, false)
		customPurgatorySouls[soul.InitSeed] = {}
		customPurgatorySouls[soul.InitSeed].nuggetDmgBonus = dmgBonus
		customPurgatorySouls[soul.InitSeed].nuggetFlags = flags
		customPurgatorySouls[soul.InitSeed].nuggetFam = fam
		customPurgatorySouls[soul.InitSeed].nuggetBlood = cNuggetFlags.nuggetBlood
		soul:GetData().nuggetBladder = cNuggetFlags.nuggetBladder
		soul.SpriteScale = Vector(scaleBonus, scaleBonus)
		soul.SpriteOffset = Vector(0, 12*(-1+scaleBonus))
		for j=1, (40-i*3) do soul:Update() end
	  end
	else
	  soul = Isaac.Spawn(1000, 189, 1, fam.Position, Vector.Zero, fam.SpawnerEntity):ToEffect()
	  soul:SetColor(color, 0, 0, false, false)
	  customPurgatorySouls[soul.InitSeed] = {}
	  customPurgatorySouls[soul.InitSeed].nuggetDmgBonus = dmgBonus
	  customPurgatorySouls[soul.InitSeed].nuggetFlags = flags
	  customPurgatorySouls[soul.InitSeed].nuggetFam = fam
	  customPurgatorySouls[soul.InitSeed].nuggetBlood = cNuggetFlags.nuggetBlood
	  soul:GetData().nuggetBladder = cNuggetFlags.nuggetBladder
	  soul.SpriteScale = Vector(scaleBonus, scaleBonus)
	  soul.SpriteOffset = Vector(0, 12*(-1+scaleBonus))
	  for i=1, 40 do soul:Update() end
	end

  elseif w_rng == 7 and bFlags[14] then                 -- Pooter shoots brimstone
	if color then
	  color:SetColorize(color.R, color.G, color.B, 0.35)
	else
	  color = Color(1, 1, 1, 1, 0, 0, 0)
	end
	if cNuggetFlags.nuggetBladder then flags = flags | TearFlags.TEAR_MYSTERIOUS_LIQUID_CREEP end
	if fam:GetData().isUltraSpooter then
	  local angles
	  if hex then
		angles = {-22.5, -7.5, 7.5, 22.5}
	  else
		angles = {-28.118, -9.567, 9.567, 28.118}
	  end
	  local angle = vel:GetAngleDegrees()

	  for i=1, 4 do
		local laser = EntityLaser.ShootAngle(1, fam.Position + vel, angles[i] + angle, 8, Vector(0, -15), fam):ToLaser()
		laser.CollisionDamage = 1.3125 * dmgBonus
		laser:GetData().nuggetType = 3
		laser:SetSize(12, Vector.One, 0)
		laser:GetSprite().Scale = Vector(0.75, 0.75)
		laser:AddTearFlags(flags)
		laser:SetColor(color, 0, 0, false, false)
		laser:Update()
		laser:Update()  --bruh
	  end
	else
	  local laser = EntityLaser.ShootAngle(1, fam.Position + vel, vel:GetAngleDegrees(), 8, Vector(0, -15), fam):ToLaser()
	  local nuggetType = 2
	  if fam:GetData().isBabySpooter then nuggetType = 1 end
	  laser.CollisionDamage = 1.3125 * dmgBonus
	  laser:GetData().nuggetType = nuggetType
	  laser:SetSize(4*nuggetType, Vector.One, 0)
	  laser:GetSprite().Scale = Vector(0.25, 0.25)*nuggetType
	  laser:AddTearFlags(flags)
	  laser:SetColor(color, 0, 0, false, false)
	  laser:Update()
	  laser:Update()  --bruh
	end
  else                                                  -- Pooter shoots tear
	if not color then color = Color(1, 1, 1, 1, 0, 0, 0) end
	if fam:GetData().isUltraSpooter then
	  local angles
	  local vels
	  if hex then
		angles = {-22.5, -7.5, 7.5, 22.5}
		vels = {7.028, 7.028, 7.028, 7.028}
	  else
		angles = {-28.118, -9.567, 9.567, 28.118}
		vels = {6.529, 7.028, 7.028, 6.529}
	  end
	  local angle = vel:GetAngleDegrees()

	  for i=1, 4 do
		local velE = Vector.FromAngle(angles[i] + angle) * vel:Length()
		local tearE = Isaac.Spawn(EntityType.ENTITY_TEAR, variant, 0, fam.Position, velE:Normalized()*vels[i], nil):ToTear()
		tearE.Scale = 1.4 * scaleBonus
		tearE.CollisionDamage = 3.5 * dmgBonus
		tearE:GetData().nuggetUltra = {color, tearE.Scale}      --used on MC_POST_ENTITY_REMOVE
		tearE:GetData().nuggetBladder = cNuggetFlags.nuggetBladder
		tearE:GetData().nuggetSplit = cNuggetFlags.nuggetSplit
		tearE:GetData().nuggetBlood = cNuggetFlags.nuggetBlood
		tearE:Update()
		tearE.TearFlags = flags
		tearE:SetColor(color, 0, 0, false, false)
	  end
	else
	  local tearE = Isaac.Spawn(EntityType.ENTITY_TEAR, variant, 0, fam.Position, vel, nil):ToTear()
	  tearE.Scale = 0.8 * scaleBonus
	  tearE.CollisionDamage = 3.5 * dmgBonus
	  tearE:GetData().nuggetBladder = cNuggetFlags.nuggetBladder
	  tearE:GetData().nuggetSplit = cNuggetFlags.nuggetSplit
	  tearE:GetData().nuggetBlood = cNuggetFlags.nuggetBlood
	  tearE:Update()
	  tearE.TearFlags = flags
	  tearE:SetColor(color, 0, 0, false, false)
	end
  end
end

mod:AddCallback(ModCallbacks.MC_POST_TEAR_INIT, function(_, tear)
  if tear.SpawnerType == 3 and tear.SpawnerVariant == 115 then
	local fam = tear.SpawnerEntity
	if not fam then return end

	if fam:GetData().bFlags then
	  if fam:GetData().bFlags[5] and math.random(4) == 1 then
		local angle = tear.Velocity:GetAngleDegrees()
		for i=0, 5 do
		  local vel = Vector.FromAngle(angle + 60*i) * tear.Velocity:Length()
		  mod:nuggetFlyAttack(fam, vel, true)
		end
	  else
		mod:nuggetFlyAttack(fam, tear.Velocity, false)
	  end
	  FiendFolio.scheduleForUpdate(function()
		tear:Remove()
	  end, 0)
	end
  end
end, 1)

mod:AddCallback(ModCallbacks.MC_POST_TEAR_UPDATE, function(_, tear)
  if tear:GetData().nuggetUltra then tear.FallingSpeed = tear.FallingSpeed * 0.65 end
  if tear:GetData().nuggetBladder and tear.FrameCount % math.ceil(2.5 * tear.Scale + 0.5) == 0 then
	--local creeps = Isaac.FindInRadius(tear.Position, 300*tear.Scale, 0xffffffff)            kilburn medio kilobyte de parche para la api aunque sea
	--for _, c in pairs(creeps) do
	--  if c.Type == 1000 and c.Variant == 53 then c:Remove() end
	--end
	local creep = Isaac.Spawn(1000, 53, 0, tear.Position, Vector(0,0), nil):ToEffect()
	creep.Scale = tear.Scale*0.625
	creep:Update()
	creep.CollisionDamage = 20/7 * tear.CollisionDamage       -- 10 * dmgBonus
	creep:SetTimeout(20)
  end
end)

mod:AddCallback(ModCallbacks.MC_POST_ENTITY_REMOVE, function(_, tear)
  if tear:GetData().nuggetUltra then
	local angles = {-156, 156}
	local angle = tear.Velocity:GetAngleDegrees()
	for i=1, 2 do
	  local vel = Vector.FromAngle(angles[i] + angle):Normalized() * 10
	  local tearE = Isaac.Spawn(EntityType.ENTITY_TEAR, tear.Variant, 0, tear.Position, vel, nil):ToTear()
	  tearE.CollisionDamage = tearE.CollisionDamage / 1.4
	  tearE:GetData().nuggetBladder = tear:GetData().nuggetBladder
	  tearE:GetData().nuggetBlood = tear:GetData().nuggetBlood
	  tearE:SetColor(tear:GetData().nuggetUltra[1], 0, 0, false, false)
	  tearE.Scale = tear:GetData().nuggetUltra[2] / 1.4
	  tearE:AddTearFlags(TearFlags.TEAR_BOUNCE)
	end
  end
  if tear:GetData().nuggetBlood then
	local creep = Isaac.Spawn(1000, 46, 0, tear.Position, Vector(0,0), nil):ToEffect()
	creep.Scale = tear.Size*0.15
	creep:Update()
	creep.CollisionDamage = 4/7 * tear.CollisionDamage      -- 2 * dmgBonus
	creep:SetTimeout(150)
  end
end, EntityType.ENTITY_TEAR)

mod:AddCallback(ModCallbacks.MC_POST_TEAR_INIT, function(_, tear)
  if tear.SpawnerEntity == nil then
	local tears = Isaac.FindInRadius(tear.Position, 0.00000001, EntityPartition.TEAR)
	for _, tearP in pairs(tears) do
	  if tearP:GetData().nuggetSplit then
		tear.Velocity = tear.Velocity:Normalized() * 4
		tear.SpawnerEntity = nil
		tear:GetData().nuggetUltra = tearP:GetData().nuggetUltra
		tear:GetData().nuggetBladder = tearP:GetData().nuggetBladder
		tear:GetData().nuggetBlood = tearP:GetData().nuggetBlood
	  end
	  break
	end
  end
end)

mod:AddCallback(ModCallbacks.MC_POST_EFFECT_INIT, function(_, eff)
  local effs = Isaac.FindByType(1000, 189, -1, false, false)
  for _, e in pairs(effs) do
	local soul = customPurgatorySouls[e.InitSeed]
	if eff.Position:Distance(e.Position) == 0 and soul then
	  FiendFolio.scheduleForUpdate(function()
		eff.CollisionDamage = 7 * soul.nuggetDmgBonus
		eff.SpriteOffset = e.SpriteOffset
		local flags = soul.nuggetFlags
		local enemies = Isaac.FindInRadius(eff.Position, 35*eff.SpriteScale.X, EntityPartition.ENEMY)
		for _, enemy in pairs(enemies) do
		  if enemy:IsVulnerableEnemy() then
			if (flags & TearFlags.TEAR_POISON) ~= BitSet128(0,0) then     enemy:AddPoison(EntityRef(soul.nuggetFam), 62, 0) end
			if (flags & TearFlags.TEAR_BURN) ~= BitSet128(0,0) then       enemy:AddBurn (EntityRef(soul.nuggetFam), 62, 0) end
			if (flags & TearFlags.TEAR_CONFUSION) ~= BitSet128(0,0) then  enemy:AddConfusion(EntityRef(soul.nuggetFam), 120, false) end
			if (flags & TearFlags.TEAR_CHARM) ~= BitSet128(0,0) then      enemy:AddCharmed(EntityRef(soul.nuggetFam), 150) end
			if (flags & TearFlags.TEAR_EGG) ~= BitSet128(0,0) then        enemy:AddEntityFlags(EntityFlag.FLAG_SPAWN_STICKY_SPIDERS) end
			if (flags & BitSet128(0,1<<(67-64))) ~= BitSet128(0,0) then   enemy:AddEntityFlags(EntityFlag.FLAG_BAITED) end
			if soul.nuggetBlood then
			  local creep = Isaac.Spawn(1000, 46, 0, eff.Position, Vector(0,0), nil):ToEffect()
			  creep.Scale = eff.SpriteScale.X * 1.5
			  creep:Update()
			  creep.CollisionDamage = 2 * soul.nuggetDmgBonus
			  creep:SetTimeout(150)
			end
		  end
		end
		customPurgatorySouls[e.InitSeed] = nil
	  end, 0)
	end
  end
end, 144)

mod:AddCallback(ModCallbacks.MC_POST_EFFECT_UPDATE, function(_, soul)
  if soul:GetData().nuggetBladder and soul.FrameCount % math.ceil(soul.SpriteScale.X + 1) == 0 then
	local creep = Isaac.Spawn(1000, 53, 0, soul.Position, Vector(0,0), nil):ToEffect()
	creep.Scale = soul.SpriteScale.X*0.625
	creep:Update()
	creep.CollisionDamage = 10 * customPurgatorySouls[soul.InitSeed].nuggetDmgBonus        -- 10 * dmgBonus
	creep:SetTimeout(20)
  end
end, 189)

function mod:creepterumai(npc, sprite, npcdata)
	local target = npc:GetPlayerTarget()
	local targetpos = target.Position
	npc:ClearEntityFlags(EntityFlag.FLAG_FREEZE | EntityFlag.FLAG_MIDAS_FREEZE)

	if not npcdata.init then
		npcdata.init = true;
		npcdata.living = true;
		npcdata.attacking = false;
		npcdata.attacktimer = math.random(90, 120)
		npcdata.attackloops = 0;
		npcdata.attackloopstarget = math.random(4,5);
		npcdata.blowtimer = math.random(30, 45);
		npcdata.slaves = {}
		npcdata.slaveangle = 0;
		npcdata.slavelength = 60;
		npcdata.confuseangle = math.random(360)
	end
	npcdata.confuseangle = npcdata.confuseangle + math.random(-30, 30)
	if not npcdata.living and game:GetRoom():IsClear() and sprite:IsPlaying("FallenIdle") then
		for _, slave in pairs(npcdata.slaves) do
			slave:Kill()
		end
		npc:Kill()
	end
	--slave control
	if #npcdata.slaves >= 3 then
		npcdata.slavelength = mod:Lerp(npcdata.slavelength, 0, 0.1);
	else
		npcdata.slavelength = mod:Lerp(npcdata.slavelength, 60, 0.1);
	end
	npcdata.slaveangle = npcdata.slaveangle + 1.5;
	mod:creepertumSlaveControl(npc, sprite, npcdata)
	if npcdata.living == true then
		--movement shit
		local targetvelocity = mod:diagonalMove(npc, 2.5, 1);

		if npc:HasEntityFlags(EntityFlag.FLAG_FEAR) then
			if (npc.Position - targetpos):Length() < 125 then
				targetvelocity = (npc.Position - targetpos):Resized(2.5)
			end
		elseif npc:HasEntityFlags(EntityFlag.FLAG_CONFUSION) then
			targetvelocity = Vector(2.5, 0):Rotated(npcdata.confuseangle)
		end

		npc.Velocity = mod:Lerp(npc.Velocity, targetvelocity, 0.15)
		--enemie logic
		if not npcdata.attacking then
			--not attacking
			if not (sprite:IsPlaying("AttackEnd") or sprite:IsPlaying("Recover")) then
				mod:spritePlay(sprite, "Walk")
			end
			if not (npc:HasEntityFlags(EntityFlag.FLAG_FEAR) or npc:HasEntityFlags(EntityFlag.FLAG_CONFUSION)) then
				npcdata.attacktimer = npcdata.attacktimer - 1;
			end
			if npcdata.attacktimer <= 0 then
				npcdata.attacking = true
				npcdata.attackloops = 0;
				npcdata.attackloopstarget = math.random(4,5);
				npcdata.blowtimer = math.random(30, 45);
				mod:spritePlay(sprite, "AttackStart")
			end
		else
			--OHHHH KILL THEM ALL!!!
			if sprite:IsFinished("AttackStart") then
				mod:spritePlay(sprite, "AttackLoop")
			elseif sprite:IsPlaying("AttackLoop") then
				if sprite:GetFrame() == 19 then
					npcdata.attackloops = npcdata.attackloops + 1;
				end
				--this is where flies spawn ouggh
				npcdata.blowtimer = npcdata.blowtimer - 1;
				if npcdata.blowtimer <= 0 then
					npc:PlaySound(SoundEffect.SOUND_SUMMONSOUND, 0.6, 0, false, 1.2)
					if math.random(1, 4) == 4 then
						EntityNPC.ThrowSpider(npc.Position, npc, mod:chooserandomlocationforskuzz(npc, 100, 50), false, 0)
					else
						local fly = Isaac.Spawn(18, 0, 0, npc.Position, npc.Velocity + (targetpos - npc.Position):Resized(math.random(15, 25) / 10), npc):ToNPC();
						fly:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
					end
					npcdata.blowtimer = math.random(20, 30);
				end
				--end that
			end
			if npcdata.attackloops >= npcdata.attackloopstarget then
				npcdata.attacking = false;
				mod:spritePlay(sprite, "AttackEnd")
				npcdata.attacktimer = math.random(90, 120)
			end
		end
	else
		npc.CanShutDoors = false
		if sprite:GetFrame() > 22 or not sprite:IsPlaying("Fall") then
			if npc:HasEntityFlags(EntityFlag.FLAG_FEAR) then
				if sprite:IsPlaying("FallenIdle") then
					if sprite:GetFrame() == 18 then
						npc.Velocity = (npc.Position - targetpos):Normalized() * 8.5
					end
					if sprite:GetFrame() < 17 and sprite:GetFrame() > 27 then
						npc.Velocity = mod:Lerp(npc.Velocity, Vector(0, 0), 0.15)
					else
						npc.Velocity = mod:Lerp(npc.Velocity, Vector(0, 0), 0.3)
					end
				else
					npc.Velocity = mod:Lerp(npc.Velocity, Vector(0, 0), 0.3)
				end
			else
				npc.Velocity = mod:Lerp(npc.Velocity, Vector(0, 0), 0.3)
			end
		end
		if sprite:IsPlaying("Fall") and sprite:GetFrame() == 1 then
			npc:PlaySound(SoundEffect.SOUND_SPIDER_COUGH, 1, 0, false, 1.60)
		elseif sprite:IsFinished("Fall") then
			npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_ALL
			npc.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_GROUND
			mod:spritePlay(sprite, "FallenIdle")
		elseif not sprite:IsPlaying("Fall") then
			--actual logic
			if not npcdata.attacking then
				if not sprite:IsPlaying("Recover")then
					mod:spritePlay(sprite, "FallenIdle")
				end
				if #npcdata.slaves < 3 then
					if not (npc:HasEntityFlags(EntityFlag.FLAG_FEAR) or npc:HasEntityFlags(EntityFlag.FLAG_CONFUSION)) then
						npcdata.attacktimer = npcdata.attacktimer - 1;
					end
				end
				if npcdata.attacktimer <= 0 then
					npcdata.attacking = true
					mod:spritePlay(sprite, "Spawn")
				end
			else
				if sprite:IsFinished("Spawn") then
					npcdata.attacking = false
					npcdata.attacktimer = math.random(80, 100)
				end
			end
		end
		--revival
		if npcdata.slavelength <= 2 and #npcdata.slaves >= 3 then
			for i = 1, #npcdata.slaves, 1 do
				npcdata.slaves[i]:Remove()
			end
			npcdata.slaves = {}
			--actually revive
			mod:spritePlay(sprite, "Recover")
		end
		--actually actually revive
		if sprite:IsPlaying("Recover") and sprite:GetFrame() >= 19 then
			npcdata.slavelength = 60
			npcdata.living = true
			npc.CanShutDoors = true
			npc.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_WALLS
			npc:ClearEntityFlags(EntityFlag.FLAG_NO_STATUS_EFFECTS | EntityFlag.FLAG_NO_TARGET)
			npc:GetData().attacking = false
			npc:GetData().attacktimer = math.random(90, 120)
		end
	end

	--events n shit

	if sprite:IsEventTriggered("Shoot") then
		npc:PlaySound(SoundEffect.SOUND_SPIDER_COUGH, 1, 0, false, math.random(90,110)/100)
		npc:PlaySound(SoundEffect.SOUND_SUMMONSOUND, 0.6, 0, false, 1.2)
		for i = 1, math.random(2, 3), 1 do
			if math.random(1, 5) == 5 then
				EntityNPC.ThrowSpider(npc.Position, npc, mod:chooserandomlocationforskuzz(npc, 100, 50), false, 0)
			else
				local fly = Isaac.Spawn(18, 0, 0, npc.Position, npc.Velocity +  RandomVector():Resized(math.random(15, 25) / 10), npc):ToNPC();
				fly:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
			end
		end
	elseif sprite:IsEventTriggered("Spawn") then
		npc:PlaySound(SoundEffect.SOUND_SUMMONSOUND, 0.6, 0, false, 1)
		npc:PlaySound(SoundEffect.SOUND_SPIDER_COUGH, 1, 0, false, 0.8)
		for i = 1, math.random(3, 4), 1 do
			if math.random(1, 5) == 5 then
				EntityNPC.ThrowSpider(npc.Position, npc, mod:chooserandomlocationforskuzz(npc, 100, 50), false, 0)
			else
				local fly = Isaac.Spawn(18, 0, 0, npc.Position, npc.Velocity +  RandomVector():Resized(math.random(15, 25) / 10), npc):ToNPC();
				fly:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
			end
		end
		local slave = Isaac.Spawn(666, 131, 0, npc.Position, npc.Velocity +  RandomVector():Resized(math.random(15, 25) / 10), npc):ToNPC();
		slave:AddEntityFlags(EntityFlag.FLAG_NO_STATUS_EFFECTS | EntityFlag.FLAG_NO_TARGET)
		slave.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS
		slave:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
		slave.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_NONE
		table.insert(npcdata.slaves, slave)
	end
end

function mod:creepertumSlaveControl(npc, sprite, npcdata)
	if #npcdata.slaves > 0 then
		for i = 1, #npcdata.slaves, 1 do
			local slave = npcdata.slaves[i]
			if npc:IsDead() then
				slave:Kill()
			end
			mod:spritePlay(slave:GetSprite(), "fly")
			local target = npc.Position + Vector(npcdata.slavelength, 0):Rotated(npcdata.slaveangle + ((i-1) * (360 / #npcdata.slaves)))
			targetVel = (target - slave.Position):Resized(4)
			if (target - slave.Position):Length() > 2 then
				slave.Velocity = mod:Lerp(slave.Velocity, targetVel, 0.3)
			else
				slave.Velocity = mod:Lerp(slave.Velocity, targetVel, 0.1)
			end
		end
	end
end

--curdle: like creepterum most death stuff is handled in the on hit
function mod:curdleai(npc, sprite, npcdata)
	local room = game:GetRoom()
	if not npcdata.init then
		npcdata.skin = true
		npcdata.state = "walk"
		npcdata.vomtimer = math.random(60, 90)
		npcdata.init = true
		npcdata.confuseangle = math.random(360)
	end

	npcdata.confuseangle = npcdata.confuseangle + math.random(-30, 30)

	local target = npc:GetPlayerTarget()
	local targetpos = target.Position
	targetpos = mod:randomConfuse(npc, targetpos)
	local targetangle = (targetpos - npc.Position):GetAngleDegrees()
	local targetdistance = (targetpos - npc.Position):Length()
	local path = npc.Pathfinder

	--creep
	if npc.FrameCount % 4 == 0 then
		local creep = Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.CREEP_RED, 0, npc.Position, Vector(0,0), npc):ToEffect();
		creep.Scale = 0.75
		if npcdata.skin then
			creep:SetTimeout(math.floor(creep.Timeout * 0.6))
		else
			creep:SetTimeout(math.floor(creep.Timeout * 0.25))
		end
		creep:Update();
	end
	--death creep
	if npc:IsDead() then
		local creep = Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.CREEP_RED, 0, npc.Position, Vector(0,0), npc):ToEffect();
		creep.SpriteScale = Vector(2, 1.33)
		creep:SetTimeout(math.floor(creep.Timeout * 0.4))
		creep:Update();
	end
	if npcdata.state == "walk" then
		--lots of this code copied from fathead

		if room:CheckLine(npc.Position,targetpos,0,1,false,false) or npc:HasEntityFlags(EntityFlag.FLAG_FEAR) or npc:HasEntityFlags(EntityFlag.FLAG_CONFUSION) then
			local speed = 3
			if npcdata.skin == false then
				speed = 4
			end
			local targetvelocity = (targetpos - npc.Position):Normalized() * speed
			if npc:HasEntityFlags(EntityFlag.FLAG_FEAR) then
				targetvelocity = targetvelocity * -1
			end
			local lerpy = 0.25
			if npcdata.skin == false then
				lerpy = 0.3
			end
			if npc:HasEntityFlags(EntityFlag.FLAG_CONFUSION) then
				targetvelocity = Vector(3.5, 0):Rotated(npcdata.confuseangle)
			end
			npc.Velocity = mod:Lerp(npc.Velocity, targetvelocity, lerpy)
		else
			if npcdata.skin == true then
				path:FindGridPath(targetpos, 0.4, 900, true)
			else
				path:FindGridPath(targetpos, 0.55, 900, true)
			end
		end

		--anim
		sprite.FlipX = false
		if npcdata.skin == true then
			if npc.Velocity:Length() < 0.25 then
				sprite:SetFrame("Appear", 20)
			elseif math.abs(npc.Velocity.X) >= math.abs(npc.Velocity.Y) then
				sprite:SetFrame("walkhori", npc.FrameCount % 22)
				if npc.Velocity.X < 0 then
					sprite.FlipX = true
				end
			else
				sprite:SetFrame("walkvert", npc.FrameCount % 22)
			end
		else
			if npc.Velocity:Length() < 0.25 then
				sprite:SetFrame("fleshbreak", 14)
			elseif math.abs(npc.Velocity.X) >= math.abs(npc.Velocity.Y) then
				sprite:SetFrame("walkhorinaked", npc.FrameCount % 22)
				if npc.Velocity.X < 0 then
					sprite.FlipX = true
				end
			else
				sprite:SetFrame("walkvertnaked", npc.FrameCount % 22)
			end
		end
		--vom logic
		if not npcdata.skin then
			npcdata.vomtimer = npcdata.vomtimer - 1
			if npc:HasEntityFlags(EntityFlag.FLAG_FEAR) or npc:HasEntityFlags(EntityFlag.FLAG_CONFUSION) then
				npcdata.vomtimer = npcdata.vomtimer + 1
			end
			if npcdata.vomtimer <= 0 then
				npcdata.state = "vom"
				npcdata.vomtimer = math.random(60, 90)
			end
		end
	elseif npcdata.state == "break" then
		mod:spritePlay(sprite, "fleshbreak")
		npc.Velocity = mod:Lerp(npc.Velocity, Vector(0,0), 0.3)
		if sprite:IsFinished("fleshbreak") then
			npcdata.state = "walk"
		end
	elseif npcdata.state == "vom" then
		mod:spritePlay(sprite, "shoot")
		npc.Velocity = mod:Lerp(npc.Velocity, Vector(0,0), 0.3)
		if sprite:IsFinished("shoot") then
			npcdata.state = "walk"
		end
	end

	--event
	if sprite:IsEventTriggered("fleshbreak") then
		--not toe people snooping in my code: DONT DO THIS THIS IS TERRIBLE
		local dummy = Isaac.Spawn(666, 140, 0, npc.Position, Vector(0,0), npc):ToNPC();
		dummy:Kill()
		for i = 1, math.random(1, 2), 1 do
			local chunk = Isaac.Spawn(310, 1, 0, npc.Position, RandomVector():Resized(math.random(2, 4)), npc):ToNPC();
			chunk:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
		end
	elseif sprite:IsEventTriggered("vomit") then
		npc:PlaySound(SoundEffect.SOUND_RAGMAN_4,1,0,false,math.random(150, 200) / 100)
		local projectile = Isaac.Spawn(9, 0, 0, npc.Position, Vector(math.floor(0.05 * targetdistance * (math.random(8, 10) / 10), 6),0):Rotated(targetangle), npc):ToProjectile();
		projectile.FallingSpeed = -30;
		projectile.FallingAccel = 2
		projectile.Height = -10
		projectile:Update()
		projectile:GetData().special = "curdled"
		local projsprite = projectile:GetSprite()
		projsprite:Load("gfx/projectiles/002.035_balloon tear.anm2",true)
		projsprite:Play("RegularTear6", true)
		projsprite:ReplaceSpritesheet(0, "gfx/projectiles/tears_balloon.png")
		projsprite:LoadGraphics()
		projectile.Scale = 2.5
	end
end

--npc:HasEntityFlags(EntityFlag.FLAG_FEAR) or npc:HasEntityFlags(EntityFlag.FLAG_CONFUSION)

--calzone: maggots fnerocr
function mod:calzoneai(npc, sprite, npcdata)
	if npcdata.init == nil then
		npcdata.init = true
		npcdata.state = "idle"
		npcdata.statetimer = 0
		npcdata.statethreshold = math.random(5, 15)
		npcdata.leapnum = 0
		npcdata.leapthreshold = math.random(2, 4)
		npcdata.leaping = false
		npcdata.target = Vector(0,0)
	end

	if mod.TrueVoteOutcome then
		if not sprite:IsPlaying("Appear") then
			Isaac.Spawn(1000,19,0, npc.Position, nilvector, npc)
			Isaac.Explode(npc.Position, npc, 5)
			npc:Kill()
		end
	end

	if not npcdata.leaping then
		npc.Velocity = mod:Lerp(npc.Velocity, nilvector, 0.25)
	end

	--flipping
	if npcdata.state ~= "vomit" then
		npc.FlipX = npc.Velocity.X < 0
	end

	--state stuff
	if npcdata.state == "idle" then
		mod:spritePlay(sprite, "idle")
		npcdata.statetimer = npcdata.statetimer + 1
		if npc:HasEntityFlags(EntityFlag.FLAG_FEAR) then
			npcdata.statetimer = npcdata.statetimer + 2
		end
		if npcdata.statetimer > npcdata.statethreshold then
			--just took this from th mamapooter ok???
			local maggotlimit = 0
			local maggotnumber = 0
			if npc.Variant == mod.FF.Breadbin.Var then
				--breadbin
				for _,entity in ipairs(Isaac.GetRoomEntities()) do
					local etype = entity.Type
					local evar = entity.Variant
					if (etype == mod.FF.RolyPoly.ID and evar == mod.FF.RolyPoly.Var) then
						maggotnumber = maggotnumber + 1
					end
					if etype == mod.FF.Breadbin.ID and evar == mod.FF.Breadbin.Var then
						maggotlimit = maggotlimit + 2
					end
				end
			else
				--normal
				for _,entity in ipairs(Isaac.GetRoomEntities()) do
					local etype = entity.Type
					local evar = entity.Variant
					if (etype == 21 or etype == 23 or etype == 31 or etype == 243) then
						maggotnumber = maggotnumber + 1
					end
					if etype == mod.FF.Calzone.ID and evar == mod.FF.Calzone.Var then
						maggotlimit = maggotlimit + 2
					end
				end
			end
			--print(maggotnumber.." "..maggotlimit)
			if maggotnumber < maggotlimit and npcdata.leapnum >= npcdata.leapthreshold and not (npc:HasEntityFlags(EntityFlag.FLAG_FEAR) or npc:HasEntityFlags(EntityFlag.FLAG_CONFUSION)) then
				mod:spritePlay(sprite, "vomit")
				npcdata.state = "vomit"
				npcdata.statetimer = 0
				npcdata.statethreshold = math.random(30, 45)
				npcdata.leapnum = 0
				npcdata.leapthreshold = math.random(2, 4)
				--flip
				npcdata.target = mod:chooserandomlocationforskuzz(npc, 175, 125)
				npc.FlipX = npcdata.target.X < npc.Position.X
			else
				mod:spritePlay(sprite, "leap")
				npcdata.state = "leap"
				npcdata.statetimer = 0
				if(npc.SubType == 1) then
					npcdata.statethreshold = math.random(15, 30)
				elseif npc.Variant == 152 then
					npcdata.statethreshold = math.random(10, 25)
				else
					npcdata.statethreshold = math.random(5, 15)
				end
				npcdata.leapnum = npcdata.leapnum + 1
			end
		end
	elseif npcdata.state == "leap" then
		if sprite:IsFinished("leap") then
			npcdata.state = "idle"
		elseif sprite:IsEventTriggered("startmove") then
			npcdata.leaping = true
			local targetpos = npc:GetPlayerTarget().Position
			if npc:HasEntityFlags(EntityFlag.FLAG_FEAR) then
				npc.Velocity = (targetpos - npc.Position):Resized(math.random(45, 60)/10) * -1
			else
				npc.Velocity = Vector(math.random(30, 45)/10, 0):Rotated(math.random(360))
			end
			npc:PlaySound(SoundEffect.SOUND_FETUS_JUMP,0.4,0,false,math.random(13, 16) / 10)
		elseif sprite:IsEventTriggered("stopmove") then
			npcdata.leaping = false
			npc:PlaySound(SoundEffect.SOUND_MEAT_JUMPS,0.6,0,false,math.random(10, 12) / 10)
		end
	elseif npcdata.state == "vomit" then
		if sprite:IsFinished("vomit") then
			npcdata.state = "idle"
		elseif sprite:IsEventTriggered("vomit") then
			if(npc.SubType == 1) then
				mod:shootMaggot(npc, npcdata.target, 2)
				npc:PlaySound(SoundEffect.SOUND_WHEEZY_COUGH, 1, 0, false, math.random(15, 18) / 10)
			elseif npc.Variant == 152 then
				mod:shootMaggot(npc, npcdata.target, 1, 7)
				npc:PlaySound(226, 1, 0, false, 1)
			else
				mod:shootMaggot(npc, npcdata.target, 1)
				npc:PlaySound(SoundEffect.SOUND_LEECH ,0.4,0,false, 0.65)
				npc:PlaySound(226, 1, 0, false, 1.3)
			end
		end
	end

	if npc:IsDead() then
		for i = 0, math.random(0, 1), 1 do
			npcdata.target = mod:chooserandomlocationforskuzz(npc, 100, 75)
			if(npc.SubType == 1) then
				mod:shootMaggot(npc, npcdata.target, 2)
			elseif npc.Variant == 152 then
				mod:shootMaggot(npc, npcdata.target, 1, 7)
			else
				mod:shootMaggot(npc, npcdata.target, 1)
			end
		end
	end
end

mod.honeydropdiagonaltable = {
	"shoot",
	"shoot",
	"shoot",
	"summon"
}

mod.honeydropdiagonaladdtable = {
	"swarm",
	"swarm",
	"swarm",
	"beeter",
	"beeter",
	"dart",
	"dart",
	"zingling"
}

--MY FIRST BOSS????????????
--honestly comments or not this whole code is such a big block o stuff that its an anyeurism to parse. I'm not looking forward to the idea of champions...
function mod:honeydropai(npc, sprite, npcdata)
	local room = game:GetRoom()
	--setup
	if not npcdata.init then
		npcdata.init = true
		npcdata.phase = "diagonal"
		npcdata.state = "idle"
		npcdata.stateframe = 0
		npcdata.statethreshold = math.random(45, 60)
		npcdata.lastattack = "none"
		npcdata.lastattackinarow = 0
		npcdata.previousshootangle = 0
		npcdata.diagonalangle = 0
		npcdata.pitch = 0
		npcdata.honeyspot = npc.Position
		npcdata.previousvelocity = npc.Velocity
		npcdata.previousxgo = 0
		npcdata.outerwallframe = 0
		npcdata.outerwallthreshold = math.random(60, 120)
		npcdata.framessinceturn = 0
		npc.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_NOPITS
		npc:AddEntityFlags(EntityFlag.FLAG_NO_KNOCKBACK)
		npcdata.confuseangle = math.random(360)

		local champSheet
		if mod.IsDeliriumRoom then
			champSheet = "gfx/bosses/honeydrop/honeydrop_cummie.png"
			npcdata.bellasheet = "gfx/bosses/honeydrop/bella_cummie.png"
			npcdata.delirioushoneydrop = true
		else
			local champ
			if npc.SubType > 0 then
				champ = npc.SubType
			elseif FiendFolio.savedata.sawHoneyDropBefore and game:GetRoom():GetType() == RoomType.ROOM_BOSS then
				local seed = game:GetRoom():GetSpawnSeed()
				grng:SetSeed(seed, 0)
				champ = grng:RandomInt(4)
			end

			if champ == 1 then
				npc.SubType = 1
				npcdata.foureyes = true
				npcdata.bellasheet = "gfx/bosses/honeydrop/bella_red.png"
				champSheet = "gfx/bosses/honeydrop/honeydrop_red.png"
			end
		end

		if champSheet then
			for i = 0, 2 do
				sprite:ReplaceSpritesheet(i, champSheet)
			end
			sprite:LoadGraphics()
		end
		FiendFolio.savedata.sawHoneyDropBefore = FiendFolio.savedata.sawHoneyDropBefore or true
	end

	npcdata.confuseangle = npcdata.confuseangle + math.random(-30, 30)

	local honeycolor = Color(1,1,1,1,0,0,0)
	honeycolor:SetColorize(5.5, 3.5, 1, 1)

	local target = npc:GetPlayerTarget()
	local targetposition = target.Position
	--print(npcdata.state)

	--actual ai
	if npcdata.phase == "diagonal" then
		--movement
		local targetvelocity = mod:diagonalMove(npc, 2.6, 1);

		if npc:HasEntityFlags(EntityFlag.FLAG_FEAR) then
			if (npc.Position - targetposition):Length() < 125 then
				targetvelocity = (npc.Position - targetposition):Resized(2.6)
			end
		elseif npc:HasEntityFlags(EntityFlag.FLAG_CONFUSION) then
			targetvelocity = Vector(2.6, 0):Rotated(npcdata.confuseangle)
		end

		npc.Velocity = mod:Lerp(npc.Velocity, targetvelocity, 0.3)
		--phase handling
		if npcdata.state == "idle" then
			sprite.FlipX = false
			mod:spritePlay(sprite, "Idle")
			if not(npc:HasEntityFlags(EntityFlag.FLAG_FEAR) or npc:HasEntityFlags(EntityFlag.FLAG_CONFUSION)) then
				npcdata.stateframe = npcdata.stateframe + 1
			end
			--phase change (putting it in the damage callback would add extra clutter and spaghetti and for what?)
			if npc.HitPoints <= npc.MaxHitPoints * 0.55 then
				npcdata.phase = "transfer"
				npcdata.state = "stillinair"
			elseif npcdata.stateframe > npcdata.statethreshold then
				--attack behaivor
				npcdata.state = mod.honeydropdiagonaltable[math.random(1, #mod.honeydropdiagonaltable)]
				npcdata.stateframe = 0
				--this big blob o code makes sure she doesnt do the same thinjg over and over too much
				if npcdata.lastattack == "none" then
					npcdata.state = "summon"
					npcdata.lastattack = npcdata.state
					npcdata.lastattackinarow = 0
				elseif npcdata.lastattack == npcdata.state then
					npcdata.lastattackinarow = npcdata.lastattackinarow + 1
					if npcdata.lastattackinarow >= 2 and npcdata.state == "summon" then
						npcdata.state = "shoot"
						npcdata.lastattack = npcdata.state
						npcdata.lastattackinarow = 0
					elseif npcdata.lastattackinarow >= 3 and npcdata.state == "shoot" then
						npcdata.state = "summon"
						npcdata.lastattack = npcdata.state
						npcdata.lastattackinarow = 0
					end
				else
					npcdata.lastattack = npcdata.state
					npcdata.lastattackinarow = 0
				end

				if npcdata.foureyes and mod.GetEntityCount(mod.FF.Honeydrip.ID, mod.FF.Honeydrip.Var) >= 1 then
					npcdata.state = "shoot"
				end

				npcdata.statethreshold = math.random(45, 60)
			end
			--OK NOW WE CAN HAVE THE ATTACVKS
		elseif npcdata.state == "shoot" then
			mod:spritePlay(sprite, "Shoot")
			--ORI GAMI DIDNT USE ANY EVENTS BICH
			local prospeed = 6
			if npcdata.foureyes then
				prospeed = 3
			end

			if sprite:GetFrame() == 12 then
				local shootyangle = math.random(1, 6) * 60
				if npcdata.foureyes then
					shootyangle = (targetposition - npc.Position):GetAngleDegrees() - 30
				end

				npcdata.previousshootangle = shootyangle
				for i = 1, 3, 1 do
					local projectile = Isaac.Spawn(9, 0, 0, npc.Position, (Vector(prospeed,0):Rotated(shootyangle)), npc):ToProjectile();
					projectile.FallingAccel = -0.1
					projectile.Scale = 2
					if npcdata.foureyes then
						projectile.Acceleration = 1.04
						--projectile.CurvingStrength = 0.002
						projectile.ProjectileFlags = ProjectileFlags.ACCELERATE --[[| ProjectileFlags.CURVE_LEFT]]
					end

					shootyangle = shootyangle + 120
				end
				npcdata.pitch = 0.75
				npc:PlaySound(185, 1, 0, false, npcdata.pitch)
				npcdata.pitch = 1.25
			elseif --[[(sprite:GetFrame() == 13 and npcdata.foureyes) or]] sprite:GetFrame() == 15 or sprite:GetFrame() == 18 or sprite:GetFrame() == 21 --[[or (sprite:GetFrame() == 23 and npcdata.foureyes)]] then
				local shootyangle = npcdata.previousshootangle + 10
				npcdata.previousshootangle = npcdata.previousshootangle + 10
				for i = 1, 3, 1 do
					local projectile = Isaac.Spawn(9, 0, 0, npc.Position, (Vector(prospeed,0):Rotated(shootyangle)), npc):ToProjectile();
					projectile.FallingAccel = -0.1
					if npcdata.foureyes then
						projectile.Acceleration = 1.04
						--projectile.CurvingStrength = 0.002
						projectile.ProjectileFlags = ProjectileFlags.ACCELERATE --[[| ProjectileFlags.CURVE_LEFT]]
					end

					shootyangle = shootyangle + 120
				end
				npc:PlaySound(185, 1, 0, false, npcdata.pitch)
				npcdata.pitch = npcdata.pitch + 0.15
			elseif sprite:GetFrame() == 25 then
				npcdata.state = "idle"
			end
		elseif npcdata.state == "summon" then
			sprite.FlipX = npc.Velocity.X > 0
			mod:spritePlay(sprite, "Summon")
			if sprite:GetFrame() == 12 then
				--spawn logic
				local add = mod.honeydropdiagonaladdtable[math.random(1, #mod.honeydropdiagonaladdtable)]
				--[[if npcdata.foureyes and (add == "swarm" or add == "dart") then
					if mod.GetEntityCount(mod.FF.HoneyEye.ID, mod.FF.HoneyEye.Var) < 2 then
						add = "zingling"
					else
						add = "beeter"
					end
				end]]

				if add == "swarm" then
					--stolen from baro ok???
					if npcdata.foureyes then
						for i = 1, 2 do
							local enemy = Isaac.Spawn(mod.FF.ShotFly.ID, mod.FF.ShotFly.Var, 0, npc.Position, npc.Velocity +  RandomVector():Resized(math.random(25, 35) / 10), npc):ToNPC();
							enemy:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
						end
					else
						local num = math.random(2, 3)
						for i = 1, num do
							local vec = RandomVector()
							local g = math.random(30)
							local fly = mod.cheekyspawn(npc.Position + vec:Rotated((360 / num) * i - 15 + g) * 7.5, npc, npc.Position + vec:Rotated((360 / num) * i + g) * 50, 281, 0, 0)
							fly.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS
						end
					end
				elseif add == "beeter" then
					if npcdata.foureyes then
						local enemy = Isaac.Spawn(mod.FF.HoneyEye.ID, mod.FF.HoneyEye.Var, 0, npc.Position, npc.Velocity +  RandomVector():Resized(math.random(25, 35) / 10), npc):ToNPC();
						enemy:GetSprite():ReplaceSpritesheet(0, "gfx/enemies/honey eye/Honey Eye_red.png")
						enemy:GetSprite():LoadGraphics()
						enemy:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
						enemy:Update()
					else
						local enemy = Isaac.Spawn(mod.FF.Beeter.ID, mod.FF.Beeter.Var, 0, npc.Position, npc.Velocity +  RandomVector():Resized(math.random(25, 35) / 10), npc):ToNPC();
						enemy:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
					end
				elseif add == "zingling" then
					if npcdata.foureyes then
						local enemy = Isaac.Spawn(mod.FF.HoneyEye.ID, mod.FF.HoneyEye.Var, 0, npc.Position, npc.Velocity +  RandomVector():Resized(math.random(25, 35) / 10), npc):ToNPC();
						enemy:GetSprite():ReplaceSpritesheet(0, "gfx/enemies/honey eye/Honey Eye_red.png")
						enemy:GetSprite():LoadGraphics()
						enemy:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
						enemy:Update()
					else
						local enemy = Isaac.Spawn(mod.FF.Zingling.ID, mod.FF.Zingling.Var, 0, npc.Position, npc.Velocity +  RandomVector():Resized(math.random(25, 35) / 10), npc):ToNPC();
						enemy:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
					end
				elseif add == "dart" then
					if npcdata.foureyes then
						for i = 1, 2 do
							local enemy = Isaac.Spawn(mod.FF.ShotFly.ID, mod.FF.ShotFly.Var, 0, npc.Position, npc.Velocity +  RandomVector():Resized(math.random(25, 35) / 10), npc):ToNPC();
							enemy:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
						end
					else
						for i = 1, 2 do
							local enemy = Isaac.Spawn(256, 0, 0, npc.Position, npc.Velocity +  RandomVector():Resized(math.random(25, 35) / 10), npc):ToNPC();
							enemy:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
						end
					end
				end
				--end spawn logic
				npc:PlaySound(181, 1, 0, false, math.random(60, 85)/100)
			elseif sprite:GetFrame() == 25 then
				npcdata.state = "idle"
			end
		end
	elseif npcdata.phase == "transfer" then
		if sprite.FlipX then
			npcdata.honeyspot = Vector(npc.Position.X + 20, npc.Position.Y)
		else
			npcdata.honeyspot = Vector(npc.Position.X - 20, npc.Position.Y)
		end
		--thjis is when shot stingnrer
		if npcdata.state == "stillinair" then
			local targetVelocity = mod:diagonalMove(npc, 2.6, 1);
			npc.Velocity = mod:Lerp(npc.Velocity, targetVelocity, 0.3)
			if  mod:findwalldistance(npc).X >= 60 and mod:findwalldistance(npc).Y >= 40 then
				npcdata.diagonalangle = npc.Velocity:GetAngleDegrees()
				npcdata.state = "fall"
				sprite:Play("Fall", true)
				if npc.Velocity.X > 0 then
					sprite.FlipX = true
				end
				npc.Mass = 100
				npc.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_GROUND
				npc:ClearEntityFlags(EntityFlag.FLAG_NO_KNOCKBACK)
			end
		else
			--non diagonal ground movement: this is the sequence after getting on the ground
			npc.Velocity = mod:Lerp(npc.Velocity, nilvector, 0.35)
			if npcdata.state == "fall" then
				if sprite:IsFinished("Fall") then
					sprite:Play("Squeeze", true)
				elseif sprite:IsFinished("Squeeze") then
					npcdata.state = "bitch"
					npcdata.stateframe = 0
					if npcdata.foureyes then
						npcdata.statethreshold = math.random(200, 240)
					else
						npcdata.statethreshold = math.random(180, 210)
					end
				elseif sprite:GetFrame() == 40 then
					game:ShakeScreen(15)
					npc.Velocity = Vector(10, 0):Rotated(npcdata.diagonalangle + 180)
					npc:PlaySound(SoundEffect.SOUND_MEATY_DEATHS, 1.33, 0, false, 0.75)
					npc:PlaySound(SoundEffect.SOUND_ROCK_CRUMBLE, 0.66, 0, false, 1)
					npc:PlaySound(mod.Sounds.FrogShoot,0.7,0,false,math.random(12,14)/10)
					--creep
					local creep = Isaac.Spawn(1000, EffectVariant.CREEP_BROWN, 0, npcdata.honeyspot, Vector(0,0), npc):ToEffect();
					creep.SpriteScale = Vector(4, 3.5)
					creep:SetTimeout(math.floor(creep.Timeout * 2.25))
					creep:Update()
					creep:GetSprite().Color = honeycolor
					--stinger spawn
					npcdata.bella = Isaac.Spawn(666, 161, 0, npc.Position, Vector(10, 0):Rotated(npcdata.diagonalangle), npc):ToNPC();
					npcdata.bella:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
					npcdata.bella.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS
					npcdata.bella:GetData().master = npc

					if npcdata.foureyes then
						npcdata.bella:GetData().foureyes = true
					end

					if npcdata.bellasheet then
						npcdata.bella:GetSprite():ReplaceSpritesheet(0, npcdata.bellasheet)
						npcdata.bella:GetSprite():LoadGraphics()
					end

					--enemies
					--zinglings
					--[[
					for i = 1, 1, 1 do
						local enemy = Isaac.Spawn(mod.FF.Zingling.ID, mod.FF.Zingling.Var, 0, npc.Position, (npcdata.bella.Velocity +  RandomVector()):Resized(math.random(25, 35) / 10), npc):ToNPC();
						enemy:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
					end
					]]--
					--dart flies
					local num, typ, var, hpmul = 2, 256, 0, 1
					if npcdata.foureyes then
						num, typ, var, hpmul = 2, mod.FF.Shoter.ID, mod.FF.Shoter.Var, 1
					end

					for i = 1, num, 1 do
						local enemy = Isaac.Spawn(typ, var, 0, npc.Position, (npcdata.bella.Velocity +  RandomVector()):Resized(math.random(25, 35) / 10):Rotated((360 / num) * i + math.random(30)), npc):ToNPC();
						enemy:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
						enemy.MaxHitPoints = enemy.MaxHitPoints * hpmul
						enemy.HitPoints = enemy.MaxHitPoints
					end
					--swarm
					if npcdata.foureyes then
						local num = 3
						for i = 1, num, 1 do
							local enemy = Isaac.Spawn(mod.FF.ShotFly.ID, mod.FF.ShotFly.Var, 0, npc.Position, (npcdata.bella.Velocity +  RandomVector()):Resized(math.random(25, 35) / 10):Rotated((360 / num) * i + math.random(30)), npc):ToNPC();
							enemy:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
							enemy.MaxHitPoints = enemy.MaxHitPoints * hpmul
							enemy.HitPoints = enemy.MaxHitPoints
						end
					else
						local num = math.random(2, 3)
						for i = 1, num, 1 do
							local vec = RandomVector()
							local g = math.random(30)
							local fly = mod.cheekyspawn(npc.Position + vec:Rotated((360 / num) * i - 15 + g) * 7.5, npc, npc.Position + vec:Rotated((360 / num) * i + g) * 50, 281, 0, 0)
							fly.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS
						end
					end
					--ok now thats all done
				end
			elseif npcdata.state == "bitch" then
				mod:spritePlay(sprite, "Cry")
				npcdata.stateframe = npcdata.stateframe + 1
				if npcdata.stateframe > npcdata.statethreshold then
					npcdata.state = "getup"
					sprite:Play("GetUp", true)
				end
				if game:GetFrameCount() % 30 == 0 then
					local creep = Isaac.Spawn(1000, EffectVariant.CREEP_BROWN, 0, npcdata.honeyspot, Vector(0,0), npc):ToEffect();
					creep.SpriteScale = Vector(1.5, 1)
					creep:SetTimeout(math.floor(creep.Timeout * 1.25))
					creep:Update()
					creep:GetSprite().Color = honeycolor
				end
			elseif npcdata.state == "getup" then
				--make sure to add creep to this one!
				if sprite:IsFinished("GetUp") then
					npcdata.phase = "chaser"
					npcdata.state = "run"
					npcdata.stateframe = 0

					if npcdata.foureyes then
					   npcdata.statethreshold = math.random(60, 120)
					else
					   npcdata.statethreshold = math.random(180, 240)
					end
					--MAYBE this fixes bug ori said?
					sprite.FlipX = not sprite.FlipX
				end
			end
		end
	elseif npcdata.phase == "chaser" then
		--finally added a cap to the bees
		local typ, var = mod.FF.Beeter.ID, mod.FF.Beeter.Var
		if npcdata.foureyes then
			typ, var = mod.FF.HoneyEye.ID, mod.FF.HoneyEye.Var
		end

		local beenum = mod.GetEntityCount(typ, var)
		--spawn shit
		if beenum < 2 then
			npcdata.outerwallframe = npcdata.outerwallframe + 1
			--print(npcdata.outerwallframe.." "..npcdata.outerwallthreshold.." "..beenum)
			if (npcdata.outerwallframe >= npcdata.outerwallthreshold and beenum <= 0) or npcdata.outerwallframe >= (npcdata.outerwallthreshold * 2) then
				--ITS RAINING BEES
				npcdata.outerwallframe = 0
				npcdata.outerwallthreshold = math.random(120, 180)

				local enemy = Isaac.Spawn(typ, var, 0, (room:GetCenterPos() + RandomVector():Resized(room:GetBottomRightPos().X - room:GetCenterPos().X + 150)), nilvector, npc):ToNPC()
				if npcdata.foureyes then
					enemy:GetSprite():ReplaceSpritesheet(0, "gfx/enemies/honey eye/Honey Eye_red.png")
					enemy:GetSprite():LoadGraphics()
				end
				enemy:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
				enemy.GridCollisionClass = GridCollisionClass.COLLISION_NONE
				enemy:Update()
			end
		end
		--state stuff
		if npcdata.state == "run" then
			npcdata.stateframe = npcdata.stateframe + 1
			npcdata.framessinceturn = npcdata.framessinceturn + 1
			--honey dropper
			if sprite.FlipX then
				npcdata.honeyspot = Vector(npc.Position.X - 20, npc.Position.Y)
			else
				npcdata.honeyspot = Vector(npc.Position.X + 20, npc.Position.Y)
			end
			if game:GetFrameCount() % 5 == 0 then
				local creep = Isaac.Spawn(1000, EffectVariant.CREEP_BROWN, 0, npcdata.honeyspot, Vector(0,0), npc):ToEffect();
				if not npcdata.foureyes then
					creep.SpriteScale = Vector(1.75, 1.25)
				end

				creep:SetTimeout(math.floor(creep.Timeout * 0.6))
				creep:Update()
				creep:GetSprite().Color = honeycolor
			end
			--sprite play
			mod:spritePlay(sprite, "Run")
			if(npcdata.state == "run") then sprite.FlipX = npc.Velocity.X > 0 end
			--velocity
			if npc:HasEntityFlags(EntityFlag.FLAG_FEAR) then
				targetposition = npc.Position + ((npc.Position - targetposition):Resized(10))
			elseif npc:HasEntityFlags(EntityFlag.FLAG_CONFUSION) then
				targetposition = npc.Position + Vector(10, 0):Rotated(npcdata.confuseangle)
			end
			if not (npcdata.stateframe >= npcdata.statethreshold and mod:findwalldistance(npc).Y >= 60) then
				local xgo = 8
				local ygo = 5
				if npc.Position.X > targetposition.X then
					xgo = -8
				end
				if npc.Position.Y > targetposition.Y then
					ygo = -5
				end
				npcdata.previousxgo = xgo
				local xgo2 = mod:Lerp(npc.Velocity.X, xgo, 0.045)
				local ygo2 = mod:Lerp(npc.Velocity.Y, ygo, 0.055)
				npc.Velocity = Vector(xgo2, ygo2)
			else
				--charge
				npc.Velocity = mod:Lerp(npc.Velocity, Vector(12, 0):Rotated(Vector(npcdata.previousxgo, 0):GetAngleDegrees()) , 0.1)
			end
			--skid
			if (math.abs(npc.Velocity.X) <= 0.5 and ((npc.Position.X > targetposition.X and npc.Velocity.X > 0) or (npc.Position.X < targetposition.X and npc.Velocity.X < 0))) and npcdata.framessinceturn >= 15 and npcdata.stateframe < npcdata.statethreshold then
				npcdata.state = "skid"
				sprite:Play("Turn", true)
				npcdata.framessinceturn = 0
			--slam
			elseif (((npcdata.previousvelocity:Resized(1).X > 0 and npc.Velocity.X < 0) or (npcdata.previousvelocity:Resized(1).X < 0 and npc.Velocity.X > 0)) and npc:CollidesWithGrid()) or (npc:CollidesWithGrid() and npcdata.stateframe >= npcdata.statethreshold and mod:findwalldistance(npc).Y >= 60) then
				npcdata.state = "slam"
				sprite:Play("Slam", true)
				npcdata.Velocity = nilvector
				sprite.FlipX = not sprite.FlipX
				game:ShakeScreen(10)
				npc:PlaySound(SoundEffect.SOUND_ROCK_CRUMBLE, 0.66, 0, false, 1.5)
				--charge stuff
				npcdata.stateframe = 0

				if npcdata.foureyes then
					npcdata.statethreshold = math.random(90, 150)
				else
					npcdata.statethreshold = math.random(180, 240)
				end

				--creep / champ shockwave
				if not npcdata.foureyes then
					local creep = Isaac.Spawn(1000, EffectVariant.CREEP_BROWN, 0, npcdata.honeyspot, Vector(0,0), npc):ToEffect();
					creep.SpriteScale = Vector(4, 3.5)
					creep:SetTimeout(math.floor(creep.Timeout * 2.25))
					creep:Update()
					creep:GetSprite().Color = honeycolor
				else
					local dir = 0
					if sprite.FlipX then -- facing right
						dir = 180
					end

					local wave = Isaac.Spawn(1000, 72, 2, npc.Position + Vector.FromAngle(dir) * 10, nilvector, boss):ToEffect()
					wave.Parent = npc
					wave.Rotation = dir
				end
				--cracker
				--[[
				local wave = Isaac.Spawn(1000, 61, 0, npc.Position, Vector(0,0), boss):ToEffect()
				wave.Parent = npc
				]]--
			end
			npcdata.previousvelocity = npc.Velocity
		elseif npcdata.state == "skid" then
			npc.Velocity = mod:Lerp(npc.Velocity, nilvector, 0.35)
			if sprite:GetFrame() == 6 then
				npcdata.state = "run"
				sprite:Play("Run", true)
				sprite.FlipX  = not sprite.FlipX

				if not npcdata.foureyes then
					local creep = Isaac.Spawn(1000, EffectVariant.CREEP_BROWN, 0, npc.Position, Vector(0,0), npc):ToEffect();
					creep.SpriteScale = Vector(2, 1.25)
					creep:SetTimeout(math.floor(creep.Timeout * 0.25))
					creep:Update()
					creep:GetSprite().Color = honeycolor
				end
			elseif sprite:GetFrame() == 4 then
				--anim bug i guess??????
				sprite.FlipX = npcdata.previousvelocity.X < 0
			end
		elseif npcdata.state == "slam" then
			npc.Velocity = mod:Lerp(npc.Velocity, nilvector, 0.55)
			if sprite:IsFinished("Slam") then
				npcdata.state = "run"
				sprite:Play("Run", true)
				sprite.FlipX  = not sprite.FlipX
				local flip = -1
				if sprite.FlipX then
					flip = 1
				end
				npc.Velocity = npc.Velocity + Vector(2.5 * flip, 0)
			end
		end
	end
end

--SERVANT OF HONEYDROP. note that spawning flies is in damage callback
function mod:bellaai(npc, sprite, npcdata)
	if not npcdata.init then
		npcdata.init = true
		npcdata.die = false
		npcdata.cooldown = 0
		npcdata.shaketimer = 0
		npcdata.previousvelocity = npc.Velocity
		npc.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_WALLS
		npc:AddEntityFlags(EntityFlag.FLAG_NO_TARGET)
	end
	local targetVelocity = mod:diagonalMove(npc, 4.5, 1);
	if npcdata.foureyes then
		targetVelocity = mod:diagonalMove(npc, 6.5, 1);
	end

	npc.Velocity = mod:Lerp(npc.Velocity, targetVelocity, 0.3)
	npcdata.cooldown = npcdata.cooldown - 1
	npcdata.shaketimer = npcdata.shaketimer - 1
	--death
	if (npcdata.master == nil or npcdata.master:IsDead()) and not npcdata.die then
		sprite:Play("Death", true)
		npcdata.die = true
		npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
		npc.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_NONE
	end
	if sprite:GetFrame() == 8 and (sprite:IsPlaying("Death") or sprite:IsPlaying("DeathUp")) then
		npc:Remove()
	end
	--animation
	if not npcdata.die then
		if npcdata.shaketimer > 0 then
			if npc.Velocity.Y > 0 then
				mod:spritePlay(sprite, "FlyShake")
			else
				mod:spritePlay(sprite, "FlyUpShake")
			end
		else
			if npc.Velocity.Y > 0 then
				mod:spritePlay(sprite, "Fly")
			else
				mod:spritePlay(sprite, "FlyUp")
			end
		end
	else
		if npc.Velocity.Y > 0 then
			mod:spritePlay(sprite, "Death")
		else
			mod:spritePlay(sprite, "DeathUp")
		end
	end
	sprite.FlipX = npc.Velocity.X > 0
	--sound
	if ((npcdata.previousvelocity:Resized(1).X > 0 and npc.Velocity.X < 0) or (npcdata.previousvelocity:Resized(1).X < 0 and npc.Velocity.X > 0)) or ((npcdata.previousvelocity:Resized(1).Y > 0 and npc.Velocity.Y < 0) or (npcdata.previousvelocity:Resized(1).Y < 0 and npc.Velocity.Y > 0)) then
		npc:PlaySound(mod.Sounds.Ricochet,1,0,false,0.5)
	end
	npcdata.previousvelocity = npc.Velocity
end

function mod:findwalldistance(npc)
	local room = game:GetRoom()
	local xdistancereturn = math.min(math.abs(npc.Position.X - room:GetTopLeftPos().X), math.abs(npc.Position.X - room:GetBottomRightPos().X))
	local ydistancereturn = math.min(math.abs(npc.Position.Y - room:GetTopLeftPos().Y), math.abs(npc.Position.Y - room:GetBottomRightPos().Y))
	return Vector(xdistancereturn, ydistancereturn)
end

function mod:margeai(npc, sprite, npcdata)
	local room = game:GetRoom()
	if not npcdata.confuseangle then
		npcdata.confuseangle = math.random(360)
	end
	npcdata.confuseangle = npcdata.confuseangle + math.random(-30, 30)
	--fathead ai redux
	if npc:IsDead() == true then
		local num = math.random(4,5)
		for i = 1, num, 1 do
			local vec = RandomVector()
			local g = math.random(15)
			local fly = mod.cheekyspawn(npc.Position + vec * 1.5, npc, npc.Position + vec * math.random(25, 45), 281, 0, 0)
		end
	end
	local target = npc:GetPlayerTarget()
	local targetpos = target.Position
	targetpos = mod:randomConfuse(npc, targetpos)
	local path = npc.Pathfinder
	if room:CheckLine(npc.Position,targetpos,0,1,false,false) or npc:HasEntityFlags(EntityFlag.FLAG_FEAR) or npc:HasEntityFlags(EntityFlag.FLAG_CONFUSION) then
		local targetvelocity = (targetpos - npc.Position):Normalized() * 3.5
		if npc:HasEntityFlags(EntityFlag.FLAG_FEAR) then
			targetvelocity = targetvelocity * -1
		elseif npc:HasEntityFlags(EntityFlag.FLAG_CONFUSION) then
			targetvelocity = Vector(3.5, 0):Rotated(npcdata.confuseangle)
		end
		local lerpy = 0.3
		if npc:HasEntityFlags(EntityFlag.FLAG_CONFUSION) then
			lerpy = 0.4
		end
		npc.Velocity = mod:Lerp(npc.Velocity, targetvelocity, lerpy)
	else
		path:FindGridPath(targetpos, 0.5, 900, true)
	end
	--anim
	sprite.FlipX = false
	if npc.Velocity:Length() < 0.25 then
		sprite:SetFrame("Appear", 6)
	elseif math.abs(npc.Velocity.X) >= math.abs(npc.Velocity.Y) then
		sprite:SetFrame("WalkRight", npc.FrameCount % 22)
		if npc.Velocity.X < 0 then
			sprite:SetFrame("WalkLeft", npc.FrameCount % 22)
		end
	else
		sprite:SetFrame("WalkVert", npc.FrameCount % 22)
	end
end

function mod:dankdipchange(npc)
	if npc.Variant == 1 then
		if npc:IsDead() then
			if FiendFolio.ChangeAi then
				local clotcheck = false
				--remove clots
				for _, clot in ipairs(Isaac.FindByType(15, 1, 0, false, false)) do
					if clot.SpawnerType == 220 and clot.Position:Distance(npc.Position) < 20 and clot.FrameCount < 1 then
						clot:Remove()
						clotcheck = true
					end
				end
				if clotcheck then
					--spawn blots
					for i = 0, 360, 30 do
						local rand = math.random()
						if math.random(1, 5) == 5 then
							local blot = Isaac.Spawn(mod.FF.Blot.ID, mod.FF.Blot.Var, 0, npc.Position, Vector(0,0.5):Rotated(i-40+rand*80), npc):ToNPC()
							local blotdata = blot:GetData()
							blotdata.downvelocity = -35 + math.random(10);
							blotdata.downaccel = 2.5
							blot.Velocity = blot.Velocity * (math.random(12, 20)/7.5)
							blot.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
							blot.GridCollisionClass = GridCollisionClass.COLLISION_NONE
							blot:GetSprite().Offset = Vector(0, -1)
							blotdata.state = "air"
							blot:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
						else
							local projectile = Isaac.Spawn(9, 0, 0, npc.Position, Vector(0,2):Rotated(i-40+rand*80), npc):ToProjectile();
							local projdata = projectile:GetData();
							local s = projectile:GetSprite()
							--s:Load("gfx/enemies/blot/monster_blot.anm2",true)
							--s:Play("InAir1",false)
							projectile.FallingSpeed = -35 + math.random(10);
							projectile.FallingAccel = 1.5
							projectile.Velocity = projectile.Velocity * (math.random(8, 14)/10)
							projectile.Scale = math.random(8, 12)/10
							projectile.Color = mod.ColorDankBlackReal
						end
					end
				end
			end
		end
	end
end

mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.dankdipchange, 220)

--patzer - disc room real? the code for this is gonna be very complex and very messy
function mod:patzerai(npc, sprite, npcdata)
	local room = game:GetRoom()
	local target = npc:GetPlayerTarget()
	local targetpos = target.Position
	local targetangle = math.rad((targetpos - npc.Position):GetAngleDegrees())
	if not npcdata.init then
		npcdata.init = true
		npcdata.shell = Isaac.Spawn(666, 201, 0, npc.Position, Vector(0, 0), npc):ToNPC()
		npcdata.shell:GetData().parent = npc
		npcdata.shell.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS
		npcdata.shell.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_NONE
		npcdata.movetimer = 45
		npcdata.movetimermax = 45
		npcdata.movin = 0
		npcdata.mainvert = false;
		npcdata.maincurve = 1;
		npcdata.offcurve = 1;
		npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS
		npc.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_WALLS
		npc:AddEntityFlags(EntityFlag.FLAG_NO_STATUS_EFFECTS)
	else
		if(not npc:IsDead()) then
			table.insert(npcdata.shell:GetData().positions, 1, npc.Position)
			table.remove(npcdata.shell:GetData().positions, 46)
			table.insert(npcdata.shell:GetData().velocities, 1, npc.Velocity)
			table.remove(npcdata.shell:GetData().velocities, 46)
			npc.PositionOffset = Vector(0, math.sin(math.rad(npc.FrameCount * 4)) * 4)
		end
		if npcdata.movin == 0 then
			npc.Velocity = mod:Lerp(npc.Velocity, Vector(0,0), 0.75)
			if sprite:IsPlaying("moveover") then
				if sprite:IsFinished("moveover") then
					mod:spritePlay(sprite, "idle")
				end
			else
				mod:spritePlay(sprite, "idle")
			end
			if(npcdata.movetimer <= 0) then
				npcdata.movin = 1
				mod:spritePlay(sprite, "movestart")
			else
				npcdata.movetimer = npcdata.movetimer - 1
			end
		--start moving
		elseif npcdata.movin == 1 then
			npc.Velocity = mod:Lerp(npc.Velocity, Vector(0,0), 0.75)
			if sprite:IsEventTriggered("movestart") then
				npcdata.movin = 2
				npcdata.movetimer = 45
				npcdata.shell:GetData().movetimer = 45
				--target selection
				if math.abs(math.sin(targetangle)) > 0.5 then
					npcdata.mainvert = true
					if(npc.Position.Y > targetpos.Y) then
						npcdata.maincurve = -1
					else
						npcdata.maincurve = 1
					end
					if npc.Position.X > targetpos.X then
						npcdata.offcurve = -1
					else
						npcdata.offcurve = 1
					end
				else
					npcdata.mainvert = false
					npcdata.maincurve = 1
					if(npc.Position.X > targetpos.X) then
						npcdata.maincurve = -1
					end
					if npc.Position.Y > targetpos.Y then
						npcdata.offcurve = -1
					else
						npcdata.offcurve = 1
					end
				end
			end
		--actual movement
		else
			--anim
			if sprite:IsPlaying("movestart") then
				if sprite:IsFinished("movestart") then
					mod:spritePlay(sprite, "move")
				end
			else
				mod:spritePlay(sprite, "move")
			end
			--velocity setting
			local targetVelocity = Vector(0, 0)
			local t = npcdata.movetimermax - npcdata.movetimer
			t = t * (2/3)
			if(npcdata.mainvert) then
				targetVelocity.Y = ((-0.045*(t - 15)^2) + 10) * npcdata.maincurve
				targetVelocity.X = ((-0.05*(t - 15)^2) + 7) * npcdata.offcurve
			else
				targetVelocity.X = ((-0.045*(t - 15)^2) + 10) * npcdata.maincurve
				targetVelocity.Y = ((-0.05*(t - 15)^2) + 7) * npcdata.offcurve
			end
			targetVelocity = targetVelocity * (2/3)
			npc.Velocity = mod:Lerp(npc.Velocity, targetVelocity, 0.3)
			--bouncex
			if(not room:IsPositionInRoom(Vector(npc.Position.X + npc.Velocity.X * 3, npc.Position.Y), 5)) then
				if(not npcdata.mainvert) then
					npcdata.maincurve = npcdata.maincurve * -1
				else
					npcdata.offcurve = npcdata.offcurve * -1
				end
			end
			--bouncey
			if(not room:IsPositionInRoom(Vector(npc.Position.X, npc.Position.Y + npc.Velocity.Y * 3), 5)) then
				if(npcdata.mainvert) then
					npcdata.maincurve = npcdata.maincurve * -1
				else
					npcdata.offcurve = npcdata.offcurve * -1
				end
			end
			--transfer
			if(npcdata.movetimer <= 0) then
				npcdata.movin = 0
				npcdata.movetimer = 45
				mod:spritePlay(sprite, "moveover")
			else
				npcdata.movetimer = npcdata.movetimer - 1
			end
		end
	end
	if(npc:IsDead()) then
		npcdata.shell:Kill()
	end
end

mod.patzershellanim = {
	{-3, 100, 100},
	{3, 105, 100},
	{0, 100, 100},
	{-2, 100, 100},
	{2, 100, 100},
	{0, 100, 100}
}

function mod:patzershellai(npc, sprite, npcdata)
	if(npcdata.parent == nil or npcdata.parent:IsDead() or mod:isStatusCorpse(npcdata.parent)) then
		npcdata.init = true
		npc:Kill()
	else
		if not npcdata.init then
			npcdata.init = true
			npcdata.positions = {}
			npcdata.velocities = {}
			for i = 1, 46, 1 do
				table.insert(npcdata.positions, npcdata.parent.Position)
			end
			for i = 1, 46, 1 do
				table.insert(npcdata.velocities, npcdata.parent.Velocity)
			end
			npcdata.movetimer = 69
			npcdata.movan = false
			npcdata.moveanim = 5
			npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS
			npc.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_NONE
			npc:AddEntityFlags(EntityFlag.FLAG_NO_STATUS_EFFECTS | EntityFlag.FLAG_NO_TARGET)
		else
			if(npcdata.movetimer ~= 69) then
				npcdata.movetimer = npcdata.movetimer - 1;
				if(npcdata.movetimer <= 0) then
					npcdata.moveanim = 0
					npcdata.movan = not npcdata.movan
					if(not npcdata.movan) then
						npcdata.movetimer = 69
					else
						npcdata.movetimer = 45
					end
				end
			end
			npcdata.moveanim = math.min(npcdata.moveanim + 1, 6)
			npc.PositionOffset = Vector(mod.patzershellanim[npcdata.moveanim][1], math.sin(math.rad(npc.FrameCount * 5)) * 4)
			sprite.Scale = Vector(mod.patzershellanim[npcdata.moveanim][2], mod.patzershellanim[npcdata.moveanim][3])
			mod:spritePlay(sprite, "idle")
			npc.Position = npcdata.positions[45]
			npc.Velocity = npcdata.velocities[45]
		end
	end
end

--mr. bones - its mr bones wild ride!
function mod:mrbonesai(npc, sprite, npcdata)
	local target = npc:GetPlayerTarget()

	-- For charm compatibility (DOESNT WORK BECAUSE BONY VARIANT AAAAAAAAAAA)
	if npcdata.parent and target.InitSeed == npcdata.parent.InitSeed then
		target = Isaac.GetPlayer(0)
	elseif npcdata.head and target.InitSeed == npcdata.head.InitSeed then
		target = Isaac.GetPlayer(0)
	end
	local targetpos = target.Position

	npc:AddEntityFlags(EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK)

	if not npcdata.init then
		npcdata.head = nil
		npcdata.time = 0
		npcdata.init = true
	end
	if npc.State == 8 then
		npc.State = 4
	end
	if npc.State == 4 then
		--set anim
		if math.abs(npc.Velocity.X) > math.abs(npc.Velocity.Y) then
			mod:spritePlay(sprite, "WalkHori")
			if npc.Velocity.X < 0 then
				sprite.FlipX = true
			else
					sprite.FlipX = false
			end
		else
			if npc.Velocity.Y < 0 then
				mod:spritePlay(sprite, "WalkUp")
			else
				mod:spritePlay(sprite, "WalkDown")
			end
		end
		if (npc.Position - targetpos):Length() <= 125 and npcdata.time > 20 and not sprite:IsPlaying("Appear") and not (npc:HasEntityFlags(EntityFlag.FLAG_FEAR) or npc:HasEntityFlags(EntityFlag.FLAG_CONFUSION)) then
			npc.State = 9
			mod:spritePlay(sprite, "Attack")
		else
			npcdata.time = npcdata.time + 1
		end
	elseif npc.State == 9 then
		--headlessbody
		npc.Velocity = mod:Lerp(npc.Velocity, Vector(0,0), 0.2)
		if npcdata.head ~= nil and (npcdata.head:IsDead() or mod:isStatusCorpse(npcdata.head)) and not (sprite:IsPlaying("Appear") or sprite:IsFinished("Appear")) then
			local guy = Isaac.Spawn(11, 0, 0, npc.Position, Vector(0, 0), npc):ToNPC()
			guy:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
			sprite = guy:GetSprite()
			if mod.isBackdrop("Mausoleum") then
				sprite:ReplaceSpritesheet(0, "gfx/enemies/mrbones/welcomeaboardmatey_mausoleum.png")
			elseif mod.isBackdrop("Ashpit") then
				sprite:ReplaceSpritesheet(0, "gfx/enemies/mrbones/welcomeaboardmatey_ashpit.png")
			else
				sprite:ReplaceSpritesheet(0, "gfx/enemies/mrbones/welcomeaboardmatey.png")
			end
			sprite:LoadGraphics()
			npc:Remove()
		elseif sprite:IsFinished("Attack") then
			mod:spritePlay(sprite, "AttackStill")
		elseif sprite:IsEventTriggered("head") then
			npc:PlaySound(SoundEffect.SOUND_MEATHEADSHOOT,1,0,false,1)
			local head = Isaac.Spawn(227, 667, 0, npc.Position, Vector(0, 0), npc):ToNPC()
			npcdata.head = head
			head.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS
			head.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_WALLS
			--head:AddEntityFlags(EntityFlag.FLAG_NO_STATUS_EFFECTS)
			head.Velocity = Vector(9, 0):Rotated((targetpos - npc.Position):GetAngleDegrees())
			head:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
			head.State = 10
			head:GetData().parent = npc
			head:GetData().airtime = math.min((npc.Position - targetpos):Length() / 8, 13)
			head:GetData().bitten = 0
			mod:spritePlay(head:GetSprite(), "HeadLaunch")
		elseif sprite:IsFinished("Appear") then
			npc.State = 4
			npcdata.time = 0
			npcdata.head = nil
		end
	elseif npc.State == 10 then
		--get ahead
		if (npcdata.parent:IsDead() or mod:isStatusCorpse(npcdata.parent)) and not mod:isLeavingStatusCorpse(npc) then
			npc:Kill()
		end
		if sprite:IsFinished("HeadLaunch") then
			mod:spritePlay(sprite, "HeadTravel")
		end
		if not npcdata.chained then
			npcdata.chained = true
			local numchains = 9
			local vecfun = npcdata.parent.Position - npc.Position
			local vecdist = vecfun:Length()
			for i = 1, numchains do
				local chain = Isaac.Spawn(1000, 1740, 0, npc.Position + vecfun:Resized(vecdist * (i / numchains+2)), nilvector, npc):ToEffect()
				local chaind = chain:GetData()
				chain:GetSprite():Load("gfx/enemies/mrbones/mrbones.anm2",true)
				if mod:CheckStage("Ashpit", {46,59}) then
					chain:GetSprite():ReplaceSpritesheet(1, "gfx/enemies/mrbones/rattlemebones_ashpit.png")
					chain:GetSprite():LoadGraphics()
				end
				chaind.Pos = i
				chaind.Num = numchains + 1
				chaind.Source = npc
				chaind.Home = npcdata.parent
				chain:Update()
			end
		end
		npcdata.airtime = npcdata.airtime - 1
		if(npcdata.airtime > 0) then
			npc.Velocity = mod:Lerp(npc.Velocity, npc.Velocity:Normalized() * 15, 0.4)
		elseif npcdata.bitten == 0 then
			mod:spritePlay(sprite, "HeadBite")
			npcdata.bitten = 1
		else
			if npcdata.bitten == 1 then
				npc.Velocity = mod:Lerp(npc.Velocity, Vector(4, 0):Rotated((npcdata.parent.Position - npc.Position):GetAngleDegrees()), 0.3)
			elseif npcdata.bitten == 2 then
				npc.Velocity = mod:Lerp(npc.Velocity, Vector(25, 0):Rotated((npcdata.parent.Position - npc.Position):GetAngleDegrees()), 0.225)
			end
			if sprite:IsEventTriggered("chormp") then
				sfx:Play(SoundEffect.SOUND_SMB_LARGE_CHEWS_4, 1.5, 0, false, 0.75)
				npcdata.bitten = 2
			elseif(npcdata.parent.Position - npc.Position):Length() < 10 then
				mod:spritePlay(npcdata.parent:GetSprite(), "Appear")
				npc:PlaySound(SoundEffect.SOUND_SCAMPER,0.5,0,false,math.random(75,125)/100)
				npc:Remove()
			end
		end

	else
		npc.State = 4
	end
end

function mod:dopeheadai(npc, sprite, npcdata)
	local room = game:GetRoom()
	if not npcdata.init then
		npc:AddEntityFlags(EntityFlag.FLAG_NO_STATUS_EFFECTS | EntityFlag.FLAG_NO_TARGET | EntityFlag.FLAG_NO_BLOOD_SPLASH)
		npc.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_WALLS
		npcdata.init = true
		npc.Velocity = Vector(1, 1)
		npcdata.prevx = FiendFolio.sign(npc.Velocity.X);
		npcdata.prevy = FiendFolio.sign(npc.Velocity.Y);
		npcdata.die = false
		mod:spritePlay(sprite, "idle")
		npc.SplatColor = mod.ColorDankBlackReal
	else
		if npcdata.die then
			npc.Velocity = mod:Lerp(npc.Velocity, Vector.Zero, 0.15)
			if sprite:IsEventTriggered("fuckoff") then
				npc:Kill()
			end
		else
			if npcdata.junksucked then --Handling beyond the timer is handled in Junkstrap AI
				npcdata.junksucked = npcdata.junksucked - 1
				if npcdata.junksucked <= 0 then
					npcdata.junksucked = nil
				end
			else
				if sprite:IsFinished("spinr") or sprite:IsFinished("spinl") then
					mod:spritePlay(sprite, "idle")
				end
				if(FiendFolio.sign(npc.Velocity.X) ~= npcdata.prevx or FiendFolio.sign(npc.Velocity.Y) ~= npcdata.prevy) then
					npcdata.prevx = FiendFolio.sign(npc.Velocity.X);
					npcdata.prevy = FiendFolio.sign(npc.Velocity.Y);
					npc.Velocity = npc.Velocity:Normalized() * 12
					if npcdata.prevx == 1 then
						sfx:Play(SoundEffect.SOUND_BONE_BOUNCE, 0.7, 0, false, 0.8)
						mod:spritePlay(sprite, "spinr")
					else
						mod:spritePlay(sprite, "spinl")
						sfx:Play(SoundEffect.SOUND_BONE_BOUNCE, 0.7, 0, false, 0.8)
					end
				end
				local d = mod:diagonalMove(npc, 2.5, true);
				npc.Velocity = mod:Lerp(npc.Velocity, d, 0.1)
			end
			if room:IsClear() and not mod.FindDoorShutter() then
				npcdata.die = true
				mod:spritePlay(sprite, "death")
				sfx:Play(SoundEffect.SOUND_DEVILROOM_DEAL, 1, 0, false, 1)
			end
		end
	end
end

function mod:dopeheadprojectileai(npc, sprite, data)
	if not data.Init then
		npc:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
        npc:AddEntityFlags(EntityFlag.FLAG_NO_STATUS_EFFECTS + EntityFlag.FLAG_NO_TARGET + EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK + EntityFlag.FLAG_NO_KNOCKBACK + EntityFlag.FLAG_NO_BLOOD_SPLASH)
        npc:AddEntityFlags(EntityFlag.FLAG_NO_DEATH_TRIGGER + EntityFlag.FLAG_HIDE_HP_BAR + EntityFlag.FLAG_NO_FLASH_ON_DAMAGE + EntityFlag.FLAG_NO_REWARD)
		npc.SplatColor = mod.ColorDankBlackReal
		data.State = "Chase"
		data.Init = true
	end

	if data.State == "Chase" then
		local player = game:GetNearestPlayer(npc.Position)
		local vec = mod:Lerp(npc.Velocity, (player.Position - npc.Position):Resized(10), 0.05)
		npc.Velocity = vec:Resized(math.max(vec:Length(), 10))

		local frame = math.floor(8 - ((mod:GetAngleDegreesButGood(vec:Rotated(215))+12.5)%360)/45)
		sprite:SetFrame("Rotate01", frame)

		if npc:CollidesWithGrid() then
			sfx:Play(SoundEffect.SOUND_BONE_BOUNCE, 0.7, 0, false, 0.8)
			data.State = "Collide"
			--mod:DestroyDopeHeadProjectile(npc)
		end
	elseif data.State == "Collide" then
		npc.Velocity = npc.Velocity * 0.925
		if not data.Anim then
			if npc.Velocity.X < 0 then
				data.Anim = "SpinR"
			else
				data.Anim = "SpinL"
			end
		end

		if sprite:IsFinished(data.Anim) then
			mod:DestroyDopeHeadProjectile(npc)
		else
			mod:spritePlay(sprite, data.Anim)
		end
	end
end

function mod:DestroyDopeHeadProjectile(npc)
	local rng = npc:GetDropRNG()
	local angle = mod:RandomAngle(rng)
	for i = 36, 360, 36 do
		local params = ProjectileParams()
		if rng:RandomFloat() <= 0.5 then
			params.Variant = 1
			params.Color = mod.ColorDopeHead
		else
			params.Variant = 0
			params.Color = mod.ColorDankBlackReal
		end
		npc:FireProjectiles(npc.Position, Vector(8,0):Rotated(i+angle), 0, params)
	end
	npc:Kill()
end

function mod:check666Hurt(npc, damage)
	local room = game:GetRoom()
	if npc.Variant == mod.FF.Load.Var or npc.Variant == mod.FF.CornLoad.Var or npc.Variant == mod.FF.Baro.Var then
		--if not (npc:HasEntityFlags(EntityFlag.FLAG_FREEZE) or npc:HasEntityFlags(EntityFlag.FLAG_MIDAS_FREEZE)) then
		--	if npc.HitPoints - damage <= 10 then
		--	npc.Velocity = nilvector
		--	npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
		--	npc.HitPoints = 0
		--	npc:ToNPC().State = 11
		--	return false
		--	end
		--end
		if npc:ToNPC().State == 17 then
			return false
		end
	elseif npc.Variant == 120 then
		--sludge host
		local npcdata = npc:GetData();
		if npcdata.invul == true then
			if not (npc:GetSprite():IsPlaying("Bombed") or npcdata.alreadybombed == true) then
				npcdata.damagedown = npcdata.damagedown + damage
					if (npcdata.damagedown >= (npc.MaxHitPoints * 2) - 1) then
					npcdata.damagedown = 0;
					npc:GetData().stateframe = 0;
					mod:spritePlay(npc:GetSprite(), "Bombed");
					npcdata.alreadybombed = true
				end
			else
				npcdata.damagedown = 0;
			end
			return false;
		end
	elseif npc.Variant == 130 then
		--creepterum
		if npc:GetData().living then
			--in air
			if (damage >= npc.HitPoints) then
				--ground him
				npc:ClearEntityFlags(EntityFlag.FLAG_FREEZE | EntityFlag.FLAG_MIDAS_FREEZE)
				npc:AddEntityFlags(EntityFlag.FLAG_NO_STATUS_EFFECTS | EntityFlag.FLAG_NO_TARGET)
				mod:spritePlay(npc:GetSprite(), "Fall")
				npc:GetData().living = false
				npc:GetData().attacking = false
				npc.HitPoints = npc.MaxHitPoints
				npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
				npc:GetData().attacktimer = math.random(120, 180)
				-- find spot
				keeploop = 100
				while keeploop > 0 do
					local landPos = mod:chooserandomlocationforskuzz(npc, 300, 300, false)
					npc.Velocity = (landPos - npc.Position) / 22
					local newPos = (npc.Position + npc.Velocity) * 22
					if room:GetGridIndex(newPos) == GridCollisionClass.COLLISION_NONE then
						keeploop = 0;
					end
					keeploop = keeploop - 1;
				end
				return false;
			end
			return true;
		else
			--on ground
			return false;
		end
	elseif npc.Variant == 140 then
		--Curdle
		if (damage >= npc.HitPoints and npc:GetData().skin) then
			npc.HitPoints = npc.MaxHitPoints
			npc:GetData().state = "break"
			npc:GetData().skin = false
		end
	elseif npc.Variant == 160 then
		if npc:GetData().phase == "transfer" then
			npc.HitPoints = npc.HitPoints + (damage * 0.33)
		end
	elseif npc.Variant == 161 then
		--Bella
		if npc:GetData().cooldown and npc:GetData().cooldown < 0 and not (npc:GetData().foureyes or mod.GetEntityCount(281) >= 4) then
			local vec = RandomVector()
			local g = math.random(15)
			local fly = mod.cheekyspawn(npc.Position + vec * 7.5, npc, npc.Position + vec * 50, 281, 0, 0)
			fly.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS
			npc:GetData().cooldown = 45
			npc:GetData().shaketimer = 4
			sfx:Play(181, 0.66, 0, false, 1.2)
		end
		return false
	elseif npc.Variant == mod.FF.DopeHead.Var or npc.Variant == mod.FF.DopeHeadProjectile.Var then
		return false
	end
end
mod:AddCallback(ModCallbacks.MC_ENTITY_TAKE_DMG, mod.check666Hurt, FiendFolio.FFID.Mini)

function mod:check666Kill(ent)

end
mod:AddCallback(ModCallbacks.MC_POST_ENTITY_KILL, mod.check666Kill, FiendFolio.FFID.Mini)

function mod:check666Death(ent)
	if ent.Variant == mod.FF.Load.Var or ent.Variant == mod.FF.CornLoad.Var then
		local npc = ent:ToNPC()
		local data = npc:GetData()

		if not (npc:HasEntityFlags(EntityFlag.FLAG_FREEZE) or
				npc:HasEntityFlags(EntityFlag.FLAG_MIDAS_FREEZE) or
				mod:isStatusCorpse(npc) or
				mod:isLeavingStatusCorpse(npc) or
				mod:grabbedByBigHorn(npc))
		then
			for i = 1, 15 do
				local bugcheck = math.random(1,6);
				Isaac.Spawn(EntityType.ENTITY_EFFECT, mod.bugtable[bugcheck], 0, npc.Position, (RandomVector()*(math.random()+math.random(5,12))), npc);
			end
		end
	elseif ent.Variant == mod.FF.Baro.Var then
		local npc = ent:ToNPC()
		local data = npc:GetData()

		if not (npc:HasEntityFlags(EntityFlag.FLAG_FREEZE) or
				npc:HasEntityFlags(EntityFlag.FLAG_MIDAS_FREEZE) or
				mod:isStatusCorpse(npc) or
				mod:isLeavingStatusCorpse(npc) or
				mod:grabbedByBigHorn(npc))
		then
			Isaac.Spawn(281, 0, 0, npc.Position, nilvector, npc);
			for i = 1, 10 do
				local bugcheck = math.random(1,6)
				Isaac.Spawn(EntityType.ENTITY_EFFECT, mod.bugtable[bugcheck], 0, npc.Position, (RandomVector()*(math.random()+math.random(5,12))), npc);
			end
		end
	end
end
mod:AddCallback(ModCallbacks.MC_POST_NPC_DEATH, mod.check666Death, FiendFolio.FFID.Mini)

function mod:checkminicollide(npc, other, low)
	if npc.Variant == mod.FF.DopeHead.Var then
		--dopehead collision
		if npc:GetData().die then
			return true
		end
		if other.Type == mod.FF.DopeHead.ID and other.Variant == mod.FF.DopeHead.Var then
			if other:GetData().die then
				return true
			end
			local xdiff = math.abs(npc.Velocity.X - other.Velocity.X)
			local ydiff = math.abs(npc.Velocity.Y - other.Velocity.Y)
			if ydiff > xdiff then
				if npc.Position.Y > other.Position.Y then
					npc.Velocity = Vector(npc.Velocity.X, math.abs(npc.Velocity.Y)*-1):Normalized() * 12
					other.Velocity = Vector(other.Velocity.X, math.abs(other.Velocity.Y)):Normalized() * 12
				else
					npc.Velocity = Vector(npc.Velocity.X, math.abs(npc.Velocity.Y)):Normalized() * 12
					other.Velocity = Vector(other.Velocity.X, math.abs(other.Velocity.Y)*-1):Normalized() * 12
				end
			else
				if npc.Position.X > other.Position.X then
					npc.Velocity = Vector(math.abs(npc.Velocity.X), npc.Velocity.Y):Normalized() * 12
					other.Velocity = Vector(math.abs(other.Velocity.X) * -1, other.Velocity.Y):Normalized() * 12
				else
					npc.Velocity = Vector(math.abs(npc.Velocity.X) * -1, npc.Velocity.Y):Normalized() * 12
					other.Velocity = Vector(math.abs(other.Velocity.X), other.Velocity.Y):Normalized() * 12
				end
			end
			npc:GetData().prevx = FiendFolio.sign(npc.Velocity.X);
			npc:GetData().prevy = FiendFolio.sign(npc.Velocity.Y);
			other:GetData().prevx = FiendFolio.sign(npc.Velocity.X);
			other:GetData().prevy = FiendFolio.sign(npc.Velocity.Y);
			if npc:GetData().prevx == 1 then
				sfx:Play(SoundEffect.SOUND_BONE_BOUNCE, 0.7, 0, false, 0.8)
				mod:spritePlay(npc:GetSprite(), "spinr")
			else
				sfx:Play(SoundEffect.SOUND_BONE_BOUNCE, 0.7, 0, false, 0.8)
				mod:spritePlay(npc:GetSprite(), "spinl")
			end
			if other:GetData().prevx == 1 then
				sfx:Play(SoundEffect.SOUND_BONE_BOUNCE, 0.7, 0, false, 0.8)
				mod:spritePlay(other:GetSprite(), "spinr")
			else
				sfx:Play(SoundEffect.SOUND_BONE_BOUNCE, 0.7, 0, false, 0.8)
				mod:spritePlay(other:GetSprite(), "spinl")
			end
			return false
		elseif other.Type == mod.FF.Junkstrap.ID and other.Variant == mod.FF.Junkstrap.Var then
			if npc:GetData().junksucked and other:GetData().Sucking then
				return true
			end
		elseif other.Type ~= 1 and other.Type ~= 2 then
			return true
		end
	elseif npc.Variant == mod.FF.DopeHeadProjectile.Var then
		if other.Type == 1 then
			mod:DestroyDopeHeadProjectile(npc)
		else
			return true
		end
	end
end

mod:AddCallback(ModCallbacks.MC_PRE_NPC_COLLISION, mod.checkminicollide, FiendFolio.FFID.Mini)

--Gmo Penny, Molten Penny (real)
function mod:gmocoin(pickup, man, low)

	local sticky = (pickup.SubType == 6)
	if man.Type == 1 and (not pickup.Touched) and (not sticky) then
		man = man:ToPlayer()
		if man:HasTrinket(TrinketType.TRINKET_GMO_PENNY) then
			local lucky = math.max(man.Luck, 0) * man:GetTrinketMultiplier(TrinketType.TRINKET_GMO_PENNY)
			lucky = math.sqrt(20 * lucky)
			if pickup.SubType == 2 then
				lucky = lucky + 2
			elseif pickup.SubType == 3 then
				lucky = lucky + 5
			elseif pickup.SubType == 5 then
				lucky = lucky + 10
			elseif pickup.SubType == 213 then
				lucky = lucky + 5
			end
			if math.random(0, 10000)/100 <= lucky + 5 then
				local pill = (man:HasCollectible(CollectibleType.COLLECTIBLE_PHD) or man:HasCollectible(CollectibleType.COLLECTIBLE_VIRGO)) and FiendFolio.PHDPills[math.random(#FiendFolio.PHDPills)] or math.random(PillEffect.NUM_PILL_EFFECTS - 1)
				pill = ((pill == PillEffect.PILLEFFECT_BAD_TRIP and man:GetHearts() <= 2) and PillEffect.PILLEFFECT_FULL_HEALTH or pill)
				pill = ((pill == PillEffect.PILLEFFECT_HEALTH_DOWN and man:GetMaxHearts() <= 1) and PillEffect.PILLEFFECT_HEALTH_UP or pill)
				man:UsePill(pill, math.random(PillColor.NUM_PILLS - 1))
			end
		end
		if man:HasTrinket(TrinketType.TRINKET_MOLTEN_PENNY) then

			local sdata = Isaac.GetPlayer():GetData().ffsavedata
			if not sdata.moltenPennyNumber then
				sdata.moltenPennyNumber = 0
			end
			sdata.moltenPennyNumber = sdata.moltenPennyNumber+1

			local lucky = math.max(man.Luck / 2, 0)
			if(pickup.SubType == 2 or pickup.SubType == 5) then
				lucky = lucky + 3
			end
			if(pickup.SubType == 3) then
				lucky = lucky + 6
			end
			if(pickup.SubType == 213) then
				lucky = lucky + 1
			end
			lucky = lucky * (1 + 0.25 * (man:GetTrinketMultiplier(TrinketType.TRINKET_MOLTEN_PENNY) - 1))
			if (math.random(0, 10000)/100 <= lucky + 2) or (sdata.moltenPennyNumber == 30)then
				man:UseActiveItem(479, false, false, true, false)
				sfx:Play(SoundEffect.SOUND_FIREDEATH_HISS, 1, 0, false, 1.5)
			end
		end
		if man:HasTrinket(TrinketType.TRINKET_FUZZY_PENNY) then
			local repeatTimes = man:GetTrinketMultiplier(TrinketType.TRINKET_FUZZY_PENNY)
			for k = 1, repeatTimes do
				local randVec = RandomVector() * math.random(5,15)
				local skuzz = Isaac.Spawn(3, FamiliarVariant.ATTACK_SKUZZ, 0, man.Position + randVec, nilvector, man):ToFamiliar()
				skuzz:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
			end
		end
	end
end

mod:AddCallback(ModCallbacks.MC_PRE_PICKUP_COLLISION, mod.gmocoin, 20)

--END OF MINICHIBIS CODE

--VERMIN CODE

function mod:danglerAI(npc)
	local room = game:GetRoom()
	local sprite = npc:GetSprite()
	local d = npc:GetData()
	local target = npc:GetPlayerTarget()
	npc.SplatColor = Color(0,0,0,1,20 / 255,10 / 255,10 / 255);

	local velocity = mod:reverseIfFear(npc,(mod:confusePos(npc,target.Position) - npc.Position):Resized(2.3))
	npc.Velocity = (npc.Velocity*0.95) + (velocity*0.05)

	--Setup
	if not d.init then
		d.state = 1
		d.init = true
		d.skin = math.random(4)
		local eternalfriend = Isaac.Spawn(96, 0, 0, npc.Position, Vector(0,0), npc):ToNPC()
		eternalfriend.Parent = npc
		eternalfriend:Update()
	else
		npc.StateFrame = npc.StateFrame + 1
	end

	--Idle
	if d.state == 1 then
		if not sprite:IsPlaying("Head0" .. d.skin) then
			sprite:Play("Head0" .. d.skin, true)
		end
		local distance = target.Position:Distance(npc.Position)
		if distance < 360 and room:CheckLine(target.Position,npc.Position,3,900,false,false) and not mod:isScareOrConfuse(npc) then
			if npc.StateFrame > 28 then
				d.state = 2
			end
		end
	end

	--Shooting
	if d.state == 2 then
		if sprite:IsFinished("AttackHead0" .. d.skin) then
			npc.StateFrame = 1
			d.state = 1
		else
			mod:spritePlay(sprite, "AttackHead0" .. d.skin)
			if sprite:IsEventTriggered("Shoot") then
				npc:PlaySound(SoundEffect.SOUND_BLOODSHOOT,1,0,false,1)
				local params = ProjectileParams()
				params.BulletFlags = params.BulletFlags | ProjectileFlags.GREED
				for i = -1,1 do
					local spreadshot = math.random(4,12)-8
					npc:FireProjectiles(npc.Position, velocity:Resized(8):Rotated(i*spreadshot*10), 0, params)
				end
			end
		end
	end
end

--END OF VERMIN CODE

-- DEAD CODE?!? (i have no idea where to put this!)
local magleechSuckableEnts = {
	{mod.FF.WombPillar.ID, mod.FF.WombPillar.Var, Pillar = true}, -- womb pillar
	{mod.FF.UteroPillar.ID, mod.FF.UteroPillar.Var, Pillar = true} -- utero pillar
}

local magleechSuckableGrids = {
	[GridEntityType.GRID_ROCK] = true,
	[GridEntityType.GRID_ROCKT] = true,
	[GridEntityType.GRID_ROCK_BOMB] = true,
	[GridEntityType.GRID_ROCK_ALT] = true,
	[GridEntityType.GRID_ROCK_SS] = true,
	[GridEntityType.GRID_WALL] = true,
	[GridEntityType.GRID_DOOR] = true
}

function mod:GetMagleechTargets(npc)
	local room = game:GetRoom()
	local path = npc.Pathfinder
	local target = npc:GetPlayerTarget()
	local tpos = target.Position
	local targets = {}
	local badtargets = {}
	local leechbuds = Isaac.FindByType(npc.Type, npc.Variant, -1, false, false)
	for _, leech in ipairs(leechbuds) do
		local d = leech:GetData()
		if d.suckon then
			badtargets[#badtargets + 1] = d.suckon.Position
		end
	end

	for _, suckable in ipairs(magleechSuckableEnts) do
		local ents = Isaac.FindByType(suckable[1], suckable[2], -1, false, false)
		for _, ent in ipairs(ents) do
			if not ent:IsDead() then
				targets[#targets + 1] = {Position = ent.Position, Entity = ent, Pillar = suckable.Pillar}
			end
		end
	end

	for i = 0, room:GetGridSize() do
		local grid = room:GetGridEntity(i)
		if grid and grid.State ~= 2 and magleechSuckableGrids[grid.Desc.Type] then
			if grid.Desc.Type ~= GridEntityType.GRID_WALL or not room:IsPositionInRoom(grid.Position, 0) then
				targets[#targets + 1] = {Position = grid.Position, Grid = grid}
			end
		end
	end

	local outtargets = {}
	-- find targets that align with player, then add to out table if pathable
	for _, targ in ipairs(targets) do
		local pos = targ.Position
		local offs = {}
		if math.abs(pos.X - tpos.X) < 80 then
			-- magleech paths to the target's position offset by half a grid, so that it can connect cleanly to the correct side
			-- picks the direction that puts magleech closest to the player
			if pos.Y > tpos.Y then
				offs[#offs + 1] = Vector(0, -1)
			else
				offs[#offs + 1] = Vector(0, 1)
			end
		end

		if math.abs(pos.Y - tpos.Y) < 80 then
			if pos.X > tpos.X then
				offs[#offs + 1] = Vector(-1, 0)
			else
				offs[#offs + 1] = Vector(1, 0)
			end
		end

		for _, off in ipairs(offs) do
			local fullpos = pos + off * 40
			if room:CheckLine(tpos, fullpos, 1, 0, false, false) and path:HasPathToPos(fullpos, false) then
				-- avoid targeting similar spots to other leeches
				local isbad
				for _, bad in ipairs(badtargets) do
					if bad:DistanceSquared(fullpos) < 100 ^ 2 then
						isbad = true
						break
					end
				end

				if not isbad then
					outtargets[#outtargets + 1] = {Entity = targ.Entity, Pillar = targ.Pillar, Grid = targ.Grid, Position = targ.Position, Offset = off, OffPosition = fullpos}
				end
			end
		end
	end

	if #outtargets > 0 then
		return outtargets
	else
		return
	end
end

function mod:magleechAI(npc, sprite, d)
	local room = game:GetRoom()
	local path = npc.Pathfinder
	if not d.init then
		d.init = true
		d.state = "idle"
	end

	npc.StateFrame = npc.StateFrame + 1

	if d.stuntime then
		d.stuntime = d.stuntime - 1
		if d.stuntime <= 0 then
			d.stuntime = nil
		end
	end

	if d.state == "idle" then
		local targetpos = npc:GetPlayerTarget().Position
		if npc:HasEntityFlags(EntityFlag.FLAG_CONFUSION) or npc:HasEntityFlags(EntityFlag.FLAG_FEAR) or not path:HasPathToPos(targetpos, false) then
			targetpos = mod:runIfFear(npc, mod:FindRandomValidPathPosition(npc), nil, true)
		elseif npc.StateFrame > 30 and math.random(1, 8) == 1 then
			local targets = mod:GetMagleechTargets(npc)
			if targets then
				local pick = targets[math.random(1, #targets)]
				d.suckon = pick
				d.state = "seek"
				npc.StateFrame = 0
			end
		end

		if d.stuntime then
			npc.Velocity = npc.Velocity * 0.8
		else
			path:FindGridPath(targetpos, 0.55, 0, false)
		end
	elseif d.state == "seek" then
		local cancel = npc:HasEntityFlags(EntityFlag.FLAG_CONFUSION) or npc:HasEntityFlags(EntityFlag.FLAG_FEAR)
		if d.suckon.Entity and (not d.suckon.Entity:Exists() or d.suckon.Entity:IsDead()) then
			cancel = true
		end

		if d.suckon.Grid and d.suckon.Grid.State == 2 then
			cancel = true
		end

		if cancel then
			d.state = "idle"
			d.suckon = nil
			npc.StateFrame = 0
		else
			if d.suckon.Entity then
				d.suckon.Position = d.suckon.Entity.Position
				d.suckon.OffPosition = d.suckon.Position + d.suckon.Offset * 40
			end

			local targetpos = d.suckon.OffPosition

			local targDist = npc.Position:DistanceSquared(targetpos)
			if npc.Position:DistanceSquared(targetpos) <= (40 + npc.Size) ^ 2 then
				if targDist <= npc.Size ^ 2 then
					local collide

					npc.Velocity = (npc.Velocity * 0.9) + (d.suckon.Position - npc.Position):Resized(0.5)

					if d.suckon.Entity then
						local dist = npc.Position:DistanceSquared(d.suckon.Entity.Position)
						if dist <= (npc.Size + d.suckon.Entity.Size) ^ 2 or npc:CollidesWithGrid() then
							collide = true
						end
					elseif npc:CollidesWithGrid() then
						collide = true
					end

					if collide then
						npc:PlaySound(SoundEffect.SOUND_GOOATTACH0,1,1,false,1)
						d.suckpos = npc.Position
						d.sucktime = math.random(30, 50)
						d.state = "suck"
						npc.StateFrame = 0
					end
				else
					npc.Velocity = (npc.Velocity * 0.9) + (d.suckon.OffPosition - npc.Position):Resized(0.5)
				end
			else
				path:FindGridPath(targetpos, 0.55, 0, false)
			end
		end
	elseif d.state == "suck" then
		local cancel
		if d.suckon.Entity and (not d.suckon.Entity:Exists() or d.suckon.Entity:IsDead()) then
			cancel = true
		end

		if d.suckon.Grid and d.suckon.Grid.State == 2 then
			cancel = true
		end

		local finish
		if cancel then
			d.state = "idle"
			finish = true
		else
			if d.suckon.Entity then
				d.suckpos = d.suckon.Entity.Position + d.suckon.Offset:Resized(npc.Size + d.suckon.Entity.Size)
				if d.suckon.Pillar then
					d.suckon.Entity:GetData().hurting = true
				end
			end

			npc.Velocity = d.suckpos - npc.Position

			local suckAnim = "01"
			if npc.StateFrame > d.sucktime / 3 then
				suckAnim = "02"
			end

			if npc.StateFrame > d.sucktime then
				npc:PlaySound(SoundEffect.SOUND_MEATY_DEATHS,1,1,false,1)
				d.state = "charge"
				d.chargedirection = d.suckon.Offset
				finish = true
			else
				local dir
				if math.abs(d.suckon.Offset.X) > 0 then
					dir = "Hori"
					sprite.FlipX = d.suckon.Offset.X > 0
				else
					sprite.FlipX = false
					if d.suckon.Offset.Y < 0 then
						dir = "Down"
					else
						dir = "Up"
					end
				end

				if d.collideanimdone then
					mod:spritePlay(sprite, "Suck" .. dir .. suckAnim)
				else
					if not d.collideanim then
						d.collideanim = "Collide" .. dir
						sprite:Play(d.collideanim, true)
					end

					if sprite:IsFinished(d.collideanim) then
						d.collideanimdone = true
					end
				end
			end
		end

		if finish then
			d.suckon = nil
			d.suckpos = nil
			d.sucktime = nil
			d.collideanimdone = nil
			d.collideanim = nil
			npc.StateFrame = 0
		end
	elseif d.state == "charge" then
		npc.Velocity = (npc.Velocity * 0.5) +  d.chargedirection * 12

		local params = ProjectileParams()
		local level = game:GetLevel()
		local stage = level:GetStage()
		local stageType = level:GetStageType()

		npc:PlaySound(SoundEffect.SOUND_BLOODSHOOT,1,0,false,1.3)
		for i = 1, math.random(2) do
			params.Variant = ProjectileVariant.PROJECTILE_BONE
			if stage == LevelStage.STAGE4_1 or stage == LevelStage.STAGE4_2 then
				if stageType == StageType.STAGETYPE_ORIGINAL or math.random(1, 4) ~= 1 then
					params.Variant = ProjectileVariant.PROJECTILE_NORMAL
				end
			end

			npc:FireBossProjectiles(1, npc.Position - d.chargedirection * 40, 0, params)
		end

		if math.abs(npc.Velocity.Y) > math.abs(npc.Velocity.X) then
			sprite.FlipX = false
			if npc.Velocity.Y < 0 then
				mod:spritePlay(sprite, "ChargeDown")
			else
				mod:spritePlay(sprite, "ChargeUp")
			end
		else
			mod:spritePlay(sprite, "ChargeHori")
			sprite.FlipX = npc.Velocity.X > 0
		end

		if (npc:CollidesWithGrid() and npc.StateFrame > 10) or npc.StateFrame >= 150 then
			d.state = "idle"
			d.stuntime = math.random(15, 30)
			d.chargedirection = nil
			npc.StateFrame = 0
		end
	end

	if d.state == "idle" or d.state == "seek" then
		local ind = room:GetGridIndex(npc.Position)
		if room:GetGridPath(ind) < 900 then
			room:SetGridPath(ind, 900)
		end

		if math.abs(npc.Velocity.Y) > math.abs(npc.Velocity.X) then
			sprite.FlipX = false
			if npc.Velocity.Y < 0 then
				mod:spritePlay(sprite, "Move Up")
			else
				mod:spritePlay(sprite, "Move Down")
			end
		else
			mod:spritePlay(sprite, "Move Hori")
			sprite.FlipX = npc.Velocity.X < 0
		end
	end
end

function mod:RemapValue(value, valLow, valHigh, toLow, toHigh)
	return toLow + (value - valLow) * (toHigh - toLow) / (valHigh - valLow)
end

function mod:PeriodicSine(time, period, offset, percent)
	offset = offset or 0
	local wave = math.sin((math.pi * 2) * (offset + time / period))
	if percent then
		return (wave + 1) / 2
	else
		return wave
	end
end

function mod:FistuloidMovement(npc, targpos, d, speed, sinlength, ampmin, ampmax)
	-- fun fact, i stole this fistuloid movement code from rev's aerotoma, which i also wrote
	-- fun fact 2: i stole aerotoma's movement code from a screenshot kil posted on the binding of isaac server
	-- https://discord.com/channels/123641386921754625/123961790529929218/400246736863363073
	-- pretty cool right?
	d.offset = d.offset or math.random()

	local wave = mod:PeriodicSine(npc.FrameCount, sinlength, d.offset)

	if not d.maxamplitude or math.abs(wave) < 0.1 then
		if not d.maxamplitude or not d.changedamplitude then
			d.maxamplitude = math.random(ampmin, ampmax)
			d.changedamplitude = true
		end
	elseif d.maxamplitude then
		d.changedamplitude = nil
	end

	local diff = targpos - npc.Position
	local dist = diff:Length()

	-- sin wave movement that gets smaller the closer **NOT AEROTOMA** is to the target, with a little rng thrown in via changing max amplitude whenever the wave resets.
	local amplitude = mod:RemapValue(dist, 200, 1000, d.maxamplitude, 0)
	local dir = diff / dist

	dir = dir:Rotated(wave * amplitude)
	npc.Velocity = dir * speed

	return dist
end

function mod:blubberAI(npc, sprite, d)
	local room = game:GetRoom()
	if not d.init then
		if npc.SubType == 1 then
			d.state = "nohead"
			npc:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
			sprite:Play("AppearHeadless", true)
			Isaac.Spawn(1000, EffectVariant.POOF01, 0, npc.Position, nilvector, npc)
		else
			d.state = "idle"
			d.wormsource = npc
		end

		d.init = true
	end

	if d.state == "idle" then
		local target = npc:GetPlayerTarget()
		local targPos, distSquared
		for i = 45, 405, 90 do
			local targ = target.Position + Vector.FromAngle(i) * 40
			local dist = npc.Position:DistanceSquared(targ)
			if (not distSquared or dist < distSquared) and room:IsPositionInRoom(targ, 0) then
				targPos = targ
			end
		end

		local dist = mod:FistuloidMovement(npc, targPos, d, 2.5, 60, 40, 70)

		sprite.FlipX = npc.Velocity.X > 0

		if not d.cooldown then
			d.cooldown = math.random(20, 40)
		end

		d.cooldown = d.cooldown - 1
		if d.wormsource and GetPtrHash(npc) ~= GetPtrHash(d.wormsource) and (d.wormsource:IsDead() or not d.wormsource:Exists()) then -- where'd my head go?!
			local explosion = Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.BLOOD_EXPLOSION, 0, npc.Position, Vector(0, 0), npc)
			explosion.PositionOffset = Vector(0, -10)
			d.state = "nohead"
			d.cooldown = nil
			d.wormsource = nil
		elseif d.cooldown <= 0 and dist <= 150 and (dist <= 80 or ((npc.Position - target.Position):GetAngleDegrees() % 45 < 30)) then
			--print(dist)
			d.state = "shoot"
			d.cooldown = nil

			sprite.FlipX = target.Position.X > npc.Position.X
			if target.Position.Y < npc.Position.Y then
				if sprite.FlipX then
					d.shootdir = Vector.FromAngle(315)
				else
					d.shootdir = Vector.FromAngle(225)
				end

				d.anim = "Attack02"
			else
				if sprite.FlipX then
					d.shootdir = Vector.FromAngle(45)
				else
					d.shootdir = Vector.FromAngle(135)
				end

				d.anim = "Attack01"
			end

			sprite:Play(d.anim, true)
		else
			mod:spritePlay(sprite, "Idle01")
		end
	elseif d.state == "shoot" then
		npc.Velocity = -d.shootdir
		if sprite:IsEventTriggered("Shoot") then
			npc:PlaySound(SoundEffect.SOUND_MONSTER_ROAR_0,1,1,false,1.8)
			local pro = Isaac.Spawn(mod.FF.MyiasisProj.ID, mod.FF.MyiasisProj.Var, 0, npc.Position + d.shootdir * 20, d.shootdir * 14, npc)
			pro:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
			pro:GetData().direction = d.shootdir
			pro:GetData().blubber = d.wormsource
			pro.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS

			if d.shootdir.Y > 0 then
				anim = "Down"
			else
				anim = "Up"
			end

			pro:GetSprite():Play(anim, true)
			pro:GetSprite().FlipX = sprite.FlipX
			pro:GetData().anim = anim
		end

		if sprite:IsFinished(d.anim) then
			d.state = "nohead"
		end
	elseif d.state == "nohead" then
		if sprite:IsPlaying("AppearHeadless") then
			npc.Velocity = nilvector
		elseif sprite:IsPlaying("Recover01") or sprite:IsPlaying("Recover02") then
			npc.Velocity = npc.Velocity * 0.8
		elseif sprite:IsFinished("Recover01") or sprite:IsFinished("Recover02") then
			d.state = "idle"
		else
			mod:FistuloidMovement(npc, npc:GetPlayerTarget().Position, d, 1.5, 90, 40, 70)
			sprite.FlipX = npc.Velocity.X > 0
			mod:spritePlay(sprite, "Idle02")
		end
	end
end

function mod:blubberProjectileAI(npc, sprite, d)
	if not d.blubber or d.blubber:IsDead() or not d.blubber:Exists() or mod:isStatusCorpse(d.blubber) then
		npc:Kill()
		return
	end

	local room = game:GetRoom()

	mod:spritePlay(sprite, d.anim)

	npc.Velocity = d.direction * 14

	npc.Position = room:ScreenWrapPosition(npc.Position, -120)

	if npc.FrameCount > 5 then
		local blubs = Isaac.FindByType(mod.FF.Myiasis.ID, mod.FF.Myiasis.Var, -1, false, false)
		for _, blub in ipairs(blubs) do
			if (blub:GetData().state == "nohead" and not (blub:GetSprite():IsPlaying("Recover01") or blub:GetSprite():IsPlaying("Recover02"))) or blub:GetSprite():WasEventTriggered("Shoot") then
				if blub.Position:DistanceSquared(npc.Position) <= (npc.Size + blub.Size + 20) ^ 2 then
					blub:GetData().wormsource = d.blubber
					blub:GetData().state = "nohead"

					blub:ToNPC():PlaySound(SoundEffect.SOUND_GOOATTACH0,1,1,false,1)
					if d.anim == "Up" then
						blub:GetSprite():Play("Recover02", true)
					else
						blub:GetSprite():Play("Recover01", true)
					end

					npc:Remove()
					break
				end
			end
		end
	end
end

function mod:viscerspiritAI(npc, sprite, d)
	if not d.found then
		local newparent = mod.FindClosestEnemyEffigy(npc.Position)
		if newparent then
			npc.Parent = newparent

			d.initialhp = npc.Parent.HitPoints

			local hpPercent = npc.Parent.HitPoints / npc.Parent.MaxHitPoints
			npc.MaxHitPoints = npc.MaxHitPoints + npc.Parent.MaxHitPoints
			npc.Parent.MaxHitPoints = npc.MaxHitPoints
			npc.Parent.HitPoints = npc.MaxHitPoints * hpPercent
			npc.HitPoints = npc.Parent.HitPoints

			if newparent:GetData().viscerspirited then
				newparent:GetData().viscerspirited = newparent:GetData().viscerspirited + 1
			else
				newparent:GetData().viscerspirited = 1
			end
			d.vec = (npc.Position - npc.Parent.Position):Resized(40)
			d.distoffset = math.random()
			d.veloffset = math.random()
			d.found = true
			npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
			npc.PositionOffset = Vector(0, (-13 / 26) * 40)
			npc:AddEntityFlags(EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK | EntityFlag.FLAG_NO_KNOCKBACK | EntityFlag.FLAG_NO_STATUS_EFFECTS | EntityFlag.FLAG_NO_TARGET)
			npc:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
			sprite:Play("Appear")
		else
			npc:Kill()
		end
	end

	if sprite:IsFinished("Appear") then
		sprite:Play("Idle")
	end

	if npc.Parent then
		if npc.Parent:GetData().viscerspirited and npc.Parent.FrameCount > 10 then
			local data = npc.Parent:GetData()
			if data.viscerspirited > 1 then
				sfx:Play(SoundEffect.SOUND_VAMP_DOUBLE)
			else
				sfx:Play(SoundEffect.SOUND_VAMP_GULP)
			end
			local effect = Isaac.Spawn(1000, 49, 0, npc.Parent.Position, Vector.Zero, npc.Parent):ToEffect()
			effect:FollowParent(npc.Parent)
			effect.DepthOffset = npc.Parent.Position.Y * 1.25
			effect.SpriteOffset = Vector(0, -30 + npc.Size * -1.0)
			data.viscerspirited = nil
		end
		npc.MaxHitPoints = npc.Parent.MaxHitPoints
		npc.HitPoints = npc.Parent.HitPoints

		local targpos = npc.Parent.Position + d.vec
		local targvel = (targpos - npc.Position)
		npc.Velocity = targvel

		sprite.FlipX = npc.Velocity.X < 0

		local distwave = mod:PeriodicSine(npc.FrameCount, 60, d.distoffset, true)
		local dist = mod:Lerp(npc.Parent.Size + 7, npc.Parent.Size + 22, distwave)
		local velwave = mod:PeriodicSine(npc.FrameCount, 60, d.veloffset, true)
		local rot = mod:Lerp(1, 6, velwave)

		d.vec = d.vec:Rotated(rot):Resized(dist)

		if npc.FrameCount > 1 then
			if d.prevhitpoints and npc.HitPoints < d.prevhitpoints then
				npc:SetColor(Color(1,1,1,1,1,0,0),3,999,true,false)
			end

			d.prevhitpoints = npc.HitPoints

			if npc.HitPoints <= d.initialhp then
				npc:Kill()
			end
		end
	else
		npc:Kill()
	end
end

--END OF DEAD CODE

--BattieAI
function mod:battyAI(npc, sprite, d)
	local room = game:GetRoom()
	local target = npc:GetPlayerTarget()
	local r = npc:GetDropRNG()


	if not d.init then
		d.init = true
		d.flapcount = 0
		d.extraframes = 0
		d.slamattackcount = 0
		d.chargeattackcount = 0
		d.state = "idle"
		local champSheet
		if mod.IsDeliriumRoom then
			champSheet = "gfx/bosses/battie/battie_cummie.png"
		else
			local champ
			if npc.SubType > 0 then
				champ = npc.SubType
			elseif FiendFolio.savedata.sawBattieBefore and game:GetRoom():GetType() == RoomType.ROOM_BOSS then
				local seed = game:GetRoom():GetSpawnSeed()
				grng:SetSeed(seed, 0)
				champ = grng:RandomInt(5)
			end

			if champ == 1 then
				npc.SubType = 1
				d.foamy = true
				champSheet = "gfx/bosses/battie/battie_brown.png"
			elseif champ == 2 then
				npc.SubType = 2
				d.purple = true
				champSheet = "gfx/bosses/battie/battie_purple.png"
			end
		end

		if champSheet then
			for i = 0, 4 do
				sprite:ReplaceSpritesheet(i, champSheet)
			end
			sprite:LoadGraphics()
		end
		FiendFolio.savedata.sawBattieBefore = true
	else
		npc.StateFrame = npc.StateFrame + 1
	end

	--Used for the death animation
	if npc.State ~= 11 then
		--Her default movement state, just flapping away.
		if d.state == "idle" then
			d.extraframes = 0
			mod:spritePlay(sprite, "Idle")
			npc.SpriteOffset = Vector(0, -25)
			if sprite:GetFrame() == 10 then
				--Flapcount determines rotation on velocity, so each flap is rotated by either -30 or 30 degrees
				--this is a dumb lazy way of doing it though.
				if d.flapcount == 0 then
					d.flapcount = 60
				else
					d.flapcount = 0
				end
				--Only updates her velocity in a flap every ten frames
				npc.Velocity = (target.Position-npc.Position):Resized(10):Rotated(-30 + d.flapcount)
				npc:PlaySound(mod.Sounds.WingFlap,0.5,0,false,math.random(70,90)/100)
			end
			--Ensures she's constantly slowing, so that she flaps and gets a boost, slowing afterwards
			npc.Velocity = npc.Velocity * 0.9
			if npc.StateFrame > 100 and r:RandomInt(10) == 0 then
				--Likely to spawn bats if there is only 1 or aren't any, but doesn't need to.
				local batcount = mod.GetBatCount()
				if (batcount < 1) or (batcount < 2 and r:RandomInt(3) == 0) then
					d.extraframes = 70
					d.spewstate = "bats"
					d.state = "spew"
				else
					--Isaac.ConsoleOutput(d.chargeattackcount .. ", " .. d.chargeattackcount / 3 .. "/ " .. d.slamattackcount .. "\n")
					--Math here is to ensure she has a balance of charging or slamming attacks.
					if r:RandomInt(3) == 0 or d.chargeattackcount / 3 >= d.slamattackcount then
						d.state = "slam"
						d.slamattackcount = d.slamattackcount + 1
						d.slamstate = 1
					else
						d.state = "charge"
						npc:PlaySound(SoundEffect.SOUND_MONSTER_YELL_B,1,1,false,1.3)
						d.chargeattackcount = d.chargeattackcount + 1
						d.chargestate = 1
					end
				end
			end

		--Charging state, the big vertical dive
		elseif d.state == "charge" then

			--Initialise the charge, and set how many times she should charge
			if d.chargestate == 1 then
				npc.Velocity = npc.Velocity * 0.85
				if sprite:IsFinished("ChargeStart") then
					mod:spritePlay(sprite, "Charge")
					d.chargestate = 2
					d.chargehori = nil
					d.chargevert = nil
					npc:AddEntityFlags(EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK)
					d.chargecount = 0
					--Either 3 or 5 charges will occur
					d.maxcharges = 3 + r:RandomInt(3)
				else
					mod:spritePlay(sprite, "ChargeStart")
				end

			--Actually performing the charge
			elseif d.chargestate == 2 then
				if sprite:GetFrame() == 4 then
					npc:PlaySound(mod.Sounds.WingFlap,0.5,0,false,math.random(130,150)/100)
				end
				local add = Vector(0, 0)
				local homeStrength = 1.5
				if d.chargehori then
					if target.Position.Y > npc.Position.Y + 10 then
						add = Vector(0, homeStrength)
					elseif target.Position.Y < npc.Position.Y - 10 then
						add = Vector(0, -homeStrength)
					end

					npc.Velocity = Vector(20 * (d.chargehori or 1), 0)
				else
					if target.Position.X > npc.Position.X + 10 then
						add = Vector(homeStrength, 0)
					elseif target.Position.X < npc.Position.X - 10 then
						add = Vector(-homeStrength, 0)
					end

					npc.Velocity = Vector(0,20 * (d.chargevert or 1))
				end

				if d.foamy then
					npc.Velocity = npc.Velocity * 0.85
				end

				npc.Velocity = npc.Velocity + add
				--Move her to the top of the screen if she goes down far enough
				local chargecomplete
				if d.chargehori then
					if d.chargehori == -1 and npc.Position.X < -100 then
						chargecomplete = true
					elseif d.chargehori ~= -1 and npc.Position.X > room:GetGridWidth() * 40 + 100 then
						chargecomplete = true
					end
				else
					if d.chargevert == -1 and npc.Position.Y < -100 then
						chargecomplete = true
					elseif d.chargevert ~= -1 and npc.Position.Y > room:GetGridHeight() * 40 + 300 then
						chargecomplete = true
					end
				end

				if chargecomplete then
					if d.foamy then
						local negative = r:RandomInt(2)
						if negative == 0 then
							negative = -1
						end

						if d.chargehori then
							d.chargevert = negative
							d.chargehori = nil
						else
							d.chargehori = negative
							d.chargevert = nil
						end
					elseif d.purple then
						if d.chargevert == -1 then
							d.chargevert = 1
						else
							d.chargevert = -1
						end
					end

					if d.chargehori then
						if d.chargehori == -1 then
							npc.Position = Vector(room:GetGridWidth() * 40 + 100, target.Position.Y)
						else
							npc.Position = Vector(-100, target.Position.Y)
						end
					else
						if d.chargevert == -1 then
							npc.Position = Vector(target.Position.X, room:GetGridHeight() * 40 + 300)
						else
							npc.Position = Vector(target.Position.X, -100)
						end
					end

					--Since her babies are a threat, if they're all dead she'll want to go back to idle soon, so she can spawn more.
					if mod.GetBatCount() == 0 then
						d.chargecount = d.chargecount + 2
					else
						d.chargecount = d.chargecount + 1
					end
				end

				--The projectiles
				if not (d.chargecount > d.maxcharges) then
					if npc.FrameCount % 4 == 0 then
						local projectile = Isaac.Spawn(9, 0, 0, npc.Position, nilvector, npc):ToProjectile()
						projectile.ProjectileFlags = projectile.ProjectileFlags | ProjectileFlags.NO_WALL_COLLIDE
						projectile.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_NONE
						if d.purple then
							projectile:GetData().purplebattie = true
						end
					end
				end

				--Make her stop charging when she needs to
				if room:IsPositionInRoom(npc.Position, 0) then
					if d.chargecount > d.maxcharges then
						mod:spritePlay(sprite, "ChargeStop")
						npc:PlaySound(mod.Sounds.Skid,0.7,0,false,1.15)
						npc:ClearEntityFlags(EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK)
						d.chargestate = 3
					end
				else
					mod:spritePlay(sprite, "Charge")
				end

			--Stopping the charge, and returning her to idle
			elseif d.chargestate == 3 then
				npc.Velocity = npc.Velocity * 0.9
				if sprite:IsFinished("ChargeStop") then
					npc.StateFrame = 0
					d.state = "idle"
				--Shoot 8 tears in 8 directions
				elseif sprite:GetFrame() == 15 then
					npc:PlaySound(mod.Sounds.Tada,1,0,false,1.25)

					local params = ProjectileParams()
					--params.BulletFlags = params.BulletFlags | ProjectileFlags.TRIANGLE
					local count, speed = 8, 13
					if d.purple then
						count, speed = 5, 9
						params.BulletFlags = params.BulletFlags | ProjectileFlags.SMART
					end

					for i = 1, count do
						local ang = (360 / count) * i
						npc:FireProjectiles(npc.Position, Vector(0,speed):Rotated(-22.5+ang), 0, params)
					end


					--[[for i = 45, 360, 45 do
						local p = Isaac.Spawn(9, 0, 0, npc.Position, Vector(0,14):Rotated(i), npc):ToProjectile()
						p.FallingSpeed = 0
						p.FallingAccel = -0.066
						p.ProjectileFlags = p.ProjectileFlags | ProjectileFlags.NO_WALL_COLLIDE

						p:GetData().projType = "boomerang"

					end]]

				else
					mod:spritePlay(sprite, "ChargeStop")
				end
			end

		--Spewing state, set up to play the animation, with a couple potential attacks
		elseif d.state == "spew" then
			npc.Velocity = npc.Velocity * 0.9
			if sprite:IsFinished("Spew") then
				d.state = "idle"
				--Extra frames are so batty might not have to wait as long for her next attack. Currently unused.
				npc.StateFrame = 0 + d.extraframes
			elseif sprite:IsEventTriggered("TrackPos") then
				d.pos = target.Position
			elseif sprite:IsEventTriggered("Shoot") then
				--Blarrrrghhh, unused currently, a champion might use it eventually.
				if d.spewstate == "proj" then
					local params = ProjectileParams()
					npc:FireBossProjectiles(10, d.pos, 10, params)
				--Cough up some bats
				elseif d.spewstate == "bats" then
					npc:PlaySound(SoundEffect.SOUND_WHEEZY_COUGH,1,0,false,1.25)
					local targvel = (d.pos - npc.Position)
					local rand = r:RandomInt(3)
					-- Foamies
					if d.foamy then
						for i = -30, 30, 60 do
							local bat = mod.spawnent(npc, npc.Position + targvel:Resized(40):Rotated(i), targvel:Resized(10):Rotated(i), mod.FF.Foamy.ID, mod.FF.Foamy.Var, 0)
							bat:GetData().quickcharge = true
							bat.HitPoints = bat.HitPoints * 0.5
							bat.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS
						end
					--Fat bat
					elseif rand == 0 then
						local fatb = mod.spawnent(npc, npc.Position + targvel:Resized(40), targvel:Resized(10), 258)
						fatb.HitPoints = fatb.MaxHitPoints * 0.75
						--b.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
					--Two one tooths (One teeth?)
					elseif rand == 1 then
						for i = -30, 30, 60 do
							local bat = mod.spawnent(npc, npc.Position + targvel:Resized(40):Rotated(i), targvel:Resized(10):Rotated(i), 234, 0, 7000)
							bat.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS
						end
					--Milk Teeth!!! Babies!
					else
						for i = -30, 30, 30 do
							local bat = mod.spawnent(npc, npc.Position + targvel:Resized(40):Rotated(i), targvel:Resized(10):Rotated(i), mod.FF.MilkTooth.ID, mod.FF.MilkTooth.Var, 7000)
							bat.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS
						end

					end
				end
			else
				mod:spritePlay(sprite, "Spew")
			end

		--Her big fat slam attack!
		elseif d.state == "slam" then
			--Stops her velocity so she won't be affected by anything
			npc.Velocity = nilvector

			--Initialises the slam attack
			if d.slamstate == 1 then
				if sprite:IsFinished("FlyUp") then
					npc.StateFrame = 0
					d.slamstate = 2
					npc.Position = d.targetpos
					npc.Visible = false
				elseif sprite:GetFrame() == 20 then
					--Entcoll change ensures she won't get hit when high up in the air
					npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
					d.targetpos = target.Position
				else
					mod:spritePlay(sprite, "FlyUp")
				end

			--This is where she finally comes down and causes a big fat slam!
			elseif d.slamstate == 2 then
				if sprite:IsFinished("FlyDown") then
					d.state = "idle"
					--She'll likely spew or charge soon!
					npc.StateFrame = 50
				--Called in the animation when she finally hits the ground
				elseif sprite:IsEventTriggered("SlamJam") then
					--The player can hit her again
					npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_ALL

					--Some effects to make it look cool
					game:ShakeScreen(15)
					npc:PlaySound(SoundEffect.SOUND_HELLBOSS_GROUNDPOUND,0.6,2,false,1.7)

					--Crackwave
					if not d.foamy then
						local wave = Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.SHOCKWAVE, 0, npc.Position, nilvector, g):ToEffect()
						wave.Parent = npc
						wave.MaxRadius = 100
					end

					--Projectiles
					local params = ProjectileParams()
					params.TargetPosition = npc.Position
					local speedmulti = 1
					if d.foamy then
						speedmulti = 1.4
						params.Variant = ProjectileVariant.PROJECTILE_BONE
					end

					--Lots of normal tears
					if not d.purple then
						for i = 22.5, 360, 22.5 do
							npc:FireProjectiles(npc.Position, Vector(0,7 * speedmulti):Rotated(i), 0, params)
						end
					end

					-- champ: homing tears
					if d.purple then
						params.BulletFlags = params.BulletFlags | ProjectileFlags.SMART
						for i = 45, 360, 45 do
							npc:FireProjectiles(npc.Position, Vector(0,8 * speedmulti):Rotated(i), 0, params)
						end
					--A few curving tears
					else
						if d.foamy then
							params.Variant = 0
						end

						params.BulletFlags = params.BulletFlags | ProjectileFlags.BOOMERANG | ProjectileFlags.CURVE_LEFT
						for i = 45, 360, 45 do
							npc:FireProjectiles(npc.Position, Vector(0,10 * speedmulti):Rotated(i), 0, params)
						end
					end

					--[[for i = 45, 360, 45 do
						local p = Isaac.Spawn(9, 0, 0, npc.Position, Vector(0,14):Rotated(i), npc):ToProjectile()
						p.FallingSpeed = 0
						p.FallingAccel = -0.066

						p:GetData().projType = "boomerang"

					end]]
				else
					if npc.StateFrame > 10 then
						mod:spritePlay(sprite, "FlyDown")
						npc.Visible = true
					end
				end
			end
		end
	end
end


function mod.battieprojupdate(v, d)
	if d.purplebattie and v:IsDead() then
		local vel = Vector(-8, 0)
		for i = 0, 180, 180 do
			local projectile = Isaac.Spawn(9, 0, 0, v.Position + vel:Rotated(i), vel:Rotated(i), v):ToProjectile()
			projectile.FallingAccel = 0.7
		end
	end
end

function mod:blueHorfAI(npc, sprite, d)
	local room = game:GetRoom()
	local target = npc:GetPlayerTarget()
	local r = npc:GetDropRNG()

	if not d.init then
		d.state = "idle"
		npc.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_NONE
		d.init = true
	else
		npc.StateFrame = npc.StateFrame + 1
	end

	local targdistance = target.Position - npc.Position
	local targrel
	if d.dir then
		targrel = mod.peeplingdirs[d.dir[1]][1]
	else
		if math.abs(targdistance.X) > math.abs(targdistance.Y) then
			if targdistance.X < 0 then
				targrel = 3 -- Left
			else
				targrel = 1 -- Right
			end
		else
			if targdistance.Y < 0 then
				targrel = 0 -- Up
			else
				targrel = 2 -- Down
			end
		end
	end

	local rangeval = targdistance:Length()
	if rangeval > 150 then
		rangeval = 150
	elseif rangeval < 100 then
		rangeval = 100
	end

	local tpa = target.Position + Vector(0, rangeval):Rotated(targrel * 90)
	local targvel
	local dist = npc.Position:Distance(tpa)

	if dist > 70 then
		targvel = (tpa - npc.Position):Resized(7)
	else
		targvel = (tpa - npc.Position):Resized(dist / 10)
	end
	npc.Velocity = mod:Lerp(npc.Velocity, targvel, 0.2)

	if d.state == "idle" then
		mod:spritePlay(sprite, "Shake")
		if npc.StateFrame > 20 then
			d.state = "shoot"
		end
	elseif d.state == "shoot" then
		if sprite:IsFinished("Attack") then
			d.state = "idle"
			npc.StateFrame = 0
		elseif sprite:IsEventTriggered("Shoot") then
			local rand = r:RandomInt(4)
			if rand == 3 then
				npc:PlaySound(SoundEffect.SOUND_WHEEZY_COUGH,1,0,false,1)
				local vec = target.Position - npc.Position
				for i = -30, 30, 30 do
					mod.spawnent(npc, npc.Position + vec:Resized(10):Rotated(i), vec:Resized(10):Rotated(i), 13)
				end
				for i = -60, 60, 120 do
					mod.spawnent(npc, npc.Position + vec:Resized(10):Rotated(i), vec:Resized(10):Rotated(i), 18)
				end
			elseif rand == 2 then
				npc:PlaySound(SoundEffect.SOUND_SHAKEY_KID_ROAR,1,0,false,1)
				local params = ProjectileParams()
				params.Scale = 2
				params.HeightModifier = 5
				params.FallingAccelModifier = -0.1
				params.BulletFlags = params.BulletFlags | ProjectileFlags.RED_CREEP
				local vec1 = (target.Position - npc.Position):Normalized()
				npc:FireProjectiles(npc.Position + vec1*10, vec1*7, 0, params)
			elseif rand == 1 then
				npc:PlaySound(mod.Sounds.FlashShakeyKidRoar,1.5,2,false,1)
				local count = math.random(3,7)
				for i = 1, count do
					local fire = Isaac.Spawn(1000,7005, 20, npc.Position, Vector(5,0):Rotated(360/count * i - 25 + math.random(50)), npc):ToEffect()
					fire:GetData().timer = 350
					fire.Parent = npc
				end
			else
				game:ButterBeanFart(npc.Position, 250, npc, 1, 0)
				npc:PlaySound(SoundEffect.SOUND_FART,1,0,false,0.7)
				Isaac.GridSpawn(14, 2, npc.Position, true)
			end
		else
			mod:spritePlay(sprite, "Attack")
		end
	end

	if npc:IsDead() then
		room:SpawnGridEntity(room:GetGridIndex(npc.Position), GridEntityType.GRID_PIT, 0, 1, 0)
		mod:UpdatePits(0)
	end
end

function mod:dukeOfDemonsAI(npc, sprite, d)
	local room = game:GetRoom()
	local target = npc:GetPlayerTarget()
	local r = npc:GetDropRNG()

	if not d.init then
		d.state = "idle"
		d.init = true
	else
		npc.StateFrame = npc.StateFrame + 1
	end

	npc.SpriteOffset = Vector(0, -35)

	if d.state == "idle" then
		mod:spritePlay(sprite, "Fly")
		if sprite:GetFrame() == 3 then
			mod:diagonalMove(npc, 5.5)
		end
		npc.Velocity = npc.Velocity * 0.96
		if r:RandomInt(20)+1 == 1 and (target.Position - npc.Position):Length() < 200 and room:CheckLine(target.Position,npc.Position,3,900,false,false) then
			if mod.GetEntityCount(mod.FF.DukesDemon.ID, mod.FF.DukesDemon.Var) < 10 then
				if math.random(2) == 1 then
					d.state = "shootsmall"
				else
					d.state = "shootbig"
					d.playerPos = target.Position
				end
			else
				d.playerPos = target.Position
				d.state = "shootbig"
			end
		end
	elseif d.state == "shootsmall" then
		if sprite:IsFinished("Shoot") then
			d.state = "idle"
		elseif sprite:IsEventTriggered("Shoot") then
			for i = -30, 30, 30 do
				local demonbaby = Isaac.Spawn(mod.FF.DukesDemon.ID, mod.FF.DukesDemon.Var, 0, npc.Position, Vector(0,15):Rotated(i), npc):ToNPC()
				demonbaby.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS
				demonbaby:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
				demonbaby:Update()
			end
		else
			mod:spritePlay(sprite, "Shoot")
		end
	elseif d.state == "shootbig" then
		npc.Velocity = npc.Velocity * 0.9
		if sprite:IsFinished("ShootBig") then
			d.state = "idle"
		elseif sprite:IsEventTriggered("Shoot") then
			local laser = EntityLaser.ShootAngle(6, npc.Position, (d.playerPos - npc.Position):GetAngleDegrees(), 15, Vector(0, -70), npc)
			laser.EntityCollisionClass = EntityCollisionClass.ENTCOLL_ALL
			laser.DepthOffset = -500
			laser.MaxDistance = 0
			laser:Update()
		else
			mod:spritePlay(sprite, "ShootBig")
		end
	end
end
function mod:dukesDemonAI(npc, sprite, d)
	local room = game:GetRoom()
	local target = npc:GetPlayerTarget()
	local r = npc:GetDropRNG()

	if not d.init then
		d.state = "idle"
		d.init = true
	else
		npc.StateFrame = npc.StateFrame + 1
	end

	if d.state == "idle" then
		mod:spritePlay(sprite, "FloatDown")
		npc.Velocity = mod:Lerp(npc.Velocity, (target.Position - npc.Position):Resized(2), 0.1)
		if r:RandomInt(20)+1 == 1 and (target.Position - npc.Position):Length() < 200 and room:CheckLine(target.Position,npc.Position,3,900,false,false) then
			d.state = "shoot"
			local vec = (target.Position - npc.Position)
			if math.abs(vec.X) > math.abs(vec.Y) then
				d.vecx = "Side"
				if vec.X > 0 then
					sprite.FlipX = false
				else
					sprite.FlipX = true
				end
			else
				if vec.Y > 0 then
					d.vecx = "Down"
				else
					d.vecx = "Up"
				end
			end
			mod:spritePlay(sprite, "FloatShoot" .. d.vecx)
			npc:FireProjectiles(npc.Position, vec:Resized(7), 0, ProjectileParams())
			npc:PlaySound(SoundEffect.SOUND_SHAKEY_KID_ROAR,1,0,false,1.3)
		end
	elseif d.state == "shoot" then
		npc.Velocity = npc.Velocity * 0.9
		if sprite:IsFinished("FloatShoot" .. d.vecx) then
			d.state = "idle"
		else
			mod:spritePlay(sprite, "FloatShoot" .. d.vecx)
		end
	end
end

function mod:griddleRenderAI(npc)
	local sprite = npc:GetSprite()
	if sprite:IsPlaying("Death") and sprite:GetFrame() == 15 then
		npc:PlaySound(SoundEffect.SOUND_BOSS_LITE_GURGLE,0.7,0,false,1)
	elseif sprite:IsPlaying("Death") and sprite:GetFrame() == 36 then
		npc:PlaySound(mod.Sounds.GriddleDeath, 1.5, 0, false, 1)
	end
end

function mod:griddleHornAI(npc, sprite, d)
	local target = npc:GetPlayerTarget()
	local r = npc:GetDropRNG()

	--Used for determining the range at which griddlehorn runs from / runs towards during idle
	local maxdist = 200
	local closedist = 75

	--Initialises griddle's variables
	if not d.init then
		npc:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
		npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
		d.state = "appear"
		sprite:Play("Appear", true)
		--Table here shows how often griddle has performed certain attacks
		--During his idle, he'll check this to see the least used attacks.
		d.ad = {--Attacks done
		{"teleport", 0},--Tele
		{"lob", 0},		--Lob
		{"thanos", 0},	--Snap
		{"shoot", 0},	--Shoot
		{"shootmote", 0}--ShootMote
		}
		d.init = true

		local champSheet
		if mod.IsDeliriumRoom then
			champSheet = "gfx/bosses/griddlehorn/boss_griddlehorn_cummie.png"
		end
		if champSheet then
			for i = 1, 5 do
				sprite:ReplaceSpritesheet(i, champSheet)
			end
			sprite:LoadGraphics()
		end

	else
		--Update this variable each frame to act as a timer
		npc.StateFrame = npc.StateFrame + 1
	end

	--Intended for making sounds when he first spawns
	if npc.FrameCount == 3 then
		sfx:Play(mod.Sounds.FireLight, 0.3, 0, false, 1.3)
	elseif npc.FrameCount == 25 then
		sfx:Play(mod.Sounds.FireFizzle, 0.4, 0, false, 1.3)
	end

	--Changes whether Griddle can be damaged when entering / leaving his hole
	if sprite:IsEventTriggered("DMG") then
		npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_ALL
		d.unhurtable = false
	elseif sprite:IsEventTriggered("NoDMG") then
		npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE

	--Sounds synced up to his holes opening / closing
	elseif sprite:IsEventTriggered("HellOpens") then
		sfx:Play(mod.Sounds.FireLight, 0.4, 0, false, 1.3)
	elseif sprite:IsEventTriggered("HellCloses") then
		sfx:Play(mod.Sounds.FireFizzle, 0.4, 0, false, 1.3)
	end

	if d.state == "appear" then
		npc.Velocity = npc.Velocity * 0.75
		if sprite:IsFinished("Appear") then
			d.state = "idle"
			npc.StateFrame = 0
		elseif sprite:IsEventTriggered("Scream") then
			game:ShakeScreen(30)
			npc:PlaySound(mod.Sounds.GriddleScream, 1.5, 0, false, 1)
		else
			mod:spritePlay(sprite, "Appear")
		end


	--The idle movement state
	elseif d.state == "idle" then
		mod:spritePlay(sprite, "Idle")
		npc.Velocity = npc.Velocity * 0.9

		local distance = npc.Position:Distance(target.Position)

		local targetvelocity = npc.Velocity
		--If player is too close
		if distance < 75 then
			targetvelocity = (npc.Position - target.Position):Resized(10)
			--They might teleport, depends if they've done anything recently
			if r:RandomInt(math.max(5, math.ceil(20 - (npc.StateFrame * 0.05)))) == 0 then
				d.state = "teleport"
			end
		--If player is too far
		elseif distance > maxdist then
			--GET CLOSER!
			targetvelocity = (target.Position - npc.Position):Resized(10)
		else
		--Regular idle movement
			--Initialises the data
			d.gridtarget = d.gridtarget or mod:FindRandomFreePosAir(target.Position, 100, maxdist)
			--Ensures it changes place every now and then, also they might move in on the player
			if npc.StateFrame % 75 == 0 then
				d.gridtarget = mod:FindRandomFreePosAir(target.Position, 50, maxdist)
			end
			--Makes em find a new place if they get too close
			if npc.Position:Distance(d.gridtarget) < 30 then
				targetvelocity = nilvector
				d.gridtarget = nil
			else --Otherwise yeah just go to it man
				targetvelocity = (d.gridtarget - npc.Position):Resized(8)
			end
		end

		--The actual velocity
		npc.Velocity = mod:Lerp(npc.Velocity, targetvelocity, 0.05)

		--He wants to stick near you, don't go too far now!
		if distance > 280 then
			d.state = "teleport"
		end

		if npc.StateFrame > 25 then
			if r:RandomInt(10) == 0 then

				local attackchoice = mod.ChooseNextAttack(d.ad, r)

				--Ensures Griddle won't start running to the same position when attacks are complete.
				d.gridtarget = nil
				--Used for the lob attack, just makes sure they'll target a fresh new position
				d.lobthrow = nil
				--Ensures a base nil value for how many lobs he's done
				d.lobcount = 0
				--Finally changes the state to perform a new attack
				d.state = attackchoice
			end
		end

	--Teleporting state, collision / sounds are handled earlier in the code
	elseif d.state == "teleport" then
		--Keeps the boy still
		npc.Velocity = nilvector
		if sprite:IsFinished("Teleport") then
			d.state = "return"
			--Teleport to a new home
			npc.Position = mod:FindRandomFreePosAir(target.Position, 100, maxdist)
		elseif sprite:IsEventTriggered("HellCloses") then
		--elseif sprite:GetFrame() == 25 then
			--Spawns a few fires just to make it threatening
			for i = 1, 6 do
				local fire = Isaac.Spawn(1000,7005, 1, npc.Position, Vector(8,0):Rotated((360/6) * i), npc)
				fire:Update()
			end
		else
			mod:spritePlay(sprite, "Teleport")
		end
	--End of the teleport state, this is when they leave their hole.
	elseif d.state == "return" then
		--Makes sure the little bastard doesn't move
		npc.Velocity = nilvector
		if sprite:IsFinished("Return") then
			--Increases the tally of how many teleports have been performed.
			d.ad[1][2] = d.ad[1][2] + 1
			--I don't think this actually gets used much, d.targ will only stay set after a recent snap attack
			if d.targ then
				d.state = "lob"
			--If there's a fire nearby, get a mote out and set it alight, keeps the room busy.
			elseif mod.FindClosestFire(npc.Position,175) and mod.GetEntityCount(mod.FF.Mote.ID, mod.FF.Mote.Var) < 2 then
				d.state = "shootmote"
			--Otherwise just return to idle
			else
				d.state = "idle"
			end
			--Reset the timer
			npc.StateFrame = 0
		else
			mod:spritePlay(sprite, "Return")
		end

	--Snap attack, changes depending on gunpowder in the room
	elseif d.state == "thanos" then
		--STOP MOVING BOY
		npc.Velocity = nilvector
		if sprite:IsFinished("SnapFinger") then
			--When all's set and done, return to the idle state.
			d.state = "idle"
			--Increase the number of snaps performed
			d.ad[3][2] = d.ad[3][2] + 1
			--Reset the timer as per usual
			npc.StateFrame = 0
		elseif sprite:IsEventTriggered("Snap") then
			npc:PlaySound(mod.Sounds.fingersnap,2.5,0,false,1)

			--This checks the amount of gunpowder creep in the room
			local numgunpowders = mod.GetEntityCount(1000,26, 7001)
			--If there isn't much, Griddle will spawn a bunch around the player
			if numgunpowders < 5 then

				--Spawns a smoke effect to look nice
				local smoke = Isaac.Spawn(1000, EffectVariant.DARK_BALL_SMOKE_PARTICLE, 0, target.Position, nilvector, npc)
				smoke.SpriteScale = Vector(3.5,3.5)
				smoke.SpriteOffset = Vector(0, -50)
				smoke:Update()

				--Calls a function that handles gunpowder, gives it a long timeout / fire time
				mod.SpawnGunpowder(npc, target.Position, 500, 200)

				--Determines a vector to be used by the cross pattern
				local vec = Vector(0,25)
				--Randomly selects if it's diagonal or cardinal
				if r:RandomInt(2) == 0 then vec = vec:Rotated(45) end
				--A loop that rotates by 90 degrees until it reaches 360
				for i = 90, 360, 90 do
					--Used to multiply the vector for distances of 25, 50 and 75
					for k = 1, 3 do
						--Finally spawns the gunpowder, the spread radius is lower here to make the cross light in a cooler way
						mod.SpawnGunpowder(npc, target.Position + vec:Rotated(i) * k, 500, 200, 30)
					end
				end

				--This gets set but is otherwise currently unused outside of a rare teleport combo
				--Could be interesting to include in a lob combo
				if r:RandomInt(3) == 0 then
					d.targ = target.Position
				end

			--If there's plenty of gunpowder in the room, just set it all alight!
			else
				--BURN BABY BURN (this calls a custom function)
				mod:SetRoomAlight(npc)
				sfx:Play(mod.Sounds.FireLight, 0.3, 0, false, 1.2)
			end
		else
			mod:spritePlay(sprite, "SnapFinger")
		end

	--The name shoot is a bit misleading, this is Griddle's vomit attack, where a bunch of coal is launched up.
	elseif d.state == "shoot" then
		--Stops him from moving during the attack
		npc.Velocity = nilvector

		if sprite:IsFinished("Shoot") then
			--If attack is all set and done, this can lead into a couple combos
			local rand = r:RandomInt(3)
			--First involves the snap attack, he'll likely set the room alight
			if rand == 0 then
				d.state = "thanos"
			--Since his teleport leaves a bunch of fire around it, this'll set the surrounding fires alight
			elseif rand == 1 then
				d.state = "teleport"
			--Otherwise he might just return to his idle phase for fun
			else
				d.state = "idle"
			end
			--Increases the tally for how many times he's vomited, and resets the timer
			d.ad[4][2] = d.ad[4][2] + 1
			npc.StateFrame = 0
		elseif sprite:IsEventTriggered("Shoot") then
			npc:PlaySound(SoundEffect.SOUND_BOSS_LITE_GURGLE,0.7,0,false,1.9)
			--Ensures at least one coal is headed towards the player, not entirely random
			local vel = ((target.Position - npc.Position) / 30)
			--Make sure he's not launching them too far
			if vel:Length() > 13 then
				vel = vel:Resized(13)
			end
			--There will always be at least 3 shots fired, up to 5
			local numshots = r:RandomInt(3) + 3
			for i = 1, numshots do
				--Due to custom behaviour, we spawn a projectile manually rather than through default projectile firing code.
				local coal = Isaac.Spawn(9, 1, 0, npc.Position, vel:Rotated((360 / numshots)*i), npc):ToProjectile()
				coal.SpawnerEntity = npc

				--This lets us pass some values to be used in the projectile's update
				--Timeout and burntime are specific data values used by gunpowder
				local coald = coal:GetData()
				coald.projType = "coal"
				coald.timeout = 500
				coald.burntime = 200

				--This messes with more of the default values, it'll fall slightly randomly
				coal.FallingSpeed = -22 + r:RandomInt(5)
				coal.FallingAccel = 1.2

				--This updates the sprite to look nice and fancy
				local coals = coal:GetSprite()
				coals:Load("gfx/projectiles/sooty_tear.anm2",true)
				coals:Play("spin",true)

				--Then ensure the projectile runs through its code this frame so it's working right.
				coal:Update()
			end
		else
			mod:spritePlay(sprite, "Shoot")
		end

	--Burning coal throw attack
	elseif d.state == "lob" then
		--Initialisation for the attack
		if not d.lobthrow then

			--Returns a vector from the player to griddle, whilst also saving the player's position at the time
			local thingy = (target.Position - npc.Position)
			d.targ = target.Position

			--Unused code where they would initially target gunpowder. Wasn't too useful.
			--[[local gunpowder = mod.FindClosestEntity(npc.Position,200,1000,26,7001)
			if gunpowder then
				thingy = (gunpowder.Position - npc.Position)
				d.targ = gunpowder.Position
			else
				thingy = (target.Position - npc.Position)
				d.targ = target.Position
			end]]

			--The attacks are a bit specifically animated, with one being better at vertical, the other at horizontal throws.
			if math.abs(thingy.X) > math.abs(thingy.Y) then
				d.lobthrow = 1
			else
				d.lobthrow = 2
			end

			--Just checks which side of griddle the player is on, and if they should use their left or right hand.
			if target.Position.X > npc.Position.X then
				sprite.FlipX = true
			else
				sprite.FlipX = false
			end
		end

		--As usual, keep griddle still
		npc.Velocity = nilvector

		--This concatenates the string for where horn throws it.
		if sprite:IsFinished("ThrowCoal0" .. d.lobthrow) then
			--Resets the throwing state
			d.lobthrow = nil
			d.targ = nil
			npc.StateFrame = 0

			--Some code to determine if griddle is ready to stop throwing coal. Max is three throws.
			if d.lobcount > 2 or math.random(4 - d.lobcount) == 1 then
				--When he's ready to stop, he tallies a new lob, and goes back to a normal state.
				d.ad[2][2] = d.ad[2][2] + 1
				d.state = "idle"
				--Resets his lobcount for next time
				d.lobcount = 0
				--Unflips his sprite if it was.
				sprite.FlipX = false
			else
				--He threw another shot, keeps it going up
				d.lobcount = d.lobcount + 1
				--Due to lobthrow being nil, quickly changes it to idle and resets the animation used
				sprite:Play("Idle")
			end
		--A quick sound trigger
		elseif sprite:IsEventTriggered("Raise") then
			npc:PlaySound(SoundEffect.SOUND_SHELLGAME,0.7,0,false,1.1)
		elseif sprite:IsEventTriggered("Shoot") then
			--Makes the sounds slightly random.
			npc:PlaySound(SoundEffect["SOUND_LITTLE_HORN_GRUNT_" .. math.random(1,2)],1.2,0,false,math.random(80,90)/100)
			sfx:Play(SoundEffect.SOUND_SHELLGAME, 0.6, 0, false, 0.8)

			--Check the "shoot" state for a better explanation of this, it's mostly the same
			local vel = (d.targ - npc.Position):Resized(7)
			local coal = Isaac.Spawn(9, 1, 0, npc.Position, vel, npc):ToProjectile()
			coal.SpawnerEntity = npc
			--Lets us mess with the projectile manually
			local coald = coal:GetData()
			coald.projType = "coal2"
			--Some regular projectile settings
			coal.FallingSpeed = -25
			coal.FallingAccel = 1
			--Change it's sprite to be prettier
			local coals = coal:GetSprite()
			coals:Load("gfx/projectiles/sooty_tear2.anm2",true)
			coals:Play("spin",true)
			--Update the projectile this frame
			coal:Update()
		else
			mod:spritePlay(sprite, "ThrowCoal0" .. d.lobthrow)
		end

	--Mote shootin time!
	elseif d.state == "shootmote" then
		--You probably know the drill at this point
		npc.Velocity = nilvector
		if sprite:IsFinished("ShootMote") then
			--Reset the state when all's done
			d.state = "idle"
			d.ad[5][2] = d.ad[5][2] + 1
			npc.StateFrame = 0
		elseif sprite:IsEventTriggered("Shoot") then
			npc:PlaySound(SoundEffect.SOUND_WHEEZY_COUGH,1,0,false,1.25)

			--Initialises the variable
			local dist
			--Checks if there's a fire nearby that the mote can be put through
			local fire = mod.FindClosestFire(npc.Position, 200)

			--If there IS a fire, shoot that mote right at it
			if fire then
				dist = (fire.Position - npc.Position):Resized(4)
			--Otherwise go for the player
			else
				dist = (target.Position - npc.Position):Resized(4)
			end

			--Spawns the ball
			local bol = mod.spawnent(npc, npc.Position + dist, dist, mod.FF.Mote.ID, mod.FF.Mote.Var)
			bol:Update()

			--A nice effect to look nice alongside the spawn
			local smoke = Isaac.Spawn(1000, EffectVariant.DARK_BALL_SMOKE_PARTICLE, 0, npc.Position, nilvector, npc)
			smoke.SpriteScale = Vector(3,3)
			smoke.SpriteOffset = Vector(0, -25)
			smoke:Update()
		else
			mod:spritePlay(sprite, "ShootMote")
		end
	end
end


function mod:goldMedallionUpdate(pickup)
	local sprite = pickup:GetSprite()
	if sprite:IsFinished("Appear") or sprite:IsFinished("AppearAlt") then
		sprite:Play("Idle", true)
		pickup.EntityCollisionClass = EntityCollisionClass.ENTCOLL_ALL
	end
	if sprite:GetAnimation() == "Collect" and sprite:GetFrame() >= 5 and not mod.IsPlayingAchievementNote() then
		game:End(3)
		pickup:Remove()
	end
	if sprite:IsEventTriggered("DropSound") then
		sfx:Play(mod.Sounds.LandSoft, 1, 0, false, 1)
		if sprite:IsPlaying("AppearAlt") then
			sfx:Play(mod.Sounds.Tada,1,0,false,1.25)
		end
	elseif sprite:IsEventTriggered("Tada") then
		sfx:Play(mod.Sounds.Tada,1,0,false,1.25)
	end
end
mod:AddCallback(ModCallbacks.MC_POST_PICKUP_UPDATE, mod.goldMedallionUpdate, 960)

function mod:trophyToMedallion(pickup)
	if Isaac.GetChallenge() == mod.challenges.dadsHomePlus then
		pickup:Morph(5, 960, 0, true)
		pickup:GetSprite():Play("AppearAlt", true)
	end
end
mod:AddCallback(ModCallbacks.MC_POST_PICKUP_INIT, mod.trophyToMedallion, 370)

mod:AddCallback(ModCallbacks.MC_PRE_PICKUP_COLLISION, function(_, pickup, collider)
	if collider.Type == 1 then
		collider = collider:ToPlayer()
		if pickup:GetSprite():WasEventTriggered("DropSound") or pickup:GetSprite():IsPlaying("Idle") then
			pickup:GetSprite():Play("Collect")
			sfx:Play(mod.Sounds.Tada, 1, 0, false, 0.75)
			collider:AnimateHappy()
			--Isaac.ExecuteCommand("cutscene 2")
			--game:Fadeout(20, 0)
		end
		return true
	else
		return true
	end
end, 960)

--Kingpin

--[[ patterns

chase:
- dig and jump toward the player exactly like weaver
- only one head can do this at a time

dash:
- pick a random direction from the player, choose a far grid in that direction, perform 1-2 jumps from there in the opposite direction (do not change direction if not necessary)

flank:
- pick a random direction from the player, choose a close grid in that direction, perform 1 jump from there in the opposite direction

if no heads are chasing, chase
otherwise, if over 50% of heads are flanking, pick dash, and if over 50% of heads are dashing, pick flank. else pick 50/50

]]

local kingpinSpacing = 6

function mod:kingpinAI(npc, sprite, d)
	local room = game:GetRoom()
	local target = npc:GetPlayerTarget()
	if target.Type == mod.FF.Kingpin.ID and target.Variant == mod.FF.Kingpin.Var and mod:isInSegmentsOf(target, npc) then
		target = Isaac.GetPlayer(0)
	end

	if not d.init then
		d.init = true
		npc:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
		d.dir = "Hori"
		npc.StateFrame = -10
		d.state = "underground"
		d.velVec = math.random(50)
		d.lerpVal = (math.random(10) / 100) + 0.05
		if not npc.Parent then
			local segCount = 19
			local subt = npc.SubType
			if subt > 1 then
				segCount = subt - 1
			end

			for i = 1, segCount do
				local seg = Isaac.Spawn(mod.FF.Kingpin.ID, mod.FF.Kingpin.Var, 0, npc.Position, nilvector, npc):ToNPC()
				if d.prevSeg then
					seg.Parent = d.prevSeg
					d.prevSeg.Child = seg
				else
					seg.Parent = npc
					npc.Child = seg
				end
				d.prevSeg = seg
				seg:Update()
			end
		end
		local champSheet
		if mod.IsDeliriumRoom then
			champSheet = "gfx/bosses/kingpin/kingpin_cummie.png"
		end
		if champSheet then
			   sprite:ReplaceSpritesheet(0, champSheet)
			sprite:LoadGraphics()
		end
	end

	if math.abs(npc.Velocity.X) > math.abs(npc.Velocity.Y) then
		d.dir = "Hori"
		if npc.Velocity.X > 0 then
			sprite.FlipX = false
		else
			sprite.FlipX = true
		end
	else
		if npc.Velocity.Y < 0 then
			d.dir = "Down"
		else
			d.dir = "Up"
		end
	end

	local isMinLength = true
	if npc.Parent and npc.Parent.Parent and npc.Parent.Parent.Parent then -- it takes less space than a loop!
		isMinLength = false
	elseif npc.Child and npc.Child.Child and npc.Child.Child.Child then
		isMinLength = false
	end

	if not npc.Parent then
		if not npc.Child then
			if not npc:IsDead() then
				d.dyingToLackOfFriends = true
				npc:Kill()
			end
		end

		if not d.calcdChildren then
			d.childcount = 1
			d.lastEnt = npc
			local finished = false
			repeat
				if d.lastEnt.Child then
					d.lastEnt = d.lastEnt.Child
					d.childcount = d.childcount + 1
				end
			until(not d.lastEnt.Child)
			d.calcdChildren = true
		end

		if not d.headinit then
			npc.MaxHitPoints = npc.MaxHitPoints * 2
			npc.HitPoints = npc.HitPoints * 2
			d.headinit = true
		end

		if d.jumped then
			d.jumps = d.jumps - 1
			d.jumpvel = npc.Velocity
			if d.jumps <= 0 then
				d.jumps = nil
				d.movestate = nil
			end

			d.jumped = nil
		end

		if not d.movestate then
			local kingpins = Isaac.FindByType(mod.FF.Kingpin.ID, mod.FF.Kingpin.Var, -1, false, false)
			local headCount, chasing, dashing, flanking = 0, 0, 0, 0
			for _, kp in ipairs(kingpins) do
				if not kp.Parent and kp.Child then
					headCount = headCount + 1
					local movestate = kp:GetData().movestate
					if movestate == "chase" then
						chasing = chasing + 1
					elseif movestate == "dash" then
						dashing = dashing + 1
					elseif movestate == "flank" then
						flanking = flanking + 1
					end
				end
			end

			local pickState
			if isMinLength and headCount <= 3 then
				pickState = "chase"
			elseif headCount == 1 then
				local pick = math.random(1, 4)
				if pick <= 2 then
					pickState = "chase"
				elseif pick == 3 then
					pickState = "flank"
				else
					pickState = "dash"
				end
			elseif chasing == 0 then
				pickState = "chase"
			else
				if dashing > headCount / 2 then
					pickState = "flank"
				elseif flanking > headCount / 2 then
					pickState = "dash"
				elseif math.random(1, 2) == 1 then
					pickState = "flank"
				else
					pickState = "dash"
				end
			end

			d.movestate = pickState
			if pickState == "chase" then
				if math.random(1, 3) == 1 then
					d.crawltime = math.random(45, 85) + math.ceil(d.childcount * 1.5)
				else
					d.jumps = 1
				end
			elseif pickState == "flank" then
				d.jumps = 1
			elseif pickState == "dash" then
				d.jumps = math.random(1, 2)
			end

			if pickState == "flank" or pickState == "dash" then
				local fromGrids = {}
				local directions = {}
				for i = 0, room:GetGridSize() do
					local pos = room:GetGridPosition(i)
					if room:IsPositionInRoom(pos, 0) and not room:GetGridEntity(i) then
						local toTarget = target.Position - pos
						local dist = toTarget:LengthSquared()
						local isFar = dist > 160 ^ 2
						if dist < (320 ^ 2) and isFar == (d.movestate == "dash") then
							local direction = toTarget:GetAngleDegrees()
							direction = math.abs(math.floor(direction / 45))
							if not fromGrids[direction] then
								directions[#directions + 1] = direction
								fromGrids[direction] = {}
							end

							fromGrids[direction][#fromGrids[direction] + 1] = pos
						end
					end
				end

				if #directions > 0 then
					local pickFrom = fromGrids[directions[math.random(1, #directions)]]
					local pickFromWeighted = {}
					local sum = 0
					for _, pos in ipairs(pickFrom) do
						local weight = 99999999 - math.floor(pos:DistanceSquared(npc.Position))
						sum = sum + weight
						pickFromWeighted[#pickFromWeighted + 1] = {pos, weight}
					end

					local rand = math.random(0, sum)
					local targPos
					for _, pick in ipairs(pickFromWeighted) do
						if rand <= pick[2] then
							targPos = pick[1]
							break
						else
							rand = rand - pick[2]
						end
					end

					d.digto = targPos
				else
					d.movestate = nil
				end
			end
		end

		npc.StateFrame = npc.StateFrame + 1
		local targvel
		local speed = 5.5
		extraspeed = math.max(10 - d.childcount, 0) / 5
		speed = speed + extraspeed

		if d.state == "crawl" then
			local targvel = (target.Position - npc.Position):Resized(speed)
			npc.Velocity = mod:Lerp(npc.Velocity, targvel, 0.07):Rotated(math.sin((npc.InitSeed + npc.FrameCount) / 7) * 8)
		elseif d.state == "surface" and d.jumpvel and room:GetGridCollisionAtPos(npc.Position) == GridCollisionClass.COLLISION_NONE then
			targvel = d.jumpvel:Resized(speed)
		elseif d.digto then
			local direction = (d.digto - npc.Position)
			local dist = direction:Length()
			dist = math.max(dist, 1)
			targvel = (direction / dist) * speed

			if dist <= 60 then
				if d.movestate == "dash" then
					d.dashdirection = target.Position - npc.Position
					npc.Velocity = d.dashdirection:Resized(speed)
				end

				d.digto = nil
				npc.StateFrame = 0
			end
		else
			if d.movestate == "dash" and not room:IsPositionInRoom(npc.Position, 20) then
				d.dashdirection = target.Position - npc.Position
			end

			if d.movestate ~= "dash" or d.state == "surface" then
				targvel = ((target.Position + target.Velocity:Resized(d.velVec)) - npc.Position):Resized(speed)
			else
				targvel = d.dashdirection:Resized(speed)
			end
		end

		--[[
		if not d.target then
			targvel = ((target.Position + target.Velocity:Resized(d.velVec)) - npc.Position):Resized(speed)
		else
			targvel = (d.target - npc.Position):Resized(speed)
			if npc.Position:Distance(d.target) < 20 then
				d.target = mod:FindRandomFreePosAirNoGrids(npc.Position, 120)
			end
		end]]

		if d.state ~= "crawl" then
			npc.Velocity = mod:Lerp(npc.Velocity, targvel, 0.15	)
		end
		if not (sprite:IsPlaying("AttackHori") or sprite:IsPlaying("AttackUp") or sprite:IsPlaying("AttackDown")) then
			mod:spritePlay(sprite, "Head" .. d.dir)
		end
	else
		local pd = npc.Parent:GetData()
		if npc.Child then
			if npc.Parent.Parent then
				mod:spritePlay(sprite, "Body")
			else
				mod:spritePlay(sprite, "Hands" .. d.dir)
			end
		else
			mod:spritePlay(sprite, "Butt" .. d.dir)
		end

		if pd.prevpositions and  #pd.prevpositions > kingpinSpacing then
			npc.StateFrame = pd.prevpositions[kingpinSpacing].stateframe
			d.state = pd.prevpositions[kingpinSpacing].state
			d.digto = pd.prevpositions[kingpinSpacing].digto
			d.crawltime = pd.prevpositions[kingpinSpacing].crawltime
			npc.Velocity = pd.prevpositions[kingpinSpacing].velocity
			npc.Position = pd.prevpositions[kingpinSpacing].pos
		end
	end

	local curvar = 1.9
	local curframe = 23

	if d.state == "underground" then
		npc.Visible = false
		npc.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_WALLS
		npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE

		--[[
		if not d.settled then
			local rand = math.random(2)
			if rand == 1 then
				d.target = nil
			else
				d.target = mod:FindRandomFreePosAirNoGrids(npc.Position, 120)
			end
			d.settled = true
		end]]

		if not npc.Parent then
			if npc.FrameCount % 4 == 1 then
				local pile = Isaac.Spawn(1000, 146, 0, npc.Position, nilvector, npc):ToEffect()
				local s = pile:GetSprite()
				s:Load("gfx/bosses/kingpin/dirtpile_big.anm2", true)
				pile:GetData().KingpinPile = true
				--pile:GetSprite().Rotation = -10 + math.random(20)
				pile:GetData().Timeout = kingpinSpacing * (d.childcount - 2)
				--pile:Update()
			end
		end

		if npc.StateFrame > 20 and not d.digto then
			if room:GetGridCollisionAtPos(npc.Position) == GridCollisionClass.COLLISION_NONE then
				if d.jumps then
					d.jumpvel = npc.Velocity
					d.jumped = true
				end

				npc:PlaySound(SoundEffect.SOUND_MAGGOT_BURST_OUT,0.3,0,false,0.8 + math.random(3)/10)

				if d.crawltime then
					d.state = "crawl"
				else
					d.state = "surface"
				end

				npc.StateFrame = 0
			end
		end
	elseif d.state == "surface" then
		-- d.settled = false
		npc.Visible = true
		npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS

		local curve = 0 - math.sin(0.2 * npc.StateFrame / curvar) * 35
		local coll = room:GetGridCollisionAtPos(npc.Position)
		if npc.StateFrame > curframe and (coll ~= GridCollisionClass.COLLISION_NONE and coll ~= GridCollisionClass.COLLISION_PIT) then
			npc.StateFrame = curframe
			d.target = nil
		end

		d.spriteoffsettarget = Vector(0, curve)
		if npc.StateFrame > 1 then
			d.interpolationframe = true
		else
			npc.SpriteOffset = d.spriteoffsettarget
		end

		if npc.StateFrame > curframe + 2 then
			npc:PlaySound(SoundEffect.SOUND_MAGGOT_ENTER_GROUND,0.3,0,false,0.8 + math.random(3)/10)
			d.state = "underground"
			npc.StateFrame = 0
		end
	elseif d.state == "crawl" then
		npc.Visible = true
		npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS

		local coll = room:GetGridCollisionAtPos(npc.Position)
		if (coll ~= GridCollisionClass.COLLISION_NONE and coll ~= GridCollisionClass.COLLISION_PIT) then
			d.spriteoffsettarget = Vector(0, -10)
		else
			d.spriteoffsettarget = nilvector
		end

		if npc.StateFrame > 1 then
			d.interpolationframe = true
		else
			npc.SpriteOffset = d.spriteoffsettarget
		end

		if not npc.Parent then
			--[[
			if npc.FrameCount % 10 == 1 then
				local params = ProjectileParams()
				params.Variant = 3
				params.HeightModifier = 15
				params.FallingAccelModifier = -0.11
				params.Acceleration = -0.1
				--params.Scale = 0.7
				npc:FireProjectiles(npc.Position, (-npc.Velocity):Resized(5), 0, params)
			end]]

			if npc.FrameCount % 20 == 1 then
				mod:spritePlay(sprite, "Attack" .. d.dir)
				npc:PlaySound(SoundEffect.SOUND_BLOODSHOOT,1,2,false,1)
				local params = ProjectileParams()
				--params.Variant = 3
				params.HeightModifier = 15
				params.FallingAccelModifier = -0.11
				--params.Acceleration = -0.1
				--params.Scale = 0.7
				local toPlayer = (target.Position - npc.Position):Normalized()
				npc:FireProjectiles(npc.Position + toPlayer * 20, toPlayer * 8, 0, params)
			end
		end

		if npc.StateFrame > d.crawltime then
			npc:PlaySound(SoundEffect.SOUND_MAGGOT_ENTER_GROUND,0.3,0,false,0.8 + math.random(3)/10)
			d.state = "underground"
			npc.StateFrame = 0
			d.crawltime = nil
			d.movestate = nil
		end
	end

	if npc:IsDead() then
		if not d.dyingToLackOfFriends then
			local off = math.random() * 360
			for i = 0, 360, 120 do
				local params = ProjectileParams()
				params.HeightModifier = 15
				params.FallingAccelModifier = -0.11
				--params.Scale = 0.7
				npc:FireProjectiles(npc.Position, Vector.FromAngle(i + off) * 7.75, 0, params)
			end
		end

		if not isMinLength and not d.headinit then
			npc:GetLastParent():GetData().calcdChildren = false
			Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.LARGE_BLOOD_EXPLOSION, 0, npc.Position, Vector(0, 0), npc)
		end
	end

	d.prevpositions = d.prevpositions or {}
	table.insert(d.prevpositions, 1, {
		state = d.state,
		digto = d.digto,
		crawltime = d.crawltime,
		pos = npc.Position,
		offset = npc.SpriteOffset.Y,
		stateframe = npc.StateFrame,
		velocity = npc.Velocity
	})
	if #d.prevpositions > 10 then
		table.remove(d.prevpositions, #d.prevpositions)
	end
end

function mod:kingpinRender(npc)
	if npc.Variant == 80 then
		local d = npc:GetData()
		if d.spriteoffsettarget then
			if d.interpolationframe then
				npc.SpriteOffset = mod:Lerp(npc.SpriteOffset, d.spriteoffsettarget, 0.5)
				d.interpolationframe = nil
			else
				npc.SpriteOffset = d.spriteoffsettarget
			end
		end
	end
end

--Commenting for my good friend budjy poo
function mod:calcPeepDir(vec)
--Rotates by 90 to get it so it matches peeping facing down, then by another 20 degrees so the cones are centred
vec = vec:Rotated(-110)
--Multiplies by -1 so it goes counter clockwise like the animation
local vecA = vec:GetAngleDegrees() * -1
--Divides the circle into 9 sectors
local ang = math.floor((vecA / 40 % 9))
return ang
end

function mod:calcPeepeeDir(vec)
vec = vec:Rotated(-112.5)
local vecA = vec:GetAngleDegrees() * -1
local ang = math.floor((vecA / 45 % 8))
return ang
end

--Peeping
function mod:peepingAI(npc, sprite, d)
	local room = game:GetRoom()
	local target = npc:GetPlayerTarget()
	local r = npc:GetDropRNG()

	if not d.init then
		d.init = true
		npc:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
		npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
		d.state = "appear"
		sprite:Play("Appear", true)
		d.ad = {--Attacks done
		{"hemo", 0},--Big Fuck You Haemolacria
		{"likeFatherLikeSon", 0},--Peepling
		{"BWOOOOM", 2},--Brimstone Sweep
		}
	else
		npc.StateFrame = npc.StateFrame + 1
	end

	if npc.HitPoints < 100 then
		d.state = "PullTheLeverKronk"
		npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
		if d.hemoCheck then
			local hemo = Isaac.Spawn(mod.FF.MegaHemo.ID, mod.FF.MegaHemo.Var, 0, npc.Position, nilvector, npc):ToNPC();
			hemo:GetData().vec = nilvector
			hemo.SpriteOffset = Vector(0,-60)
			hemo:Update()
			d.hemoCheck = false
		end
		if d.Brimmy then
			d.Brimmy:Remove()
		end
	end

	if d.state == "appear" then
		if sprite:IsFinished("Appear") then
			d.state = "idle"
			npc.StateFrame = 0
		elseif sprite:IsEventTriggered("Scream") then
			game:ShakeScreen(30)
			npc:PlaySound(mod.Sounds.MonsterYellFlash,1.5,0,false,0.9)
		elseif sprite:IsEventTriggered("Blink") then
			npc:PlaySound(SoundEffect.SOUND_MEAT_JUMPS,0.7,0,false,0.9)
		elseif sprite:IsEventTriggered("SquishBlink") then
			npc:PlaySound(SoundEffect.SOUND_SKIN_PULL,0.4,0,false,1.6)
		elseif sprite:IsEventTriggered("PopSFX") then
			sfx:Stop(mod.Sounds.StretchEye)
			npc:PlaySound(SoundEffect.SOUND_PLOP,1,0,false,0.8)
			npc:BloodExplode()
		elseif sprite:IsEventTriggered("Grow") then
			npc:PlaySound(mod.Sounds.StretchEye,0.3,0,false,1)
		elseif sprite:IsEventTriggered("Slam") then
			npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_ALL
			npc:PlaySound(SoundEffect.SOUND_FORESTBOSS_STOMPS,0.5,0,false,1)
			game:ShakeScreen(15)
		else
			mod:spritePlay(sprite, "Appear")
		end
	elseif d.state == "idle" then
		mod:spritePlay(sprite, "Walk")
		if npc.StateFrame > 5 then
			d.substate = nil
			if npc.HitPoints < 350 and not d.plantedPeepee then
				if mod.GetEntityCount(mod.FF.Peepstalk.ID, mod.FF.Peepstalk.Var,0) > 0 then
					d.state = "peepeePlant"
				end
				d.plantedPeepee = 1
			else
				d.successfullBrimDid = false
				d.state = mod.ChooseNextAttack(d.ad, r)
			end
		end
	elseif d.state == "PullTheLeverKronk" then
	--Time for you to die!
		npc.Velocity = npc.Velocity * 0.7
		if sprite:IsFinished("Phase2Start") or sprite:IsEventTriggered("Explode") then
			npc:Kill()
		elseif sprite:IsEventTriggered("BloodStart") then
			local eye = Isaac.Spawn(mod.FF.Peeping2.ID, mod.FF.Peeping2.Var, 0, mod:Lerp(npc.Position, target.Position, 0.66), nilvector, npc)
			eye.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
			eye:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
			eye:Update()
			d.spawnedPhase2 = true
		elseif sprite:IsEventTriggered("SuckIn") then
			npc:PlaySound(mod.Sounds.StretchEye,1,0,false,1)
		elseif sprite:IsEventTriggered("Grow") then
			sfx:Stop(mod.Sounds.StretchEye)
			npc:PlaySound(mod.Sounds.WhipCrack,0.7	,0,false,1)
			npc:BloodExplode()
			for index,entity in ipairs(Isaac.FindByType(mod.FF.Peepstalk.ID, mod.FF.Peepstalk.Var, 2, EntityPartition.ENEMY, true)) do
				entity:GetData().state = "collapse"
			end
		elseif sprite:IsEventTriggered("Slam") then
			npc:PlaySound(SoundEffect.SOUND_MEAT_IMPACTS, 1, 0, false, 1);
		else
			mod:spritePlay(sprite, "Phase2Start")
		end
	elseif d.state == "peepeePlant" then
		npc.Velocity = npc.Velocity * 0.7
		d.substate = d.substate or "tearItUp"
		if d.substate == "tearItUp" then
			if sprite:IsFinished("PillarSummon2Spit") then
				d.substate = "shootDude"
			elseif sprite:IsEventTriggered("Spawn") then
				--[[local safestBets = {}
				local backupOptions = {}]]
				d.targetPeepstalks = {}
				for index,entity in ipairs(Isaac.FindByType(mod.FF.Peepstalk.ID, mod.FF.Peepstalk.Var, 0, EntityPartition.ENEMY, true)) do
					--[[if mod.farFromAllPlayers(entity.Position, 100) then
						table.insert(safestBets, entity)
					else
						table.insert(backupOptions, entity)
					end]]
					entity.SubType = 1
					table.insert(d.targetPeepstalks, entity)
				end

				--[[local rand = 1
				if #safestBets > 0 then
					if #safestBets > 1 then
						rand = math.random(#safestBets)
					end
					safestBets[rand].SubType = 1
					d.targetPeepstalk = safestBets[rand]
				elseif #backupOptions > 0 then
					if #backupOptions > 1 then
						rand = math.random(#backupOptions)
					end
					backupOptions[rand].SubType = 1
					d.targetPeepstalk = backupOptions[rand]
				else
					local pos = Isaac.GetFreeNearPosition(Isaac.GetRandomPosition(), 40)
					local peepee = Isaac.Spawn(980, 92, 1, pos, nilvector, npc)
					peepee:Update()
					d.targetPeepstalk = peepee
				end]]


			--Sound and visual flair
			elseif sprite:IsEventTriggered("Rip") then
				npc:PlaySound(SoundEffect.SOUND_MAGGOT_ENTER_GROUND,0.5,0,false,1)
			elseif sprite:IsEventTriggered("Swishy") then
				npc:PlaySound(SoundEffect.SOUND_FETUS_JUMP,0.5,0,false,1)
			elseif sprite:IsEventTriggered("Slam") then
				npc:PlaySound(SoundEffect.SOUND_MAGGOT_BURST_OUT,0.5,0,false,1)
				game:ShakeScreen(15)
			else
				mod:spritePlay(sprite, "PillarSummon2Spit")
			end
		elseif d.substate == "shootDude" then
			if sprite:IsFinished("SpitPeepee02") then
				d.state = "idle"
			elseif sprite:IsEventTriggered("SuckIn") then
				npc:PlaySound(SoundEffect.SOUND_FRAIL_CHARGE,0.5,0,false,1)
			elseif sprite:IsEventTriggered("Shoot") then
				--This is the important bit yo
				for i = 1, #d.targetPeepstalks do
					local vec = (d.targetPeepstalks[i].Position - npc.Position)
					local peepee = Isaac.Spawn(mod.FF.Peepee.ID, mod.FF.Peepee.Var, 1, npc.Position, vec:Resized(3), npc)
					local peed = peepee:GetData()
					peed.startPos = npc.Position
					peed.endGoal = d.targetPeepstalks[i].Position
					peed.target = d.targetPeepstalks[i]
					peepee:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
					peepee.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
					peepee.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_NONE
					peepee.SpriteOffset = Vector(0, -50)
					peepee:Update()
				end
				--Flair
				npc:PlaySound(mod.Sounds.WateryBarf,1.5,0,false,1)
				game:ShakeScreen(15)
			else
				mod:spritePlay(sprite, "SpitPeepee02")
			end
		end
	elseif d.state == "hemo" then
		d.substate = d.substate or "prepareTheBeast"
		if d.substate == "prepareTheBeast" then
			mod:diagonalMove(npc, 2.5)
			if sprite:IsFinished("Hemolacria") then
				d.substate = "holdItRightThere"
				npc.StateFrame = 0
			elseif sprite:IsEventTriggered("Grow") then
				npc:PlaySound(mod.Sounds.BaloonShort, 1.5, 0, false, 1.5);

				--[[ old
				for index,entity in ipairs(Isaac.FindByType(980, 92, 2, EntityPartition.ENEMY, true)) do
					local ed = entity:GetData()
					if ed.state == "idle" then
						ed.state = "shoot"
						ed.playerpos = target.Position + target.Velocity * 5
						ed.vecang = mod:calcPeepeeDir(target.Position - entity.Position) + 1
						ed.wait = math.random(1,15)
						entity:Update()
					end
				end]]
			elseif sprite:IsEventTriggered("HemolacriaStart") then
				local corners = {}
				for i = 0, 360, 90 do
					corners[#corners + 1] = target.Position + Vector(120, 0):Rotated(i + 45)
				end

				local peepees = Isaac.FindByType(mod.FF.Peepstalk.ID, mod.FF.Peepstalk.Var, 2, EntityPartition.ENEMY, true)
				local pospairs = mod:PairEntitiesToPositions(peepees, corners)
				for ind, entpair in ipairs(pospairs) do
					local ent = entpair.ent
					local pos = corners[entpair.posind]
					local ed = ent:GetData()
					if ed.state == "idle" then
						ed.state = "shoot"
						ed.shoottarget = pos
						ed.vecang = mod:calcPeepeeDir(ed.shoottarget - ent.Position) + 1
						ed.wait = 0
						ent:Update()
					end
				end

				d.hemoCheck = true
			else
				mod:spritePlay(sprite, "Hemolacria")
			end
		elseif d.substate == "holdItRightThere" then
			mod:diagonalMove(npc, 2.5)
			mod:spritePlay(sprite, "HemolacriaLoop")
			if npc.StateFrame > 0 then
				d.recordedPos = target.Position + target.Velocity * 10
				d.substate = "shootboi"
				d.animNum = mod:calcPeepDir(target.Position - npc.Position) + 1
			end
		elseif d.substate == "shootboi" then
			npc.Velocity = npc.Velocity * 0.7
			if sprite:IsFinished("HemolacriaShoot0" .. d.animNum) then
				d.ad[1][2] = d.ad[1][2] + 0.5
				--[[if math.random(2) == 1 then
					d.substate = nil
				else]]
					d.state = "idle"
					npc.StateFrame = 0
				--end
			elseif sprite:IsEventTriggered("Shoot") then
				d.hemoCheck = false
				npc:PlaySound(SoundEffect.SOUND_BOSS2_BUBBLES,1,0,false,math.random(70,90)/100)
				local vec = ((d.recordedPos - npc.Position)*0.04)
				--local vec = (d.recordedPos - npc.Position):Resized(9)
				local hemo = Isaac.Spawn(mod.FF.MegaHemo.ID, mod.FF.MegaHemo.Var, 0, npc.Position, vec, npc):ToNPC();
				hemo:GetData().vec = vec
				hemo.SpriteOffset = Vector(0,-60)
				hemo:Update()
			else
				mod:spritePlay(sprite, "HemolacriaShoot0" .. d.animNum)
			end
		end
	elseif d.state == "likeFatherLikeSon" then
		--Movement
		local vec = (target.Position - npc.Position):Rotated(135)
		local vecA = vec:GetAngleDegrees()
		local targrel = math.floor((vecA / 90 % 4))

		local rangeval = vec:Length()
		if rangeval > 250 then
			rangeval = 250
		elseif rangeval < 150 then
			rangeval = 150
		end

		local tpa = target.Position + Vector(0, rangeval):Rotated(targrel * 90)
		local targvel
		local dist = npc.Position:Distance(tpa)

		if dist > 70 then
			targvel = (tpa - npc.Position):Resized(7)
		else
			targvel = (tpa - npc.Position):Resized(dist / 10)
		end
		npc.Velocity = mod:Lerp(npc.Velocity, targvel, 0.2)

		if not d.substate then
			d.substate = "prepareShoot"
			d.rotVal = 0
			d.orderVal = {0, 2}
			d.tears = {}
			sprite:Play("PeeplingAttack", true)
		end
		if d.substate == "prepareShoot" then
			--Attack Handling
			if sprite:IsFinished("PeeplingAttack") then
				d.substate = "SHOOT SON"
				local vec = (target.Position - npc.Position):Rotated(-135)
				local vecA = vec:GetAngleDegrees() * -1
				local ang = math.floor((vecA / 90 % 4))
				d.shootAng = ang + 1
			elseif sprite:IsPlaying("PeeplingAttack") and sprite:GetFrame() == 2 then
				--[[ old
				for index,entity in ipairs(Isaac.FindByType(980, 92, 2, EntityPartition.ENEMY, true)) do
					local ed = entity:GetData()
					if ed.state == "idle" then
						ed.state = "shoot"
						ed.playerpos = target.Position + target.Velocity * 5
						ed.vecang = mod:calcPeepeeDir(target.Position - entity.Position) + 1
						ed.wait = math.random(1,20)
						entity:Update()
					end
				end ]]
			elseif sprite:IsEventTriggered("Shoot") then
				npc:PlaySound(SoundEffect.SOUND_BLOODSHOOT,1,0,false,0.9)
				local vel = Vector(0, 10):Rotated(d.rotVal)
				local p = Isaac.Spawn(9, 0, 0, npc.Position, vel, npc):ToProjectile()
				p.FallingSpeed = 0
				p.FallingAccel = -0.1
				p.Parent = npc
				p.ProjectileFlags = p.ProjectileFlags | ProjectileFlags.GHOST
				p.Color = mod.ColorNormal
				p.Scale = 2

				local pd = p:GetData()
				pd.projType = "peepingBoss"
				pd.origVel = p.Velocity
				pd.orderVal = d.orderVal[1] + 1

				p:Update()

				table.insert(d.tears, p)
				d.rotVal = d.rotVal - 18
				d.orderVal[2] = (d.orderVal[2] + 1) % 5
				if d.orderVal[2] == 0 then
					d.orderVal[1] = (d.orderVal[1] + 1) % 4
				end
			else
				mod:spritePlay(sprite, "PeeplingAttack")
			end
		elseif d.substate == "SHOOT SON" then
			if sprite:IsFinished("Peepling0" .. d.shootAng) then
				d.substate = nil
				d.ad[2][2] = d.ad[2][2] + 1
				d.state = "idle"
			elseif sprite:IsEventTriggered("Shoot") then
				local corners = {}
				for i = 0, 360, 90 do
					corners[#corners + 1] = target.Position + Vector(120, 0):Rotated(i + 45)
				end

				local peepees = Isaac.FindByType(mod.FF.Peepstalk.ID, mod.FF.Peepstalk.Var, 2, EntityPartition.ENEMY, true)
				local pospairs = mod:PairEntitiesToPositions(peepees, corners)
				for ind, entpair in ipairs(pospairs) do
					local ent = entpair.ent
					local pos = corners[entpair.posind]
					local ed = ent:GetData()
					if ed.state == "idle" then
						ed.state = "shoot"
						ed.shoottarget = pos
						ed.vecang = mod:calcPeepeeDir(ed.shoottarget - ent.Position) + 1
						ed.wait = 0
						ent:Update()
					end
				end

				npc:PlaySound(SoundEffect.SOUND_BOSS_LITE_HISS, 0.4, 0, false, 0.7)
				for i = 1, #d.tears do
					if d.tears[i] then
						d.tears[i].Parent = nil
						local teard = d.tears[i]:GetData()
						teard.Fired = true
						if teard.orderVal then
							if teard.orderVal == d.shootAng then
								teard.origVel = teard.origVel * 1.2
							else
								teard.origVel = teard.origVel * 0.7
							end
						end
					end
				end
			else
				mod:spritePlay(sprite, "Peepling0" .. d.shootAng)
			end
		end
	elseif d.state == "BWOOOOM" then
		d.substate = d.substate or "hugeAssAttackTell"
		if d.substate == "hugeAssAttackTell" then
			if sprite:IsFinished("BrimstoneTell") or (sprite:GetFrame() == 75 and not d.successfullBrimDid) then
				d.substate = "fireUp"
				d.recordedPos = target.Position - (target.Velocity * 20)
				d.animNum = mod:calcPeepDir(d.recordedPos - npc.Position) + 1
				d.moveToCentre = false
			elseif sprite:GetFrame() == 52 then
				for index,entity in ipairs(Isaac.FindByType(mod.FF.Peepstalk.ID, mod.FF.Peepstalk.Var, 2, EntityPartition.ENEMY, true)) do
					local ed = entity:GetData()
					if ed.state == "brimPrepare" then
						ed.state = "brimSHOOTE"
						entity:Update()
					end
				end
			elseif sprite:IsEventTriggered("Scream") then
				npc:PlaySound(SoundEffect.SOUND_RAGMAN_2,1,0,false,0.8)
				sfx:Stop(mod.Sounds.StretchEye)
				d.moveToCentre = true
			elseif sprite:IsEventTriggered("HemolacriaStart") then
				npc:PlaySound(mod.Sounds.StretchEye,0.4,0,false,1.3)
				for index,entity in ipairs(Isaac.FindByType(mod.FF.Peepstalk.ID, mod.FF.Peepstalk.Var, 2, EntityPartition.ENEMY, true)) do
					local ed = entity:GetData()
					if not ed.brimming then
						ed.state = "brimPrepare"
						ed.targetPos = target.Position
						ed.brimming = true
						entity:Update()
						d.successfullBrimDid = true
					end
				end
			else
				mod:spritePlay(sprite, "BrimstoneTell")
			end
			if d.moveToCentre then
				local targ = room:GetCenterPos()
				local targVec = (targ - npc.Position)
				npc.Velocity = mod:Lerp(npc.Velocity, targVec * 0.06, 0.3)
			end
		elseif d.substate == "fireUp" then
			npc.Velocity = nilvector
			if sprite:IsPlaying("Brimstone0" .. d.animNum) and sprite:GetFrame() == 15 then
				--Safety check
				d.substate = "trackTheBastard"
				npc.StateFrame = 0
			elseif sprite:IsEventTriggered("Shoot") then
				local shootVec = d.recordedPos - npc.Position
				local laser = EntityLaser.ShootAngle(1, npc.Position + Vector(0, -40) + mod.peepLaserOffsets[d.animNum], shootVec:GetAngleDegrees(), 999999999, Vector(0, -20), npc)
				laser.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYERONLY
				laser.CollisionDamage = 0
				laser.DepthOffset = 45
				laser:Update()
				d.Brimmy = laser:ToLaser()
				d.substate = "trackTheBastard"
				npc.StateFrame = 0
			else
				mod:spritePlay(sprite, "Brimstone0" .. d.animNum)
			end
		elseif d.substate == "trackTheBastard" then
			npc.Velocity = nilvector
			d.recordedPos = mod:Lerp(d.recordedPos, target.Position, 0.1)
			if target.Velocity:LengthSquared() >= 2 then
				d.recordedVel = target.Velocity
			end

			local laserVec = d.recordedPos - (npc.Position + Vector(0, -40))
			local val = mod:calcPeepDir(laserVec) + 1
			sprite:SetFrame("BrimLoop0" .. val, npc.StateFrame % 24)
			--Default Timer is 30
			local brimTimer = 30
			if d.Brimmy then
				d.Brimmy.DisableFollowParent = true
				d.Brimmy.Angle = laserVec:GetAngleDegrees()
				d.Brimmy.SpawnerEntity = npc
				d.Brimmy.Parent = npc
				d.Brimmy.Position = npc.Position + Vector(0, -40) + mod.peepLaserOffsets[val]
				d.Brimmy.DepthOffset = 45

				local vec = (laserVec * -1):Rotated(-90 + math.random(180)):Resized(math.random(10,15))
				local brimDrops = Isaac.Spawn(1000, 70, 0, d.Brimmy:GetEndPoint(), vec, nil):ToEffect()
				brimDrops.FallingAcceleration = 1.3
				brimDrops.FallingSpeed = -3
				brimDrops.PositionOffset = Vector(vec.X, math.abs(vec.Y) * -1)
				brimDrops:Update()

				if npc.StateFrame == brimTimer then
					d.Brimmy.Timeout = 10
				end
				d.Brimmy:Update()
			end
			if npc.StateFrame > brimTimer + 5 then
				d.substate = "finishThis"
				--Failsafe
				d.Brimmy.Timeout = 5.

				-- if the player stops, don't shoot brimstone straight at them
				local useVel = d.recordedVel or target.Velocity
				local length = useVel:Length()
				local normal = useVel / length
				d.recordedPos2 = target.Position + (normal * math.max(length * 120,300))
				d.recordedVel = nil

				d.animNum = mod:calcPeepDir(d.recordedPos2 - npc.Position) + 1
			end
		elseif d.substate == "finishThis" then
			if sprite:IsFinished("Brimstone0" .. d.animNum) then
				d.ad[3][2] = d.ad[3][2] + 3
				d.state = "idle"
			elseif sprite:IsEventTriggered("Shoot") then
				local shootVec = d.recordedPos2 - npc.Position
				local laser = EntityLaser.ShootAngle(1, npc.Position + Vector(0, -40) + mod.peepLaserOffsets[d.animNum], shootVec:GetAngleDegrees(), 20, Vector(0, -20), npc)
				laser.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYERONLY
				laser.CollisionDamage = 0
				laser.DepthOffset = 45
				laser:Update()
			else
				mod:spritePlay(sprite, "Brimstone0" .. d.animNum)
			end
		end
	end

end

mod.peepLaserOffsets = {
--I hate myself
[1] = Vector(2,3),
[2] = Vector(19,3),
[3] = Vector(32,-2),
[4] = Vector(27,-6),
[5] = Vector(10,-8),
[6] = Vector(-10,-8),
[7] = Vector(-24,-6),
[8] = Vector(-29,-2),
[9] = Vector(-15,3)
}

function mod.peepingprojupdate(v,d)
	if d.projType == "peepingBoss" then
		v.Color = mod.ColorNormal
		--[[for _, tear in pairs(Isaac.FindByType(2, -1, -1, false, false)) do
			if tear.Position:Distance(v.Position) < 20 then
				tear:Remove()
			end
		end]]
		if v.Parent and v.Parent.HitPoints > 99 then
			local p = v.Parent

			local offsetval = 75
			if v.FrameCount < 15 then
				offsetval = v.FrameCount * math.max(1, (10 - v.FrameCount/3))
				v.Velocity = p.Velocity + (d.origVel * (1 - (math.max(5, v.FrameCount))/10))
			else
				v.Velocity = p.Velocity
			end

			v.Position = p.Position + d.origVel:Resized(offsetval)

		else
			if d.Fired then
				v.Velocity = d.origVel
			else
				v.FallingSpeed = 1
				v.FallingAccel = 1
			end
			v.ProjectileFlags = v.ProjectileFlags ~ ProjectileFlags.GHOST
			d.projType = nil
		end
	elseif d.projType == "HemoPart2" then
		if v:IsDead() then
			sfx:Play(SoundEffect.SOUND_MEAT_IMPACTS, 1, 0, false, 1.5);
			local vec = Vector(10,0)
			d.hemoRot = d.hemoRot or 0
			for i = 90, 360, 90 do
				local projectile = Isaac.Spawn(9, 0, 0, v.Position + vec:Rotated(i + d.hemoRot), vec:Rotated(i + d.hemoRot), v):ToProjectile();
				projectile.ProjectileFlags = v.ProjectileFlags
			end
		end
	elseif d.projType == "SlowDownSon" then
		d.slowDownSpeed = d.slowDownSpeed or 0.97
		v.Velocity = v.Velocity * d.slowDownSpeed
	elseif d.projType == "peepstalk" then -- why figure out how to calculate arcs to land at the right position when you could just fake it with rotation?
		local through = v.FrameCount / d.timeout
		local height = -(Vector(65, 0):Rotated(mod:Lerp(60, 180, through)).Y)
		height = height - 10

		v.FallingSpeed = height - v.Height
		v.FallingAccel = 0

		if v.FrameCount >= d.timeout or v:IsDead() then
			sfx:Play(SoundEffect.SOUND_MEAT_IMPACTS, 1, 0, false, 1.5);
			local vec = Vector(5,0)
			local creep = Isaac.Spawn(1000,22,0,v.Position,Vector.Zero,v):ToEffect()
			creep:SetTimeout(30)
			--[[for i = 90, 360, 90 do
				local projectile = Isaac.Spawn(9, 0, 0, v.Position + vec:Rotated(i), vec:Rotated(i), v):ToProjectile();
				projectile.FallingSpeed = -10;
				projectile.FallingAccel = 1.5;
				projectile.ProjectileFlags = v.ProjectileFlags
			end]]

			if not v:IsDead() then
				v:Die()
			end
		end
	end
end

function mod:bigHemoProjAI(npc)
	local d = npc:GetData()
	local r = npc:GetDropRNG()

	if not d.init then
		npc:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
		npc:AddEntityFlags(EntityFlag.FLAG_NO_TARGET)
		d.init = true
	end
	d.vec = d.vec or nilvector
	npc.Velocity = d.vec

	mod:spritePlay(npc:GetSprite(), "Idle")

	if npc.SpriteOffset.Y > -20 then
		npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYERONLY
	else
		npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
	end

	d.fallspeed = d.fallspeed or -5
	d.fallspeed = d.fallspeed + 0.5
	npc.SpriteOffset = Vector(0, npc.SpriteOffset.Y + d.fallspeed)

	if npc:CollidesWithGrid() or npc.SpriteOffset.Y > 0 then
		npc:PlaySound(SoundEffect.SOUND_MEATHEADSHOOT,1,0,false,0.7)

		local sploshEffect = Isaac.Spawn(1000, 1738, 0, npc.Position, nilvector, npc):ToEffect()
		sploshEffect.SpriteOffset = npc.SpriteOffset
		sploshEffect:Update()
		npc:Remove()

		local params = ProjectileParams()
		for i = 45, 360, 45 do
			local rand = r:RandomFloat()
			local p = Isaac.Spawn(9, 0, 0, npc.Position, Vector(0,6):Rotated(i), npc):ToProjectile()
			p.FallingSpeed = -25
			p.FallingAccel = 1.5
			p.Parent = npc
			p.Scale = 2

			local pd = p:GetData()
			pd.projType = "HemoPart2"
			if i % 90 == 0 then
				pd.hemoRot = 45
			end

			p:Update()
		end

	end
end

function mod:hemoSplat(e)
	local anim = e:GetData().anim or "Poof"
	if e:GetSprite():IsFinished(anim) then
		e:Remove()
	else
		mod:spritePlay(e:GetSprite(), anim)
	end
end
mod:AddCallback(ModCallbacks.MC_POST_EFFECT_UPDATE, mod.hemoSplat, 1738)
mod:AddCallback(ModCallbacks.MC_POST_EFFECT_UPDATE, mod.hemoSplat, 1739)
--It does the same thing so ykno

--peeping2
function mod:peepingPhase2AI(npc, sprite, d)
	local subt = npc.SubType
	local target = npc:GetPlayerTarget()

	if not d.init then
		npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
		npc:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
		d.state = "fallDown"
		sprite:Play("Appear", true)
		d.init = true
	else
		npc.StateFrame = npc.StateFrame + 1
	end

	if d.state == "fallDown" then
		if sprite:IsFinished("Appear") then
			d.state = "moveBitchGetOutTheWay"
			npc.StateFrame = 0
		elseif sprite:IsEventTriggered("Hop") then
			d.moving = true
		elseif sprite:IsEventTriggered("Land") then
			npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_ALL
			if not d.bouncedYet then
				npc:PlaySound(SoundEffect.SOUND_FORESTBOSS_STOMPS,0.5,0,false,1)
				game:ShakeScreen(15)
				d.bouncedYet = true
			else
				d.finallyLanded = true
				npc:PlaySound(SoundEffect.SOUND_FORESTBOSS_STOMPS,0.3,0,false,1.3)
				game:ShakeScreen(5)
			end
		else
			mod:spritePlay(sprite, "Appear")
		end
	elseif d.state == "moveBitchGetOutTheWay" then
		if npc.Velocity.X > 0 then
			if npc.Velocity.Y > 0 then
				d.movAl = 1
			else
				d.movAl = 4
			end
		else
			if npc.Velocity.Y > 0 then
				d.movAl = 2
			else
				d.movAl = 3
			end
		end
		sprite:SetFrame("Walk0" .. d.movAl, npc.StateFrame % 18)
	end

	if d.moving then
		if npc.FrameCount % 3 == 1 then
			local blood = Isaac.Spawn(1000, 7, 0, npc.Position, nilvector, npc)
			blood.SpriteScale = Vector(0.4,0.4)
			blood:Update()
		end

		local peepees = mod.GetEntityCount(mod.FF.Peepee.ID, mod.FF.Peepee.Var)
		if peepees > 0 then
			peepees = peepees + 1
		end

		local speedNerf = math.floor(((peepees ^ 2) * 0.25))
		d.speed = math.max(9 - speedNerf, 4.5)
		if not d.finallyLanded then
			d.speed = 3.5
		end

--		d.speed = d.speed or 4.5
		if d.changeOff and d.changeOff % 2 == 1 then
			mod:diagonalMove(npc, d.speed, nil, 0.3, true)
		else
			mod:diagonalMove(npc, d.speed, nil, 0.6, true)
		end

		for k,v in ipairs(mod.GetGridEntities()) do
			if v.Position:Distance(npc.Position) < 45 then
				v:Destroy()
			end
		end
		if npc:CollidesWithGrid() and npc.StateFrame > 15 then
			if npc.HitPoints > 10 then
				npc:TakeDamage(3.5, 0, EntityRef(npc), 0)
			end

			d.changeOff = d.changeOff or 0
			d.changeOff = d.changeOff + 1
			npc:PlaySound(SoundEffect.SOUND_FORESTBOSS_STOMPS,0.5,0,false,math.random(95,105)/100)
			game:ShakeScreen(5)
			npc.StateFrame = 0
			local projCount = 8
			local rot = -26.5
			for i = 1, 2 do
				if i == 2 then
					projCount = 16
					rot = 0
				elseif i == 1 then
					rot = 26.5
				end

				for j = 1, projCount do
					local rotVal = ((360 / projCount) * j) + rot
					local vec = Vector(11,0):Rotated(rotVal)
					--npc:FireProjectiles(npc.Position + vec:Resized(20 + rot/3), vec, 0, ProjectileParams())
					local projectile = Isaac.Spawn(9, 0, 0, npc.Position + vec:Resized(20 + rot/3), vec, npc):ToProjectile();
					projectile.FallingAccel = -0.05
					local projdata = projectile:GetData();
					projdata.projType = "SlowDownSon"
				end
			end
		end
	end

end

function mod:peepstalkAI(npc, sprite, d)
	local subt = npc.SubType
	local target = npc:GetPlayerTarget()

	npc.Velocity = nilvector

	if subt == 0 then
		npc:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
		npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
		npc:AddEntityFlags(EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK | EntityFlag.FLAG_NO_KNOCKBACK | EntityFlag.FLAG_NO_STATUS_EFFECTS)
		npc.Visible = false
	else
		if not d.init then
			npc:ClearEntityFlags(EntityFlag.FLAG_NO_STATUS_EFFECTS)
			mod:spritePlay(sprite, "Drop")
			npc.Visible = true
			d.state = "appear"
			d.init = true
		else
			npc.StateFrame = npc.StateFrame + 1
		end

		if d.state == "appear" then
			if sprite:IsFinished("PillarAppear") then
				d.state = "waitingForLove"
			elseif sprite:IsEventTriggered("DMG") then
				npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS
			else
				mod:spritePlay(sprite, "PillarAppear")
			end
		elseif d.state == "waitingForLove" then
			mod:spritePlay(sprite, "Idle02")
			if subt == 2 then
				d.state = "Land"
				mod:spritePlay(sprite, "Land")
			end
		elseif d.state == "Land" then
			if sprite:IsFinished("Land") then
				d.state = "idle"
			else
				mod:spritePlay(sprite, "Land")
			end
		elseif d.state == "idle" then
			mod:spritePlay(sprite, "Idle01")
			if mod.GetEntityCount(mod.FF.Peeping.ID, mod.FF.Peeping.Var) < 1 then
				d.state = "collapse"
			--[[elseif npc.StateFrame > 50 and math.random(15) == 1 then
				d.state = "shoot"
				d.playerpos = target.Position + target.Velocity * 5
				d.vecang = mod:calcPeepeeDir(target.Position - npc.Position) + 1]]
			end
		elseif d.state == "shoot" then
			if sprite:IsFinished("Shoot0" .. d.vecang) then
				d.state = "idle"
				npc.StateFrame = 0
			elseif sprite:IsEventTriggered("Shoot") then
				-- OLD: local shotspeed = (target.Position - npc.Position)*0.05
				--[[
				local shotspeed = (d.shoottarget - npc.Position)*0.06
				if shotspeed:Length() > 8 then
					shotspeed = shotspeed:Resized(8)
				end
				local projectile = Isaac.Spawn(9, 0, 0, npc.Position, shotspeed, npc):ToProjectile();
				projectile.FallingAccel = 0.5;
				projectile.Height = -85
				projectile.Scale = 2
				projectile:GetData().projType = "CricBod2"]]

				local flighttime = 20
				local shotspeed = (d.shoottarget - npc.Position) / flighttime
				local projectile = Isaac.Spawn(9, 0, 0, npc.Position, shotspeed, npc):ToProjectile();
				projectile.Scale = 2
				projectile:GetData().projType = "peepstalk"
				projectile:GetData().timeout = flighttime

				npc.StateFrame = 0
			else
				if d.wait and d.wait > 0 then
					d.wait = d.wait - 1
				else
					mod:spritePlay(sprite, "Shoot0" .. d.vecang)
				end
			end
		elseif d.state == "brimPrepare" then
			d.shooting = false
			d.targetPos = d.targetPos or target.Position
			if sprite:IsFinished("BrimstoneTell") then
				mod:spritePlay(sprite, "Idle01Brim")

			else
				if not d.prepared then
					mod:spritePlay(sprite, "BrimstoneTell")
					local tracer = Isaac.Spawn(1000, 198, 0, npc.Position, Vector(0.001,0), npc):ToEffect()
					tracer.Timeout = 60
					tracer.TargetPosition = Vector(1,0):Rotated(mod:GetAngleDegreesButGood(target.Position - npc.Position))
					tracer.LifeSpan = 55
					tracer:FollowParent(npc)
					tracer.SpriteScale = Vector(2,2)
					tracer.Color = Color(1,0.2,0,0.3,0.2,0,0)
					tracer.SpriteOffset = Vector(0, 57)
					tracer:Update()
					d.prepared = true
				end
			end
		elseif d.state == "brimSHOOTE" then
			d.prepared = false
			--They should know this but I just want to be safe
			d.targetPos = d.targetPos or target.Position
			d.shootang = d.targetPos - (npc.Position + Vector(0, -58))

			d.vecang = d.vecang or mod:calcPeepeeDir(d.shootang) + 1

			if sprite:IsFinished("Brimstone0" .. d.vecang) then
				d.vecang = nil
				d.shootang = nil
				d.brimming = nil
				d.state = "idle"
			elseif sprite:IsEventTriggered("Shoot") then
				local laser = EntityLaser.ShootAngle(1, npc.Position + Vector(0, -58) + d.shootang:Resized(3), d.shootang:GetAngleDegrees(), 10, Vector(0, -20), npc)
				laser.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYERONLY
				laser.CollisionDamage = 0
				laser.DepthOffset = 57
				laser:Update()
			else
				mod:spritePlay(sprite, "Brimstone0" .. d.vecang)
			end
		elseif d.state == "collapse" then
			if sprite:IsEventTriggered("Explode") or sprite:IsFinished("PillarDeath") then
				npc:BloodExplode()
				d.state = "boop"
				npc:Morph(mod.FF.Peepee.ID, mod.FF.Peepee.Var, 2, -1)
			else
				mod:spritePlay(sprite, "PillarDeath")
			end
		end

		--[[if d.shooting then
			if npc.StateFrame % 2 == 0 then
				local vec = (d.playerpos - npc.Position) * 0.045
				if vec:Length() > 10 then
					vec = vec:Resized(10)
				end
				local params = ProjectileParams()
				params.HeightModifier = -55
				params.FallingAccelModifier = 0.3
				npc:FireProjectiles(npc.Position + vec:Resized(15), vec, 0, params)
				d.shooting = d.shooting + 1
				if d.shooting == 4 then
					d.shooting = nil
				end
			end
		end]]
	end
end

function mod:peepeeAI(npc, sprite, d)
	local room = game:GetRoom()
	local subt = npc.SubType
	local target = npc:GetPlayerTarget()
	if not d.init then
		if subt == 1 then
			d.state = "air"
		elseif subt == 2 then
			d.state = "boop"
		else
			d.state = "idle"
			npc.SpriteOffset = Vector(0, 3)
		end
		d.init = true
	else
		npc.StateFrame = npc.StateFrame + 1
	end



	if d.state == "air" then
		mod:spritePlay(sprite, "InAir")
		local vec = (d.endGoal - npc.Position)
		npc.Velocity = mod:Lerp(npc.Velocity, vec * 0.1, 0.3)
		d.fallspeed = d.fallspeed or -7
		d.fallspeed = d.fallspeed + 0.5
		npc.SpriteOffset = Vector(0, npc.SpriteOffset.Y + d.fallspeed)
		--print(npc.SpriteOffset.Y)
		if npc.SpriteOffset.Y > -51 and (d.target and npc.Position:Distance(d.target.Position) < 10 and not d.target:IsDead()) then
			d.target.SubType = 2
			d.target:Update()
			npc:Remove()
		elseif npc.SpriteOffset.Y > 1 then
			d.state = "suddenLand"
			npc.SpriteOffset = Vector(0, 3)
		end
	elseif d.state == "idle" then
		npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_ALL
		mod:spritePlay(sprite, "Idle03")
		npc.Velocity = npc.Velocity * 0.9
		if npc.StateFrame > 5 and math.random(5) == 1 then
			d.yorsopposedtojompatme = d.yorsopposedtojompatme or math.random(3) - 1
			if room:CheckLine(target.Position,npc.Position,3,900,false,false) and d.yorsopposedtojompatme > 2 and not mod:isScareOrConfuse(npc) then
				d.state = "shoote"
				d.yorsopposedtojompatme = 0
			else
				d.state = "joomp"
				d.yorsopposedtojompatme = d.yorsopposedtojompatme + 1
			end
		end
	elseif d.state == "joomp" then
		if sprite:IsFinished("Hop") then
			d.state = "idle"
			npc.StateFrame = 0
		elseif sprite:IsEventTriggered("Hop") then
			npc:PlaySound(SoundEffect.SOUND_MEAT_JUMPS,0.7,0,false,1)
			d.jumping = true
			if mod:isScare(npc) or (room:CheckLine(target.Position,npc.Position,0,900,false,false) and math.random(3) == 1 and not mod:isConfuse(npc)) then
				npc.Velocity = mod:reverseIfFear(npc, (target.Position - npc.Position):Resized(6))
			else
				npc.Velocity = RandomVector()*6
			end
			if npc.Velocity.X > 0 then
				sprite.FlipX = false
			else
				sprite.FlipX = true
			end
		elseif sprite:IsEventTriggered("Land") then
			npc:PlaySound(SoundEffect.SOUND_MEAT_IMPACTS,1,0,false,1)
			d.jumping = false
		else
			mod:spritePlay(sprite, "Hop")
		end

		if not d.jumping then
			npc.Velocity = npc.Velocity * 0.9
		end
	elseif d.state == "shoote" then
		npc.Velocity = npc.Velocity * 0.9
		if sprite:IsFinished("Shoot") then
			d.state = "idle"
		elseif sprite:IsEventTriggered("Shoot") then
			npc:PlaySound(SoundEffect.SOUND_WORM_SPIT,1,0,false,1)
			if target.Position.X > npc.Position.X then
				sprite.FlipX = false
			else
				sprite.FlipX = true
			end
			local shootVec = (target.Position - npc.Position):Resized(8)
			--[[for i = -30, 30, 20 do
				npc:FireProjectiles(npc.Position + shootVec, shootVec:Rotated(i), 0, ProjectileParams())
			end]]
			local params = ProjectileParams()
			params.Scale = 2
			npc:FireProjectiles(npc.Position + shootVec, shootVec, 0, params)
		else
			mod:spritePlay(sprite, "Shoot")
		end
	elseif d.state == "boop" then
		npc.Velocity = npc.Velocity * 0.9
		if sprite:IsFinished("PeepeeFall") then
			d.state = "transform"
			npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_ALL --Just making sure at this point
		elseif sprite:IsEventTriggered("Land") then
			npc:PlaySound(SoundEffect.SOUND_MEAT_IMPACTS,1,0,false,1)
			npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_ALL
			npc.SpriteOffset = Vector(0, 3)
		else
			mod:spritePlay(sprite, "PeepeeFall")
		end
	elseif d.state == "transform" then
		npc.Velocity = npc.Velocity * 0.9
		if sprite:IsFinished("Transform") then
			d.state = "idle"
		elseif sprite:IsEventTriggered("Explode") then
			npc:BloodExplode()
		else
			mod:spritePlay(sprite, "Transform")
		end
	elseif d.state == "suddenLand" then
		npc.Velocity = npc.Velocity * 0.9
		if sprite:IsFinished("SuddenLand") then
			d.state = "transform"
		else
			mod:spritePlay(sprite, "SuddenLand")
		end
	end
end


--LUNCHEON LUNCHEON LUNCHEON
--The fat fucker himself
function mod:luncheonAI(npc)
local sprite = npc:GetSprite()
local d = npc:GetData()

	if not d.init then
		d.init = true

		--Then regular init stuff for the fella
		npc:AddEntityFlags(EntityFlag.FLAG_NO_TARGET | EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK | EntityFlag.FLAG_NO_KNOCKBACK)
		mod.DeadWorms = 0 --Resets on a spawn
		d.state = "summon"
	else
		npc.StateFrame = npc.StateFrame + 1
	end

	npc.Velocity = npc.Velocity * 0.1

	if d.state == "idle" then
		if d.hurt then
			if not sprite:IsPlaying("Flinch") then
				sprite:Play("Flinch", false)
				npc:PlaySound(SoundEffect.SOUND_MONSTER_GRUNT_1,1,0,false,math.random(8,12)/10)
			end
		else
			mod:spritePlay(sprite, "Idle")
			if mod.DeadWorms > 1 then
			d.state = "shakey"
			d.sprayVec = 1
			mod.DeadWorms = mod.DeadWorms - 2
			end
			if npc.StateFrame > 30 and mod.GetEntityCount(mod.FF.Tapeworm.ID, mod.FF.Tapeworm.Var) < 4 then
				d.state = "summon"
			end
		end
		if sprite:IsFinished("Flinch") then
			d.hurt = false
		end
		mod.DeadWorms = mod.DeadWorms or 0
	elseif d.state == "summon" then
		d.hurt = false
		if sprite:IsFinished("Spit") then
			d.state = "idle"
		elseif sprite:IsEventTriggered("Spit") then
			npc:PlaySound(mod.Sounds.LuncheonVom, 1, 0, false, math.random(90,110)/100)
			local threatHead, threatBody, threatTail = -45 + math.random(0, 1) * 90, -45 + math.random(0, 1) * 90, -45 + math.random(0, 1) * 90
			for i = -45, 45, 90	 do
				local ball = Isaac.Spawn(mod.FF.WormBall.ID,mod.FF.WormBall.Var,0,npc.Position,Vector(0,8):Rotated(i),npc)
				ball:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
				ball.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE


				local bd = ball:GetData()
				bd.Target = npc.Position + Vector(0,130):Rotated(i)

				local ballsprite = ball:GetSprite()
				bd.Color = {}
				for j = 0, 2 do
					if (j == 0 and i == threatHead) or (j == 1 and i == threatBody) or (j == 2 and i == threatTail) then
						rand = math.random(2)
					else
						rand = math.random(2) + 2
					end

					bd.Color[j + 1] = rand
					ballsprite:ReplaceSpritesheet(j, "gfx/bosses/luncheon/" .. mod.TapeColors[rand].anm2 .. "_segments_connected.png")
				end
				ballsprite:LoadGraphics()

				ball:Update()

			end

		elseif sprite:IsEventTriggered("Cronch") then
			npc:PlaySound(mod.Sounds.CronchyWorms, 2, 0, false, math.random(70,80)/100)
		elseif sprite:IsEventTriggered("Slurp") then
			npc:PlaySound(mod.Sounds.CartoonSlurp, 1, 0, false, math.random(50,70)/100)
		else
			mod:spritePlay(sprite, "Spit")
		end
	elseif d.state == "shakey" then
		d.hurt = false
		if sprite:IsFinished("Shake") then
			d.state = "idle"
		elseif sprite:IsEventTriggered("Shake") then
			Game():ShakeScreen(5)
			for _,egg in ipairs(Isaac.FindByType(mod.FF.TapewormEgg.ID, mod.FF.TapewormEgg.Var, -1, EntityPartition.ENEMY, true)) do
				egg:GetData().dying = true
			end
		elseif sprite:IsEventTriggered("Spray") then
			d.sprayVec = d.sprayVec * -1
			--npc:PlaySound(SoundEffect.SOUND_BLOODSHOOT,1,2,false,1)


			local params = ProjectileParams()
			params.HeightModifier = -50
			for i = 1, 6 do
				local shotspeed = (Vector(5 * d.sprayVec, math.random(7,14)/2):Rotated(-70+math.random(140)))
				params.Scale = math.random(7, 10) / 10
				params.FallingSpeedModifier = -20 + math.random(10);
				params.FallingAccelModifier = 1.4 + math.random(10)/10;
				npc:FireProjectiles(npc.Position + shotspeed * 4, shotspeed, 0, params)
			end
		elseif sprite:IsEventTriggered("Swish") then
			npc:PlaySound(SoundEffect.SOUND_FETUS_JUMP, 1, 0, false, math.random(130,150)/100)
			Game():ShakeScreen(5)
		else
			mod:spritePlay(sprite, "Shake")
		end
	end
end


--Tapeworm bollocks
mod.TapeColors = {
[1] = {name = "pinky", color = Color(1,1,1,1,0,0,0), anm2 = "petunia"},
[2] = {name = "redford", color = Color(2,0.5,0.5,1,0,0,0), anm2 = "greg"},
[3] = {name = "whiteboi", color = Color(5,5,5,1,0,0,0), anm2 = "minkus"},
[4] = {name = "slapbass", color = Color(0.1,0.1,0.1,1,0,0,0), anm2 = "boris"}
}

function mod:calculateDir(npc, vector)
	vector = vector or npc.Velocity
	local sprite = npc:GetSprite()
	local d = npc:GetData()
	local rotAMNT = 0.5

	if math.abs(vector.X) > math.abs(vector.Y) then
		d.dir = "Hori"
		if vector.X > 0 then
			sprite.FlipX = false
		else
			sprite.FlipX = true
		end
	else
		npc:GetData().dist = 27
		rotAMNT = 0.1
		if vector.Y > 0 then
			d.dir = "Down"
		else
			d.dir = "Up"
		end
	end
	local rot = (((vector:GetAngleDegrees() + 45) % 90) - 45) * rotAMNT
	if sprite.FlipX then
		rot = rot * -1
	end
	npc.SpriteRotation = rot
end

function mod:tapewormAI(npc, subt)
local sprite = npc:GetSprite()
local d = npc:GetData()
local target = npc:GetPlayerTarget()
if target.Type == mod.FF.Tapeworm.ID and target.Variant == mod.FF.Tapeworm.Var and mod:isInSegmentsOf(target, npc) then
	target = Isaac.GetPlayer(0)
end
local targetpos = mod:confusePos(npc, target.Position)
local path = npc.Pathfinder
local rotval = 0.5


	if not d.init then
		npc:AddEntityFlags(EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK | EntityFlag.FLAG_NO_KNOCKBACK)
		local rand = d.ColorID or math.random(4)
		--rand = 4
		if d.ColorID then
			d.landing = true
		end
		d.ColorID = rand
		d.Color = mod.TapeColors[rand].name
		--npc.Color = mod.TapeColors[rand].color
		if npc.Parent or npc.Child then
			sprite:ReplaceSpritesheet(0, "gfx/bosses/luncheon/" .. mod.TapeColors[rand].anm2 .. "_segments_connected.png")
			d.hasAltSpritesheet = true
		else
			sprite:ReplaceSpritesheet(0, "gfx/bosses/luncheon/" .. mod.TapeColors[rand].anm2 .. "_segments.png")
		end
		sprite:LoadGraphics()
		d.init = true
	else
		npc.StateFrame = npc.StateFrame + 1
	end

	d.dist = 37
	if npc.Velocity:Length() > 0.1 then
		mod:calculateDir(npc)
	else
		--sprite:SetFrame("Head_Hori", 0)
		d.dir = "Hori"
	end

	if d.AAAHELP then
		d.shootcount = d.shootcount or 0
		d.shootcount = d.shootcount + 1

		npc:PlaySound(SoundEffect.SOUND_BLOODSHOOT,1,2,false,1)
		local params = ProjectileParams()
		local shotspeed = ((target.Position - npc.Position)*0.04):Rotated(-10+math.random(20))
		shotspeed = shotspeed:Resized(6)
		params.Scale = math.random(2, 10) / 10
		params.FallingSpeedModifier = -20 + math.random(10);
		params.FallingAccelModifier = 1.1 + math.random(2)/10;
		params.HeightModifier = 20
		params.Variant = 4
		npc:FireProjectiles(npc.Position, shotspeed, 0, params)

		if d.shootcount > 6 then
			d.AAAHELP = false
			d.shootcount = 0
		end
	end

	if npc:IsDead() or mod:isLeavingStatusCorpse(npc) then
		mod.DeadWorms = mod.DeadWorms or 0
		mod.DeadWorms = mod.DeadWorms + 1
		for _, luncheon in pairs(Isaac.FindByType(mod.FF.Luncheon.ID, mod.FF.Luncheon.Var, -1, false, false)) do
			luncheon:TakeDamage(25, DamageFlag.DAMAGE_CLONES, EntityRef(npc), 0)
			luncheon:GetData().hurt = true
		end
	end

	if npc.Parent and mod:isStatusCorpse(npc.Parent) then
		npc.Parent = nil
	end

	if npc.Child and mod:isStatusCorpse(npc.Child) then
		npc.Child = nil
	end

	--Spawn a completely random one
	if subt == 0 then
		npc:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
		if npc.StateFrame == 1 then
			--TODO : MAKE THIS LESS SHIT
			local head = Isaac.Spawn(mod.FF.Tapeworm.ID, mod.FF.Tapeworm.Var, 1, npc.Position, nilvector, npc)
			local body = Isaac.Spawn(mod.FF.Tapeworm.ID, mod.FF.Tapeworm.Var, 2, npc.Position, nilvector, npc)
			local tail = Isaac.Spawn(mod.FF.Tapeworm.ID, mod.FF.Tapeworm.Var, 3, npc.Position, nilvector, npc)


			head.Child = body
			body.Parent = head
			body.Child = tail
			tail.Parent = body

			head.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS
			body.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS
			tail.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS
			npc:Remove()
		end



	--Head
	elseif subt == 1 then
		npc.RenderZOffset = 400
		if d.landing then
			if sprite:IsFinished("Head_Land") then
				d.landing = false
			else
				mod:spritePlay(sprite, "Head_Land")
			end
			npc.Velocity = npc.Velocity * 0.9
		elseif npc.Child and npc.Child:GetData().egglaying then
			mod:spritePlay(sprite, "EggLay_Head")
			npc.Velocity = mod:SnapVector(npc.Velocity * 0.9, 180)
		else
			if not npc.Child and d.hasAltSpritesheet then
				d.hasAltSpritesheet = false
				sprite:ReplaceSpritesheet(0, "gfx/bosses/luncheon/" .. mod.TapeColors[d.ColorID].anm2 .. "_segments.png")
				sprite:LoadGraphics()
			end
			if d.chargetell then
				if sprite:IsFinished("ChargeTell_Head_" .. d.lastdir) then
					d.chargetell = false
				elseif sprite:IsEventTriggered("Charge") then
					d.chargin = true
					npc:PlaySound(SoundEffect.SOUND_MONSTER_ROAR_0,1,2,false,math.random(13,15)/10)
				else
					mod:spritePlay(sprite, "ChargeTell_Head_" .. d.lastdir)
				end
			elseif d.chargin then
				mod:spritePlay(sprite, "Charge_Head_" .. d.dir)
			else
				sprite:SetFrame("Head_" .. d.dir, npc.FrameCount % 19)
				if npc.FrameCount % 19 == 10 then
					npc:PlaySound(mod.Sounds.WormScoot, 0.2, 0, false, math.random(97,103)/100)
				end
			end

			if d.Color == "pinky" then
				--local targvel = (target.Position - npc.Position):Resized(5)
				--npc.Velocity = mod:Lerp(npc.Velocity, targvel, 0.07):Rotated(math.sin((npc.InitSeed + npc.FrameCount) / 7) * 3)
				if npc.FrameCount % 19 == 10 then
					d.rot = d.rot or 30
					d.rot = d.rot * -1
					local targvel = (targetpos - npc.Position):Resized(15):Rotated(d.rot)
					npc.Velocity = mod:Lerp(npc.Velocity, targvel, 0.5)
				else
					npc.Velocity = npc.Velocity * 0.95
				end
			elseif d.Color == "redford" then
				if d.chargin then
					npc.Velocity = d.chargevel:Resized(15)
					if npc:CollidesWithGrid() then
						d.chargin = false
						npc.StateFrame = 0
					end
				elseif d.chargetell then
					npc.Velocity = npc.Velocity * 0.9
				else
					local targvel = (targetpos - npc.Position):Resized(2)
					npc.Velocity = mod:Lerp(npc.Velocity, targvel, 0.7)
					if npc.StateFrame > 15 and math.random(10) == 1 and not mod:isScareOrConfuse(npc) then
						d.chargetell = true
						mod:calculateDir(npc)
						d.lastdir = d.dir
						d.chargevel = npc.Velocity
					end
				end
			elseif d.Color == "whiteboi" then
				local pdist = target.Position:Distance(npc.Position)
				if (pdist < 200 and Game():GetRoom():CheckLine(target.Position,npc.Position,3,900,false,false)) then
					npc.Velocity = mod:Lerp(npc.Velocity, (target.Position - npc.Position):Resized(-3 - ((200 - pdist) / 100)), 0.15)
					npc.StateFrame = 161
				else
					if npc.StateFrame > 160 or not d.walktarg then
						--Find a random position in the room to walk to
						local validPositions = {}
						local room = Game():GetRoom()
						local size = room:GetGridSize()
						for i=0, size do
							local gridpos = room:GetGridPosition(i)
							if path:HasPathToPos(gridpos, false) and not room:GetGridEntity(i) then
								table.insert(validPositions, gridpos)
							end
						end
						if #validPositions > 0 then
							d.walktarg = validPositions[math.random(#validPositions)]
						else
							d.walktarg = npc.Position
						end
						npc.StateFrame = 0
					end
					if npc.Position:Distance(d.walktarg) > 30 then
						if Game():GetRoom():CheckLine(npc.Position,d.walktarg,0,1,false,false) then
							local targetvel = (d.walktarg - npc.Position):Resized(2)
							npc.Velocity = mod:Lerp(npc.Velocity, targetvel,0.2)
						else
							path:FindGridPath(d.walktarg, 0.2, 900, true)
						end
					else
						d.walktarg = nil
					end
				end
			elseif d.Color == "slapbass" then
				if npc.FrameCount % 19 == 10 then
					local targvel = (targetpos - npc.Position):Resized(15)
					if math.random(2) == 1 or mod:isConfuse(npc) then
						targvel = RandomVector()*15
					end
					npc.Velocity = mod:Lerp(npc.Velocity, targvel, 0.5)
				end
				npc.Velocity = npc.Velocity * 0.9
			end
		end


	--Body
	elseif subt == 2 then
		npc.RenderZOffset = -300 --Enables datamining features
		local creeppos = npc.Position

		--Follow parent
		if npc.Parent then

			if npc.Parent:GetData().Color == "whiteboi" then
				if d.dir == "Down" then
					d.dist = d.dist - 15
				elseif d.dir == "Up" then
					d.dist = d.dist - 10
				end
			end

			creeppos = npc.Parent.Position
			--npc.Position = npc.Parent.Position - mod:SnapVector(npc.Parent.Velocity:Resized(dist), 90)
			local parentvel = mod:SnapVector(npc.Parent.Velocity, 90):Rotated((((npc.Parent.Velocity:GetAngleDegrees() + 45) % 90) - 45) * rotval)
			npc.Position = mod:Lerp(npc.Position, (npc.Parent.Position - parentvel:Resized(d.dist)), 0.6)
			npc.Velocity = mod:Lerp(npc.Velocity, parentvel, 0.6)


		--Or if parent is dead
		else
			if not npc.Parent and d.hasAltSpritesheet then
				d.hasAltSpritesheet = false
				sprite:ReplaceSpritesheet(0, "gfx/bosses/luncheon/" .. mod.TapeColors[d.ColorID].anm2 .. "_segments.png")
				sprite:LoadGraphics()
			end

			local speed, friction, randChance, maxRotation = 15, 0.9, .5, 50
			if d.Color == "pinky" then
				friction = 0.95
				randChance = .25
				maxRotation = 30
			elseif d.Color == "redford" then
				randChance = 0
			elseif d.Color == "whiteboi" then
				randChance = .75
				maxRotation = 0
				friction = 0.85
				speed = 20
			end

			if npc.FrameCount % 19 == 10 then
				local targvel = (target.Position - npc.Position):Resized(speed):Rotated(math.random(-maxRotation, maxRotation))
				if math.random() < randChance then
					targvel = RandomVector()*speed
				end
				npc.Velocity = mod:Lerp(npc.Velocity, targvel, 0.5)
			end
			npc.Velocity = npc.Velocity * friction

		end

		local creepPeriod = 5

		--Animation
		if d.landing then
			if sprite:IsFinished("Body_Land") then
				d.landing = false
			else
				mod:spritePlay(sprite, "Body_Land")
			end
			npc.Velocity = npc.Velocity * 0.9
		elseif npc.Child and npc.Child:GetData().egglaying then
			mod:spritePlay(sprite, "EggLay_Body")
			d.egglaying = true
		elseif npc.Parent and npc.Parent:GetData().chargetell then
			d.egglaying = false
			local pd = npc.Parent:GetData()
			d.chargetell = true
			d.lastdir = pd.lastdir
			mod:spritePlay(sprite, "ChargeTell_Body_" .. pd.lastdir)
		elseif npc.Parent and npc.Parent:GetData().chargin then
			d.egglaying = false
			d.dist = d.dist + 5
			d.chargetell = false
			d.chargin = true
			creepPeriod = 2
			mod:spritePlay(sprite, "Charge_Body_" .. d.dir)
		else
			d.chargetell = false
			d.egglaying = false
			d.chargin = false
			sprite:SetFrame("Body_" .. d.dir, npc.FrameCount % 19)
		end
		--Body effects
		if d.Color == "pinky" then
			if npc.FrameCount % creepPeriod == 1 then
				local creep = Isaac.Spawn(1000, 22, 0, npc.Position, nilvector, npc):ToEffect();
				creep.Color = Color(10,15,15,1,0,0,0)
				creep.SpriteRotation = npc.SpriteRotation
				creep:SetTimeout(30)
				creep:Update()
			end
		elseif d.Color == "redford" then
			local amount = 20
			if d.chargin then amount = 5 end
			if npc.FrameCount % amount == 1 then
				local params = ProjectileParams()
				params.FallingAccelModifier = -0.05
				params.FallingSpeedModifier = 0
				npc:PlaySound(SoundEffect.SOUND_BLOODSHOOT,1,2,false,1)
				npc:FireProjectiles(npc.Position, nilvector, 0, params)
			end
		elseif d.Color == "whiteboi" then
			--aahelp at the start
		elseif d.Color == "slapbass" then
			if npc.FrameCount % creepPeriod == 1 then
				local creep = Isaac.Spawn(1000, 26, 0, npc.Position, nilvector, npc):ToEffect();
				creep.SpriteRotation = npc.SpriteRotation
				creep:SetTimeout(50)
				creep:Update()
			end
		end


	--ASSSSSSSS
	elseif subt == 3 then
		npc.RenderZOffset = -600
		d.dist = d.dist - 5
		if d.landing then
			if sprite:IsFinished("Tail_Land") then
				d.landing = false
			else
				mod:spritePlay(sprite, "Tail_Land")
			end
			npc.Velocity = npc.Velocity * 0.9
		elseif d.egglaying then
			if sprite:IsFinished("EggLay_Tail") then
				d.egglaying = false
				npc.StateFrame = 0
			elseif sprite:IsEventTriggered("Spawn") then
				npc:PlaySound(SoundEffect.SOUND_PLOP,0.7,2,false,1.07)
				local egg = Isaac.Spawn(mod.FF.TapewormEgg.ID, mod.FF.TapewormEgg.Var, d.ColorID, npc.Position + npc.Velocity:Resized(-50), nilvector, npc):ToNPC();
				egg:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
				egg:GetSprite():Play("Appear", true)
				if sprite.FlipX then
					egg:GetSprite().FlipX = true
				end
				egg:Update()
			else
				mod:spritePlay(sprite, "EggLay_Tail")
			end
		elseif npc.Parent and npc.Parent:GetData().chargetell then
			local pd = npc.Parent:GetData()
			d.chargetell = true
			d.lastdir = pd.lastdir
			mod:spritePlay(sprite, "ChargeTell_Tail_" .. pd.lastdir)
		elseif npc.Parent and npc.Parent:GetData().chargin then
			d.dist = d.dist + 5
			d.chargetell = false
			d.chargin = true
			mod:spritePlay(sprite, "Charge_Tail_" .. d.dir)
		else
			sprite:SetFrame("Tail_" .. d.dir, npc.FrameCount % 19)
			if npc.Parent then
				if npc.StateFrame > 15 and math.random(25) == 1 and d.dir == "Hori" and (not d.egglaying) and Game():GetRoom():GetGridCollisionAtPos(npc.Position + npc.Velocity:Resized(-50)) == GridCollisionClass.COLLISION_NONE and mod.GetEntityCount(mod.FF.Luncheon.ID, mod.FF.Luncheon.Var) > 0 and mod.GetEntityCount(mod.FF.TapewormEgg.ID, mod.FF.TapewormEgg.Var, d.ColorID) < 1 then
					d.egglaying = true
				end
			else
				local speed, friction, randChance, maxRotation = 6, 0.92, .5, 180
				if d.Color == "pinky" then
					friction = 0.95
					randChance = .4
					maxRotation = 60
					speed = 7.5
				elseif d.Color == "redford" then
					randChance = .2
					friction = .9
				elseif d.Color == "whiteboi" then
					randChance = .85
					maxRotation = 0
					friction = 0.85
					speed = 4
				end

				if npc.FrameCount % 19 == 10 then
					local targvel = (target.Position - npc.Position):Resized(speed):Rotated(math.random(-maxRotation, maxRotation))
					if math.random() < randChance then
						targvel = RandomVector()*speed
					end
					npc.Velocity = targvel
				end
				npc.Velocity = npc.Velocity * friction
			end
		end



		if npc.Parent then
			--npc.Position = npc.Parent.Position - mod:SnapVector(npc.Parent.Velocity:Resized(dist), 90)
			local parentvel = mod:SnapVector(npc.Parent.Velocity, 90):Rotated((((npc.Parent.Velocity:GetAngleDegrees() + 45) % 90) - 45) * rotval)
			npc.Position = mod:Lerp(npc.Position, (npc.Parent.Position - parentvel:Resized(d.dist)), 0.6)
			npc.Velocity = mod:Lerp(npc.Velocity, parentvel, 0.6)


		else
			if not npc.Parent and d.hasAltSpritesheet then
				d.hasAltSpritesheet = false
				sprite:ReplaceSpritesheet(0, "gfx/bosses/luncheon/" .. mod.TapeColors[d.ColorID].anm2 .. "_segments.png")
				sprite:LoadGraphics()
			end
		end
		local rot = (((npc.Velocity:GetAngleDegrees() + 45) % 90) - 45) * rotval
		if sprite.FlipX then
			rot = rot * -1
		end
		npc.SpriteRotation = rot
	end
end

--EGGS EGGS EEGS SEGGS EGG DOUBLE GS EGGS MY ASS IS SO TREMENDOUSLY WIDE BOYOYOYOYO
function mod:flipToTarget(npc, target, distval)
	distval = distval or 20
	local dist = math.abs(math.abs(target.Position.X) - math.abs(npc.Position.X))
	if dist > distval then
			local sprite = npc:GetSprite()
		if target.Position.X > npc.Position.X then
			sprite.FlipX = false
		else
			sprite.FlipX = true
		end
	end
end


function mod:tapewormEggAI(npc, subt)
local sprite = npc:GetSprite()
local d = npc:GetData()
local target = npc:GetPlayerTarget()

	if not d.init then
		npc.RenderZOffset = -750
		npc:AddEntityFlags(EntityFlag.FLAG_NO_TARGET)
		d.init = true
	else
		npc.StateFrame = npc.StateFrame + 1
	end

	if subt == 0 then
		npc:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
		if npc.StateFrame == 1 then
			local rand = math.random(4)
			local egg = Isaac.Spawn(mod.FF.TapewormEgg.ID, mod.FF.TapewormEgg.Var, rand, npc.Position, nilvector, npc):ToNPC();
			egg:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
			egg:GetSprite():Play("Appear", true)
			egg:Update()
			npc:Remove()
		end
	end

	npc.Velocity = npc.Velocity * 0.8

	if d.dying or mod.GetEntityCount(mod.FF.Luncheon.ID, mod.FF.Luncheon.Var) < 1 then
		if sprite:IsFinished("Death") or sprite:IsEventTriggered("Explode") then
			npc:BloodExplode()
			npc:Remove()
		else
			mod:spritePlay(sprite, "Death")
		end
	else
		if not d.appeared then
			if sprite:IsFinished("Appear") then
				d.appeared = true
				d.state = "idle"
			else
				mod:spritePlay(sprite, "Appear")
			end
		else
			--Petunia
			if subt == 1 then
				if d.state == "idle" then
					mod:spritePlay(sprite, "Idle")
					if npc.StateFrame > 30 and math.random(5) == 1 then
						d.state = "attack"
						d.targvec = target.Position - npc.Position
						if math.abs(d.targvec.X) > math.abs(d.targvec.Y) then
							d.dir = "Hori"
						else
							if d.targvec.Y > 0 then
								d.dir = "Down"
							else
								d.dir = "Up"
							end
						end

						if d.targvec.X > 0 then
							sprite.FlipX = false
						else
							sprite.FlipX = true
						end
					end
				elseif d.state == "attack" then
					if sprite:IsFinished("Puke_" .. d.dir) then
						d.state = "idle"
						npc.StateFrame = 0
					elseif sprite:IsEventTriggered("Shoot") then
						npc:PlaySound(SoundEffect.SOUND_SPEWER,1,0,false,1.3)
						d.vomming = true
						d.vomcount = 0
						d.prevVom = npc.Position
					else
						mod:spritePlay(sprite, "Puke_" .. d.dir)
					end
				end

				if d.vomming then
					d.vomcount = d.vomcount + 1
					local pos = d.prevVom + d.targvec:Resized(7)
					d.prevVom = pos
					local creep = Isaac.Spawn(1000, 22, 0, pos, nilvector, npc):ToEffect();
					creep.Color = Color(10,15,15,1,0,0,0)
					creep.Scale = ((d.vomcount + 10) / 80)
					creep.SpriteScale = creep.SpriteScale * 2.5
					creep:SetTimeout(24)
					creep:Update()

					--[[local blood = Isaac.Spawn(1000, 2, 960, pos, nilvector, npc):ToEffect()
					blood.Scale = 0.5
					blood.Color = Color(10,15,15,1,0,0,0)
					blood:Update()]]

					if d.vomcount > 14 then
						d.vomming = false
					end
				end
			--Greg
			elseif subt == 2 then
				if d.state == "idle" then
					mod:spritePlay(sprite, "Idle")
					if npc.StateFrame > 120 and math.random(15) == 1 then
						mod:flipToTarget(npc, target, 0)
						d.state = "attack"
						d.targpos = target.Position
						if target.Position.Y < npc.Position.Y then
							d.animpos = "Up"
						else
							d.animpos = "Down"
						end
					end
				elseif d.state == "attack" then
					if sprite:IsFinished("Slam_" .. d.animpos) then
						d.state = "idle"
						npc.StateFrame = 0
					elseif sprite:IsEventTriggered("Slam") then
						Game():ShakeScreen(5)
						local vec = (d.targpos - npc.Position):Resized(1)
						local crack = Isaac.Spawn(1000, 72, 0, npc.Position, vec, npc):ToEffect()
						crack.Rotation = vec:GetAngleDegrees()
						crack:Update()
					else
						mod:spritePlay(sprite, "Slam_" .. d.animpos)
					end
				end
			--Minkus
			elseif subt == 3 then
				mod:spritePlay(sprite, "Hop")
				if sprite:IsEventTriggered("Hop") then
					local pdist = target.Position:Distance(npc.Position)
					if pdist > 200 then
						d.targvec = RandomVector():Resized(10)
					else
						d.targvec = (npc.Position - target.Position):Resized(10)
					end
					if npc.Position.X < (npc.Position + d.targvec).X then
						sprite.FlipX = false
					else
						sprite.FlipX = true
					end
					npc.Velocity = mod:Lerp(npc.Velocity, d.targvec, 0.9)
					d.SHOOTBOI = true
				end
			--Boris
			elseif subt == 4 then
				mod:spritePlay(sprite, "Idle")
				if npc.FrameCount % 20 == 1 then
					local creep = Isaac.Spawn(1000, 26, 980, npc.Position, nilvector, npc):ToEffect();
					creep.SpriteScale = creep.SpriteScale * 3
					--creep:GetSprite().Scale = creep:GetSprite().Scale * 0.1
					creep:SetTimeout(150)
					creep:Update()
				end

			end
			if d.SHOOTBOI then
				d.shootcount = d.shootcount or 0
				d.shootcount = d.shootcount + 1

				npc:PlaySound(SoundEffect.SOUND_BLOODSHOOT,0.2,2,false,1)
				local params = ProjectileParams()
				local shotspeed = (npc.Velocity * -2):Resized(4):Rotated(-10+math.random(20))
				params.Scale = math.random(2, 10) / 10
				params.FallingSpeedModifier = -20 + math.random(10);
				params.FallingAccelModifier = 1.1 + math.random(2)/10;
				params.HeightModifier = -30
				params.Variant = 4
				npc:FireProjectiles(npc.Position, shotspeed, 0, params)

				if d.shootcount > 6 then
					d.SHOOTBOI = false
					d.shootcount = 0
				end
			end
		end

	end
end

--Fuckin boris >:(
function mod:borisCreepPool(e)
	local sprite = e:GetSprite()
	local d = e:GetData()
	--e.SpriteScale = e.SpriteScale * 3
	if e.FrameCount < 80 then
		if not d.smalled then
			e.SpriteScale = e.SpriteScale * 0.1
			e.SpriteRotation = math.random(360)
			d.smalled = true
		end
		--sprite.Scale = sprite.Scale * 1.15
		e.SpriteScale = e.SpriteScale * 1.032
	end
end

function mod:wormBall(npc)
local sprite = npc:GetSprite()
local d = npc:GetData()
	d.Target = d.Target or Vector(0,0)
	local dist = npc.Position:Distance(d.Target)
	npc.Velocity = mod:Lerp(npc.Velocity, (d.Target - npc.Position):Resized(dist / 10), 0.3)
	mod:spritePlay(sprite, "Launch")

	d.fallAccel = d.fallAccel or -10
	d.fallAccel = math.min(d.fallAccel + 1, 10)
	d.yOff = d.yOff or -50
	d.yOff = d.yOff + d.fallAccel

	npc.SpriteOffset = Vector(0, d.yOff)

	if npc.SpriteOffset.Y > -5 then
		local numsegments = 3
		d.segs = {}

		for i = 1, numsegments do
			local spawnSeg = 2
			if i == 1 then
				--Spawn head the first time
				spawnSeg = 1
			elseif i == numsegments then
				--Spawn tail the last time
				spawnSeg = 3
			end

			local seg = Isaac.Spawn(mod.FF.Tapeworm.ID, mod.FF.Tapeworm.Var, spawnSeg, npc.Position, nilvector, npc)
			--Parenting handling
			d.segs[i] = seg
			if d.segs[i - 1] then
				d.segs[i - 1].Child = seg
				seg.Parent = d.segs[i - 1]
			end
			--Color stuff
			local sd = seg:GetData()
			sd.ColorID = d.Color[i] or math.random(4)
			--Don't appear normally
			seg:ClearEntityFlags(EntityFlag.FLAG_APPEAR)

			--Make head flip
			if not seg.Parent then
				local flippy = 1
				if math.random(2) == 1 then flippy = -1 end
				seg.Velocity = Vector(5,0):Rotated(-10 + math.random(20)) * flippy
			end

			seg:Update()
		end

		npc:Remove()
	end
end

--POLLUTION YO
--BORN 2 LOSE SK8 AND DESTROY

mod.pollutionTricks = {
[1] = {stateName = "SpitBlot", FadeVal1 = 3, FadeVal2 = 3, Idle1 = 4, Idle2 = 7, AttackOff = 250},
[2] = {stateName = "KickFlip", FadeVal1 = 2, FadeVal2 = 2, Idle1 = 3, Idle2 = 6, AttackOff = 200},
[3] = {stateName = "BigSwing", FadeVal1 = 4, FadeVal2 = 2, Idle1 = 5, Idle2 = 6, AttackOff = 200},
[4] = {stateName = "nilpasta", FadeVal1 = 1, FadeVal2 = 1, Idle1 = 2, Idle2 = 2, AttackOff = 200},
[5] = {stateName = "EndTrick", FadeVal1 = 1, FadeVal2 = 1, Idle1 = 2, Idle2 = 2, AttackOff = 50}
}

function mod:pollutionSmoke(npc, xoff, yoff)
	xoff = xoff or 40
	yoff = yoff or 10
	if not npc:GetSprite().FlipX then
		xoff = xoff * -1
	end
	local extravel = Vector(xoff / 5, 0):Rotated(-20 + math.random(40))
	local smoke = Isaac.Spawn(1000, EffectVariant.DARK_BALL_SMOKE_PARTICLE, 0, npc.Position + Vector(xoff, yoff), extravel, npc)
	smoke:GetSprite().PlaybackSpeed = math.random() * 0.4 + 0.4
	smoke.SpriteScale = Vector(1,1)
	smoke.SpriteOffset = Vector(0, -25)
	smoke:Update()
end

function mod:pollutionAI(npc, sprite, d)
	local target = npc:GetPlayerTarget()
	local r = npc:GetDropRNG()
	local room = game:GetRoom()

	if not d.init then
		d.state = "idle"
		npc.Velocity = RandomVector() * 3
		d.init = true
		npc.SplatColor = mod.ColorDankBlackReal
	else
		npc.StateFrame = npc.StateFrame + 1
	end

	if mod.allPlayersDead() then
		npc:PlaySound(mod.Sounds.PollutionWins, 2, 0, false, 1)
	end

	if d.state ~= "crash" and npc.HitPoints < 300 then
		if not (d.substate == jumpOut or d.substate == jumpIn) then
			sfx:StopLoopingSounds()
			d.state = "crash"
			d.substate = nil
		end
	end

	if d.state == "idle" then
		mod:spritePlay(sprite, "Idle01")
		if npc.Velocity.X < 0 then
			sprite.FlipX = true
		else
			sprite.FlipX = false
		end
		npc.Velocity = mod:Lerp(npc.Velocity, npc.Velocity:Resized(3), 0.3)
		--npc.Velocity = npc.Velocity:Rotated(-10 + math.random(20))
		if npc.StateFrame > 20 then
			if d.doSomeTricks then
				d.state = "showOff"
			else
				d.state = "chase"
			end
			d.substate = nil
		end
	elseif d.state == "crash" then
		npc.Velocity = npc.Velocity * 0.7
		d.substate = d.substate or "screech"
		if d.substate == "screech" then
			if sprite:IsFinished("FallOffHorse") then
				d.substate = "horseTime"
			elseif sprite:IsEventTriggered("Fall") then
				npc:PlaySound(mod.Sounds.WhipCrack,0.7,0,false,0.7)
				local pp2 = Isaac.Spawn(mod.FF.Pollution2.ID, mod.FF.Pollution2.Var, 0, npc.Position, nilvector, npc)
				local pp2d = pp2:GetData()
				pp2.Parent = npc
				pp2d.backupPosition = npc.Position
				npc.Child = pp2
				pp2d.state = "launched"
				pp2:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
				pp2.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
				pp2.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_NONE
				pp2:Update()
				d.spawnedPhase2 = true
			else
				mod:spritePlay(sprite, "FallOffHorse")
			end
		elseif d.substate == "horseTime" then
			mod:spritePlay(sprite, "Horse")
		end
	elseif d.state == "chase" then
		d.substate = d.substate or "revThoseFryers"
		if d.substate == "revThoseFryers" then
			if sprite:IsFinished("ChaseStart") then
				d.substate = "vROOM"
				npc.StateFrame = 0
			elseif sprite:IsEventTriggered("Laugh") then
				npc:PlaySound(mod.Sounds.PollutionSmirk, 1.6, 0, false, 1.1)
			elseif sprite:IsEventTriggered("Screech") then
				npc:PlaySound(mod.Sounds.CarIgnition, 0.7, 0, false, 1.3)
			elseif sprite:IsEventTriggered("Chase") then
				d.chasing = true
			else
				mod:spritePlay(sprite, "ChaseStart")
			end
		elseif d.substate == "vROOM" then
			mod:spritePlay(sprite, "ChaseLoop")
			if npc.StateFrame > 120 then
				d.substate = "haltCitizen"
			end
		elseif d.substate == "haltCitizen" then
			if sprite:IsFinished("Halt") then
				d.state = "idle"
				npc.StateFrame = 0
				d.doSomeTricks = true
			elseif sprite:IsEventTriggered("Halt") then
				d.chasing = false
				sfx:Stop(mod.Sounds.LoopingBike)
				npc:PlaySound(mod.Sounds.SkidShort, 1, 0, false, 1)
			else
				mod:spritePlay(sprite, "Halt")
			end
		end
		if d.chasing then
			if not sfx:IsPlaying(mod.Sounds.LoopingBike) then
				sfx:Play(mod.Sounds.LoopingBike, 1, 0, true, 0.3)
			end
			if npc.Velocity.X < 0 then
				sprite.FlipX = true
			else
				sprite.FlipX = false
			end

			mod:pollutionSmoke(npc)

			--[[local targvel = (target.Position - npc.Position):Resized(9)
			npc.Velocity = mod:Lerp(npc.Velocity, targvel, 0.1)]]
			mod:CatheryPathFinding(npc, target.Position, {
			Speed = 16,
			Accel = 0.05,
			GiveUp = true
			})

			if npc.StateFrame % 2 == 0 then
				for i = -30, 30, 60 do
					local projectile = Isaac.Spawn(9, 0, 0, npc.Position, npc.Velocity:Resized(-14):Rotated(i), npc):ToProjectile();
					projectile.FallingAccel = 0
					local projdata = projectile:GetData();
					projdata.projType = "SlowDownSon"
					projdata.slowDownSpeed = 0.9
				end
			end
		else
			npc.Velocity = npc.Velocity * 0.9
		end
	elseif d.state == "showOff" then
		if not d.substate then
			npc.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_NONE
			d.tricks = {1}
			for i = 2, 3 do
				table.insert(d.tricks, math.random(#d.tricks + 1), i)
			end
			table.insert(d.tricks, 1, 4)
			table.insert(d.tricks, 5)
			d.trickNum = 1
			d.substate = "andale andale"
			if room:GetCenterPos().X > npc.Position.X then
				d.moveVec = Vector(1,0)
				sprite.FlipX = false
			else
				d.moveVec = Vector(-1,0)
				sprite.FlipX = true
			end
		end

		local inPotentialFlameState = d.substate ~= "andale andale" and d.substate ~= "BigSwing" and d.substate ~= "EndTrick"
		local inNonFlameAnim = sprite:IsPlaying("FadeIn01") or sprite:IsFinished("FadeIn01") or sprite:IsPlaying("FadeOut01") or sprite:IsPlaying("Idle02") or sprite:IsFinished("TrickStart")
		if npc.FrameCount % 4 == 0 and room:IsPositionInRoom(npc.Position, 0) and inPotentialFlameState and not inNonFlameAnim then
			local fire = Isaac.Spawn(1000,7005, 20, npc.Position - npc.Velocity:Resized(35), npc.Velocity:Resized(-1.5) + RandomVector() * .3, npc):ToEffect()
			fire:GetData().timer = 55
			--fire:GetData().gridcoll = 0
			fire.Parent = npc
			fire:Update()
		end

		if d.substate == "andale andale" then
			if sprite:IsFinished("TrickStart") then
				d.substate = "charging"
				d.chargeState = 2
			elseif sprite:IsEventTriggered("Halt") then
				npc:PlaySound(mod.Sounds.HorseGoWhee, 1, 0, false, math.random(97,103)/100)
			elseif sprite:IsEventTriggered("Laugh") then
				npc:PlaySound(mod.Sounds.PollutionLaugh, 2, 0, false, 1.3)
			elseif sprite:IsEventTriggered("Shoot") then
				d.charging = 1
				npc:PlaySound(mod.Sounds.PollutionCharge, 2, 0, false, 1)
			elseif sprite:IsEventTriggered("Screech") then
				npc:PlaySound(mod.Sounds.CarIgnition, 0.7, 0, false, 1.3)
				d.SFXSlowCharge = true
				d.playLoop = true
			else
				mod:spritePlay(sprite, "TrickStart")
			end
		elseif d.substate == "charging" then
			--[[for i = 1, #d.tricks do
				Isaac.ConsoleOutput(d.tricks[i])
			end
			Isaac.ConsoleOutput("\n")]]
			mod:pollutionSmoke(npc)

			d.playLoop = true
			mod:spritePlay(sprite, "Idle0" .. mod.pollutionTricks[d.tricks[d.trickNum]]["Idle" .. d.chargeState])
			local offval = mod.pollutionTricks[d.tricks[d.trickNum]].AttackOff
			if d.chargeState == 1 then
				if (npc.Position.X > room:GetCenterPos().X - offval and not sprite.FlipX) or
					(npc.Position.X < room:GetCenterPos().X + offval and sprite.FlipX) then
					d.substate = mod.pollutionTricks[d.tricks[d.trickNum]].stateName
					sfx:Stop(mod.Sounds.LoopingBike)
					npc:PlaySound(mod.Sounds.SkidUltraShort, 1, 0, false, math.random(60,80)/100)
					d.playLoop = false
				end
			else
				if npc.Position.X > room:GetGridWidth()*40-200 and not sprite.FlipX then
					d.substate = "jumpOut"
				elseif sprite.FlipX and npc.Position.X < 200 then
					d.substate = "jumpOut"
				end
			end
		elseif d.substate == "jumpOut" then
			local spriteToPlay = "FadeOut0" .. mod.pollutionTricks[d.tricks[d.trickNum]].FadeVal2
			if sprite:IsFinished(spriteToPlay) then
				local yPos = room:GetCenterPos().Y
				if sprite.FlipX then
					npc.Position = Vector(room:GetGridWidth()*40+100, yPos)
				else
					npc.Position = Vector(-100, yPos)
				end
				d.substate = "jumpIn"
				d.chargeState = 1
				d.trickNum = d.trickNum + 1
			elseif sprite:IsEventTriggered("Jump") then
				d.speed = 8
				npc:PlaySound(mod.Sounds.SkateboardJump, 1, 0, false, 0.9)
			else
				mod:spritePlay(sprite, spriteToPlay)
				if d.speed ~= 8 then
					mod:pollutionSmoke(npc)
				end
			end
		elseif d.substate == "jumpIn" then
			mod:pollutionSmoke(npc)
			local spriteToPlay = "FadeIn0" .. mod.pollutionTricks[d.tricks[d.trickNum]].FadeVal1
			if sprite:IsFinished(spriteToPlay) then
				d.substate = "charging"
				d.chargeState = 1
			elseif sprite:IsEventTriggered("Land") then
				d.speed = 12
				npc:PlaySound(SoundEffect.SOUND_BIRD_FLAP, 2, 0, false, 0.9)
			else
				mod:spritePlay(sprite, spriteToPlay)
			end
		elseif d.substate == "SpitBlot" then
			d.speed = 5
			if sprite:IsFinished("ShootBlot") then
				d.substate = "charging"
				d.speed = 12
				d.chargeState = 2
			elseif sprite:IsEventTriggered("Shoot") then
				npc:PlaySound(mod.Sounds.PollutionVom, 1.5, 0, false, 1)
				for i = 60, 360, 60 do
					local blotVec = Vector(4, 0):Rotated(i - 20 + math.random(40))
					local blot = Isaac.Spawn(mod.FF.Blot.ID, mod.FF.Blot.Var, 0, npc.Position + d.moveVec:Resized(-10), blotVec, npc):ToNPC();
					local blotdata = blot:GetData();
					blotdata.downvelocity = -25
					blotdata.downaccel = 2.5
					blot.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
					blot.GridCollisionClass = GridCollisionClass.COLLISION_NONE
					blot:GetSprite().Offset = Vector(0, -30)
					blotdata.state = "air"
					blot:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
					blot:Update()
				end
			else
				mod:spritePlay(sprite, "ShootBlot")
			end
		elseif d.substate == "KickFlip" then
			d.speed = 6
			if sprite:IsFinished("KickFlip") then
				d.substate = "charging"
				d.speed = 12
				d.chargeState = 2
			elseif sprite:IsEventTriggered("Jump") then
				npc:PlaySound(mod.Sounds.SkateboardJump, 1, 0, false, 1)
			elseif sprite:IsEventTriggered("Shoot") then
				d.beeterMode = true
				npc.StateFrame = 0
				d.attackang = (target.Position - npc.Position):Resized(7)
				d.strobe = Vector(d.moveVec.X * 60, 0)
				d.strobeUpd = Vector(d.moveVec.X * -12, 0)
			elseif sprite:IsEventTriggered("Land") then
				d.beeterMode = false
				sfx:Stop(SoundEffect.SOUND_ULTRA_GREED_SPINNING)
				npc:PlaySound(mod.Sounds.SkateboardLand, 1, 0, false, 1)
			else
				mod:spritePlay(sprite, "KickFlip")
			end
		elseif d.substate == "BigSwing" then
			d.speed = 4
			if sprite:IsFinished("Swing") then
				d.substate = "charging"
				d.speed = 12
				d.chargeState = 2
			elseif sprite:IsEventTriggered("Land") then
				npc:PlaySound(SoundEffect.SOUND_BIRD_FLAP, 2, 0, false, 0.9)
				sprite.FlipX = d.currentFlipVal
			elseif sprite:IsEventTriggered("Jump") then
				npc:PlaySound(mod.Sounds.BingBingWahoo, 0.1, 0, false, 0.7)
				npc:PlaySound(mod.Sounds.SkateboardJump, 1, 0, false, 1)
				d.currentFlipVal = sprite.FlipX
				if target.Position.X > npc.Position.X then
					sprite.FlipX = true
				else
					sprite.FlipX = false
				end
			elseif sprite:GetFrame() == 25 then
				npc:PlaySound(SoundEffect.SOUND_FIRE_RUSH, 1, 0, false, 1)
			elseif sprite:IsEventTriggered("Shoot") then
				local targvec = target.Position - npc.Position
				local vec
				local calc = 1
				local angie = 87.5 -- old: 80
				local angieIncrease = 35 -- old: 32
				if math.abs(targvec.X) > math.abs(targvec.Y) * 1.6 then
					calc = 2
					angie = 69 -- old: 60
					angieIncrease = 23 -- old: 20
					if target.Position.X < npc.Position.X then
						vec = Vector(-13,0)
					else
						vec = Vector(13,0)
					end
				else
					if target.Position.Y < npc.Position.Y then
						vec = Vector(0,-9)
					else
						vec = Vector(0,9)
					end
				end
				for i = -angie, angie, angieIncrease do
					local multcalc
					if calc == 1 then
						multcalc = (1 + math.abs(i)/100)
					else
						multcalc = (1.6 - math.abs(i)/100)
					end
					local fire = Isaac.Spawn(1000,7005, 20, npc.Position, (vec * multcalc):Rotated(i) * 0.95, npc):ToEffect()
					fire:GetData().timer = 50
					fire:GetData().gridcoll = 0
					fire.Parent = npc
					fire:Update()
				end
			else
				mod:spritePlay(sprite, "Swing")
			end
		elseif d.substate == "EndTrick" then
			d.charging = 2
			if sprite:IsFinished("Shoot") then
				d.substate = "nil"
				d.speed = nil
				d.chargeState = nil
				d.state = "idle"
				d.doSomeTricks = false
				npc.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_GROUND
				d.SFXSlowCharge = false
				sfx:Stop(mod.Sounds.SlowMotor)
				npc.StateFrame = -30
			elseif sprite:IsEventTriggered("Shoot") then
				npc:PlaySound(mod.Sounds.PollutionSpit,1.5,0,false,math.random(80,110)/100)
				d.charging = false
				local gunk = Isaac.Spawn(mod.FF.Punk.ID, mod.FF.Punk.Var, 1, npc.Position, (target.Position - npc.Position):Resized(7), npc)
				gunk.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS
				gunk:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
				gunk.SpriteOffset = Vector(0, -20)
				gunk.HitPoints = gunk.MaxHitPoints * 0.6
			else
				mod:spritePlay(sprite, "Shoot")
			end
		end

		if d.charging == 1 then
			d.speed = d.speed or 16
			npc.Velocity = mod:Lerp(npc.Velocity, d.moveVec:Resized(d.speed), 0.3)
		elseif d.charging == 2 then
			npc.Velocity = npc.Velocity * 0.9
		else
			npc.Velocity = npc.Velocity * 0.1
		end
		--[[if d.playLoop then
			if not sfx:IsPlaying(mod.Sounds.LoopingBike) then
				sfx:Play(mod.Sounds.LoopingBike, 1, 0, true, 0.8)
			end
		end]]
		if d.SFXSlowCharge then
			if not sfx:IsPlaying(mod.Sounds.SlowMotor) then
				sfx:Play(mod.Sounds.SlowMotor, 1, 0, true, 0.8)
			end
		end
		if d.beeterMode then
			if not sfx:IsPlaying(SoundEffect.SOUND_ULTRA_GREED_SPINNING) then
				sfx:Play(SoundEffect.SOUND_ULTRA_GREED_SPINNING, 0.4, 0, true, 1.8)
			end
			if npc.StateFrame % 3 == 0 then
				local params = ProjectileParams()
				params.FallingAccelModifier = -0.09
				for i = 1, 3 do
					npc:FireProjectiles(npc.Position + d.strobe, d.attackang:Rotated(120*i), 0, params)
				end
				local rotvec = 20
				if sprite.FlipX then rotvec = rotvec * -1 end
				d.attackang = d.attackang:Rotated(rotvec)
				d.strobe = d.strobe + d.strobeUpd
			end
		end
	end

	if npc:HasMortalDamage() then
		sfx:StopLoopingSounds()
	end
end

function mod:pollution2RenderAI(npc)
	local sprite = npc:GetSprite()
	if sprite:IsPlaying("Death") then
		sprite:RemoveOverlay()
		if sprite:IsEventTriggered("Explode") then
			sfx:Play(mod.Sounds.WormSplode, 1, 0, false, 1)
		end
	end
end

--PollutionPart2, PollutionPhase2, Pollution Part 2, Pollution Phase 2, Pollution2AI, etc.
function mod:pollutionHorsepowerAI(npc, sprite, d)
	local room = game:GetRoom()
	local target = npc:GetPlayerTarget()
	local r = npc:GetDropRNG()

	if not d.init then
		d.state = d.state or "idle"
		d.init = true
		npc.SplatColor = mod.ColorDankBlackReal
	else
		npc.StateFrame = npc.StateFrame + 1
	end

	if mod.allPlayersDead() then
		npc:PlaySound(mod.Sounds.PollutionWins2, 2, 0, false, 1)
	end

	if d.state == "launched" then
		if not d.substate then
			d.fallspeed = -14
			npc.SpriteOffset = Vector(0, -20)
			d.substate = "falloff"
			mod:spritePlay(sprite, "InAir01")
		elseif d.substate == "falloff" then
			if d.fallspeed > 0 then
				if sprite:IsFinished("Apex01") then
					mod:spritePlay(sprite, "Fall01")
				end
			elseif d.fallspeed > -10 then
				mod:spritePlay(sprite, "Apex01")
			else
				mod:spritePlay(sprite, "InAir01")
			end

			local targvec = room:GetCenterPos() - npc.Position
			npc.Velocity = mod:Lerp(npc.Velocity, targvec * 0.1, 0.3)

			d.fallspeed = d.fallspeed + 1
			npc.SpriteOffset = Vector(0, npc.SpriteOffset.Y + d.fallspeed)

			if npc.SpriteOffset.Y > -5 then
				d.substate = "land"
				npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS
				npc.SpriteOffset = Vector(0, 0)
				mod:spritePlay(sprite, "Land")
				npc.Velocity = nilvector
				npc:BloodExplode()

				sfx:Play(SoundEffect.SOUND_BONE_SNAP, 0.6, 0, false, 0.7)

				local headExplode = Isaac.Spawn(1000,7009,0,npc.Position + Vector(0, 10),nilvector,npc):ToEffect()
				local hES = headExplode:GetSprite()
				hES:ReplaceSpritesheet(2, "gfx/bosses/pollution/effect_meltypoof_butpollution.png")
				hES:LoadGraphics()
				headExplode:Update()

				for i = -30, 30, 30 do
					local blotVec = Vector(0, 4):Rotated(i - 20 + math.random(40))
					local blot = Isaac.Spawn(mod.FF.Blot.ID, mod.FF.Blot.Var, 0, npc.Position, blotVec, npc):ToNPC();
					local blotdata = blot:GetData();
					blotdata.downvelocity = -15
					blotdata.downaccel = 2.5
					blot.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
					blot.GridCollisionClass = GridCollisionClass.COLLISION_NONE
					blot:GetSprite().Offset = Vector(0, -10)
					blotdata.state = "air"
					blot:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
					blot:Update()
				end
			end
		elseif d.substate == "land" then
			npc.Velocity = npc.Velocity * 0.3
			npc.SpriteOffset = Vector(0, 0)
			if sprite:IsFinished("Land") then
				d.fallspeed = -14
				npc.SpriteOffset = Vector(0, -20)
				d.substate = "jumpback"
				npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
				npc:PlaySound(SoundEffect.SOUND_SHELLGAME, 1, 0, false, 1)
			else
				mod:spritePlay(sprite, "Land")
			end
		elseif d.substate == "jumpback" then
			if d.fallspeed > 0 then
				if sprite:IsFinished("Apex02") then
					mod:spritePlay(sprite, "Fall02")
				end
			elseif d.fallspeed > -10 then
				mod:spritePlay(sprite, "Apex02")
			else
				mod:spritePlay(sprite, "InAir02")
			end
			d.fallspeed = d.fallspeed + 1
			npc.SpriteOffset = Vector(0, npc.SpriteOffset.Y + d.fallspeed)

			if npc.Parent then
				d.aimedPos = npc.Parent.Position
			else
				d.aimedPos = d.backupPosition
			end

			local targvec = d.aimedPos - npc.Position
			npc.Velocity = mod:Lerp(npc.Velocity, targvec * 0.1, 0.3)

			if npc.SpriteOffset.Y > -5 then
				d.substate = "appear"
				npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_ALL
				npc.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_GROUND
				npc.SpriteOffset = Vector(0, 0)
				mod:spritePlay(sprite, "Appear")
				npc.Velocity = nilvector
				if npc.Parent then
					if npc.Parent:GetSprite().FlipX then
						sprite.FlipX = true
					end
					npc.Parent:Remove()

					npc:PlaySound(SoundEffect.SOUND_SHELLGAME, 1, 0, false, 0.7)
					npc:PlaySound(SoundEffect.SOUND_SLOTSPAWN,1.3,0,false, 0.5)
					npc:PlaySound(mod.Sounds.CarIgnition, 1, 0, false, 0.8)

					--Horse
					local vec = (target.Position - npc.Position) * 0.04
					local horse = Isaac.Spawn(mod.FF.ThrownHorse.ID, mod.FF.ThrownHorse.Var, 0, npc.Position, vec, npc):ToNPC();
					local horsed = horse:GetData()
					horse.SpriteOffset = Vector(0,-30)
					horsed.vec = vec
					horsed.fallspeed = -7
					horse:Update()
				end
			end
		elseif d.substate == "appear" then
			if sprite:IsFinished("Appear") then
				d.state = "idle"
			else
				mod:spritePlay(sprite, "Appear")
			end
		end
	elseif d.state == "idle" then
		--npc.Velocity = mod:Lerp(

		--[[if not sfx:IsPlaying(mod.Sounds.SteamTrain) then
			sfx:Play(mod.Sounds.SteamTrain, 0.7, 0, true, 0.9)
		end]]

		mod:CatheryPathFinding(npc, target.Position, {
			Speed = 11,
			Accel = 0.05,
			GiveUp = true
		})

		if npc.FrameCount % 6 == 2 then
			--sfx:Play(SoundEffect.SOUND_FETUS_JUMP, 1, 0, false, 0.7)
			for i = -30, 30, 30 do
				local fire = Isaac.Spawn(1000,7005, 20, npc.Position + Vector(0,-50), npc.Velocity:Resized(-5):Rotated(i) + Vector(0, 3), npc):ToEffect()
				fire:GetData().timer = 50
				--fire:GetData().gridcoll = 0
				fire.Parent = npc
				fire:Update()
			end
		end

		if math.abs(npc.Velocity.X) > math.abs(npc.Velocity.Y) then
			mod:spritePlay(sprite, "WalkHori")
			mod:spriteOverlayPlay(sprite, "HeadHori")
			if npc.Velocity.X < 0 then
				sprite.FlipX = true
			else
				sprite.FlipX = false
			end
		else
			if npc.Velocity.Y > 0 then
				mod:spritePlay(sprite, "WalkDown")
				mod:spriteOverlayPlay(sprite, "HeadDown")
			else
				mod:spritePlay(sprite, "HeadUp")
				mod:spriteOverlayPlay(sprite, "WalkUp")
			end
		end
		if npc.StateFrame > 150 then
			d.state = "charge"
			mod:spritePlay(sprite, "ChargeStart")
			sprite:RemoveOverlay()
			if target.Position.X > npc.Position.X then
				d.chargeVec = mod:Lerp(Vector(1, 0), (target.Position - npc.Position):Normalized(), 0.5):Normalized()
				sprite.FlipX = false
			else
				sprite.FlipX = true
				d.chargeVec = mod:Lerp(Vector(-1, 0), (target.Position - npc.Position):Normalized(), 0.5):Normalized()
			end
			d.substate = nil
		end
	elseif d.state == "charge" then
		d.substate = d.substate or "initTheBinch"
		if d.substate == "initTheBinch" then
			if sprite:IsFinished("ChargeStart") then
				d.substate = "loopyLoop"
			elseif sprite:IsEventTriggered("Shoot") then
				npc:PlaySound(mod.Sounds.HorseGoWhee, 1, 0, false, math.random(80,85)/100)
			elseif sprite:IsEventTriggered("Charge") then
				d.chargin = true
				npc.StateFrame = 0
			else
				mod:spritePlay(sprite, "ChargeStart")
			end
		elseif d.substate == "loopyLoop" then
			mod:spritePlay(sprite, "ChargeLoop")
		elseif d.substate == "impact" then
			if sprite:IsFinished("Impact") then
				d.state = "framebreath"
				d.timesFired = 0
				d.substate = nil
				npc.StateFrame = -1
			else
				mod:spritePlay(sprite, "Impact")
			end
		end

		if d.chargin then
			npc.Velocity = d.chargeVec:Resized(17)
			for k,v in ipairs(mod.GetGridEntities()) do
				if v.Position:Distance(npc.Position + d.chargeVec:Resized(30)) < 30 then
					v:Destroy()
				end
			end
			if npc.FrameCount % 3 == 2 then
				--sfx:Play(SoundEffect.SOUND_FETUS_JUMP, 1, 0, false, 0.7)
				for i = -60, 60, 60 do
					local fire = Isaac.Spawn(1000,7005, 20, npc.Position + Vector(0,-50), npc.Velocity:Resized(-5):Rotated(i) + Vector(0, 3), npc):ToEffect()
					fire:GetData().timer = 50
					--fire:GetData().gridcoll = 0
					fire.Parent = npc
					fire:Update()
				end
			end
			if npc.StateFrame > 5 and npc:CollidesWithGrid() then
				d.chargin = false
				npc.Velocity = nilvector
				d.substate = "impact"
				mod:spritePlay(sprite, "Impact")
				game:ShakeScreen(15)
				npc:PlaySound(SoundEffect.SOUND_HELLBOSS_GROUNDPOUND, 1, 0, false, 1)
			end
		else
			npc.Velocity = npc.Velocity * 0.9
		end
	elseif d.state == "framebreath" then
		npc.Velocity = npc.Velocity * 0.7
		d.substate = d.substate or "start"
		local targvec = target.Position - npc.Position
		if d.substate == "start" then
			if math.abs(targvec.X) > math.abs(targvec.Y) then
				sprite:SetFrame("WalkHori", 0)
				sprite:SetOverlayFrame("HeadHoriShootStart", npc.StateFrame)
				if targvec.X < 0 then
					sprite.FlipX = true
				else
					sprite.FlipX = false
				end
			else
				if targvec.Y > 0 then
					sprite:SetFrame("WalkDown", 0)
					sprite:SetOverlayFrame("HeadDownShootStart", npc.StateFrame)
				else
					sprite:SetFrame("HeadUpShootStart", npc.StateFrame)
					sprite:SetOverlayFrame("WalkUp", 0)
				end
			end

			if npc.StateFrame > 13 then
				d.substate = "flameWar"
				npc:PlaySound(mod.Sounds.FriedLoop,1,0,true,1)
			elseif npc.StateFrame == 5 then
				d.rotval = 0
				d.firing = true
				npc:PlaySound(mod.Sounds.FriedStart,1,0,false,0.7)
				d.targetedVec = targvec
			end
		elseif d.substate == "flameWar" then
			local targvec = d.targetedVec
			if math.abs(targvec.X) > math.abs(targvec.Y) then
				sprite:SetFrame("WalkHori", 0)
				mod:spriteOverlayPlay(sprite, "HeadHoriShoot")
				if targvec.X < 0 then
					sprite.FlipX = true
				else
					sprite.FlipX = false
				end
			else
				if targvec.Y > 0 then
					sprite:SetFrame("WalkDown", 0)
					mod:spriteOverlayPlay(sprite, "HeadDownShoot")
				else
					mod:spritePlay(sprite, "HeadUpShoot")
					sprite:SetOverlayFrame("WalkUp", 0)
				end
			end
		end
		if d.firing then
			d.rotval = d.rotval or 0
			d.rotval = d.rotval + 1
			if d.rotval > 60 then
				d.timesFired = d.timesFired + 1
				if d.timesFired > 2 then
					d.state = "idle"
				else
					d.substate = nil
				end
				d.firing = false
				npc.StateFrame = -1
				sfx:Stop(mod.Sounds.FriedLoop)
				npc:PlaySound(mod.Sounds.FriedEnd,1,0,false,0.7)
			end
			if npc.FrameCount % 2 == 1 then
				local emberParticle = Isaac.Spawn(1000,66, 0, npc.Position, d.targetedVec:Resized(math.random(4,7)):Rotated(-35 + math.random(70)), npc):ToEffect()
				emberParticle.SpriteOffset = Vector(0, -20)
				emberParticle:Update()

				local smoke = Isaac.Spawn(1000, EffectVariant.DARK_BALL_SMOKE_PARTICLE, 0, npc.Position, d.targetedVec:Resized(math.random(4,7)):Rotated(-35 + math.random(70)), npc)
				smoke.SpriteRotation = math.random(360)
				smoke.Color = Color(1,1,1,0.3,75 / 255,70 / 255,50 / 255)
				--smoke.SpriteScale = Vector(2,2)
				smoke.SpriteOffset = Vector(0, -20)
				smoke.RenderZOffset = 300
				smoke:Update()
			end
			if d.rotval % 4 == 0 then
				for i = -50, 50, 50 do
					local vec = (d.targetedVec):Resized(10):Rotated(i + math.sin((d.rotval) / 6.5) * 15) -- used to be (val / 6) * 15, lower first value = faster rotation, lower second value = less extreme rotation
					local fire = Isaac.Spawn(1000,7005, 0, npc.Position + Vector(0,-30), vec, npc):ToEffect()
					fire:SetColor(Color(1,1,1,1,-100 / 255,70 / 255,455 / 255),10,1,true,false)
					fire:GetData().flamethrower = true
					fire:GetData().timer = 50
					--fire:GetData().gridcoll = 1
					fire.Parent = npc
					fire:Update()
				end
			end
		end
	end

	if npc:HasMortalDamage() then
		sfx:StopLoopingSounds()
	end
end

function mod:horse(npc)
	local d = npc:GetData()
	local r = npc:GetDropRNG()

	if not d.init then
		npc:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
		npc:AddEntityFlags(EntityFlag.FLAG_NO_TARGET)
		d.init = true
	end
	d.vec = d.vec or nilvector
	npc.Velocity = d.vec

	mod:spritePlay(npc:GetSprite(), "Spin")

	if npc.SpriteOffset.Y > -20 then
		npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYERONLY
	else
		npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
	end

	d.fallspeed = d.fallspeed or -5
	d.fallspeed = d.fallspeed + 0.5
	npc.SpriteOffset = Vector(0, npc.SpriteOffset.Y + d.fallspeed)

	if npc:CollidesWithGrid() or npc.SpriteOffset.Y > 0 then
		--npc:PlaySound(SoundEffect.SOUND_MEATHEADSHOOT,1,0,false,0.7)
		Isaac.Explode(npc.Position, npc, 10)
		local sploshEffect = Isaac.Spawn(1000, 1739, 0, npc.Position, nilvector, npc):ToEffect()
		sploshEffect.SpriteOffset = npc.SpriteOffset
		sploshEffect:Update()
		npc:Remove()
	end
end

function mod:meltdown2RenderAI(npc)
	local sprite = npc:GetSprite()
	if sprite:IsPlaying("Death") then
		if sprite:IsEventTriggered("Scream") then
			sfx:Play(mod.Sounds.MDP2_Death, 1, 0, false, 1)
		end
	end
end

function mod:meltdownAI(npc, sprite, d)
	local room = game:GetRoom()
	local target = npc:GetPlayerTarget()

	if not d.init then
		d.state = "idle"
		d.spawnedMorsel = {}
		d.init = true
		d.flinchDenial = true
	else
		npc.StateFrame = npc.StateFrame + 1
	end

	if npc.HitPoints < npc.MaxHitPoints * 0.55 and room:IsPositionInRoom(npc.Position, 0) then
		d.state = "CantTakeItAnymore"
	end
	if d.state == "idle" and npc.FrameCount % 3 == 1 and not d.flinchDenial then
		for i = 1, 20 do
			if (not d.spawnedMorsel[i]) and npc.HitPoints < npc.MaxHitPoints * (0.05 * i) then
				d.state = "flinch"
				d.flinchDenial = true
			end
		end
	end

	if d.state == "CantTakeItAnymore" then
		npc.Velocity = nilvector
		if sprite:IsFinished("Transition") then
			npc:Remove()
		else
			mod:spritePlay(sprite, "Transition")
		end

			--All da sounds
		if sprite:IsEventTriggered("Blink") then
			npc:PlaySound(mod.Sounds.Boink,1,0,false,math.random(80,120)/100)
		elseif sprite:IsEventTriggered("Grrrrrrrr") then
			npc:PlaySound(mod.Sounds.MDP1_TransGrr,1,0,false,1)
		elseif sprite:IsEventTriggered("Scream") then
			npc:PlaySound(mod.Sounds.MetalDrop,0.8,0,false,0.7)
			npc:PlaySound(SoundEffect.SOUND_BONE_SNAP,0.8,0,false,0.7)
		elseif sprite:IsEventTriggered("Shoot") then
			sfx:Play(mod.Sounds.WingFlap,1,0,false,math.random(120,130)/100)
		elseif sprite:IsEventTriggered("Grah") then
			sfx:Play(mod.Sounds.MDP1_TransThrow,1,0,false,1)
		elseif sprite:IsEventTriggered("Strangle") then
			npc:PlaySound(mod.Sounds.StretchEye,0.8,0,false,1)
			npc:PlaySound(mod.Sounds.MDP1_TransitionStrangle,1,0,false,1)
		elseif sprite:IsEventTriggered("OhShit") then
			npc:PlaySound(mod.Sounds.GlobSurprise,1,0,false,0.7)
		elseif sprite:IsEventTriggered("RipSound") then
			sfx:Stop(mod.Sounds.StretchEye)
			npc:PlaySound(mod.Sounds.ClothRip,1,0,false,1)
		elseif sprite:GetFrame() == 162 then
			npc:PlaySound(mod.Sounds.Nuke,1,0,false,1)
		elseif sprite:GetFrame() == 165 then
			--npc:PlaySound(mod.Sounds.Nuke,2,0,false,1)
			npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
			npc.RenderZOffset = 1000000
			game:ShakeScreen(60)
		elseif sprite:GetFrame() == 117 then
			npc:PlaySound(mod.Sounds.BusterDethBeep,1,0,false,1.4)
			--Actual Transition bit
		elseif sprite:GetFrame() == 170 then
			local phase2 = Isaac.Spawn(mod.FF.Meltdown2.ID, mod.FF.Meltdown2.Var, 0, npc.Position, nilvector, npc)
			phase2:GetData().state = "transition"
			phase2:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
			phase2:Update()
			d.spawnedPhase2 = true
		elseif sprite:GetFrame() > 170 and sprite:GetFrame() < 180 then
			if StageAPI then
				StageAPI.ChangeRoomGfx(mod.SmokyBackdrop)
			end
		end
	elseif d.state == "flinch" then
		d.flinchChoice = d.flinchChoice or math.random(2)
		if sprite:IsFinished("Flinch0" .. d.flinchChoice) then
			d.state = "idle"
			d.flinchChoice = nil
		elseif sprite:IsEventTriggered("Spawn") then
			npc:PlaySound(mod.Sounds.MDP1_Flinch, 1, 0, false, 1)
			for i = 1, 20 do
				if (not d.spawnedMorsel[i]) and npc.HitPoints < npc.MaxHitPoints * (0.05 * i) then
					local skin = Isaac.Spawn(mod.FF.Falafel.ID, mod.FF.Falafel.Var, 0, npc.Position + Vector(0, 5) + RandomVector():Resized(0.5 + math.random(25)/10), Vector(0, 1):Rotated(-45 + math.random(90)):Resized(0.5 + math.random(25)/10), npc)
					skin.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
					skin:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
					skin:GetData().fallspeed = -8 - math.random(4)
					skin.SpriteOffset = Vector(0, -10 - math.random(20))
					skin:GetData().fallaccel = 1
					skin:GetData().state = "thrown"
					skin:Update()
					d.spawnedMorsel[i] = true
				end
			end
		else
			mod:spritePlay(sprite, "Flinch0" .. d.flinchChoice)
		end
	elseif d.state == "idle" then
		if not (sprite:IsPlaying("Twitch") or sprite:IsPlaying("Flinch01") or sprite:IsPlaying("Flinch02")) then
			mod:spritePlay(sprite, "Idle")
			if sprite:GetFrame() == 18 and math.random(2) == 1 then
				mod:spritePlay(sprite, "Twitch")
			end
		end

		if npc.StateFrame % 30 == 0 or (not d.targetvel) then
			local gridtarget = mod:FindRandomFreePosAir(target.Position, 120)
			d.targetvel = (gridtarget - npc.Position):Resized(5)
		end
		if d.targetvel then
			npc.Velocity = mod:Lerp(npc.Velocity, d.targetvel, 0.05)
			if d.targetvel.X < 0 then
				sprite.FlipX = true
			else
				sprite.FlipX = false
			end
		end

		if npc.StateFrame > 60 and math.random(5) == 1 then
			d.targetvel = nil
			d.flinchDenial = false
			local choice = math.random(3)
			if d.justBonkd then
				choice = math.random(2)
			end
			if choice == 1 and not d.justChargd then
				d.state = "charge"
				d.cstate = nil
				d.justChargd = true
				d.justBombd = false
				d.justBonkd = false
				mod:spritePlay(sprite, "DashStart")
				if room:GetCenterPos().X < npc.Position.X then
					sprite.FlipX = true
				else
					sprite.FlipX = false
				end
			elseif choice == 2 and not d.justBombd then
				d.state = "bomberboy"
				d.justBombd = true
				d.justChargd = false
				d.justBonkd = false
				d.cstate = "throw"
				d.flippin = true
			else
				d.state = "bonk"
				d.justBombd = false
				d.justChargd = false
				if target.Position.X < npc.Position.X then
					sprite.FlipX = true
				else
					sprite.FlipX = false
				end
				d.flippin = true
			end
		end
	elseif d.state == "bonk" then
		npc.Velocity = npc.Velocity * 0.7
		if d.flippin then
			if target.Position.X < npc.Position.X then
				sprite.FlipX = true
			else
				sprite.FlipX = false
			end
		end
		if sprite:IsFinished("HitHorse") then
			d.state = "idle"
			d.justBonkd = true
			npc.StateFrame = 40
		elseif sprite:IsEventTriggered("Grrrrrrrr") then
			--npc:PlaySound(mod.Sounds.BuckAppear2, 1, 0, false, 1.2)
		elseif sprite:IsEventTriggered("Scream") then
			npc:PlaySound(mod.Sounds.MDP1_HitHorseScream, 1, 0, false, 1)
		elseif sprite:IsEventTriggered("Grah") then
			--npc:PlaySound(mod.Sounds.MDP1_HitHorseStart, 1, 0, false, 1)
		elseif sprite:GetFrame() == 39 then
			npc:PlaySound(mod.Sounds.MDP1_HitHorseStart, 1, 0, false, 1)
		elseif sprite:IsEventTriggered("Shoot") then
			npc:PlaySound(mod.Sounds.FunnyBonk,2,0,false,math.random(90,100)/100)
			npc:PlaySound(SoundEffect.SOUND_MEATY_DEATHS,1,1,false,1)
			for i = -15, 15, 15 do
				local vec = (target.Position - npc.Position):Resized(13):Rotated(i)
				if i == 0 then
					vec = vec:Resized(17)
				end
				--npc:FireProjectiles(npc.Position + vec:Resized(15), vec, 0, ProjectileParams())
				local proj = Isaac.Spawn(9, 0, 0, npc.Position + vec:Resized(15), vec, npc):ToProjectile()
				proj:GetData().projType = "Radioactive"
				proj:GetSprite():ReplaceSpritesheet(0, "gfx/projectiles/radioactive.png")
				proj:GetSprite():LoadGraphics()
				proj:Update()
			end
			d.flippin = false
		else
			mod:spritePlay(sprite, "HitHorse")
		end
	elseif d.state == "bomberboy" then
		npc.Velocity = npc.Velocity * 0.7
		if d.flippin then
			if target.Position.X < npc.Position.X then
				sprite.FlipX = true
			else
				sprite.FlipX = false
			end
		end
		if d.cstate == "throw" then
			if sprite:IsFinished("TNTThrow") then
				--[[d.state = "idle"
				d.waitinForBarrel = true
				npc.StateFrame = 30]]
				d.cstate = "loogie"
			elseif sprite:IsEventTriggered("Grah") then
				npc:PlaySound(mod.Sounds.MDP1_TNT_1, 1, 0, false, 1)
			elseif sprite:IsEventTriggered("Scream") then
				npc:PlaySound(mod.Sounds.MDP1_TNT_2, 1, 0, false, 1)
			elseif sprite:IsEventTriggered("Shoot") then
				npc:PlaySound(mod.Sounds.MDP1_TNT_3, 1, 0, false, 1)
				d.flippin = false
				local spawnPoint = (target.Position - npc.Position)
				spawnPoint = npc.Position + spawnPoint:Resized(math.max(120, spawnPoint:Length()))
				local pos = room:FindFreeTilePosition(spawnPoint, 10)
				d.rememberThis = pos
				local barrel = Isaac.Spawn(mod.FF.NuclearWaste.ID, mod.FF.NuclearWaste.Var, 0, npc.Position, nilvector, npc)
				barrel.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_WALLS
				barrel.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
				local bd = barrel:GetData()
				bd.targpos = pos
				bd.state = "inair"
				bd.fallspeed = -15
				bd.fallaccel = 1
				barrel:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
				if sprite.FlipX then
					barrel:GetSprite().FlipX = true
				end
				barrel:Update()
			elseif sprite:GetFrame() == 44 then
				sfx:Play(SoundEffect.SOUND_SHELLGAME,2,0,false,math.random(80,90)/100)
			else
				mod:spritePlay(sprite, "TNTThrow")
			end
		elseif d.cstate == "loogie" then
			if sprite:IsFinished("SpitFireball") then
				d.state = "idle"
				npc.StateFrame = 0
			elseif sprite:IsEventTriggered("OhShit") then
				npc:PlaySound(mod.Sounds.MDP1_DashStartGrah, 1, 0, false, 0.7)
			elseif sprite:IsEventTriggered("Shoot") then
				npc:PlaySound(mod.Sounds.MDP1_DashEnd, 1, 0, false, 0.7)
				d.flippin = false
				local ash = mod.FindClosestUnlitPowder(npc.Position, npc)
				local targetpos = target.Position
				if ash then
					targetpos = ash.Position
				end
				local vel = (targetpos - npc.Position) * 0.03
				local coal = Isaac.Spawn(9, 1, 0, npc.Position, vel, npc):ToProjectile()
				local coald = coal:GetData()
				coald.projType = "coalRadioactive"
				coald.projSpeed = 5
				coal.FallingSpeed = -15
				coal.FallingAccel = 1
				--coal.Color = Color(0.5,1.5,1,1,0,0,0)
				local coals = coal:GetSprite()
				coals:Load("gfx/projectiles/sooty_tear_radioactive.anm2",true)
				coals:Play("spin",true)
				coal:Update()
			else
				mod:spritePlay(sprite, "SpitFireball")
			end
		else
			d.cstate = "throw"
		end
	elseif d.state == "charge" then
		if sprite:IsFinished("DashStart") then
			mod:spritePlay(sprite, "Dash")
		end
		if not d.cstate then
			npc.Velocity = npc.Velocity * 0.7
			if sprite:IsEventTriggered("Grah") then
				npc:PlaySound(mod.Sounds.MDP1_DashStartStart, 1, 0, false, 1)
			elseif sprite:IsEventTriggered("Scream") then
				npc:PlaySound(mod.Sounds.MDP1_DashStartScream, 1, 0, false, 1)
			elseif sprite:IsEventTriggered("Dash") or sprite:IsFinished("DashStart") or sprite:IsPlaying("Dash") then
				npc:PlaySound(mod.Sounds.MDP1_DashStartGrah, 1, 0, false, 1)
				d.cstate = "GOOO"
				npc.StateFrame = 0
				npc.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_NONE
			end
		end
		if d.cstate == "GOOO" then
			local chargeVec = Vector(math.min(30, (15 + npc.StateFrame * 0.5)), 0)
			if sprite.FlipX then
				chargeVec = chargeVec * -1
			end
			npc.Velocity = mod:Lerp(npc.Velocity, chargeVec, 0.7)

			local changeState
			if npc.Position.X > room:GetGridWidth()*50+200 and not sprite.FlipX then
				changeState = true
			elseif sprite.FlipX and npc.Position.X < -200 then
				changeState = true
			end

			if changeState then
				d.cstate = "watchingFromTheEdge"
				local yPos = target.Position.Y
				local spawnPos
				if sprite.FlipX then
					spawnPos = Vector(room:GetGridWidth()*50+200, yPos)
				else
					spawnPos = Vector(-200, yPos)
				end
				npc.Position = spawnPos + Vector(0, -200)
				d.Saveposition = npc.Position
				npc.Visible = false
				npc.Velocity = nilvector
				local fakehorse = Isaac.Spawn(mod.FF.FakeHorse.ID, mod.FF.FakeHorse.Var, 0, spawnPos, nilvector, npc):ToNPC()
				fakehorse:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
				if sprite.FlipX then fakehorse:GetSprite().FlipX = true end
				fakehorse:GetData().vec = chargeVec:Resized(15)
				d.chargeVec = chargeVec:Resized(15)
				fakehorse.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_NONE
				fakehorse:Update()
				npc.Child = fakehorse
			end

		end
		if d.cstate == "watchingFromTheEdge" then
			d.Saveposition = d.Saveposition or npc.Position
			npc.Position = d.Saveposition
			if (npc.Child and (not npc.Child:Exists())) or (not npc.Child) then
				npc.Child = nil
				local ypos = 100
				local chargey = 5
				if target.Position.Y < room:GetCenterPos().Y then
					ypos = (room:GetGridHeight() * 50) + 30
					chargey = -5
				end
				npc.Position = Vector(npc.Position.X, ypos)
				npc.Velocity = Vector(d.chargeVec.X, chargey):Resized(15)
				npc.TargetPosition = npc.Position + npc.Velocity:Resized(500)
				--Isaac.Spawn(1000,1,0,npc.TargetPosition,nilvector,nil)
				npc.Visible = true
				d.cstate = "reenter"
			end
		end
		if d.cstate == "reenter" then
			npc.TargetPosition = npc.TargetPosition or player.Position
			local targvec = (npc.TargetPosition - npc.Position):Resized(15)
			npc.Velocity = mod:Lerp(npc.Velocity, targvec, 0.1)
			if room:IsPositionInRoom(npc.Position, 0) then
				npc.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_WALLS
				mod:spritePlay(sprite, "DashEnd")
				d.cstate = "slowit"
			end
		end
		if d.cstate == "slowit" then
			npc.Velocity = npc.Velocity * 0.9
			if sprite:IsFinished("DashEnd") then
				d.state = "idle"
				npc.StateFrame = 0
				if math.random(3) ~= 1 then
					d.state = "bonk"
					d.flippin = true
				end
			elseif sprite:GetFrame() == 5 then
				npc:PlaySound(mod.Sounds.MDP1_DashEnd, 1, 0, false, 1)
			else
				mod:spritePlay(sprite, "DashEnd")
			end
		end
	end
end
function mod:meltdownForsakenAI(npc, sprite, d)
	local room = game:GetRoom()
	local r = npc:GetDropRNG()
	local target = npc:GetPlayerTarget()
	if not d.init then
		d.init = true
		mod.meltdownForsakenTearStuff = nil
		d.state = d.state or "idle"
		npc.SplatColor = mod.ColorCharred
	else
		npc.StateFrame = npc.StateFrame + 1
	end

	npc.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_WALLS

	if d.state == "transition" then
		npc.Velocity = npc.Velocity * 0.7
		if npc.FrameCount < 60 then
			mod:spritePlay(sprite, "TransitionIdle")
		else
			if sprite:IsFinished("Appear") then
				d.state = "idle"
			elseif sprite:IsEventTriggered("Scream") then
				npc:PlaySound(mod.Sounds.MDP2_Appear,1,0,false,1)
				npc:PlaySound(mod.Sounds.FireLight, 2, 0, false, 1)
			else
				mod:spritePlay(sprite, "Appear")
			end
		end
	elseif d.state == "idle" then
		if d.pickedUp then
			mod:spritePlay(sprite, "Idle02")
			if npc.StateFrame > 30 then
				d.state = "dropTheBomb"
			end
		else
			mod:spritePlay(sprite, "Idle01")
		end
		d.goPassives = true
		local nuke = mod.FindClosestEntity(npc.Position, 99999, mod.FF.DavyCrockett.ID, mod.FF.DavyCrockett.Var)
		if nuke and nuke:GetData().state == "sitte" and not d.pickedUp then
			local targvec = (nuke.Position - npc.Position):Resized(8)
			npc.Velocity = mod:Lerp(npc.Velocity, targvec, 0.05)

			if npc.Position:Distance(nuke.Position) < 20 then
				npc.Velocity = nilvector
				npc.Position = nuke.Position + Vector(0, -5)
				d.state = "pickup"
				d.nuke = nuke
			end
		else
			if npc.StateFrame % 30 == 0 or (not d.targetvel) then
				local gridtarget = mod:FindRandomFreePosAir(target.Position, 120)
				d.targetvel = (gridtarget - npc.Position):Resized(8)
			end
			if d.targetvel then
				npc.Velocity = mod:Lerp(npc.Velocity, d.targetvel, 0.05)
			end
		end
	elseif d.state == "pickup" then
		if (d.nuke and d.nuke:Exists()) or d.pickedUp then
			if d.nuke then
				npc.Position = d.nuke.Position + Vector(0, -5)
			end
			if sprite:IsFinished("PickUpBomb") then
				d.state = "idle"
				npc.StateFrame = 0
			elseif sprite:IsEventTriggered("Strain") then
				npc:PlaySound(mod.Sounds.MDP2_PickupStrain,1,1,false,1)
				mod:spritePlay(d.nuke:GetSprite(), "Shake")
				d.nuke.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
			elseif sprite:IsEventTriggered("PickUp") then
				d.pickedUp = true
				d.nuke:Remove()
				npc:PlaySound(mod.Sounds.MDP2_PickupPickup,1,1,false,1)
				sfx:Stop(mod.Sounds.MDP2_PickupScream)
			elseif sprite:IsEventTriggered("OhBoy") then
				npc:PlaySound(mod.Sounds.MDP2_PickupOhboy,1,1,false,1)
			elseif sprite:IsEventTriggered("Scream") then
				sfx:Stop(mod.Sounds.MDP2_PickupOhboy)
				npc:PlaySound(mod.Sounds.MDP2_PickupScream, 1, 0, false, 1)
			else
				mod:spritePlay(sprite, "PickUpBomb")
			end
		else
			d.state = "idle"
			d.nuke = nil
		end
	elseif d.state == "dropTheBomb" then
		if sprite:IsFinished("ThrowBomb") then
			d.state = "idle"
			d.pickedUp = false
		elseif sprite:IsEventTriggered("Shoot") then
			npc:PlaySound(mod.Sounds.MDP2_Throw,1,0,false,1)
			sfx:Play(SoundEffect.SOUND_SHELLGAME,2,0,false,math.random(120,130)/100)
			local pos = room:FindFreeTilePosition(target.Position, 10)
			local barrel = Isaac.Spawn(mod.FF.DavyCrockett.ID, mod.FF.DavyCrockett.Var, 0, npc.Position, nilvector, npc)
			barrel.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_WALLS
			barrel.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
			local bd = barrel:GetData()
			bd.targpos = pos
			barrel.SpriteOffset = Vector(0, -20)
			bd.state = "inair"
			bd.fallspeed = -15
			bd.fallaccel = 1
			barrel:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
			if sprite.FlipX then
				barrel:GetSprite().FlipX = true
			end
			barrel:Update()
		elseif sprite:IsEventTriggered("OhBoy") then

		elseif sprite:IsEventTriggered("Strain") then
			npc:PlaySound(mod.Sounds.MDP2_ThrowStrain,1,0,false,1)
		else
			mod:spritePlay(sprite, "ThrowBomb")
		end
	end


	if d.goPassives then
		--Radioactive tears
		mod.meltdownForsakenTearStuff = {
			{StartPos = Vector(room:GetCenterPos().X - 100, 50),		ShootVec = Vector(5, 10):Resized(9)},
			{StartPos = Vector(room:GetCenterPos().X + 100, 50),		ShootVec = Vector(-5, 10):Resized(9)},
			{StartPos = Vector(room:GetCenterPos().X - 100, 50),		ShootVec = Vector(-5, 10):Resized(9)},
			{StartPos = Vector(room:GetCenterPos().X + 100, 50),		ShootVec = Vector(5, 10):Resized(9)},
			}
		if npc.FrameCount % 25 == 0 then
			d.prevRandomThing = d.prevRandomThing or 1
			local randomThing = d.prevRandomThing
			while randomThing == d.prevRandomThing do
				randomThing = r:RandomInt(#mod.meltdownForsakenTearStuff) + 1
			end
			d.prevRandomThing = randomThing
			local mfts = mod.meltdownForsakenTearStuff[randomThing]
			local proj = Isaac.Spawn(9, 0, 0, mfts.StartPos, mfts.ShootVec:Resized(5), npc):ToProjectile()
			proj.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_NONE
			proj.FallingSpeed = -0.1
			proj.FallingAccel = -0.1
			proj.ProjectileFlags = proj.ProjectileFlags | ProjectileFlags.NO_WALL_COLLIDE
			proj:GetData().projType = "Radioactive"
			proj:GetSprite():ReplaceSpritesheet(0, "gfx/projectiles/radioactive.png")
			proj:GetSprite():LoadGraphics()
			proj:Update()
		end

		--Fire
		if npc.FrameCount % 25 == 1 then
			d.fireRots = d.fireRots or 0
			d.fireRots = d.fireRots + 1
			local vec = Vector(0,7):Rotated(45 * d.fireRots)
			for i = 72, 360, 72 do
				local fire = Isaac.Spawn(1000,7005, 10, npc.Position + Vector(0,-50), vec:Rotated(i) + npc.Velocity, npc):ToEffect()
				fire:GetData().timer = 35
				--fire:GetData().gridcoll = 0
				--fire.Color = Color(0.5,1.5,1,1,0,0,0)
				fire:GetSprite():ReplaceSpritesheet(0, "gfx/effects/effect_005_fire_radioactive.png")
				fire:GetSprite():LoadGraphics()
				fire:GetData().timeTested = true
				fire:GetData().initVel = vec:Rotated(i)
				fire:GetData().parentcounter = 1
				fire:GetData().subt10val1 = 1.5
				fire:GetData().subt10val2 = 1
				fire.Parent = npc
				fire:Update()
			end
		end

		--Spawn Nuke
		mod.nukeDrops = mod.nukeDrops or {}
		if mod.GetEntityCount(mod.FF.DavyCrockett.ID, mod.FF.DavyCrockett.Var) < 1 and (not d.pickedUp) and not (#mod.nukeDrops > 0) then
			local spawnPoint = room:FindFreeTilePosition(npc.Position, 120)
			local nuke = Isaac.Spawn(mod.FF.DavyCrockett.ID, mod.FF.DavyCrockett.Var, 0, spawnPoint, nilvector, npc)
			local nd = nuke:GetData()
			nd.state = "drop"
			nuke:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
			nuke.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
			nuke:Update()
		end
	end
end

function mod:meltdownBombHorseAI(npc, sprite, d)
	local room = game:GetRoom()
	if d.vec then
		d.vec = d.vec * 1.02
		if d.vec:Length() > 40 then
			d.vec = d.vec:Resized(40)
		end
		npc.Velocity = d.vec
	end
	mod:spritePlay(sprite, "Dash")
	if room:IsPositionInRoom(npc.Position, 0) then
		npc.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_NOPITS
	end
	if npc:CollidesWithGrid() or npc:IsDead() then
		Isaac.Explode(npc.Position, npc, 25)
		for i = 90, 360, 90 do
			Isaac.Explode(npc.Position + Vector(50, 0):Rotated(i), npc, 25)
		end
		if not npc:IsDead() then
			npc:Kill()
		end
	end
end

function mod:davyCrockettAI(npc, subt)
	local d = npc:GetData()
	local sprite = npc:GetSprite()

	if d.state == "drop" then
		npc.SpriteOffset = Vector(0, -5)
		if sprite:IsFinished("Fall") then
			d.state = "sitte"
		elseif sprite:IsEventTriggered("DropThaBomb") then
			npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYERONLY
			npc:PlaySound(SoundEffect.SOUND_SHOVEL_DROP, 1, 0, false, 1)
		else
			mod:spritePlay(sprite, "Fall")
		end
	elseif d.state == "sitte" then
		npc.SpriteOffset = Vector(0, -5)
		npc.Velocity = npc.Velocity * 0.5
		if not sprite:IsPlaying("Shake") then
			mod:spritePlay(sprite, "Idle02")
		end
	elseif d.state == "inair" then
		mod:spritePlay(sprite, "InAir")
		local vec = d.targpos - npc.Position
		npc.Position = npc.Position + vec * 0.02
		npc.Velocity = vec * 0.02
		d.fallspeed = d.fallspeed + d.fallaccel
		npc.SpriteOffset = Vector(0, npc.SpriteOffset.Y + d.fallspeed)
		if npc.SpriteOffset.Y > 0 then
			npc:Remove()
		end
	end
	if npc:IsDead() or mod.GetEntityCount(mod.FF.Meltdown2.ID, mod.FF.Meltdown2.Var) < 1 then
		--Isaac.Explode(npc.Position, nil, 25)
		game:BombExplosionEffects(npc.Position, 10, DamageFlag.DAMAGE_TNT, mod.ColorNormal, npc, 1, false, true)
		mod.nukeDrops = mod.nukeDrops or {}
		table.insert(mod.nukeDrops, {spawner = npc, pos = npc.Position, count = 0})
		if not npc:IsDead() then
			npc:Remove()
		end
	end
end

function mod.nukePathLogic()
	if mod.nukeDrops and #mod.nukeDrops > 0 then
		local room = game:GetRoom()
		for _, bomb in pairs(mod.nukeDrops) do
			bomb.count = bomb.count + 1
			--if bomb.count < 6 then
				--[[if bomb.count % 2 == 1 then
					local spawnedAny
					for i = 90, 360, 90 do
						local spawnpos = bomb.pos + Vector(bomb.count * 40, 0):Rotated(i)
						if room:IsPositionInRoom(spawnpos, 0) then
							spawnedAny = true
							game:BombExplosionEffects(spawnpos, 10, DamageFlag.DAMAGE_TNT, mod.ColorNormal, bomb.spawner, 1, false, true)
						end
					end
					if not spawnedAny then
						mod.nukeDrops = {}
					end
				end]]
				if bomb.count % 2 == 1 then
					local spawnedAny
					for i = 90, 360, 90 do
						local spawnpos = bomb.pos + Vector(bomb.count * 20, 0):Rotated(i)
						if room:IsPositionInRoom(spawnpos, 0) then
							spawnedAny = true
							local vec = RandomVector():Resized(math.random(10,20)/10)
							local fire = Isaac.Spawn(1000,7005, 20, spawnpos + vec, vec * 0.1, nil):ToEffect()
							fire:GetData().timer = 10
							fire:GetData().timeTested = true
							--fire:GetData().gridcoll = 0
							--fire.Color = Color(0.5,1.5,1,1,0,0,0)
							fire:GetSprite():ReplaceSpritesheet(0, "gfx/effects/effect_005_fire_radioactive.png")
							fire:GetSprite():LoadGraphics()
							fire:Update()
						end
					end
					if bomb.count % 4 ~= 1 then
						for i = 45, 315, 90 do
							local spawnpos = bomb.pos + Vector(bomb.count * 5, 0):Rotated(i)
							if room:IsPositionInRoom(spawnpos, 0) then
								spawnedAny = true
								local vec = RandomVector():Resized(math.random(10,20)/10)
								local fire = Isaac.Spawn(1000,7005, 20, spawnpos + vec, vec * 0.1, nil):ToEffect()
								fire:GetData().timer = 10
								fire:GetData().timeTested = true
								--fire:GetData().gridcoll = 0
								--fire.Color = Color(0.5,1.5,1,1,0,0,0)
								fire:GetSprite():ReplaceSpritesheet(0, "gfx/effects/effect_005_fire_radioactive.png")
								fire:GetSprite():LoadGraphics()
								fire:Update()
							end
						end
					end
					if bomb.count % 4 ~= 1 and (not spawnedAny) then
						mod.nukeDrops = {}
					end
				end
			--end
		end
	end
end

function mod:nuclearWasteBarrelAI(npc, subt)
	local d = npc:GetData()
	local sprite = npc:GetSprite()

	if d.state == "inair" then
		mod:spritePlay(sprite, "InAir")
		local vec = d.targpos - npc.Position
		npc.Position = npc.Position + vec * 0.02
		npc.Velocity = vec * 0.02
		d.fallspeed = d.fallspeed + d.fallaccel
		npc.SpriteOffset = Vector(0, npc.SpriteOffset.Y + d.fallspeed)
		if npc.FrameCount > 5 and (not d.lastAsh or d.lastAsh and npc.Position:Distance(d.lastAsh) > 25) then
			mod.SpawnGunpowder(npc, npc.Position, 999999, 15, nil, nil, nil, nil, "gfx/effects/effect_005_fire_radioactive.png")
			d.lastAsh = npc.Position
		end
		if npc.SpriteOffset.Y > 0 then
			npc.SpriteOffset = nilvector
			d.state = "landed"
			npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_ALL
			npc.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_GROUND
			mod:spritePlay(sprite, "Land")
		end
	elseif d.state == "landed" then
		npc.Velocity = nilvector
		if not sprite:IsPlaying("Land") then
			if npc.FrameCount > 100 then
				npc.SpriteOffset = (Vector((npc.FrameCount % 2 == 0 and 0.6 or -0.6), 0))
			end
			mod:spritePlay(sprite, "Idle")
		end
		if mod.FindClosestFire(npc.Position,30) or npc:HasMortalDamage() or npc.FrameCount > 150 then
			Isaac.Explode(npc.Position, nil, 25)
			for i = 45, 360, 45 do
				local fire = Isaac.Spawn(1000,7005, 0, npc.Position, Vector(12, 0):Rotated(i), npc):ToEffect()
				fire:GetData().timer = 150
				fire:GetData().Friction = 0.9
				--fire:GetData().gridcoll = 0
				--fire.Color = Color(0.5,1.5,1,1,0,0,0)
				fire:GetSprite():ReplaceSpritesheet(0, "gfx/effects/effect_005_fire_radioactive.png")
				fire:GetSprite():LoadGraphics()
				fire.Parent = npc
				fire:Update()
			end
			npc:Remove()
		end
	end
end

function mod:bossProjectileCollision(proj, entity, mysteryBoolean)
	if entity.Type == mod.FF.Dusk.ID and entity.Variant == mod.FF.Dusk.Var then
		if proj.SpawnerEntity and proj.SpawnerEntity.Parent and proj.SpawnerEntity.Parent.InitSeed == entity.InitSeed then
			return true
		end
	elseif entity.Type == mod.FF.DuskHand.ID and entity.Variant == mod.FF.DuskHand.Var then
		if proj.SpawnerEntity and proj.SpawnerEntity.Parent and proj.SpawnerEntity.Parent.InitSeed == entity.Parent.InitSeed then
			return true
		end
	elseif entity.Type == mod.FF.Kingpin.ID and entity.Variant == mod.FF.Kingpin.Var then
		if proj.SpawnerEntity and proj.SpawnerEntity.Type == mod.FF.Kingpin.ID and proj.SpawnerEntity.Variant == mod.FF.Kingpin.Var and mod:isInSegmentsOf(entity, proj.SpawnerEntity) then
			return true
		end
	elseif entity.Type == mod.FF.Tapeworm.ID and entity.Variant == mod.FF.Tapeworm.Var then
		if proj.SpawnerEntity and proj.SpawnerEntity.Type == mod.FF.Tapeworm.ID and proj.SpawnerEntity.Variant == mod.FF.Tapeworm.Var and mod:isInSegmentsOf(entity, proj.SpawnerEntity) then
			return true
		end
	end
end
mod:AddCallback(ModCallbacks.MC_PRE_PROJECTILE_COLLISION, mod.bossProjectileCollision)

function mod:bossCollision(boss, entity, mysteryBoolean)
	local var = boss.Variant
	if var == 0 and boss.SubType == 100 then
		if entity.Type == 1 and boss:GetData().state == "chase" then
			Isaac.Explode(boss.Position, boss, 10)
			boss:Kill()
		end
	end
	if var == 10 then
		if entity:IsEnemy() then
			local d = boss:GetData()
			if d.state == "charge" then
				if d.chargestate == 2 then
					if entity.Type == 33 then
						entity:Kill()
						boss:TakeDamage(20, 0, EntityRef(boss), 0)
					end
					entity:TakeDamage(20, 0, EntityRef(boss), 0)
				end
			end
		end
	elseif boss.Variant >= 50 and boss.Variant <= 55 and entity.Type == mod.FFID.Boss and entity.Variant >= 50 and entity.Variant <= 55 then
		return false
	elseif boss.Variant == 55 and entity.Type == 4 and entity:GetData().sun and entity.FrameCount <= 10 then
		return false
	elseif boss.Variant >= 60 and boss.Variant <= 63 and entity.Type == mod.FFID.Boss and entity.Variant >= 60 and entity.Variant <= 63 then
		return true
	elseif boss.Variant == mod.FF.Basco.Var then
		return mod:bascoCollision(boss, entity)
	elseif boss.Variant == mod.FF.Kingpin.Var then
		if entity.Type == mod.FF.Kingpin.ID and entity.Variant == mod.FF.Kingpin.Var and mod:isInSegmentsOf(entity, boss) then
			return true
		end
	elseif boss.Variant == mod.FF.Tapeworm.Var then
		if entity.Type == mod.FF.Tapeworm.ID and entity.Variant == mod.FF.Tapeworm.Var and mod:isInSegmentsOf(entity, boss) then
			return true
		end
	elseif var == 120 then
		if entity.Type == 33 then
			entity:Kill()
		end
	elseif var == 122 then
		if entity.Type == 33 then
			entity:Kill()
			return false
		elseif entity:IsEnemy() or entity.Type == 1 then
			boss:Kill()
		end
	elseif var == mod.FF.Dusk.Var then
		mod:duskColl(boss, entity)
	elseif var == mod.FF.DuskHand.Var then
		mod:duskHandColl(boss, entity)
	elseif var == mod.FF.Cacamancer.Var then
		if entity.Type == mod.FF.CacaSplurt.ID and entity.Variant == mod.FF.CacaSplurt.Var then
			if boss:GetData().charging and not entity:GetData().collCool then
				entity.Velocity = boss.Velocity
				if math.abs(boss.Position.X - entity.Position.X) > math.abs(boss.Position.Y - entity.Position.Y) then
					boss.Velocity = Vector(-boss.Velocity.X, boss.Velocity.Y)
				else
					boss.Velocity = Vector(boss.Velocity.X, -boss.Velocity.Y)
				end
				entity:GetData().collCool = 3
			end
		end
	elseif var == mod.FF.Emmission.Var then
		return mod:emmissionColl(boss, entity)
	elseif var == mod.FF.EmmissionProjectile.Var then
		mod:emmissionProjectileColl(boss, entity)
	end
end
mod:AddCallback(ModCallbacks.MC_PRE_NPC_COLLISION, mod.bossCollision, mod.FFID.Boss)

--Projectile updates

--this function makes projectiles have special effects and aesthetics! i'll kill you
function mod.postprojupdate(projectile, projdata)
	local rando = 1;
	--creep check
	if projdata.creeptype then
		if projdata.creeptype == "brown" then
			projectile.SplatColor = mod.ColorBrowniePoop;
			if projectile:CollidesWithGrid() or projectile:IsDead() then
				local creep = Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.CREEP_SLIPPERY_BROWN, 0, projectile.Position, Vector(0,0), projectile):ToEffect();
				if projdata.creepsize then
					creep.SpriteScale = projdata.creepsize;
				end
				if projdata.creepduration then
					creep:SetTimeout(projdata.creepduration)
				end
				creep:Update();
			end
		elseif projdata.creeptype == "green" then
			if projectile:CollidesWithGrid() or projectile:IsDead() then
				local creep = Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.CREEP_GREEN, 0, projectile.Position, Vector(0,0), projectile):ToEffect();
				if projdata.creepsize then
					creep.SpriteScale = projdata.creepsize;
				end
				if projdata.creepduration then
					creep:SetTimeout(projdata.creepduration)
				end
				creep:Update();
			end
		elseif projdata.creeptype == "black" then
			if projectile:CollidesWithGrid() or projectile:IsDead() then
				local creep = Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.CREEP_BLACK, 0, projectile.Position, Vector(0,0), projectile):ToEffect();
				if projdata.creepsize then
					creep.SpriteScale = projdata.creepsize;
				end
				if projdata.creepduration then
					creep:SetTimeout(projdata.creepduration)
				end
				creep:Update();
			end
		elseif projdata.creeptype == "white" then
			if projectile:CollidesWithGrid() or projectile:IsDead() then
				local creep = Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.CREEP_WHITE, 0, projectile.Position, Vector(0,0), projectile):ToEffect();
				if projdata.creepsize then
					creep.SpriteScale = projdata.creepsize;
				end
				if projdata.creepduration then
					creep:SetTimeout(projdata.creepduration)
				end
				creep:Update();
			end
		elseif projdata.creeptype == "red" then
			if projectile:CollidesWithGrid() or projectile:IsDead() then
				local creep = Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.CREEP_RED, 0, projectile.Position, Vector(0,0), projectile):ToEffect();
				if projdata.creepsize then
					creep.SpriteScale = projdata.creepsize;
				end
				if projdata.creepduration then
					creep:SetTimeout(projdata.creepduration)
				end
				creep:Update();
			end
		end
	end
	-- worm check
	if projdata.wormchance then
		if projectile:IsDead() then
			if projdata.wormchecknumber then
				for i = 1, projdata.wormchecknumber, 1 do
					rando = math.random(1, projdata.wormchance.Y)
					if rando <= projdata.wormchance.X then
					Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.WORM, 0, projectile.Position, Vector(0,0), projectile);
					end
				end
			else
				rando = math.random(1, projdata.wormchance.Y)
				if rando <= projdata.wormchance.X then
					Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.WORM, 0, projectile.Position, Vector(0,0), projectile);
				end
			end
		end
	end
	--fly check
	if projdata.flychance then
		if projectile:IsDead() then
			if projdata.flychecknumber then
				for i = 1, projdata.flychecknumber, 1 do
					rando = math.random(1, projdata.wormchance.Y)
					if rando <= projdata.flychance.X then
					Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.TINY_FLY, 0, projectile.Position, Vector(0,0), projectile);
					end
				end
			else
				rando = math.random(1, projdata.flychance.Y)
				if rando <= projdata.flychance.X then
					Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.TINY_FLY, 0, projectile.Position, Vector(0,0), projectile);
				end
			end
		end
	end
	--splattering
	if projdata.special then
		if projdata.special == "loadshot" then
			if projectile:IsDead() then
				--pool of creep
				local creep = Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.CREEP_SLIPPERY_BROWN, 0, projectile.Position, Vector(0,0), projectile):ToEffect();
				creep.SpriteScale = Vector(4.5, 3.5);
				if projdata.special2 then
					creep:SetTimeout(280)
				else
					--doesnt change color, will need fixin
					creep.Color = Color(0,0,0,1,102 / 255,61 / 255,40 / 255)
				end
				creep:Update()
				--explosion
				Isaac.Explode(projectile.Position, projectile, 2)
				--tear splatter
				if projdata.special2 then
					Isaac.Spawn(295, 0, 0, projectile.Position, nilvector, projectile);
				else
					local tearnumber = math.random(6,10);
					for I = 1, tearnumber, 1 do
						local corncheck = math.random(1,4);
						if corncheck ~= 4 then
							--normal tear
							local projectile2 = Isaac.Spawn(EntityType.ENTITY_PROJECTILE, ProjectileVariant.PROJECTILE_PUKE, 0, projectile.Position, (RandomVector()*(math.random()+math.random(6,10))), projectile):ToProjectile();
							local projdata2 = projectile:GetData();
							projectile2.FallingSpeed = -(math.random(20,35));
							projectile2.FallingAccel = 2;
							projdata2.creeptype = "brown";
							projdata2.creepsize = Vector(0.6,0.5);
							local s = projectile2:GetSprite()
							s:ReplaceSpritesheet(0, "gfx/projectiles/cornpoop_projectile.png")
							s:LoadGraphics()
						else
							--corn tear, for funsies
							local projectile2 = Isaac.Spawn(EntityType.ENTITY_PROJECTILE, ProjectileVariant.PROJECTILE_CORN, 0, projectile.Position, (RandomVector()*(math.random()+math.random(3,7))), projectile):ToProjectile();
							local projdata2 = projectile:GetData();
							projectile2.FallingSpeed = -(math.random(15,30));
							projectile2.FallingAccel = 2.5;
							projdata2.creeptype = "brown";
							projdata2.wormchance = Vector(1,4);
							projdata2.wormchecknumber = 2;
							projdata2.flychance = Vector(1,2);
						end
					end
				end
			end
		elseif projdata.special == "curdled" then
			if projectile.FrameCount % 5 == 0 then
				local trail = Isaac.Spawn(1000, 111, 0, projectile.Position, Vector(0,0), projectile):ToEffect()
				trail:GetSprite().Offset = Vector(0, projectile.Height * 0.75)
			end
			if projectile:IsDead() then
				local projnum = math.random(6, 8)
				for i = 1, projnum, 1 do
					local projectile2 = Isaac.Spawn(EntityType.ENTITY_PROJECTILE, 0, 0, projectile.Position, Vector(1,0):Rotated((i * 360/projnum) + math.random(-15, 15)):Resized(math.random(5, 8)), projectile):ToProjectile()
					projectile2.FallingSpeed = -1 * math.random(15, 20)
					projectile2.FallingAccel = 2;
					projectile2.Scale = math.random(7, 15)/10
					--projectile2:GetSprite():ReplaceSpritesheet(0, "gfx/projectiles/tears_balloon.png")
					projectile2:GetSprite():LoadGraphics()
					Isaac.Spawn(1000, 14, 1, projectile.Position, Vector(0,0), projectile)
					sfx:Play(SoundEffect.SOUND_MEAT_IMPACTS, 1, 0, false, 1.5)
				end
			end
		end
	end
end

function mod.postprojupdate2(v,d)
	local room = game:GetRoom()
	local projectile = v
	local data = d

	if data.projType == "dank slime" then
		if projectile:IsDead() then
			--mod.cheekyspawn(v.Position, v, v.Position, 950, 0, 0)
			--mod.spawnent(v, v.Position, nilvector, mod.FF.TarBubble.ID)

			Isaac.Spawn(mod.FF.TarBubble.ID, mod.FF.TarBubble.Var, 0, projectile.Position, Vector.Zero, projectile.SpawnerEntity or projectile)
		end
	elseif data.projType == "septic slime" then
		if projectile:IsDead() then
			local slime = Isaac.Spawn(mod.FF.TarBubble.ID, mod.FF.TarBubble.Var, 8, projectile.Position, Vector.Zero, projectile.SpawnerEntity or projectile)

			local sprite = slime:GetSprite()
			sprite:ReplaceSpritesheet(0, "gfx/bosses/tsar/slime_septic.png")
			sprite:LoadGraphics()
		end
	elseif data.projType == "pee slime" then
		if projectile:IsDead() then
			local slime = Isaac.Spawn(mod.FF.TarBubble.ID, mod.FF.TarBubble.Var, 9, projectile.Position, Vector.Zero, projectile.SpawnerEntity or projectile)

			local sprite = slime:GetSprite()
			sprite:ReplaceSpritesheet(0, "gfx/bosses/tsar/slime_pee.png")
			sprite:LoadGraphics()
		end
	elseif data.projType == "poop slime" then
		if projectile:IsDead() then
			local slime = Isaac.Spawn(mod.FF.TarBubble.ID, mod.FF.TarBubble.Var, 10, projectile.Position, Vector.Zero, projectile.SpawnerEntity or projectile)

			local sprite = slime:GetSprite()
			sprite:ReplaceSpritesheet(0, "gfx/bosses/tsar/slime_poop.png")
			sprite:LoadGraphics()
		end
	elseif d.projType == "thrownbomb" then
		if not d.replacesprite then
			local s = v:GetSprite()
			s:Load("gfx/projectiles/projectile_bomb.anm2", true)
			if d.projTypeS then
				s:Play("Golden", true)
			elseif d.pinkBomb then
				s:Play("Red", true)
			elseif d.poopBomb then
				s:Play("Poop", true)
			elseif d.copperBomb then
				s:Play("Copper", true)
			else
				s:Play("Normal", true)
			end
			d.replacesprite = true
		end
		v.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
		if v:IsDead() then
			if d.projTypeS then
				local bomb = Isaac.Spawn(4, 0, 0, v.Position, v.Velocity, v)
				bomb.SpawnerEntity = v.SpawnerEntity
				local bs = bomb:GetSprite()
				bs:Load("gfx/projectiles/goldbomb.anm2",true)
				bs:Play("Pulse",true)
			elseif d.pinkBomb then
				local bomb = Isaac.Spawn(4, 13, 0, v.Position, v.Velocity, v):ToBomb()
				bomb:ToBomb():SetExplosionCountdown(20)
				bomb.SpawnerEntity = v.SpawnerEntity
			elseif d.copperBomb then
				local bomb = Isaac.Spawn(4, 923, 0, v.Position, v.Velocity, v):ToBomb()
				bomb.ExplosionDamage = bomb.ExplosionDamage * 1.85
				bomb:GetData().FFCopperBomb = true
				bomb:ToBomb():SetExplosionCountdown(20)
				bomb.SpawnerEntity = v.SpawnerEntity
			elseif d.poopBomb then
				local bomb = Isaac.Spawn(4, 9, 0, v.Position, v.Velocity, v):ToBomb()
				bomb:ToBomb():SetExplosionCountdown(20)
				bomb.SpawnerEntity = v.SpawnerEntity
			else
				local bomb = Isaac.Spawn(4, 0, 0, v.Position, v.Velocity, v)
				bomb.SpawnerEntity = v.SpawnerEntity
			end
			v:Remove()
		end
	elseif d.projType == "buckbomb" then
		if not d.replacesprite then
			local s = v:GetSprite()
			s:Load("gfx/projectiles/projectile_bomb.anm2", true)
			if d.projTypeS then
				s:Play("Golden", true)
			else
				s:Play("Normal", true)
			end
			d.replacesprite = true
		end
		v.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
		if v:IsDead() then
			--local snagger = mod.FindClosestEntity(v.Position,100,mod.FF.Snagger.ID,mod.FF.Snagger.Var,0);

			--if snagger ~= nil then
				local bomb = Isaac.Spawn(5, 40, 1, v.Position, v.Velocity:Resized(math.min(v.Velocity:Length(), 7)), v)
				bomb:GetSprite():Play("Idle", true)
				bomb.EntityCollisionClass = EntityCollisionClass.ENTCOLL_ALL
				bomb:GetData().buckBomb = true
				bomb.SpawnerEntity = v.SpawnerEntity
				bomb:Update()
				if d.projTypeS then
					local bs = bomb:GetSprite()
					bs:Load("gfx/projectiles/goldbomb.anm2",true)
					bs:Play("Pulse",true)
				end
			--else
			--	Isaac.Explode(v.Position, v, 10)
			--end

			--if d.projTypeS then
			--local bs = bomb:GetSprite()
			--bs:Load("gfx/projectiles/goldbomb.anm2",true)
			--bs:Play("Pulse",true)
			--end
			v:Remove()
		end
	elseif d.projType == "CricBod" then
		if v:IsDead() then
			sfx:Play(SoundEffect.SOUND_MEAT_IMPACTS, 1, 0, false, 1.5);
			local vec = RandomVector()*5
			for i = 90, 360, 90 do
				projectile = Isaac.Spawn(9, 0, 0, v.Position + vec:Rotated(i), vec:Rotated(i), v):ToProjectile();
				projectile.FallingSpeed = -10;
				projectile.FallingAccel = 1.5;
				projectile.ProjectileFlags = v.ProjectileFlags
				mod:makeProjectileConsiderFriend(v.SpawnerEntity, projectile)
			end
		end
	elseif d.projType == "CricBod2" then
		if v:IsDead() then
			sfx:Play(SoundEffect.SOUND_MEAT_IMPACTS, 1, 0, false, 1.5);
			local vec = Vector(5,0)
			for i = 90, 360, 90 do
				projectile = Isaac.Spawn(9, 0, 0, v.Position + vec:Rotated(i), vec:Rotated(i), v):ToProjectile();
				projectile.FallingSpeed = -10;
				projectile.FallingAccel = 1.5;
				projectile.ProjectileFlags = v.ProjectileFlags
			end
		end
	elseif d.projType == "yummer" then
		if v:IsDead() then
			sfx:Play(SoundEffect.SOUND_MEAT_IMPACTS, 1, 0, false, 1.5);
			local vec = Vector(9,0)
			for i = 45, 360, 45 do
				projectile = Isaac.Spawn(9, 0, 0, v.Position + vec:Rotated(i), vec:Rotated(i), v):ToProjectile();
				projectile.FallingSpeed = -10;
				projectile.FallingAccel = 1.5;
				projectile.ProjectileFlags = v.ProjectileFlags
			end
		end
	elseif d.projType == "superGrimace" then
		v.Velocity = v.Velocity * math.max(0.5,(1 - v.FrameCount / 200))

		if v:IsDead() then
			for i = 90, 360, 90 do
				local shootvec = Vector(9,0):Rotated(i)
				local proj = Isaac.Spawn(9,0,0,v.Position + shootvec:Resized(10), shootvec, v):ToProjectile()
				mod:makeProjectileConsiderFriend(v.SpawnerEntity, proj)
				proj:Update()
			end
			sfx:Play(SoundEffect.SOUND_DEATH_BURST_SMALL)
			v:Die()
		end
	elseif d.projType == "GraterShot" then
		if v:IsDead() then
			local creep = Isaac.Spawn(1000, 26, 0, v.Position, nilvector, npc):ToEffect()
			creep.SpriteScale = Vector(4, 4)
			creep:SetTimeout(100)
			creep:Update()
		end
	elseif d.projType == "boomerang" then
		--[[if not sfx:IsPlaying(SoundEffect.SOUND_ULTRA_GREED_SPINNING) then
			sfx:Play(SoundEffect.SOUND_ULTRA_GREED_SPINNING, 0.2, 0, true, 1)
		end
		if v:IsDead() then
			sfx:Stop(SoundEffect.SOUND_ULTRA_GREED_SPINNING)
		end]]
		if v.Position:Distance(d.origpos) < 3 and v.FrameCount > 20 then
			v.Velocity = nilvector
			v.FallingAccel = 1
		end
		if d.state == 1 then
			if v.Velocity:Length() > 10 then
				v.Velocity = v.Velocity:Resized(15)
			elseif v.Velocity:Length() < 10 then
				v.Velocity = v.Velocity * 1.08
			end
			if v.Velocity:Length() < 2.5 then
				v.Velocity = v.Velocity * 1.08
			end
		else
			v.Velocity = v.Velocity * 0.92
			if v.Velocity:Length() < 2.5 then
				v.Velocity = v.Velocity * 0.92
			end
			if v.Velocity:Length() < 0.5 then
				v.Velocity = v.Velocity * -1
				d.state = 1
			end
		end
	elseif d.projType == "dank trail" then
		if v.FrameCount % 3 == 0 then
			local creep = Isaac.Spawn(1000, 26, 0, v.Position+RandomVector()*10, nilvector, v):ToEffect()
			creep:SetTimeout(150)
			creep:Update()
		end
	elseif d.projType == "septic trail" then
		if v.FrameCount % 3 == 0 then
			local c = Isaac.Spawn(1000, 23, 0, v.Position+RandomVector()*10, nilvector, v):ToEffect()
			c.Timeout = 150
		end
		if v:IsDead() then
			local c = Isaac.Spawn(1000, 23, 0, v.Position, nilvector, v)
			c.SpriteScale = Vector(2.5, 2.5)
			c:Update()
		end
	elseif d.projType == "quick septic trail" then
		if v.FrameCount % 3 == 0 then
			local c = Isaac.Spawn(1000, 23, 0, v.Position, nilvector, v):ToEffect()
			c.SpriteScale = Vector(0.8, 0.8)
			c:Update()
			c.Timeout = 45
		end
	elseif d.projType == "boomerang2" then
		--[[if not sfx:IsPlaying(SoundEffect.SOUND_ULTRA_GREED_SPINNING) then
			sfx:Play(SoundEffect.SOUND_ULTRA_GREED_SPINNING, 0.2, 0, true, 1)
		end
		if v:IsDead() then
			sfx:Stop(SoundEffect.SOUND_ULTRA_GREED_SPINNING)
		end]]
		v.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_NONE
		if d.origpos then
			local resize = 10
			if d.rot == 0 then
				resize = 12
			end
			local targetvel = (d.origpos - v.Position):Resized(resize)
			d.rot = d.rot / (1 + (v.FrameCount * 0.001))
			v.Velocity = mod:Lerp(v.Velocity, targetvel, 0.01 + (v.FrameCount*0.001)):Rotated(d.rot)
			if v.Position:Distance(d.origpos) < 15 and v.FrameCount > 20 then
				if v.Parent then
					sfx:Play(SoundEffect.SOUND_BONE_DROP,1,2,false,1.3)
					v.Parent:GetData().npcState = "Submerge"
					sfx:Stop(SoundEffect.SOUND_ULTRA_GREED_SPINNING)
					v:Remove()
				end
			end
		end
		if v.Parent then
			if v.Parent:IsDead() then
				v.FallingSpeed = 1
			end
			if v.Parent:GetData().npcState == "Appear" then
				v.Parent = nil
			end
		else
			v.FallingSpeed = 1
		end

	elseif d.projType == "blot" then
		local s = v:GetSprite();
		if not d.anim then
			s:Load("gfx/enemies/blot/monster_blot.anm2",true);
			d.anim = mod:getRandomBlotSprite();
			s:ReplaceSpritesheet(0, "gfx/enemies/blot/monster_blot_"..d.anim.name..".png");
			s:LoadGraphics();
			s:Play("InAir",false);
		end
		s.Offset = Vector(0,-10);
		if v:IsDead() then
			local blot = mod.spawnent(v, v.Position, nilvector, mod.FF.Blot.ID, mod.FF.Blot.Var);
			blot:GetData().anim = d.anim;
			blot:GetSprite():ReplaceSpritesheet(0, "gfx/enemies/blot/monster_blot_"..d.anim.name..".png");
			blot:GetSprite():LoadGraphics();
			--if not blot:ToNPC().Pathfinder:HasPathToPos(blot:GetPlayerTarget().Position, false) then blot:ToNPC():Morph(950,0,0,-1) end--make sure theyre not spawned at a position where the player cant reach them
			--fiddle with this some more as it seems to think of way too many positions that really are reachable as unreachable
		end
	elseif d.projType == "triplesplit" then
		local vec
		if d.target then
			if d.target:IsDead() then
				vec = v.Velocity
			else
				vec = (d.target.Position - v.Position):Resized(7)
			end
		else
			vec = v.Velocity
		end

		v.Velocity = mod:Lerp(v.Velocity, vec, 0.3)

		if v.FrameCount > 15 then
			for i = -30, 30, 30 do
				local projectile = Isaac.Spawn(9, 0, 0, v.Position, v.Velocity:Resized(8):Rotated(i), npc):ToProjectile();
				if i == 0 then
					projectile.Scale = 1
				else
					projectile.Scale = 0.5
				end
				projectile.Color = mod.ColorPsyGrape
			end
			local effect = Isaac.Spawn(1000, 2, 0, v.Position, nilvector, v):ToEffect()
			effect.Color = mod.ColorPsyGrape
			effect:Update()
			v:Remove()
		end
	elseif d.projType == "acidic splot" then
		if v:IsDead() then
			local creep = Isaac.Spawn(1000, 23, 0, v.Position, nilvector, v):ToEffect()
			creep:SetColor(Color(0, 0, 0, 1, 99 / 255, 56 / 255, 74 / 255), 60, 99999, true, false)
			if d.creepTimer then
				creep:SetTimeout(d.creepTimer)
			end
			creep:Update()
		end
	elseif d.projType == "acidic piss" then
		if v:IsDead() then
			local creep = Isaac.Spawn(1000, 24, 0, v.Position, nilvector, v):ToEffect()
			creep:SetColor(Color(0,0,0,1,180 / 255,180 / 255,30 / 255), 0, 99999, true, false)
			creep:Update()
		end
	elseif d.projType == "ogreCreep" then
		if v:IsDead() then
			if not room:GetGridEntityFromPos(v.Position) and room:IsPositionInRoom(v.Position, 0) then
				Isaac.GridSpawn(10, 0, v.Position, true)
			end
		end
	elseif d.projType == "bloodafter" then
		if v:IsDead() then
			local creep = Isaac.Spawn(1000, 22, 0, v.Position, nilvector, v):ToEffect()
			creep:SetTimeout(math.random(30,75))
		end
	elseif d.projType == "coal" then
		v.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
		v.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_WALLS
		v.SpriteRotation = v.SpriteRotation + 30
		if v:IsDead() then
			local timeout = d.timeout or 200
			local burntime = d.burntime or 50
			mod.SpawnGunpowder(v.SpawnerEntity,v.Position, timeout, burntime)
			local vec = (RandomVector()*20)
			for i = 1, 6 do
				local vec2 = vec:Rotated(360/6 * i - 15 + math.random(30)):Resized(math.random(25,40))
				mod.SpawnGunpowder(v.SpawnerEntity,v.Position + vec2, timeout, burntime)

				local smoke = Isaac.Spawn(1000, EffectVariant.DARK_BALL_SMOKE_PARTICLE, 0, v.Position + vec2 * 0.2, vec2 * 0.15, npc):ToEffect()
				smoke.SpriteRotation = math.random(360)
				smoke.RenderZOffset = 300
				smoke:Update()
			end
			--[[local num = math.random(3,5)
			for i = 1, num do
				local r = Isaac.Spawn(1000, 4, 0, v.Position + Vector(0, 1):Rotated(i*(360/num)):Resized(math.random(3, 5)*math.random(3)), nilvector, nil)
				r.Color = Color(0.6,0.6,0.9,1,0,0,0)
				r:Update()
			end]]
			sfx:Play(SoundEffect.SOUND_ROCK_CRUMBLE,0.15,2,false,1.6)
			local tearpoof = Isaac.Spawn(1000,mod.FF.SootyTearPoof.Var, mod.FF.SootyTearPoof.Sub, v.Position, nilvector, v):ToEffect()
			tearpoof.SpriteOffset = v.SpriteOffset
			v:Remove()
		end
	elseif d.projType == "coalButActuallyRock" then
		--v.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
		--v.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_WALLS
		v.SpriteRotation = v.SpriteRotation + 30
		if v:IsDead() then
			sfx:Play(SoundEffect.SOUND_ROCK_CRUMBLE,0.15,2,false,1.2)
			local tearpoof = Isaac.Spawn(1000,mod.FF.SootyTearPoof.Var, mod.FF.SootyTearPoof.Sub, v.Position, nilvector, v):ToEffect()
			tearpoof:GetSprite():Load("gfx/projectiles/sooty_tear_rock.anm2",true)
			tearpoof.SpriteOffset = v.SpriteOffset
			v:Remove()
		end
	elseif d.projType == "coal2" then
		v.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
		v.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_WALLS
		v.SpriteRotation = v.SpriteRotation + 30
		if v:IsDead() then
			local vec = (RandomVector()*8)
			if d.projSpeed then
				vec = vec:Resized(d.projSpeed)
			end
			local numberofflames = 6
			for i = 1, numberofflames do
				local fire = Isaac.Spawn(1000,7005, 1, v.Position, vec:Rotated((360/numberofflames) * i), v.SpawnerEntity)
				if v.SpawnerEntity then
					fire.Parent = v.SpawnerEntity
				end
				fire:Update()
			end
			--[[local num = math.random(3,5)
			for i = 1, num do
				local r = Isaac.Spawn(1000, 4, 0, v.Position + Vector(0, 1):Rotated(i*(360/num)):Resized(math.random(3, 5)*math.random(3)), nilvector, nil)
				r.Color = Color(0.6,0.6,0.9,1,0,0,0)
				r:Update()
			end]]
			sfx:Play(SoundEffect.SOUND_ROCK_CRUMBLE,0.15,2,false,1.5)
			sfx:Play(mod.Sounds.FireFizzle, 0.4, 0, false, 1.3)
			local tearpoof = Isaac.Spawn(1000,mod.FF.SootyTear2Poof.Var, mod.FF.SootyTear2Poof.Sub, v.Position, nilvector, v):ToEffect()
			tearpoof.SpriteOffset = v.SpriteOffset
			v:Remove()
		end
	elseif d.projType == "coalRadioactive" then
		v.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
		v.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_WALLS
		v.SpriteRotation = v.SpriteRotation + 30
		if v:IsDead() then
			local ash = mod.FindClosestUnlitPowder(v.Position, v)
			if ash and ash.Position:Distance(v.Position) < 40 then
				ash:GetData().flaming = true
			end
			sfx:Play(SoundEffect.SOUND_ROCK_CRUMBLE,0.15,2,false,1.5)
			sfx:Play(mod.Sounds.FireFizzle, 0.4, 0, false, 1.3)
			local tearpoof = Isaac.Spawn(1000,mod.FF.SootyTear2Poof.Var, mod.FF.SootyTear2Poof.Sub, v.Position, nilvector, v):ToEffect()
			tearpoof:GetSprite():Load("gfx/projectiles/sooty_tear_radioactive.anm2",true)
			tearpoof.SpriteOffset = v.SpriteOffset
			for i = -30, 30, 30 do
				local smoke = Isaac.Spawn(1000, EffectVariant.DARK_BALL_SMOKE_PARTICLE, 0, v.Position, Vector(0,-10):Rotated(i), v)
				--smoke.SpriteScale = Vector(1,1)
				smoke.SpriteOffset = Vector(0, -10)
				smoke.Color = Color(0.5,1.5,1,1,0,0,0)
				smoke:Update()
			end
			v:Remove()
		end
	elseif d.projType == "HoneyCreep" then
		if v:IsDead() then
			local honeycolor = Color(1,1,1,1,0,0,0)
			honeycolor:SetColorize(5.5, 3.5, 1, 1)
			local creep = Isaac.Spawn(1000, EffectVariant.CREEP_BROWN, 0, v.Position, nilvector, npc):ToEffect()
			creep.SpriteScale = Vector(2, 1.25)
			creep:SetTimeout(creep.Timeout + 70)
			creep:Update()
			creep:GetSprite().Color = honeycolor
		end
	elseif d.projType == "PusyCreep" then
		if v:IsDead() then
			local creep = Isaac.Spawn(1000, EffectVariant.CREEP_BROWN, 0, v.Position, nilvector, npc):ToEffect()
			creep.SpriteScale = Vector(2, 1.25)
			creep:SetTimeout(creep.Timeout + 70)
			creep:Update()
		end
	elseif d.projType == "Radioactive" then
		d.Height = v.Height
		d.customProjSplat = "gfx/projectiles/radioactiveSplat.png"
		if v.FrameCount % 5 == 0 then
			local trail = Isaac.Spawn(1000, 111, 0, v.Position, nilvector, v):ToEffect()
			trail:GetSprite().Offset = Vector(0, v.Height * 0.75)
			local color = Color(1,1,1,0.5,0.3,1,0)
			color:SetColorize(1,1,1,1)
			trail.Color = color
			trail.SpriteScale = Vector(0.5, 0.5)
			trail:Update()
		end
		if v:IsDead() then

		end
		if v.ProjectileFlags == v.ProjectileFlags | ProjectileFlags.NO_WALL_COLLIDE then
			v.Velocity = v.Velocity * 1.01
			if v.FrameCount % 1 == 0 then
				local blood = Isaac.Spawn(1000, 7, 0, v.Position, nilvector, v)
				blood.SpriteScale = Vector(0.4,0.4)
				blood.Color = Color(0.2, 0.2, 0.2, 0.1, 0, 0, 0)
				blood:Update()
			end
			if v.FrameCount > 70 then
				v:Remove()
			end
		end
	elseif d.projType == "killerNeedle" then
		v.SpriteRotation = v.Velocity:GetAngleDegrees()
	elseif d.projType == "crackWave" then
		if v:IsDead() then
			local wave3 = Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.SHOCKWAVE, 0, v.Position, Vector.Zero, v):ToEffect()
			wave3.Parent = v
			wave3.MaxRadius = -30
		end
	end
end

function mod.getProjDebug(v)

--Isaac.DebugString("Velocity:" .. v.Velocity:GetAngleDegrees())

print(v.ProjectileFlags)
print("Type:" .. v.Variant)
print("R:" .. v.Color.R)
print("G:" .. v.Color.G)
print("G:" .. v.Color.G)
print("B:" .. v.Color.B)
print("A:" .. v.Color.A)
print("RO:" .. v.Color.RO)
print("GO:" .. v.Color.GO)
print("BO:" .. v.Color.BO)
end

--	function mod.ensureFlashingTearProjectiles(v,d)
--		if v.Variant == 4 then
--			if not d.becameFlashing then
--				d.becameFlashing = true
--				local sprite = v:GetSprite()
--				local anim
--				--Thanks Nicalis for not letting me just get what's playing
--				for i = 1, 13 do
--					if sprite:IsPlaying("RegularTear" .. i) then
--						anim = "RegularTear" .. i
--					end
--				end
--
--				if anim then
--					sprite:Load("gfx/projectiles/flashingTearProj.anm2", true)
--					sprite:Play(anim, true)
--				end
--
--				--[[local oldScale = v.Scale
--				sprite:Load("gfx/projectiles/flashingTearProj.anm2", true)
--				sprite:Play("RegularTear6", true)
--				v.Scale = oldScale]]
--			end
--		end
--	end

function mod:FakeFart(npc, pos, range)
	range = range or 40
	if npc and (not mod:isFriend(npc)) then
		for _, player in pairs(Isaac.FindInRadius(pos, range, EntityPartition.PLAYER)) do
			player:TakeDamage(1, 0, EntityRef(npc), 0)
		end
	end
end

mod:AddCallback(ModCallbacks.MC_POST_ENTITY_REMOVE, function(_, v)
	local d = v:GetData()
	if d.projType == "TrashFart" then
		game:ButterBeanFart(v.Position, 140, v, true, false)
	elseif d.projType == "DangerFart" then
		local range = 40
		if d.fartscale then
			range = range * d.fartscale
		end
		game:Fart(v.Position, range, v.SpawnerEntity, 1, 0)
		mod:FakeFart(v.SpawnerEntity, v.Position, range)
		--game:BombExplosionEffects(v.Position, 9, TearFlags.TEAR_POISON, Color(0, 0, 0, 0, 0, 0, 0), v, 1.3, false, true)
	elseif d.projType == "CharmFart" then
		game:CharmFart(v.Position, 40, v)
	end
end, EntityType.ENTITY_PROJECTILE)

function mod:OnProjUpdate(v)
	local d = v:GetData();

	--mod.ensureFlashingTearProjectiles(v, d)
	mod.postprojupdate(v,d)
	mod.postprojupdate2(v,d)
	mod.erflyProjectiles(v,d)
	mod.orbitalprojupdate(v,d)
	mod.puntedProjectiles(v, d)
	mod.warbleProjectiles(v, d)
	mod.sensoryGrimaceProjectiles(v, d)
	mod.anemoneProjectiles(v, d)
	mod.ferriumProj(v, d)
	mod.cakeProj(v, d)
	mod.dryWheezeProj(v, d)
	mod:projectileFlags(v, d)
	--mod.getProjDebug(v)
	mod.babyCraterTears(v, d)
end
mod:AddCallback(ModCallbacks.MC_POST_PROJECTILE_UPDATE, mod.OnProjUpdate)

function mod:OnProjColl(proj, npc, mysteryBool)
	if proj:GetData().projType then
		local d = proj:GetData()
		if d.projType == "ogreCreep" then
			npc:AddSlowing(EntityRef(proj),100,1,Color(1.5,1.5,1.5,1,0,0,0))
			npc:AddEntityFlags(EntityFlag.FLAG_SLOW)
		elseif d.projType == "dwellerGodhead" then
			if proj.Child then
				proj.Child:GetSprite():Play("Disappear", true)
				proj.Child.Parent = proj.Child
			end
		end
	end
	mod.ferriumProjColl(proj, npc, bool)
end
mod:AddCallback(ModCallbacks.MC_PRE_PROJECTILE_COLLISION, mod.OnProjColl)

mod.KillableTechs = {
	[mod.FF.CherubskullHand.Var] = true,
}

function mod:OnTearColl(tear, npc, mysteryBool)
local etype = npc.Type
local evar = npc.Variant
local esubtype = npc.SubType
local data = npc:GetData()
local sprite = npc:GetSprite()
 -- Death failsafe for euthanasia, chaos card and little horn --
  tear:GetData().FF_InstantKillPierce = false
  if tear.Variant == 9 or
  (tear:HasTearFlags(TearFlags.TEAR_LUDOVICO)) or
  ((tear:HasTearFlags(TearFlags.TEAR_PIERCING)) and not (tear:HasTearFlags(TearFlags.TEAR_BOUNCE))) or
  ((tear:HasTearFlags(TearFlags.TEAR_BELIAL)) and not (tear:HasTearFlags(TearFlags.TEAR_BOUNCE))) then
	tear:GetData().FF_InstantKillPierce = true
  end

 if not npc:HasEntityFlags(EntityFlag.FLAG_FRIENDLY) then

  -- ENEMIES
	if etype == mod.FF.MotherOrb.ID and evar == etype == mod.FF.MotherOrb.Var then
		if tear.Variant == 9 then
			local nd = npc:GetData()
			if nd.DingCount < 5 then
				nd.DamageCount = 15
				nd.DingCount = 4
				game:BombExplosionEffects(npc.Position, 2, 0, mod.ColorNormal, npc, 1, false, true)
			end
			tear:Remove()
		else
			tear:Die()
		end
		return false
	end
	 if (tear.Variant == 9 or (tear:HasTearFlags(TearFlags.TEAR_HORN) or tear:HasTearFlags(TearFlags.TEAR_NEEDLE))) and not (npc:HasEntityFlags(EntityFlag.FLAG_FREEZE) or npc:HasEntityFlags(EntityFlag.FLAG_MIDAS_FREEZE)) then

	  if etype == mod.FFID.Tech then -- Technicals
		if evar == mod.FF.Gary.Var or evar == mod.FF.Bubble.Var or evar == mod.FF.FlyBundle.Var then -- Gary, Bubble, Fly Bundle
			npc.Velocity = nilvector
			npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
			npc.HitPoints = 0
			npc:ToNPC().State = 11
		elseif evar == mod.FF.TarBubble.Var then -- Tar Bubble, Spider Egg
			local r = npc:GetDropRNG()
			if esubtype == 1 then
				for i = 1, math.random(4,10) do
					mod.spawnent(npc, npc.Position, RandomVector()*math.random(20), 85, 962)
				end
			else
				for i = 30, 360, 30 do
					local rand = r:RandomFloat()
					local projectile = Isaac.Spawn(9, npc.SubType == 10 and 3 or 0, 0, npc.Position, Vector(0,2):Rotated(i-40+rand*80), npc):ToProjectile()
					projectile.FallingSpeed = -50 + math.random(10)
					projectile.FallingAccel = 2
					projectile.Velocity = projectile.Velocity * (math.random(12, 20)/10)
					projectile.Scale = math.random(8, 12)/10
					projectile.Color = (projectile.Variant == 3) and projectile.Color or (npc.SplatColor or mod.ColorDankBlackReal)
				end
			end
			npc:Kill()
		end
		if not mod.KillableTechs[npc.Variant] then
			if tear:GetData().FF_InstantKillPierce then
				return true
			else
				tear:Die()
				return false
			end
		end
	  elseif etype == mod.FF.GorgerAss.ID and evar == mod.FF.GorgerAss.Var and esubtype ==  mod.FF.GorgerAss.Sub then -- Gorger Ass
			local referenceEntity = npc
			if npc.SubType == mod.FF.GorgerAss.Sub and npc.Parent then
				referenceEntity = npc.Parent
			end

			local spawned = Isaac.Spawn(referenceEntity.Type, referenceEntity.Variant, referenceEntity.SubType, referenceEntity.Position, nilvector, referenceEntity)
			spawned:ToNPC():Morph(spawned.Type, spawned.Variant, spawned.SubType, referenceEntity:ToNPC():GetChampionColorIdx())
			spawned.HitPoints = 0
			spawned:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
			spawned.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
			spawned:ToNPC().State = 11
			spawned:GetSprite().FlipX = referenceEntity:GetSprite().FlipX

			local spawnedData = spawned:GetData()
			spawnedData.FFIsDeathAnimation = true

			if (referenceEntity:HasEntityFlags(EntityFlag.FLAG_FRIENDLY)) then
				spawned:AddEntityFlags(EntityFlag.FLAG_FRIENDLY)
			end

			if npc.SubType == mod.FF.GorgerAss.Sub then
				if npc.Parent then
					npc.Parent:Remove()
				end
			end
			npc:Remove()

		   if tear:GetData().FF_InstantKillPierce then
			return true
		   else
			tear:Die()
			return false
		   end
	  elseif etype == mod.FF.HeadHoncho.ID and evar == mod.FF.HeadHoncho.Var then -- Head Honcho
		if npc:ToNPC().State == 11 then
		   if tear:GetData().FF_InstantKillPierce then
			return true
		   else
			tear:Die()
			return false
		   end
		end
	  elseif etype == mod.FF.Melty.ID and evar == mod.FF.Melty.Var then -- Melty
		if npc:ToNPC().State == 11 then
		   if tear:GetData().FF_InstantKillPierce then
			return true
		   else
			tear:Die()
			return false
		   end
		end
	  elseif etype == mod.FF.Phoenix.ID and evar == mod.FF.Phoenix.Var and esubtype == mod.FF.PhoenixUnignited.Sub then -- Phoenix
		if npc:ToNPC().State == 11 then
		   if tear:GetData().FF_InstantKillPierce then
			return true
		   else
			tear:Die()
			return false
		   end
		end
	  elseif etype == mod.FF.Blastcore.ID and evar == mod.FF.Blastcore.Var then -- Blastcore
		if npc:ToNPC().State == 11 then -- Blastcore currently doesn't play death animation when killed by little horn tear effect.
		   if tear:GetData().FF_InstantKillPierce then
			return true
		   else
			tear:Die()
			return false
		   end
		end
	  end

	 end

  -- BOSSES
	 if tear.Variant == 9 then
	  if etype == mod.FF.Psion.ID and evar == mod.FF.Psion.Var then -- Psion
		 npc.Velocity = nilvector
		 npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
		 npc.HitPoints = 0
		 npc:ToNPC().State = 11
		 npc:ToNPC():PlaySound(mod.Sounds.PsionDeath,1,0,false,1)
		 sfx:Stop(mod.Sounds.PsionRedirectLoop)
			return true
	  elseif etype == mod.FFID.Boss and evar == mod.FF.Monsoon.Var then -- Monsoon
		 npc.Velocity = nilvector
		 npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
		 npc.HitPoints = 0
		 npc:ToNPC().State = 11
			return true
	  elseif etype == mod.FFID.Boss and evar == mod.FF.SunBody.Var then -- The Sun
		 npc:GetData().earth:Kill()
		 npc:GetData().venus:Kill()
		 npc:GetData().neptune:Kill()
		 npc:GetData().spawnCard = true
			return true
	  elseif etype == mod.FFID.Boss and evar >= mod.FF.OrgChaser.Var and evar <= mod.FF.OrgPokey.Var then -- Organization
			if evar == mod.FF.OrgChaser.Var and esubtype == mod.FF.OrgPokeyCorpse.Sub then
			 npc:GetData().Chaser:Kill()
			elseif evar ~= mod.FF.OrgChaser.Var and esubtype ~= mod.FF.OrgPokeyCorpse.Sub then
			 npc:GetSprite().FlipX = false
			 npc:GetSprite():Play("CorpseDeath", true)
			 npc:GetData().State = "Death"
			else
			 npc:Kill()
			end
			return true
	  elseif etype == mod.FF.SunSpike.ID and evar == mod.FF.SunSpike.Var then -- The Sun Spikes
			return true
	  elseif etype == mod.FF.Meltdown.ID and evar == mod.FF.Meltdown.Var then -- Meltdown first phase
			npc:ToNPC():Morph(mod.FF.Meltdown2.ID, mod.FF.Meltdown2.Var, 0, -1)
			npc:Kill()
			return true
	  elseif etype == mod.FF.Whispers.ID and evar == mod.FF.Whispers.Var then
			npc.Parent:Kill()
			return true
	  end
	 end

	 if tear:HasTearFlags(TearFlags.TEAR_HORN) or tear:HasTearFlags(TearFlags.TEAR_NEEDLE) then
		if etype == mod.FF.SunBody.ID and evar == mod.FF.SunBody.Var then
			return false
		end
	 end


 end
 -- Death Failsafe END --

	--Moved this here so the failsafe runs first, makes more sense I think
	mod:fiendTearCollision(tear, collider)
	if etype == mod.FF.Luncheon.ID and evar == mod.FF.Luncheon.Var then
		if not tear:GetData().LuncheonReflected then
			tear.Velocity = (tear.Velocity * -1):Rotated(-20 + math.random(40))
			tear:GetData().LuncheonReflected = true
			sfx:Play(mod.Sounds.Ricochet,1,0,false,0.7)
			return false
		end
	end
end
mod:AddCallback(ModCallbacks.MC_PRE_TEAR_COLLISION, mod.OnTearColl)

function mod:OnBombColl(bomb, npc, mysteryBool)
local etype = npc.Type
local evar = npc.Variant
	if etype == mod.FF.SunSpike.ID and evar == mod.FF.SunSpike.Var and bomb:GetData().sun and bomb.FrameCount < 10 then
		return false
	end
end

mod:AddCallback(ModCallbacks.MC_PRE_BOMB_COLLISION , mod.OnBombColl)


--RUN AI
function mod:checkGaper(npc)
	if npc.SubType == 960 then
		npc:GetSprite():SetOverlayFrame("Head", 19)
		npc.SubType = 0
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkGaper, 10)
function mod:checkSatan(npc)
	--print(npc.Variant)
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkSatan, 84)

--GlobalEntityUpdate, GlobalEnemy, GlobalUpdate, GlobalNPC
function mod:checkAllEnemy(npc)
	if mod.spookInRoom then
		if npc:IsEnemy() and npc:IsDead() then
			mod.spookJustKilledEnemy = 1
		end
	end
	if npc:IsEnemy() then
		--Grotto beast sparkle
		if npc.SpawnerEntity and npc.SpawnerEntity.Type == 1 then
			local d = npc:GetData()
			if d.sparklyGrottoBeast then
				if npc.FrameCount % 3 == 0 then
					local randvec = Vector(-15 + math.random(20), -15 + math.random(20))
					local sparkle = Isaac.Spawn(1000, 7003, 0, npc.Position, randvec * 0.1, npc):ToEffect()
					sparkle.RenderZOffset = -5
					sparkle.SpriteOffset = randvec + Vector(0, -20)
					--sparkle.SpriteScale = Vector(0.3,0.3)
				end
			end
		end
		--Fiend effects
		if mod.FiendDoingFireballs then
			if npc:GetData().spawnFiendishBlackHeart then
				npc:GetData().spawnFiendishBlackHeart = nil
				if npc:HasMortalDamage() and not npc:HasEntityFlags(EntityFlag.FLAG_NO_REWARD) then
					if npc:GetData().SpawnedAtRoomStart then
						if npc:GetDropRNG():RandomInt(2) < 1 then
							local heart = Isaac.Spawn(5, PickupVariant.PICKUP_HALF_IMMORAL_HEART, 0, npc.Position, RandomVector():Resized(math.random(1,20)/10), Isaac.GetPlayer()):ToPickup()
							heart.Timeout = 60
							heart:Update()
						end
					else
						if mod.fiendImmoralSpawnOnSpawnedChance and mod.fiendImmoralSpawnOnSpawnedChance > 0 then
							if npc:GetDropRNG():RandomInt(4) < mod.fiendImmoralSpawnOnSpawnedChance then
								local heart = Isaac.Spawn(5, PickupVariant.PICKUP_HALF_IMMORAL_HEART, 0, npc.Position, RandomVector():Resized(math.random(1,20)/10), Isaac.GetPlayer()):ToPickup()
								heart.Timeout = 60
								heart:Update()
								mod.fiendImmoralSpawnOnSpawnedChance = mod.fiendImmoralSpawnOnSpawnedChance / 2
								--mod.fiendImmoralSpawnOnSpawnedChance = math.floor(mod.fiendImmoralSpawnOnSpawnedChance)
							end
						end
					end
				end
			end
			if npc:GetData().spawnFiendFireball then
				--[[if npc:HasMortalDamage() and not npc:HasEntityFlags(EntityFlag.FLAG_NO_REWARD) then
					local player = npc:GetData().spawnFiendFireball
					local data = player:GetData().ffsavedata
					data.orbitingfireballs = math.min(data.orbitingfireballs + 1, 3)
					player:AddCacheFlags(CacheFlag.CACHE_FAMILIARS)
					player:EvaluateItems()
				end]]--
				local player = npc:GetData().spawnFiendFireball
				local data = player:GetData().ffsavedata
				local cap = 40 + 10 * math.max(game:GetLevel():GetStage(), 1)
				if data.fiendDamageDealt and data.fiendDamageDealt >= cap then
					data.fiendDamageDealt = 0

					fiendflasheffect = Isaac.Spawn(1000, 668, 0, player.Position, Vector(0,0), player):ToEffect()
					fiendflasheffect:GetData().parent = player
					sfx:Play(SoundEffect.SOUND_FLAME_BURST, 0.3, 0, false, math.random(150,160)/100)

					data.orbitingfireballs = math.min(data.orbitingfireballs + 1, 3)
					player:AddCacheFlags(CacheFlag.CACHE_FAMILIARS)
					player:EvaluateItems()
				end
				npc:GetData().spawnFiendFireball = nil
			end
		end
		local d = npc:GetData()
		mod:erflyGlobalNPCUpdate(npc, d)
		--Peppermint
		if d.PeppermintSlowed then
			if not npc:HasEntityFlags(EntityFlag.FLAG_SLOW) then
				d.PeppermintSlowed = nil
				npc:ClearEntityFlags(EntityFlag.FLAG_ICE)
			end
		end
		if d.tookChaldeanAxeDamageRecently then
			d.tookChaldeanAxeDamageRecently = d.tookChaldeanAxeDamageRecently - 1
			if d.tookChaldeanAxeDamageRecently <= 0 then
				d.tookChaldeanAxeDamageRecently = nil
			end
		end
		if d.DevilsDaggerBurn then
			if not npc:HasEntityFlags(EntityFlag.FLAG_BURN) then
				d.DevilsDaggerBurn = nil
			end
			if npc:IsDead() then
				local fire = Isaac.Spawn(1000, 51, 960, npc.Position, nilvector, Isaac.GetPlayer())
				fire:GetData().timer = 30
				fire:Update()
			end
		end
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkAllEnemy)

mod:AddCallback(ModCallbacks.MC_ENTITY_TAKE_DMG, function(_, ent, damage, flags, source, iframes)
	if source and source.Entity and source.Entity:GetData().spawnTempBlackHeart then
		ent:GetData().spawnFiendishBlackHeart = true
		mod.FiendDoingFireballs = true
	end
end)

function mod:AddFireballGenDamageCallback()
	mod:AddCallback(ModCallbacks.MC_ENTITY_TAKE_DMG, function(_, ent, damage, flags, source, countdown)
		local cloned = flags & DamageFlag.DAMAGE_CLONES ~= 0

		local player = nil
		local playerIsFiend = false
		if source.Type == EntityType.ENTITY_PLAYER and
		   source.Variant == 0 and
		   source.Entity and source.Entity.SubType == FiendFolio.PLAYER.FIEND
		then
			player = source.Entity:ToPlayer()
			playerIsFiend = true
		elseif source.Entity and
			   not (source.Entity:ToNPC() or source.Entity:ToPickup() or source.Entity:ToFamiliar()) and
			   source.Entity.SpawnerEntity and
			   source.Entity.SpawnerEntity.Type == EntityType.ENTITY_PLAYER and
			   source.Entity.SpawnerEntity.Variant == 0 and
			   source.Entity.SpawnerEntity:ToPlayer():GetPlayerType() == FiendFolio.PLAYER.FIEND
		then
			player = source.Entity.SpawnerEntity:ToPlayer()
			playerIsFiend = true
		end

		local sourceIsFireball = false
		if source.Type == EntityType.ENTITY_TEAR and
		   source.Entity and
		   source.Entity:GetData().specialfiend
		then
			sourceIsFireball = true
		end

		if playerIsFiend and not sourceIsFireball and not cloned and ent:IsVulnerableEnemy() then
			ent:GetData().spawnFiendFireball = player
			player:GetData().ffsavedata.fiendDamageDealt = (player:GetData().ffsavedata.fiendDamageDealt or 0) + math.min(damage, ent.HitPoints)
			mod.FiendDoingFireballs = true
		end
	end)
end

local downloadFailureBlacklist = {
	[EntityType.ENTITY_MOTHER] = true,
	[EntityType.ENTITY_DARK_ESAU] = true,
	[EntityType.ENTITY_MOTHERS_SHADOW] = true,
}

function mod:preNPCUpdateAllEnemy(npc)
	local d = npc:GetData()
	if (mod.downloadFailureCarded or d.DownloadFailuredManually) and not npc.Parent and not npc.Child and not downloadFailureBlacklist[npc.Type] and not (not npc:IsVulnerableEnemy() and npc.CanShutDoors) then
		if d.DownloadFailuredManually then
			local square = Isaac.Spawn(mod.FF.WhiteSquareEffect.ID, mod.FF.WhiteSquareEffect.Var, mod.FF.WhiteSquareEffect.Sub, npc.Position, nilvector, npc)
			square:Update()
		end
		if d.downloadFailureCarded then
			npc:SetColor(Color(1.5,1.5,1.5,0.3,50 / 255,50 / 255,50 / 255),15,1,true,false)
			if npc.FrameCount % 30 == 1 then
				npc:TakeDamage(2, 0, EntityRef(npc), 0)
			end
			if math.random(d.downloadFailureCarded) == 1 then
				d.downloadFailureCarded = nil
				d.poopleAI = nil
			else
				d.downloadFailureCarded = d.downloadFailureCarded - 1
			end
			if d.poopleAI then
				mod:poopleAI(npc)
			end
			return true
		else
			if math.random(50) == 1 then
				d.downloadFailureCarded = math.random(100)
				if math.random(5) == 1 then
					d.poopleAI = true
				end
			end
		end
	end
end
mod:AddCallback(ModCallbacks.MC_PRE_NPC_UPDATE, mod.preNPCUpdateAllEnemy)

function mod:checkEnemyInitDelirium(npc)
	if mod.IsDeliriumRoom then
		local etype = npc.Type
		local evar = npc.Variant
		local esub = npc.SubType
		local morph
		for _,v in ipairs(mod.BlacklistedDeliriumBosses) do
			if v[3] then if etype == v[1] and evar == v[2] and esub == v[3] then morph = true end
			elseif v[2] then if etype == v[1] and evar == v[2] then morph = true end
			elseif etype == v[1] then morph = true end
		end
		if morph then
			npc:Morph(412, 0, 0, -1)
			npc:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
		end
	--Since these champions can be spawned by delirious item, the blacklist for them is done the other way and they turn into specific existing champions.

		if etype == 20 and evar == 0 and esub == mod.FF.MucusMonstro.Sub then -- Spitum Monstro
			npc:Morph(20, 0, 2, -1)
			npc:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
		elseif etype == 62 and evar == 0 and esub == mod.FF.TechnoPin.Sub then -- Techno Pin
			npc:Morph(62, 0, 1, -1)
			npc:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
		end
	end
end
mod:AddCallback(ModCallbacks.MC_POST_NPC_INIT, mod.checkEnemyInitDelirium)

function mod:stopDelirium(npc)
	if mod.IsDeliriumRoom then
		local etype = npc.Type
		local evar = npc.Variant
		local esub = npc.SubType
		local morph
		for _,v in ipairs(mod.BlacklistedDeliriumBosses) do
			if v[3] then if etype == v[1] and evar == v[2] and esub == v[3] then morph = true end
			elseif v[2] then if etype == v[1] and evar == v[2] then morph = true end
			elseif etype == v[1] then morph = true end
		end
		if morph then
			return true
		end
	end

end
mod:AddCallback(ModCallbacks.MC_PRE_NPC_COLLISION , mod.stopDelirium)

function mod:checkPacer(npc)
	local d = npc:GetData()
	if not d.replacecheck then
		local subt = npc.SubType
		local sprite = npc:GetSprite()
			if subt == 770 then
				sprite:ReplaceSpritesheet(0, "gfx/enemies/mrhorf/monsterbody.png")
				sprite:LoadGraphics()
			elseif subt == 772 then
				sprite:ReplaceSpritesheet(0, "gfx/enemies/mrhorf/monsterbodyred.png")
				sprite:LoadGraphics()
			elseif subt == 830 then
				mod:ReplaceEnemySpritesheet(npc, "gfx/enemies/pester/bodyblood", 0)
			end
		--Isaac.ConsoleOutput("a")
		d.replacecheck = true
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkPacer, 11)

--Run nerve ending AI
function mod:checkNerveEnding(npc)
	if npc.SubType == 960 then
		npc.HitPoints = 500
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkNerveEnding, 231)

--Run Hungrygan AI
function mod:checkHungrygan(npc)
	if npc.Variant == mod.FF.Facade.Var then
		mod:hungryganAI(npc)
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkHungrygan, 16)

--Run Shopkeeper AI
function mod:checkShopkeeper(npc)
	if npc.Variant == mod.FF.FFShopkeeper.Var then
		mod:ffShopkeeperAI(npc)
	end
	local d = npc:GetData()
	if d.inMinecart and d.inMinecart:Exists() then
		npc.TargetPosition = d.inMinecart.Position
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkShopkeeper, 17)

--Run Fly AI
function mod:checkFly(npc)
	--Drowned attack fly ehehehehehehehehehehehehehehe
	if npc.Variant == mod.FF.DrownedAttackFly.Var then
		local blue = Color(1,1,1,1,0,0,0)
		blue:SetColorize(1, 1, 3, 1)
		npc:GetSprite().Color = blue
		if npc:IsDead() then
			local maggot = Isaac.Spawn(23, 1, 0, npc.Position, Vector(0,0), npc)
			local params = ProjectileParams()
			for i = 45, 405, 90 do
				npc:FireProjectiles(npc.Position, Vector(8,0):Rotated(i), 0, params)
			end
		end
	end

	--Isaac.ConsoleOutput(npc.GridCollisionClass)
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkFly, 18)

--Run Maggot
function mod:checkMaggot(npc)
	local sprite = npc:GetSprite();
	local npcdata = npc:GetData();
	local var = npc.Variant
	if var == mod.FF.RolyPoly.Var then
		mod:rolyPolyAI(npc, npc.SubType)
	elseif var == mod.FF.Nimbus.Var then
		mod:nimbusai(npc, sprite, npcdata)
	elseif var == mod.FF.PsiKnight.Var then
		mod:psionicKnightAI(npc, sprite, npcdata)
	elseif var == mod.FF.SeaCucumber.Var then
		mod:seaCucumberAI(npc, sprite, npcdata)
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkMaggot, 21)



function mod:checkMaggotCollision(npc1, npc2, low)
	if npc1.Variant == mod.FF.PsiKnight.Var then
		if npc1.Parent and npc1.Parent.InitSeed == npc2.InitSeed then
			return true
		elseif npc1.Child and npc1.Child.InitSeed == npc2.InitSeed then
			return true
		end
	end
end
mod:AddCallback(ModCallbacks.MC_PRE_NPC_COLLISION, mod.checkMaggotCollision, 21)

function mod:checkMaggotDeath(npc)
	local var = npc.Variant
	if var == mod.FF.RolyPoly.Var then
		sfx:Stop(mod.Sounds.RolyPolyRoll)
	elseif var == mod.FF.PsiKnight.Var then
		if npc.Child then
			npc.Child:Remove()
		end
	end
end
mod:AddCallback(ModCallbacks.MC_POST_NPC_DEATH, mod.checkMaggotDeath, 21)

function mod:checkMaggotKill(npc)
	local var = npc.Variant
	if var == mod.FF.PsiKnight.Var then
		if npc.SubType == 1 then
			--if npc.Parent and npc:HasEntityFlags(EntityFlag.FLAG_ICE) then
			--	local data = npc.Parent:GetData()
			--
			--	npc.Parent:AddEntityFlags(EntityFlag.FLAG_ICE)
			--	data.FFForceFreezeOnDeath = true
			--	data.FFPreventDeath = true
			--	npc.Parent:TakeDamage(0.001, 0, EntityRef(nil), 0)
			--elseif npc.Parent and not mod:isStatusCorpse(npc.Parent) then
			if npc.Parent and not (mod:isStatusCorpse(npc.Parent) or mod:isLeavingStatusCorpse(npc.Parent)) then
				npc.Parent:Kill()
			end
			npc:Remove()
		end
	end
end
mod:AddCallback(ModCallbacks.MC_POST_ENTITY_KILL, mod.checkMaggotKill, 21)

function mod:checkMaggotHurt(npc, damage, flag, source)
	--if npc.Variant == mod.FF.PsiKnight.Var then
	--	if flag & DamageFlag.DAMAGE_CLONES == 0 then
	--		if npc.SubType ~= 1 then
	--			return false
	--		else
	--			if npc.Parent then
	--				npc.Parent:TakeDamage(damage, flag | DamageFlag.DAMAGE_CLONES, EntityRef(npc), 0)
	--			end
	--		end
	--	end
	if npc.Variant == mod.FF.PsiKnight.Var then
		local data = npc:GetData()

		--if data.FFForceFreezeOnDeath then -- For Uranus compatibility
		--	return nil
		--elseif npc.Child and source.Entity and npc.Child.InitSeed == source.Entity.InitSeed then
		if npc.Child and source.Entity and npc.Child.InitSeed == source.Entity.InitSeed then
			return false
		elseif npc.Parent and source.Entity and npc.Parent.InitSeed == source.Entity.InitSeed then
			return false
		elseif flag == flag | DamageFlag.DAMAGE_POISON_BURN then -- Keep Poison/Burn synced to once per 40 frames
			data.FFLastPoisonProc = data.FFLastPoisonProc or 0
			if Isaac.GetFrameCount() - data.FFLastPoisonProc < 40 then
				return false
			end
			data.FFLastPoisonProc = Isaac.GetFrameCount()

			if flag ~= flag | DamageFlag.DAMAGE_CLONES then
				if npc.SubType ~= 1 then
					--if npc.Child then
					--	npc.Child:TakeDamage(damage, flag | DamageFlag.DAMAGE_CLONES, source, 0)
					--end
				else
					if npc.Parent then
						npc.Parent:TakeDamage(damage, flag | DamageFlag.DAMAGE_CLONES, source, 0)
					end
					return false
				end
			end
		elseif flag ~= flag | DamageFlag.DAMAGE_CLONES then -- Regular damage
			if npc.SubType ~= 1 then
				return false
			else
				if npc.Parent then
					npc.Parent:TakeDamage(damage, flag | DamageFlag.DAMAGE_CLONES, source, 0)
				end
				return false
			end
		--elseif npc.SubType ~= 1 and flag ~= flag | DamageFlag.DAMAGE_NOKILL then -- For Uranus compatibility
		--	npc:TakeDamage(damage, flag | DamageFlag.DAMAGE_NOKILL, source, 0)
		--	return false
		end
	elseif npc.Variant == mod.FF.SeaCucumber.Var then
		local data = npc:GetData()
		local sprite = npc:GetSprite()
		if not data.anim then
			if sprite:IsPlaying("Move Hori") then
				data.anim = "ShootHori"
				data.offset = 1.6
			elseif sprite:IsPlaying("Move Down") then
				data.anim = "ShootDown"
				data.offset = 0.3
			elseif sprite:IsPlaying("Move Up") then
				data.anim = "ShootUp"
				data.offset = 1.1
			end

			if data.anim then
				sprite:SetFrame(data.anim, 0)
			end
		end
	end
end

mod:AddCallback(ModCallbacks.MC_ENTITY_TAKE_DMG, mod.checkMaggotHurt, 21)

--Run Hive AI
function mod:checkHive(npc)
	local sprite = npc:GetSprite();
	local npcdata = npc:GetData();
	if npc.Variant == mod.FF.Cistern.Var then
		mod:cisternai(npc, sprite, npcdata)
	elseif npc.Variant == 1 then
		mod:drownedhivedontnt(npc, npcdata)
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkHive, 22)

--Stop replacing cisterns with drowned friggin hives
function mod:hiveinit(npc)
	local sprite = npc:GetSprite();
	local npcdata = npc:GetData();
	if npc.Variant == mod.FF.Cistern.Var then
		npcdata.fuckoff = true
	end
end
mod:AddCallback(ModCallbacks.MC_POST_NPC_INIT, mod.hiveinit, 22)

--Run Charger AI
function mod:checkCharger(npc)
	if npc.Variant == mod.FF.Sternum.Var or npc.Variant == mod.FF.Splodum.Var then
		mod:rocketChargerAI(npc, npc.Variant)
	elseif npc.Variant == mod.FF.ReheatedCharger.Var then
		mod:reheatedChargerAI(npc)
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkCharger, 23)

--Run Boom Fly AI
function mod:checkBoom(npc)
	if npc.Variant == mod.FF.DoomFly.Var then
		mod:doomFlyAI(npc)
	elseif npc.Variant == mod.FF.GBF.Var then
		mod:gbfAI(npc)
	elseif npc.Variant == mod.FF.Warhead.Var then
		mod:warheadAI(npc)
	elseif npc.Variant == mod.FF.Drainer.Var then
		mod:drainerAI(npc)
	elseif npc.Variant == mod.FF.PsychoFly.Var then
		mod:psychoFlyAI(npc)
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkBoom, 25)

--Run Maw AI
function mod:checkMaw(npc)
	if npc.SpawnerType == 216 and not npc:GetData().SwingerMaw then
		local sprite = npc:GetSprite()
		sprite:Load("gfx/enemies/swinger head/swinger_head.anm2",true)
		sprite:Play("Appear",true)
		npc:GetData().SwingerMaw = true
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkMaw, 26)

--Run Host AI
function mod:checkHost(npc)
	if npc.SubType == mod.FF.ReheatedHost1.Sub then
		mod:reheatedHost1AI(npc)
	elseif npc.SubType == mod.FF.ReheatedHost2.Sub then
		mod:reheatedHost2AI(npc)
	elseif npc.SubType == mod.FF.ReheatedHost3.Sub then
		mod:reheatedHost3AI(npc)
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkHost, 27)

--Run Hopper AI
function mod:checkHopper(npc)
	local var = npc.Variant
	local subT = npc.SubType
	if var == mod.FF.Tot.Var then
		mod:totAI(npc)
	elseif var ==  mod.FF.Spinneretch.Var then
		mod:spinneretchAI(npc)
	elseif var == mod.FF.SourpatchHead.Var then
		mod:sourpatchHeadAI(npc, npc.SubType)
	elseif var ==  mod.FF.Bombmuncher.Var and subT ==  mod.FF.Bombmuncher.Sub then
		mod:bombmuncherAI(npc)
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkHopper, 29)

--Run Boil AI
function mod:checkBoil(npc)
	if npc.Variant == mod.FF.StickySack.Var then
		mod:stickySackAI(npc)
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkBoil, 30)

--Run Boil AI
function mod:checkWalkingBoil(npc)
	if npc.Variant == mod.FF.WalkingStickySack.Var or npc.Variant == mod.FF.StumblingStickySack.Var then
		mod:walkingStickySackAI(npc)
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkWalkingBoil, 88)

--Run Boil AI
function mod:checkFire(npc)
	if npc.Variant == 10 then
		for key, value in ipairs(npc) do
			--print(key, value)
		end
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkFire, 33)

--Run Grimace AI
function mod:checkGrimace(npc)
	local variant = npc.Variant
	if variant > 959 and variant < 970 then
		local sprite = npc:GetSprite();
		local npcdata = npc:GetData();
		npc.Visible = true
		if variant == mod.FF.Wetstone.Var then
			mod:wetstoneai(npc, sprite, npcdata)
		elseif variant == mod.FF.Cauldron.Var then
			mod:cursedGrimaceAI(npc)
		--[[elseif variant == 7709 or variant == 7710 then
			mod:spawnCongression(npc, variant, npc.SubType)]]
		elseif variant == mod.FF.SensoryGrimace.Var then
			mod:sensoryGrimaceAI(npc, sprite, npcdata)
		elseif variant == mod.FF.Casted.Var then
			mod:castedAI(npc, sprite, npcdata)
		end
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE , mod.checkGrimace, 42)

function mod:checkGrimaceHurt(npc, damage, flag, source, count)
	local variant = npc.Variant
	if variant > 959 and variant < 970 then
		local sprite = npc:GetSprite()
		local npcdata = npc:GetData()
		if variant == mod.FF.Casted.Var then
			mod:castedHurt(npc, npcdata, source)
		end
	end
end
mod:AddCallback(ModCallbacks.MC_ENTITY_TAKE_DMG, mod.checkGrimaceHurt, 42)

--Run Poky AI
function mod:checkPoky(npc)
local variant = npc.Variant
	if variant == mod.FF.ArteryM.Var or variant == mod.FF.ArteryS.Var then
		mod:arteryAI(npc, variant)
	elseif variant == mod.FF.Vein.Var then
		mod:veinAI(npc)
	elseif variant == mod.FF.Graterhole.Var then
		mod:grateholeAI(npc)
	elseif variant >= mod.FF.PipeSeptic.Var and variant <= mod.FF.PipeSplit.Var then
		mod:pipeAI(npc, variant, npc.SubType)
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE , mod.checkPoky, 44)

--Run Mom AI
function mod:checkMom(npc)
	local subt = npc.SubType
	if subt == mod.FF.FiendMom.Sub then
		mod:momFFChampionAI(npc, npc.Variant)
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkMom, 45)
--adding compat to hmmbp maybe?
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkMom, 396)

function mod:mominit(npc)
	if npc.SubType == 3 then --Replace Maus Mom on main path with Fiend Mom
		local stagetype = game:GetLevel():GetStageType()
		if not (stagetype == StageType.STAGETYPE_REPENTANCE or stagetype == StageType.STAGETYPE_REPENTANCE_B) then
			npc:Morph(npc.Type, npc.Variant, mod.FF.FiendMom.Sub, -1)
			npc.MaxHitPoints = npc.MaxHitPoints * 0.75
			npc.HitPoints = npc.MaxHitPoints
		end
	end
end
mod:AddCallback(ModCallbacks.MC_POST_NPC_INIT, mod.mominit, 45)

function mod:momhurt(npc, amount, damageFlags, source)
	if npc.SubType == mod.FF.FiendMom.Sub then
		return mod:IgnoreFireDamage(npc, amount, damageFlags, source)
	end
end
mod:AddCallback(ModCallbacks.MC_ENTITY_TAKE_DMG, mod.momhurt, 45)

mod.overwriteDopleCrawlspace = true

function mod:preDople(npc)
	if mod.overwriteDopleCrawlspace then
		local room = Game():GetRoom()
		local sprite = npc:GetSprite()
		if room:GetBackdropType() == 29 then
			if npc.FrameCount <= 1 then
				npc:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
			end
			local target = npc:GetPlayerTarget()
			local targetpos = target.Position
			local centre = room:GetCenterPos()
			local targetVec = targetpos - centre
			npc.TargetPosition = centre + Vector(targetVec.X * -1, targetVec.Y)
			local ts = target:GetSprite()
			--local tsA, tsOA = ts:GetAnimation(), ts:GetOverlayAnimation()
			if tsA and tsOA then
				sprite:SetFrame(tsA, ts:GetFrame())
				sprite:SetOverlayFrame(tsOA, ts:GetOverlayFrame())
			else
				 if npc.TargetPosition:Distance(npc.Position) > 1 then
					local vec = npc.TargetPosition - npc.Position

					if math.abs(vec.X) > math.abs(vec.Y) then
						sprite:SetOverlayFrame("HeadHori", 0)
						mod:spritePlay(sprite, "WalkHori")
						if vec.X > 0 then
							sprite.FlipX = false
						else
							sprite.FlipX = true
						end
					else
						mod:spritePlay(sprite, "WalkVert")
						if vec.Y > 0 then
							sprite:SetOverlayFrame("HeadDown", 0)
						else
							sprite:SetOverlayFrame("HeadUp", 0)
						end
					end
				else
					npc.Velocity = nilvector
					sprite:SetFrame("WalkVert", 0)
					sprite:SetOverlayFrame("HeadDown", 0)
				end
			end
			npc.Position = centre + Vector(targetVec.X * -1, targetVec.Y)
			npc.Velocity = nilvector
			return true
		end
	end
end
mod:AddCallback(ModCallbacks.MC_PRE_NPC_UPDATE, mod.preDople, 53)

function mod:checkDople(npc)
	if not mod.overwriteDopleCrawlspace then
		local room = Game():GetRoom()
		if room:GetBackdropType() == 29 then
			local target = npc:GetPlayerTarget()
			local targetpos = target.Position
			local centre = room:GetCenterPos()
			local targetVec = targetpos - centre
			npc.TargetPosition = centre + Vector(targetVec.X * -1, targetVec.Y)
			npc.Position = centre + Vector(targetVec.X * -1, targetVec.Y)
		end
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkDople, 53)

function mod:checkParabite(npc)
	local data = npc:GetData()
	if not data.ParabiteInit then
		if npc.Variant == 0 then
			if mod.roomBackdrop == 10 or (npc.SpawnerType == mod.FF.Nematode.ID and npc.SpawnerVariant == mod.FF.Nematode.Var) then
				mod:ReplaceEnemySpritesheet(npc, "gfx/monsters/classic/monster_199_parabite_morbus", 0)
				mod:ReplaceEnemySpritesheet(npc, "gfx/monsters/classic/monster_199_parabite_morbus", 1)
			end
		end
		data.ParabiteInit = true
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE , mod.checkParabite, 58)

function mod:parabiteCollide(npc, npc2, mysteryBoolean)
	if npc.Variant == mod.FF.HungryParabite.Var then
		if npc2.Type == 1 then
			local roundy = Isaac.Spawn(276, 0, 0, npc.Position, nilvector, npc):ToNPC()
			npc:PlaySound(SoundEffect.SOUND_VAMP_GULP,1,0,false,0.8)
			roundy:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
			npc:Remove()
		end
	end
end
mod:AddCallback(ModCallbacks.MC_PRE_NPC_COLLISION , mod.parabiteCollide, 58)

--Run Sucker AI
function mod:checkSucker(npc)
	local variant = npc.Variant
	if variant == mod.FF.Spitroast.Var or variant == mod.FF.Spitfire.Var then
		mod:spitroastAI(npc)
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE , mod.checkSucker, 61)

function mod:checksuckerhurt(npc, damage, flag, source)
	local variant = npc.Variant
	if variant == mod.FF.Spitroast.Var or variant == mod.FF.Spitfire.Var then
		if flag & DamageFlag.DAMAGE_FIRE ~= 0 then
			if source.Type ~= 1 then
				return false
			else
				npc:TakeDamage(damage * 2, flag & DamageFlag.DAMAGE_CLONES, EntityRef(target), 0)
			end
		end
	end
end
mod:AddCallback(ModCallbacks.MC_ENTITY_TAKE_DMG, mod.checksuckerhurt, 61)

--Run Spooter AI
function mod:checkSpooter(npc)
	if mod.FlickerspiritInRoom then
		if npc:GetData().flickerspirited then
			npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYERONLY
		end
	end
	local var = npc.Variant
	if var == mod.FF.Spooter.Var or var == mod.FF.SuperSpooter.Var or var == mod.FF.MegaSpooter.Var or var == mod.FF.LitterBug.Var or var == mod.FF.LitterBugToxic.Var or var == mod.FF.LitterBugCharmed.Var then
		mod:spooterAI(npc, var)
	elseif var == mod.FF.BabySpider.Var then
		mod:babySpiderAI(npc)
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkSpooter, 85)

--Run Gurgle AI
function mod:checkGurgle(npc)
	if npc.Variant == mod.FF.ReheatedGurgle.Var then
		mod:reheatedGurgleAI(npc)
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkGurgle, 87)

--Run Big Spider AI
function mod:checkBigSpider(npc)
	if mod.FlickerspiritInRoom then
		if npc:GetData().flickerspirited then
			npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYERONLY
		end
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkBigSpider, 94)

--Run Gutbuster AI
function mod:checkLongLegs(npc)
	local var = npc.Variant
	if var == mod.FF.Gutbuster.Var or var == mod.FF.KrassBlaster.Var then
		mod:drownedLongLegsAI(npc)
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkLongLegs, 207)

--Run Fatty AI
function mod:checkFatty(npc)
	local sprite = npc:GetSprite();
	local npcdata = npc:GetData();
	if npc.Variant == mod.FF.DankFatty.Var then
		mod:dankFattyAI(npc, sprite)
	elseif npc.Variant == mod.FF.Tubby.Var then
		mod:wehai(npc, sprite, npcdata)
	elseif npc.Variant == mod.FF.Mouthful.Var then
		mod:morselMommyAI(npc, sprite)
	elseif npc.Variant == mod.FF.BigSmoke.Var then
		mod:bigSmokeAI(npc, sprite)
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkFatty, 208)

--Run Lvl2 Spider AI
function mod:checkLvl2Fly(npc)
	local var = npc.Variant
	if var == mod.FF.ReheatedIckyFly.Var then
		mod:reheatedIckyAI(npc)
	elseif var == mod.FF.ReheatedBobbyFly.Var then
		mod:reheatedTickingAI(npc)
	elseif var == mod.FF.ReheatedFly.Var then
		mod:reheatedFlyAI(npc)
	elseif var == mod.FF.ReheatedSackyFly.Var then
	mod:reheatedsSpiderSackAI(npc)
	elseif var == mod.FF.ReheatedChompyFly.Var then
	mod:reheatedFlyScarsAI(npc)
	elseif var == mod.FF.ReheatedTickingFly.Var then
	mod:nonCanonReheatedFlyTickingRealsAI(npc)
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkLvl2Fly, 214)

--Run Lvl2 Spider AI
function mod:checkLvl2Spider(npc)
	if mod.FlickerspiritInRoom then
		if npc:GetData().flickerspirited then
			npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYERONLY
		end
	end
	local var = npc.Variant

	if var == 0 and npc:GetData().IsSpoilie then
		mod.spoiliespiderAI(npc)
	end

	if var == mod.FF.FullSpider.Var then
		mod:reheatedSpiderFullAI(npc)
	elseif var == mod.FF.ReheatedBobbySpider.Var then
		mod:reheatedTickingAI(npc)
	elseif var == mod.FF.ReheatedSpider.Var then
		mod:reheatedSpiderAI(npc)
	elseif var == mod.FF.ReheatedSackySpider.Var then
		mod:reheatedsSpiderSackAI(npc)
	elseif var == mod.FF.ReheatedIckySpider.Var then
		mod:reheatedIckyAI(npc)
	elseif var == mod.FF.ReheatedChompySpider.Var then
		mod:reheatedSpiderScarsAI(npc)
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkLvl2Spider, 215)

--Black Maw funneee
function mod:checkBlackMaw(npc)
	if npc.Variant == mod.FF.BlackMawHapyHed.Var then
		if npc.SubType == 0 then
			local sprite = npc:GetSprite()
			mod:ReplaceEnemySpritesheet(npc, "gfx/enemies/blackmaw/monster_224_blackmaw", 0)
			sprite:LoadGraphics()
			npc.SubType = 1
		end
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE , mod.checkBlackMaw, 225)

--Run Bony AI
function mod:checkBony(npc)
	local var = npc.Variant
	if var == mod.FF.HollowKnight.Var then
		mod:hollowKnightAI(npc)
	elseif var == mod.FF.Powderkeg.Var then
		mod:powderkegAI(npc)
	elseif var == mod.FF.Crepitus.Var then
		local sprite = npc:GetSprite();
		local npcdata = npc:GetData();
		mod:crepitusai(npc, sprite, npcdata)
	elseif var == mod.FF.MrBones.Var then
		local sprite = npc:GetSprite();
		local npcdata = npc:GetData();
		mod:mrbonesai(npc, sprite, npcdata)
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE , mod.checkBony, 227)

function mod:checkBonyHurt(npc, damage, flag, source)
	if npc.Variant == mod.FF.Powderkeg.Var then
		if flag & DamageFlag.DAMAGE_FIRE ~= 0 then
			npc:Kill()
		end
	elseif npc.Variant == mod.FF.HollowKnight.Var then
		local data = npc:GetData()

		if flag == flag | DamageFlag.DAMAGE_POISON_BURN then -- Keep Poison/Burn synced to once per 40 frames
			data.FFLastPoisonProc = data.FFLastPoisonProc or 0
			if Isaac.GetFrameCount() - data.FFLastPoisonProc < 40 then
				return false
			end
			data.FFLastPoisonProc = Isaac.GetFrameCount()

			if flag ~= flag | DamageFlag.DAMAGE_CLONES then
				--if npc.Child then
				--	npc.Child:TakeDamage(damage, flag | DamageFlag.DAMAGE_CLONES, source, 0)
				--end
			end
		elseif flag ~= flag | DamageFlag.DAMAGE_CLONES and not data.FFTakingBleedDamage then -- Regular damage
			return false
		end
	end
end

mod:AddCallback(ModCallbacks.MC_ENTITY_TAKE_DMG, mod.checkBonyHurt, 227)

function mod:checkBonyKill(npc)
	local var = npc.Variant
	if var == mod.FF.HollowKnight.Var then
		local data = npc:GetData()
		if data.brain and data.brain:Exists() then
			data.brain:Kill()
		end
	end
end
mod:AddCallback(ModCallbacks.MC_POST_ENTITY_KILL, mod.checkBonyKill, 227)

function mod:checkBonyCollision(npc, entity, mysteryBool)
	local var = npc.Variant
	if var == mod.FF.HollowKnight.Var then
		local data = npc:GetData()
		if data.brain and entity.InitSeed == data.brain.InitSeed and entity.Index == data.brain.Index then
			return true
		end
	elseif var == mod.FF.MrBones.Var then
		local data = npc:GetData()
		if data.head and entity.InitSeed == data.head.InitSeed and entity.Index == data.head.Index then
			return true
		elseif data.parent and entity.InitSeed == data.parent.InitSeed and entity.Index == data.parent.Index then
			return true
		end
	end
end
mod:AddCallback(ModCallbacks.MC_PRE_NPC_COLLISION, mod.checkBonyCollision, 227)

--Run Bat AI
function mod:checkBat(npc)
	if npc.Variant == 0 then
		if npc.FrameCount == 5 then
			if npc.SubType == 7000 then
				npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_ALL
			end
		end
	elseif npc.Variant == mod.FF.Jawbone.Var then
		mod:jawboneAI(npc)
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE , mod.checkBat, 234)

--Run Wall Creep AI
function mod:checkWallCreep(npc)
	local var = npc.Variant
	if var == mod.FF.Fried.Var then
		mod:friedAI(npc)
	elseif var == mod.FF.OgreCreep.Var then
		mod:ogreCreepAI(npc)
	elseif var == mod.FF.ReheatedIckyCreep.Var then
		mod:reheatedCreep1AI(npc)
	elseif var == mod.FF.ReheatedTechyCreep.Var then
		mod:reheatedCreep2AI(npc)
	elseif var == mod.FF.ScowlCreep.Var then
		mod:scowlCreepAI(npc)
	elseif var == mod.FF.ScopeCreep.Var then
		mod:scopeCreepAI(npc)
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE , mod.checkWallCreep, 240)

function mod:checkWallCreepHurt(npc, damage, flag, source)
	if npc.Variant == mod.FF.Fried.Var then
		if flag & DamageFlag.DAMAGE_FIRE ~= 0 and source.Type ~= 1 then
			return false
		end
	end
end
mod:AddCallback(ModCallbacks.MC_ENTITY_TAKE_DMG, mod.checkWallCreepHurt, 240)

function mod:checkTickingSpider(npc)
	if mod.FlickerspiritInRoom then
		if npc:GetData().flickerspirited then
			npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYERONLY
		end
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkTickingSpider, 250)

--[[function mod:checkBegotten(npc)
	--Ms. Dominator ones

	local d = npc:GetData()
	if npc.SubType == 960 and d.dominated then
		mod:dominatorBegottenAI(npc, d)
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkBegotten, 251)]]

--Run Fat Bat AI
function mod:checkFatBat(npc)
	local var = npc.Variant
	if var == mod.FF.BubbleBat.Var then
		mod:drownedFatBatAI(npc)
	elseif var == mod.FF.Ribbone.Var then
		mod:ribboneAI(npc)
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkFatBat, 258)

--Run Cyclopia AI
function mod:checkCyclopia(npc)
	local var = npc.Variant
	if var == mod.FF.ReheatedCyclopia.Var then
		mod:reheatedCyclopiaAI(npc)
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkCyclopia, 284)

function mod:checkStoney(npc)
	if not npc:HasEntityFlags(EntityFlag.FLAG_NO_TARGET) then
		npc:AddEntityFlags(EntityFlag.FLAG_NO_TARGET)
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkStoney, 302)

function mod:checkGrudge(npc)
	if npc.Variant == mod.FF.Grievance.Var then
		mod:grievanceAI(npc)
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkGrudge, 877)

function mod:checkGrudgeCollision(npc, coll, bool)
	if npc.Variant == mod.FF.Grievance.Var then
		mod:grievanceColl(npc, coll, bool)
	end
end
mod:AddCallback(ModCallbacks.MC_PRE_NPC_COLLISION, mod.checkGrudgeCollision, 877)

function mod:checkMinecart(npc)
	if npc.Child then
		npc.Child:GetData().inMinecart = npc
		if npc.Child.Type == 907 then
			npc.SpriteScale = Vector(10, 1)
		end
		--[[if npc.Child.Type == mod.FF.Centipede.ID and npc.Child.Variant == mod.FF.Centipede.Var then
			npc.Visible = false
		end]]
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkMinecart, 965)

--Mini - Run AI
function mod:check666(npc)
	local sprite = npc:GetSprite();
	local npcdata = npc:GetData();
	local var = npc.Variant
		if var == mod.FF.SoftServe.Var or var == mod.FF.Sundae.Var or var == mod.FF.Scoop.Var then
			if not npcdata.eraserinit then
				if(var == mod.FF.Sundae.Var) then
					npc:Morph(666,0,0,-1)
					npcdata.scoopnumber = 2
				elseif var == mod.FF.Scoop.Var then
					npc:Morph(666,0,0,-1)
					npcdata.scoopnumber = 1
				end
				npcdata.eraserinit = true
			end
			mod:softServeAI(npc, sprite, npcdata, var);
		elseif var == mod.FF.Load.Var or var == mod.FF.CornLoad.Var then
			mod:loadai(npc, sprite, npcdata, var)
		elseif var == mod.FF.Baro.Var then
			mod:baroai(npc, sprite, npcdata)
		elseif var == mod.FF.Chorister.Var then
			mod:choristerai(npc, sprite, npcdata)
		elseif var == mod.FF.Foamy.Var then
			mod:rabidbatai(npc, sprite, npcdata)
		elseif var == mod.FF.Fathead.Var then
			mod:fatheadai(npc, sprite, npcdata)
		elseif var == mod.FF.Skuzz.Var then
			mod:skuzzai(npc, sprite, npcdata)
		elseif var == mod.FF.Ransacked.Var then
			mod:ransackedai(npc, sprite, npcdata)
		elseif var == mod.FF.Skuzzball.Var then
			mod:skuzzballai(npc, sprite, npcdata)
		elseif var == mod.FF.SkuzzballSmall.Var then
			if not npcdata.init then
				npcdata.init = true
				sprite.Offset = Vector(0, 0)
				npcdata.jumpytimer = math.random(20, 60)
				npcdata.state = "idle"
				npcdata.stateframe = 0
				npcdata.lookdown = "not"
				npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS
				npc.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_GROUND
				npcdata.spidernumber = 3
				npcdata.spiderlist = {0, 6, 12}
				npcdata.size = "small"
				npcdata.jumpsize = "small"
				npcdata.jumpstartdone = false
				npcdata.isCorpse = mod:CheckStage("Corpse", {34,43,44})
				for _, player in ipairs(Isaac.FindByType(1, -1, -1, false, false)) do
					player = player:ToPlayer()
					if player:HasCollectible(377) then
						npc.CollisionDamage = 0
						npcdata.bursting = 1
					end
				end
			end
			mod:skuzzballai(npc, sprite, npcdata)
		elseif var == mod.FF.Boiler.Var then
			mod:boilerai(npc, sprite, npcdata)
		elseif var == mod.FF.DrinkWorm.Var then
			mod:drinkwormai(npc, sprite, npcdata)
		elseif var == mod.FF.DrunkWorm.Var then
			mod:drunkwormai(npc, sprite, npcdata)
		elseif var == mod.FF.Wobbles.Var then
			mod:wobblesai(npc, sprite, npcdata)
		elseif var == mod.FF.SludgeHost.Var then
			mod:sludgehostai(npc, sprite, npcdata);
		elseif var == mod.FF.Creepterum.Var then
			mod:creepterumai(npc, sprite, npcdata)
		elseif var == mod.FF.Curdle.Var then
			mod:curdleai(npc, sprite, npcdata)
		elseif var == mod.FF.CurdleNaked.Var then
			if not npcdata.init then
				npc:Morph(666,mod.FF.Curdle.Var,0,-1)
				sprite:Load("gfx/enemies/curdle/curdleLEWD.anm2",true)
				npcdata.skin = false
				npcdata.state = "walk"
				npcdata.vomtimer = math.random(60, 90)
				npcdata.confuseangle = math.random(360)
				npcdata.init = true
			end
			mod:curdleai(npc, sprite, npcdata)
		elseif var == mod.FF.Calzone.Var or var == mod.FF.Breadbin.Var  then
			mod:calzoneai(npc, sprite, npcdata)
		elseif var == mod.FF.Honeydrop.Var then
			mod:honeydropai(npc, sprite, npcdata)
		elseif var == mod.FF.Bella.Var then
			mod:bellaai(npc, sprite, npcdata)
		elseif var == mod.FF.Marge.Var then
			mod:margeai(npc, sprite, npcdata)
		elseif var == mod.FF.Heiress.Var then
			mod:heiressai(npc, sprite, npcdata)
		elseif var == mod.FF.Patzer.Var then
			mod:patzerai(npc, sprite, npcdata)
		elseif var == mod.FF.PatzerShell.Var then
			mod:patzershellai(npc, sprite, npcdata)
		elseif var == mod.FF.DopeHead.Var then
			mod:dopeheadai(npc, sprite, npcdata)
		elseif var == mod.FF.DopeHeadProjectile.Var then
			mod:dopeheadprojectileai(npc, sprite, npcdata)
		end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.check666, 666)

function mod:check666Init(npc)
	local sprite = npc:GetSprite();
	local npcdata = npc:GetData();
	local var = npc.Variant
		if var == Isaac.GetEntityVariantByName("Soft Serve") or var == Isaac.GetEntityVariantByName("Sundae") or var == Isaac.GetEntityVariantByName("Scoop") then
			if (npc.SubType == 1 or npc.SubType == 2) and npc:HasEntityFlags(EntityFlag.FLAG_APPEAR) then
				npc:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
				sprite:Play("Appear" .. npc.SubType, true)
				npc:AddEntityFlags(EntityFlag.FLAG_APPEAR)
			end
		end
end
mod:AddCallback(ModCallbacks.MC_POST_NPC_INIT , mod.check666Init, 666)

mod:AddCallback(ModCallbacks.MC_POST_EFFECT_UPDATE, function(_, eff)
	if eff.SubType == 960 then
		eff.Variant = 1230

		eff.SpriteScale = eff.SpriteScale * 2
		-- scale to 1 from current scale in timeout frames
		eff.Scale = 1 / (eff.SpriteScale.X ^ (1 / eff.Timeout))
		eff.Timeout = 6
		eff.Rotation = math.random(0, 360)

		local sprite = eff:GetSprite()
		sprite:Load('gfx/effects/effect_rockpoof.anm2', true)
		sprite:Play("Poof", true)
		sprite.PlaybackSpeed = 14 / eff.LifeSpan

		local data = eff:GetData()
		data.IsScaledEff = true
	end
end, EffectVariant.DUST_CLOUD)

mod:AddCallback(ModCallbacks.MC_POST_EFFECT_UPDATE, function(_, eff)
	eff.Velocity = eff.Velocity * eff.Friction
	eff.Rotation = eff.Rotation + (eff.InitSeed % 40)
end, 1230)

mod:AddCallback(ModCallbacks.MC_POST_EFFECT_UPDATE, function(_, eff)
	if eff.SubType == 960 then
		local d = eff:GetData()
		if d.shrink then
			eff.SpriteScale = eff.SpriteScale * d.shrink
			eff.Color = Color(eff.Color.R, eff.Color.G, eff.Color.B, eff.Color.A * d.shrink, eff.Color.RO, eff.Color.GO, eff.Color.BO)
		end
	end
end, EffectVariant.DARK_BALL_SMOKE_PARTICLE)

mod:AddCallback(ModCallbacks.MC_POST_EFFECT_UPDATE, function(_, eff)
	if eff.SubType == 960 then
		local d = eff:GetData()
		if d.shrink then
			eff.SpriteScale = eff.SpriteScale * d.shrink
			eff.Color = Color(eff.Color.R, eff.Color.G, eff.Color.B, eff.Color.A * d.shrink, eff.Color.RO, eff.Color.GO, eff.Color.BO)
		end
	end
end, EffectVariant.DARK_BALL_SMOKE_PARTICLE)

mod:AddCallback(ModCallbacks.MC_POST_EFFECT_UPDATE, function(_, eff)
	if eff.SubType == 960 then
		eff.Color = Color(eff.Color.R, eff.Color.G, eff.Color.B, eff.Color.A * 0.9, eff.Color.RO, eff.Color.GO, eff.Color.BO)
	end
end, EffectVariant.POOF02)

mod:AddCallback(ModCallbacks.MC_POST_EFFECT_UPDATE, function(_, eff)
	local sprite = eff:GetSprite()
	if eff.FrameCount < 2 then
		if sprite:GetFilename() == "gfx/grid/grid_rock.anm2" then
			if game:GetRoom():GetBackdropType() == 31 then
				sprite:ReplaceSpritesheet(0, "gfx/grid/rocks_downpour_entrance.png")
				sprite:LoadGraphics()
			end
		end
	end
end, EffectVariant.GRID_ENTITY_PROJECTILE_HELPER)

function mod:checkVerminEnemies(npc)
	local var = npc.Variant
	if var == 1 then
		--nothing here yet
	else
		--The Default Boy
		mod:danglerAI(npc)
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkVerminEnemies, FiendFolio.FFID.Vermin)

--Run Worm AI
function mod:checkWorm(npc)
	local sprite = npc:GetSprite();
	local npcdata = npc:GetData();
	if npc.Variant == mod.FF.BoneWorm.Var then
		mod:bonewormai(npc, sprite, npcdata)
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkWorm, 244)


function mod:checkDeliriumInit(npc)
	mod.IsDeliriumRoom = true
end
mod:AddCallback(ModCallbacks.MC_POST_NPC_INIT, mod.checkDeliriumInit, 412)

function mod:checkWormInit(npc)
	local sprite = npc:GetSprite();
	local npcdata = npc:GetData();
	local var = npc.Variant
		if var == Isaac.GetEntityVariantByName("Soft Serve") or var == Isaac.GetEntityVariantByName("Solid Serve") then
			if (npc.SubType == 1 or npc.SubType == 2) and npc:HasEntityFlags(EntityFlag.FLAG_APPEAR) then
				npc:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
				sprite:Play("Appear" .. npc.SubType, true)
				npc:AddEntityFlags(EntityFlag.FLAG_APPEAR)
			end
		end
end
mod:AddCallback(ModCallbacks.MC_POST_NPC_INIT , mod.checkWormInit, FiendFolio.FFID.Mini)

local spikerel = {
	Vector(-60, 0),
	Vector(60, 0),
	Vector(-30, 20),
	Vector(30, 20),
}

local sunAIs = {
	[50] = function(npc, sprite, data) -- The Sun
		local room = game:GetRoom()

		if not data.init then
			npc.CanShutDoors = false
			npc:AddEntityFlags(EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK | EntityFlag.FLAG_NO_KNOCKBACK | EntityFlag.FLAG_NO_STATUS_EFFECTS | EntityFlag.FLAG_NO_TARGET)

			npc.Position = Vector(npc.Position.X, 200)

			FiendFolio.NPCBlockerGrid:Spawn(room:GetGridIndex(npc.Position), true, false, { Parent = npc })

			data.venus = Isaac.Spawn(npc.Type, 51, npc.SubType, npc.Position + Vector(0, 80):Rotated(-60), nilvector, npc)
			data.venus:GetData().sun = npc
			data.earth = Isaac.Spawn(npc.Type, 52, npc.SubType, npc.Position + Vector(0, 140):Rotated(60), nilvector, npc)
			data.earth:GetData().sun = npc
			data.neptune = Isaac.Spawn(npc.Type, 53, npc.SubType, npc.Position + Vector(0, 200):Rotated(-60), nilvector, npc)
			data.neptune:GetData().sun = npc

			data.orbitalpos = {
				venus = data.venus.Position - npc.Position,
				earth = data.earth.Position - npc.Position,
				neptune = data.neptune.Position - npc.Position,
			}

			data.orbitalspeed = {
				venus = 0.5,
				earth = -1,
				neptune = 1.2,
				neptuneInPractice = 1.2, -- used for gradual adjustments
			}

			data.spikes = {}
			for i = 1, 4 do
				data.spikes[i] = Isaac.Spawn(npc.Type, 55, npc.SubType, npc.Position + spikerel[i], nilvector, npc)
				data.spikes[i]:GetData().sun = npc
				if i % 2 == 0 then
					data.spikes[i]:GetSprite().FlipX = true
				end
			end

			sprite:Play("Idle")

			--[[for _, p in pairs(Isaac.FindByType(1, -1, -1)) do
				if p.Position.Y < npc.Position.Y or p.Position:Distance(npc.Position) - p.Size - npc.Size <= 0 then
					p.Position = npc.Position + Vector(0, 150)
				end
			end]]

			data.last = npc.FrameCount
			data.lastroll = 0

			data.init = true
		end

		npc.Velocity = nilvector

		if sprite:IsFinished("SpawnHollow") or sprite:IsFinished("SpitFire") or sprite:IsFinished("SpitBomb") then
			sprite:Play("Idle")
			data.last = npc.FrameCount
		end

		local canattack = data.venus.HitPoints + data.earth.HitPoints + data.neptune.HitPoints < (data.venus.MaxHitPoints + data.earth.MaxHitPoints + data.neptune.MaxHitPoints) * 9/10

		if sprite:IsPlaying("Idle") and canattack and ((data.last + 60 < npc.FrameCount and math.random(30) == 1) or data.last + 90 < npc.FrameCount) then
			local r = data.lastroll
			while r == data.lastroll do
				r = math.random(3)
			end
			--r = 1

			if r == 1 then
				sprite:Play("SpawnHollow")
				if (mod.GetEntityCount(40) + mod.GetEntityCount(227)) > 1 then
					if data.lastroll == 2 then
						sprite:Play("SpitBomb")
						r = 3
					else
						sprite:Play("SpitFire")
						r = 2
					end
				end
			elseif r == 2 then
				sprite:Play("SpitFire")
			elseif r == 3 then
				sprite:Play("SpitBomb")
			end

			data.lastroll = r
		end

		if sprite:IsPlaying("SpawnHollow") then
			if sprite:IsEventTriggered("Grunt") then
				npc:PlaySound(mod.Sounds.FlashSatanHurt,2,0,false,1.3)
			elseif sprite:IsEventTriggered("Pop") then
				npc:PlaySound(SoundEffect.SOUND_MEATY_DEATHS,1,0,false,0.7)
			end
		elseif sprite:IsPlaying("SpitFire") then
			if sprite:IsEventTriggered("Grunt") then
				npc:PlaySound(mod.Sounds.FlashSatanCharge,2,0,false,1.3)
			elseif sprite:IsEventTriggered("FireStart") then
				npc:PlaySound(mod.Sounds.FlashDevilCard,2,0,false,math.random(90,120)/100)
			end
		elseif sprite:IsPlaying("SpitBomb") then
			if sprite:IsEventTriggered("Grunt") then
				npc:PlaySound(mod.Sounds.FlashSatanSpit1,2,0,false,1.3)
			elseif sprite:IsEventTriggered("Grunt2") then
				npc:PlaySound(mod.Sounds.FlashSatanSpit1,2,0,false,1.6)
			elseif sprite:IsEventTriggered("Phew") then
				npc:PlaySound(mod.Sounds.FireLight,2,0,false,1.6)
			end
		end

		if sprite:IsEventTriggered("Shoot") then
			npc:PlaySound(mod.Sounds.FlashSatanSpit2,2,0,false,math.random(150,180)/100)
			local b = Isaac.Spawn(4, 8, 0, npc.Position, (npc:GetPlayerTarget().Position - npc.Position):Resized(13), npc):ToBomb()
			b:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
			b.ExplosionDamage = 20
			b.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS
			b.Flags = TearFlags.TEAR_BURN
			b:GetData().sun = true
		end

		if sprite:WasEventTriggered("FireStart") and not sprite:WasEventTriggered("FireEnd") then
			local f = Isaac.Spawn(1000, 7005, 0, npc.Position - (npc:GetPlayerTarget().Position - npc.Position):Resized(15), (npc:GetPlayerTarget().Position - npc.Position):Resized(8):Rotated(math.random(-10, 10)), npc):ToEffect()
			f:SetColor(Color(1,1,1,1,-100 / 255,70 / 255,455 / 255),10,1,true,false)
			f:GetData().timer = 24
			f:GetData().flamethrower = true
			f:Update()
		end

		if sprite:IsEventTriggered("Summon") then
			npc:PlaySound(mod.Sounds.FlashSatanBlast,1,0,false,1.3)
			if (math.random(2) == 1) and not (mod.GetEntityCount(277) > mod.GetEntityCount(40)) then
				for i = -30, 30, 60 do -- Hollow Knights
					local e = Isaac.Spawn(mod.FF.RollingHollowKnight.ID, mod.FF.RollingHollowKnight.Var, 1, npc.Position + Vector(i, 15), Vector(i/15, 10):Resized(13), npc)
					e:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
					local es = e:GetSprite()
					es:ReplaceSpritesheet(0, "gfx/enemies/hollowknight/hollow_knight_sun.png")
					es:ReplaceSpritesheet(1, "gfx/enemies/hollowknight/hollow_knight_sun.png")
					es:LoadGraphics()
					e.SpriteOffset = Vector(0, -14)
				end
			else
				for i = -30, 30, 60 do --Guts
					local e = Isaac.Spawn(40, 0, 4, npc.Position + Vector(i, 75), Vector(0, 10):Resized(13), npc)
					e:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
					e.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS
					--e.SpriteOffset = Vector(0, -14)
				end
			end
		end

		if npc.FrameCount > 24 then
			if not data.venus:IsDead() then
				local brainorbit = true
				if data.earth:IsDead() or data.neptune:IsDead() then
					brainorbit = false
					data.venus:GetData().enraged = true
				end
				if brainorbit then
					local oldpos = data.orbitalpos.venus
					data.orbitalpos.venus = data.orbitalpos.venus:Rotated(data.orbitalspeed.venus)
					local len = data.venus.Velocity:Length() + 0.1
					local maxlen = oldpos:Distance(data.orbitalpos.venus)

					data.venus.Velocity = ((npc.Position + data.orbitalpos.venus) - data.venus.Position):Resized(len) * 1.2
					if data.venus.Velocity:Length() > maxlen then
						data.venus.Velocity = data.venus.Velocity:Resized(maxlen)
					end
				else
					data.venus.Velocity = (npc:GetPlayerTarget().Position - data.venus.Position):Resized(2)
				end

			end
			if not data.earth:IsDead() then
				local oldpos = data.orbitalpos.earth
				data.orbitalpos.earth = data.orbitalpos.earth:Rotated(data.orbitalspeed.earth)
				if data.venus:IsDead() or data.neptune:IsDead() then
					data.earth:GetData().enraged = true
					local targdist = (npc:GetPlayerTarget().Position - npc.Position):Length()
					if targdist > data.orbitalpos.earth:Length() then
						data.orbitalpos.earth = data.orbitalpos.earth:Resized(data.orbitalpos.earth:Length() + 1)
					else
						data.orbitalpos.earth = data.orbitalpos.earth:Resized(data.orbitalpos.earth:Length() - 1)
					end
					if (npc:GetPlayerTarget().Position - data.earth.Position):Length() < 150 then
						local extra = (npc:GetPlayerTarget().Position - data.earth.Position):Length() / 300
						data.orbitalspeed.earth = mod:Lerp(data.orbitalspeed.earth, -1 + extra, 0.1)
					elseif not room:IsPositionInRoom(data.earth.Position, 0) then
						data.orbitalspeed.earth = mod:Lerp(data.orbitalspeed.earth, -2, 0.1)
					else
						data.orbitalspeed.earth = mod:Lerp(data.orbitalspeed.earth, -1, 0.1)
					end
				end
				local len = data.earth.Velocity:Length() + 0.1
				local maxlen = oldpos:Distance(data.orbitalpos.earth)

				data.earth.Velocity = ((npc.Position + data.orbitalpos.earth) - data.earth.Position):Resized(len) * 1.2
				if data.earth.Velocity:Length() > maxlen then
					data.earth.Velocity = data.earth.Velocity:Resized(maxlen)
				end
			end
			if not data.neptune:IsDead() then
				if (data.venus:IsDead() or data.earth:IsDead()) and not data.neptune:GetData().enraged then
					data.neptune:GetData().enraged = true
					data.orbitalspeed.neptune = 2
				end
				local oldpos = data.orbitalpos.neptune
				data.orbitalspeed.neptuneInPractice = mod:Lerp(data.orbitalspeed.neptuneInPractice, data.orbitalspeed.neptune, 0.2)
				data.orbitalpos.neptune = data.orbitalpos.neptune:Rotated(data.orbitalspeed.neptuneInPractice)
				local len = data.neptune.Velocity:Length() + 0.1
				local maxlen = oldpos:Distance(data.orbitalpos.neptune)

				data.neptune.Velocity = ((npc.Position + data.orbitalpos.neptune) - data.neptune.Position):Resized(len) * 1.2
				if data.neptune.Velocity:Length() > maxlen then
					data.neptune.Velocity = data.neptune.Velocity:Resized(maxlen)
				end
			end
		end

		if data.venus:IsDead() and data.earth:IsDead() and data.neptune:IsDead() and not data.dead then
			sprite:Play("Death")
			data.dead = true
		end

		if sprite:IsPlaying("Death") and sprite:IsEventTriggered("Grunt") then
			npc:PlaySound(mod.Sounds.FlashSatanBlast,2,0,false,0.8)
		end

		if sprite:IsEventTriggered("KillSpikes") then
			for _, s in pairs(data.spikes) do
				s:Kill()
			end

			if data.spawnCard then
				sprite:Play("Dead")
			end
		end

		if sprite:IsFinished("Death") then
			npc.CollisionDamage = 0
			sprite:Play("Dead")
		end

		if sprite:IsPlaying("Dead") and data.spawnCard then
			if game:GetRoom():GetType() == RoomType.ROOM_BOSS then
				Isaac.Spawn(5,100,CollectibleType.COLLECTIBLE_PLANET_BADGE,npc.Position,nilvector,npc)
			end
			npc:BloodExplode()
			for i = 1, 20 do
				Isaac.Spawn(EntityType.ENTITY_EFFECT, 5, 0, npc.Position + RandomVector()*math.random(1,50), (RandomVector()*(math.random()+math.random(5,12))), npc);
			end
			npc:Remove()
		end
	end,
	[51] = function(npc, sprite, data) -- Venus (The Brain)
		if data.sun and data.sun:Exists() then
			if not data.init then
				npc:AddEntityFlags(EntityFlag.FLAG_NO_KNOCKBACK | EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK)
				npc.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_NONE

				sprite:Play("Idle")
				sprite.Offset = Vector(0, -14)

				data.last = npc.FrameCount

				data.init = true
			end

			if sprite:IsFinished("SpawnBrain") then
				sprite:Play("Idle")
			end

			if sprite:IsPlaying("Idle") then
				if data.enraged then
					if (mod.GetEntityCount(32, 0, 0) < 3) and ((data.last + 120 < npc.FrameCount and math.random(17) == 1) or data.last + 150 < npc.FrameCount) then
						sprite:Play("SpawnBrain")
					end
				elseif (mod.GetEntityCount(32, 0, 0) < 1) and (data.sun.Position + data.sun:GetData().orbitalpos.venus:Rotated(data.sun:GetData().orbitalspeed.venus * 30)).Y > data.sun.Position.Y - 20 and ((data.last + 120 < npc.FrameCount and math.random(17) == 1) or data.last + 150 < npc.FrameCount) then
					sprite:Play("SpawnBrain")
				end
			end

			if mod.GetEntityCount(32) > 0 then
				data.last = npc.FrameCount
			end

			if sprite:IsEventTriggered("Spawn") then
				npc:PlaySound(SoundEffect.SOUND_SUMMONSOUND, 0.6, 0, false, 1)
				data.last = npc.FrameCount
				local brain = Isaac.Spawn(32, 0, 0, npc.Position, nilvector, npc)
				brain:GetSprite():ReplaceSpritesheet(0, "gfx/bosses/the sun/sunbrain.png")
				brain:GetSprite():LoadGraphics()
			elseif sprite:IsEventTriggered("Liftoff") then
				npc:PlaySound(SoundEffect.SOUND_MEATY_DEATHS,1,0,false,1.3)
			end
		else
			npc:Kill()
		end
	end,
	[52] = function(npc, sprite, data) -- Earth (The Kidney)
		if data.sun and data.sun:Exists() then
			if not data.init then
				npc:AddEntityFlags(EntityFlag.FLAG_NO_KNOCKBACK | EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK)
				npc.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_NONE

				sprite:Play("Idle")
				sprite.Offset = Vector(0, -14)

				data.stones = {}
				for i = 1, 2 do
					data.stones[i] = Isaac.Spawn(npc.Type, 54, npc.SubType, npc.Position + Vector(30, 30):Rotated(180 * i), nilvector, npc)
					data.stones[i]:GetSprite():Play("Stone0"..i)
					data.stones[i]:GetData().skin = i
					data.stones[i].Parent = npc
				end

				data.orbitalpos = {
					data.stones[1].Position - npc.Position,
					data.stones[2].Position - npc.Position,
				}

				data.init = true
			end

			if npc.FrameCount > 24 then
				for i, s in pairs(data.stones) do
					local speed = 1
					if data.enraged then
						speed = 3
					end
					data.orbitalpos[i] = data.orbitalpos[i]:Rotated(speed)
					s.Velocity = (npc.Position + data.orbitalpos[i]) - s.Position
				end
			end

			if npc:IsDead() then
				for _, s in pairs(data.stones) do
					s:Kill()
				end
			end
		else
			npc:Kill()
		end
	end,
	[53] = function(npc, sprite, data) -- Neptune (The Heart)
		if data.sun and data.sun:Exists() then
			local room = game:GetRoom()

			if not data.init then
				npc:AddEntityFlags(EntityFlag.FLAG_NO_KNOCKBACK | EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK)
				npc.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_NONE

				sprite:Play("Idle")
				sprite.Offset = Vector(0, -14)

				data.last = npc.FrameCount

				data.init = true
			end

			if sprite:IsFinished("BeatStart") then
				sprite:Play("Beating")
				data.beat = npc.FrameCount
			elseif sprite:IsFinished("BeatEnd") then
				sprite:Play("Idle")
				data.last = npc.FrameCount
				data.blowOut = false
			end

			if sprite:IsEventTriggered("Done") then
				npc:PlaySound(SoundEffect.SOUND_HEARTIN, 1.5, 0, false, 0.7)
				if data.blowOut then
					for i = 30, 360, 30 do
						local params = ProjectileParams()
						params.FallingAccelModifier = -0.08
						params.FallingSpeedModifier = 0
						params.Scale = 2
						local vec = Vector(9, 0):Rotated(i)
						npc:FireProjectiles(npc.Position + Vector(20, 0):Rotated(i), Vector(9, 0):Rotated(i), 0, params)
					end
				end
			elseif data.blowOut and sprite:IsPlaying("BeatEnd") and sprite:GetFrame() == 21 then
				for i = 30, 360, 30 do
					local params = ProjectileParams()
					params.FallingAccelModifier = -0.08
					params.FallingSpeedModifier = 0
					params.Scale = 2
					local vec = Vector(9, 0):Rotated(i)
					npc:FireProjectiles(npc.Position + Vector(20, 0):Rotated(i + 15), Vector(9, 0):Rotated(i + 15), 0, params)
				end
			end

			if sprite:IsPlaying("Idle") then
				if data.last + 480 < npc.FrameCount and room:IsPositionInRoom(npc.Position, 0) and math.random(6) == math.random(6) then
					sprite:Play("BeatStart")
				end
			elseif sprite:IsPlaying("Beating") then
				if sprite:GetFrame() % 8 == 0 then
					npc:PlaySound(SoundEffect.SOUND_HEARTBEAT_FASTEST, 1.5, 0, false, 1.3)
					local offset = math.random(360)
					for i = 1, 4 do
						local p = Isaac.Spawn(9, 0, 0, npc.Position, Vector(3, 0):Rotated(i * 90 + 5 * (npc.FrameCount % 360)), npc)
					end
				end

				if data.beat + 80 <= npc.FrameCount or not room:IsPositionInRoom(npc.Position, 0) then
					sprite:Play("BeatEnd")
				end
			end

			if npc.FrameCount % 4 == 0 and room:IsPositionInRoom(npc.Position, 0) then
				local c = Isaac.Spawn(1000, 22, 0, npc.Position, nilvector, npc):ToEffect()
				c:SetTimeout(30)
				if npc.FrameCount % 8 == 0 then
					local params = ProjectileParams()
					params.FallingAccelModifier = -0.08
					params.FallingSpeedModifier = 0
					npc:FireProjectiles(npc.Position, nilvector, 0, params)
				end
			end

			if data.enraged then
				if not room:IsPositionInRoom(npc.Position, 0) then
					if not data.flippedYet then
						if data.sun then
							local sund = data.sun:GetData()
							sund.orbitalspeed.neptune = sund.orbitalspeed.neptune * -1
							if sprite:IsPlaying("Idle") then
								sprite:Play("BeatEnd")
								data.blowOut = true
								Game():ShakeScreen(15)
								npc:PlaySound(SoundEffect.SOUND_HELLBOSS_GROUNDPOUND,0.6,2,false,1)
							end
						end
						data.flippedYet = true
					end
				else
					data.flippedYet = false
				end
			end
		else
			npc:Kill()
		end
	end,
	[54] = function(npc, sprite, data) -- Moon (The Kidney Stones)
		if npc.Parent and npc.Parent:Exists() then
			if not data.init then
				npc:AddEntityFlags(EntityFlag.FLAG_NO_KNOCKBACK | EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK | EntityFlag.FLAG_NO_STATUS_EFFECTS)
				npc.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_NONE

				sprite.Offset = Vector(0, -14)
				data.Cooldown = 0
				data.last = npc.FrameCount
				data.skin = data.skin or math.random(2)
				data.init = true
			end

			data.Cooldown = data.Cooldown - 1
			if sprite:IsFinished("Shoot0"..data.skin) then
				data.last = npc.FrameCount
				sprite:Play("Stone0"..data.skin)
			end

			--[[if sprite:IsPlaying("Stone0"..data.skin) then
				if data.last + 150 < npc.FrameCount and room:IsPositionInRoom(npc.Position, 0) and math.random(35) == math.random(35) then
					sprite:Play("Shoot0"..data.skin)
				end
			end]]

			if sprite:IsEventTriggered("Shoot") then
				--local p = Isaac.Spawn(9, 4, 0, npc.Position, (npc:GetPlayerTarget().Position - npc.Position):Resized(7), npc)
				--p:SetColor(Color(1, 1, 0, 1, 0, 0, 0), 0, 0, 0, false, true)
				data.targVec = (npc:GetPlayerTarget().Position - npc.Position):Normalized()
				npc.StateFrame = 3
			end

			if npc.StateFrame > 0 then
				if npc.StateFrame == 3 then
					npc:PlaySound(mod.Sounds.Valvo, 1.5, 0, false, math.random(9,11)/10)
				end
				npc.StateFrame = npc.StateFrame - 1
				local power = (15-(5 - npc.StateFrame-6))/15
				local pistolet = ProjectileParams()
				pistolet.Color = FiendFolio.ColorLemonYellow
				--pistolet.Variant = 4
				npc.Velocity = npc.Velocity - data.targVec*3*(power^3)
				Game():ShakeScreen(math.floor(((power^2)*15)*0.3))
				--if npc.FrameCount%(5-math.ceil((power^2)*4))==0 then
					for i=0,math.ceil((power^2)*1.5),1 do
						local projectileSpeed = math.random(40,80)/10*power*1.2
						pistolet.Scale = (projectileSpeed-3)/3.5 +(1-power)/7
						pistolet.FallingAccelModifier = math.random(1,5)/20*(2-power)
						npc:FireProjectiles(npc:ToNPC().Position + data.targVec*10, data.targVec:Rotated(-5):Rotated(math.random(0,10))*projectileSpeed, 0, pistolet)
					end
				--end
			end
		else
			npc:Kill()
		end
	end,
	[55] = function(npc, sprite, data) -- Sun Spikes
		if data.sun and data.sun:Exists() then
			if not data.init then
				npc:AddEntityFlags(EntityFlag.FLAG_NO_KNOCKBACK | EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK | EntityFlag.FLAG_NO_STATUS_EFFECTS)
				npc.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_NONE
				data.init = true
			end

			npc.Velocity = nilvector
		else
			npc:Kill()
		end
	end,
}

function mod:hollowKnightProjectileAI(npc, sprite, data)
	if not data.init then
		--npc:AddEntityFlags(EntityFlag.FLAG_NO_STATUS_EFFECTS | EntityFlag.FLAG_NO_TARGET | EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK | EntityFlag.FLAG_NO_KNOCKBACK)
		npc:AddEntityFlags(EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK | EntityFlag.FLAG_NO_KNOCKBACK)
		npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS
		data.init = true
	end

	if npc.FrameCount < 5 then
		npc.SpriteOffset = npc.SpriteOffset * (1 - npc.FrameCount / 5)
	end

	if sprite:IsFinished("ShotOut") then
		sprite:Play("Roll")
	end
	if sprite:IsFinished("Roll") then
		sprite:Play("Spawn")
	end

	if not sprite:IsPlaying("ShotOut") then
		npc.Velocity = npc.Velocity * 0.9
	end

	if sprite:IsEventTriggered("SpawnBrain") then
		data.brain = Isaac.Spawn(mod.FF.Cortex.ID, mod.FF.Cortex.Var, 0, npc.Position, nilvector, npc)
		data.brain:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
		data.brain.Parent = npc
		data.brain.HitPoints = npc.HitPoints
	end

	if sprite:IsFinished("Spawn") then
		local knight = Isaac.Spawn(mod.FF.HollowKnight.ID, mod.FF.HollowKnight.Var, 0, npc.Position, nilvector, npc)
		if npc.SubType == 1 then
			local es = knight:GetSprite()
			es:ReplaceSpritesheet(0, "gfx/enemies/hollowknight/hollow_knight_sun.png")
			es:ReplaceSpritesheet(1, "gfx/enemies/hollowknight/hollow_knight_sun.png")
			es:LoadGraphics()
		end
		knight:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
		--knight:AddEntityFlags(EntityFlag.FLAG_NO_STATUS_EFFECTS | EntityFlag.FLAG_NO_TARGET)
		data.brain.Parent = knight
		local d = knight:GetData()
		d.init = true
		d.brain = data.brain
		npc:Remove()
	end
end

--Run Boss AI
function mod:checkBosses(npc)
	local sprite = npc:GetSprite();
	local npcdata = npc:GetData();
	local var = npc.Variant
	if var == 10 then
		mod:battyAI(npc, sprite, npcdata)
	elseif var == 1000 then
		mod:blueHorfAI(npc, sprite, npcdata)
	elseif var == 1010 then
		mod:dukeOfDemonsAI(npc, sprite, npcdata)
	elseif var == 1011 then
		mod:dukesDemonAI(npc, sprite, npcdata)
	elseif var == 21 then
		mod:commissionAI(npc, sprite, npcdata)
	elseif var == 30 then
		mod:griddleHornAI(npc, sprite, npcdata)
	elseif var == 40 then
		mod:MoistroAKAJackTheDripperAI(npc, sprite, npcdata)
	elseif var >= 50 and var <= 55 then
		sunAIs[var](npc, sprite, npcdata)
	elseif var >= 60 and var <= 63 then
		mod:organizationAI(npc, sprite, npcdata)
	elseif var == 70 then
		mod:bascoAI(npc, sprite, npcdata)
	elseif var == 71 then
		mod:bascoFruitAI(npc, sprite, npcdata)
	elseif var == 80 then
		mod:kingpinAI(npc, sprite, npcdata)
	elseif var == 90 then
		mod:peepingAI(npc, sprite, npcdata)
	elseif var == 91 then
		mod:peepingPhase2AI(npc, sprite, npcdata)
	elseif var == 92 then
		mod:peepstalkAI(npc, sprite, npcdata)
	elseif var == 93 then
		mod:peepeeAI(npc, sprite, npcdata)
	elseif var == 100 then
		mod:luncheonAI(npc)
	elseif var == 101 then
		local subt = npc.SubType
		mod:tapewormAI(npc, subt)
	elseif var == 102 then
		local subt = npc.SubType
		mod:tapewormEggAI(npc, subt)
	elseif var == 103 then
		mod:wormBall(npc)
	elseif var == 110 then
		mod:pollutionAI(npc, sprite, npcdata)
	elseif var == 111 then
		mod:pollutionHorsepowerAI(npc, sprite, npcdata)
	elseif var == 120 then
		mod:meltdownAI(npc, sprite, npcdata)
	elseif var == 121 then
		mod:meltdownForsakenAI(npc, sprite, npcdata)
	elseif var == 122 then
		mod:meltdownBombHorseAI(npc, sprite, npcdata)
	elseif var == 160 then
		mod:bluehorfRealAI(npc, sprite, npcdata)
	elseif var == 161 then
		mod:babybluehorfAI(npc, sprite, npcdata)
	elseif var == mod.FF.Dusk.Var then
		mod:duskBossAI(npc, sprite, npcdata)
	elseif var == mod.FF.DuskHand.Var then
		mod:duskHandAI(npc, sprite, npcdata)
	elseif var == mod.FF.Cacamancer.Var then
		mod:cacamancerAI(npc, sprite, npcdata)
	elseif var == mod.FF.CacaSplurt.Var then
		mod:cacaSplurtAI(npc, sprite, npcdata)
	elseif var == mod.FF.Gutso.Var then
		mod:gutsoAI(npc, sprite, npcdata)
	elseif var == mod.FF.Ghostbuster.Var then
		mod:ghostbusterAI(npc, sprite, npcdata)
	elseif var == mod.FF.Emmission.Var then
		mod:emmissionAI(npc, sprite, npcdata)
	elseif var == mod.FF.CongressingEmmission.Var then
		mod:congressingEmmissionAI(npc, sprite, npcdata)
	elseif var == mod.FF.EmmissionProjectile.Var then
		mod:emmissionProjectileAI(npc, sprite, npcdata)
	elseif var == mod.FF.EmmissionDeathHitbox.Var then
		mod:emmissionDeathHitboxAI(npc, sprite, npcdata)
	elseif var == mod.FF.WhispersController.Var then
		mod:whispersControllerAI(npc, sprite, npcdata)
	elseif var == mod.FF.Whispers.Var then
		mod:whispersAI(npc, sprite, npcdata)
	elseif var == mod.FF.CacophobiaVenus.Var then
		mod:cacophobiaAI(npc, sprite, npcdata)
	elseif var == mod.FF.Junkstrap.Var then
		mod:JunkstrapAI(npc, sprite, npcdata)
	elseif var == 0 then
		if npc.SubType == 100 then
			mod:lezAI(npc, sprite, npcdata)
		else
			mod:buckAI(npc, sprite, npcdata)
		end
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkBosses, mod.FFID.Boss)
--bossai, check980, 980ai

--bossrender
function mod:renderBosses(npc, offset)
	mod:organizationRender(npc)
	mod:kingpinRender(npc)
	local var = npc.Variant
	if var == 0 then
		mod:buckRenderAI(npc)
	elseif var == 30 then
		mod:griddleRenderAI(npc)
	elseif var == 111 then
		mod:pollution2RenderAI(npc)
	elseif var == 121 then
		mod:meltdown2RenderAI(npc)
	elseif var == mod.FF.Aquagob.Var then
		mod:aquagobRenderAI(npc)
	elseif var == mod.FF.Cacamancer.Var then
		mod:cacamancerRenderAI(npc)
	elseif var == mod.FF.Dusk.Var then
		mod:duskRenderAI(npc)
	elseif var == mod.FF.Ghostbuster.Var then
		mod:ghostbusterRender(npc, offset)
	elseif var == mod.FF.Emmission.Var then
		mod:emmissionRender(npc, offset)
	elseif var == mod.FF.CongressingEmmission.Var then
		mod:congressingEmmissionRender(npc, offset)
	elseif var == mod.FF.EmmissionProjectile.Var then
		mod:emmissionProjectileRender(npc, offset)
	elseif var == mod.FF.WarpZone.Var then
		mod:warpZoneRender(npc)
	elseif var == mod.FF.Junkstrap.Var then
		mod:JunkstrapRender(npc, npc:GetSprite())
	end
end

mod:AddCallback(ModCallbacks.MC_POST_NPC_RENDER, mod.renderBosses, mod.FFID.Boss)

--980hurt
function mod:checkBossHurt(npc, damage, flag, source, cooldown)
	local variant = npc.Variant;

	if variant == Isaac.GetEntityVariantByName("Buck") then
		return mod:buckHurt(npc, damage, flag, source);
	elseif variant == 30 then -- Griddle
		if flag & DamageFlag.DAMAGE_FIRE ~= 0 and source.Type ~= 1 then
			return false
		elseif npc:GetData().unhurtable then
			return false
		end
	elseif variant == 40 then -- Moistro / Jack the Dripper, JackTheDripper
		if not (npc:HasEntityFlags(EntityFlag.FLAG_FREEZE) or npc:HasEntityFlags(EntityFlag.FLAG_MIDAS_FREEZE)) then
			if npc.HitPoints - damage <= 10 then
			npc.Velocity = nilvector
			npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
			npc.HitPoints = 0
			npc:ToNPC().State = 11
			return false
			end
		end
	elseif variant == 50 or variant == 55 then
		return false
	elseif variant == 51 then
		if npc:GetData().sun then
			npc:GetData().sun:GetData().orbitalspeed.venus = npc:GetData().sun:GetData().orbitalspeed.venus + 0.02
		end
		if flag ~= flag | DamageFlag.DAMAGE_CLONES and npc:GetData().sun then
			local sund = npc:GetData().sun:GetData()
			if sund.earth then
				sund.earth:TakeDamage(damage/2, flag | DamageFlag.DAMAGE_CLONES, source, cooldown)
			end
			if sund.neptune then
				sund.neptune:TakeDamage(damage/2, flag | DamageFlag.DAMAGE_CLONES, source, cooldown)
			end
		end
		if flag & DamageFlag.DAMAGE_FIRE ~= 0 and source.Type == 1000 and source.Variant == 7005 then
			return false
		end
	elseif variant == 52 then
		if flag ~= flag | DamageFlag.DAMAGE_CLONES and npc:GetData().sun then
			local sund = npc:GetData().sun:GetData()
			if sund.venus then
				sund.venus:TakeDamage(damage/2, flag | DamageFlag.DAMAGE_CLONES, source, cooldown)
			end
			if sund.neptune then
				sund.neptune:TakeDamage(damage/2, flag | DamageFlag.DAMAGE_CLONES, source, cooldown)
			end
		end
		if flag & DamageFlag.DAMAGE_FIRE ~= 0 and source.Type == 1000 and source.Variant == 7005 then
			return false
		end
	elseif variant == 53 then
		if flag ~= flag | DamageFlag.DAMAGE_CLONES and npc:GetData().sun then
			local sund = npc:GetData().sun:GetData()
			if sund.venus then
				sund.venus:TakeDamage(damage/2, flag | DamageFlag.DAMAGE_CLONES, source, cooldown)
			end
			if sund.earth then
				sund.earth:TakeDamage(damage/2, flag | DamageFlag.DAMAGE_CLONES, source, cooldown)
			end
		end
		if flag & DamageFlag.DAMAGE_FIRE ~= 0 and source.Type == 1000 and source.Variant == 7005 then
			return false
		end
	elseif variant == 54 then
		if npc:GetData().Cooldown <= 0 then
			npc:GetData().Cooldown = 45
			npc:GetSprite():Play("Shoot0"..npc:GetData().skin)
		end
		return false
	elseif variant == 55 then
		return false
	elseif variant == mod.FF.Basco.Var then
		return mod:bascoHurt(npc, damage, flag, source)
	elseif variant == mod.FF.BascoFood.Var then
		return mod:bascoFruitHurt(npc, damage, flag, source)
	elseif variant == 90 then
		if npc:GetData().state == "peepeePlant" then
			npc.HitPoints = npc.HitPoints + damage * 0.75
		end
	elseif variant == 92 then
		return false
	elseif variant == 100 then
		if flag & DamageFlag.DAMAGE_CLONES == 0 then
			return false
		end
	elseif variant == 101 then
		local d = npc:GetData()
		if (d.Color == "whiteboi" and npc.SubType == 2) or (npc.Parent and npc.Parent.SubType == 2 and npc.Parent:GetData().Color == "whiteboi") or (npc.Child and npc.Child.SubType == 2 and npc.Child:GetData().Color == "whiteboi") then
			d.damagetook = d.damagetook or 0
			d.damagetook = d.damagetook + damage
			if d.damagetook > 7 then
				d.AAAHELP = true
				d.damagetook = 0
			end
		end
	elseif variant == 102 then
		return false
	elseif variant == 111 then
		if flag & DamageFlag.DAMAGE_FIRE ~= 0 and source.Type == 1000 and source.Variant == 7005 then
			return false
		end
	elseif variant == 120 then
		if flag & DamageFlag.DAMAGE_FIRE ~= 0 and source.Type == 1000 and source.Variant == 7005 then
			return false
		elseif flag ~= flag | DamageFlag.DAMAGE_CLONES then
			if npc:GetSprite():IsPlaying("Transition") then
				npc:TakeDamage(damage * 0.05, flag | DamageFlag.DAMAGE_CLONES, source, cooldown)
				return false
			end
		end
	elseif variant == 121 then
		if flag & DamageFlag.DAMAGE_TNT ~= 0 and source.Type == mod.FFID.Tech then
			return false
		elseif flag & DamageFlag.DAMAGE_FIRE ~= 0 and source.Type == 1000 and source.Variant == 7005 then
			return false
		elseif flag ~= flag | DamageFlag.DAMAGE_CLONES then
			if npc:GetSprite():IsPlaying("Appear") or npc:GetSprite():IsPlaying("TransitionIdle") then
				npc:TakeDamage(damage * 0.05, flag | DamageFlag.DAMAGE_CLONES, source, cooldown)
				return false
			end
		end
	elseif variant == mod.FF.Dusk.Var then
		mod:duskHurt(npc, damage, flag, source, cooldown)
	elseif variant == mod.FF.DuskHand.Var then
		if npc.Parent then
			npc.Parent:TakeDamage(damage, flag | DamageFlag.DAMAGE_CLONES, source, cooldown)
			--npc:SetColor(Color(30,1,1,1,0,0,0), 2, 1, false, false)
			return false
		end
	elseif variant == mod.FF.Cacamancer.Var then
		if flag == flag | DamageFlag.DAMAGE_EXPLOSION then
			npc:GetData().preventGas = 30
		end
	elseif variant == mod.FF.Whispers.Var then
		return mod:whispersHurt(npc, damage, flag, source, cooldown)
	elseif variant == mod.FF.CacophobiaVenus.Var then
		return mod:cacophobiaHurt(npc, damage, flag, source, cooldown)
	end
end
mod:AddCallback(ModCallbacks.MC_ENTITY_TAKE_DMG, mod.checkBossHurt, mod.FFID.Boss)

function mod:checkBossKill(npc)
	local variant = npc.Variant;


end
mod:AddCallback(ModCallbacks.MC_POST_ENTITY_KILL, mod.checkBossKill, mod.FFID.Boss)

function mod:checkBossDeath(npc)
	local variant = npc.Variant;


end
mod:AddCallback(ModCallbacks.MC_POST_NPC_DEATH, mod.checkBossDeath, mod.FFID.Boss)

-- Guillotine21 AI --
function mod:check940(npc)
 local variant = npc.Variant
 local subType = npc.SubType
	if variant == 10 then

	else
		mod:honeyeyeAI(npc)
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.check940, mod.FFID.Guill)
-- Guillotine21 AI END--

--Run Technical AI, 950ai, technicalai
function mod:checkTechnical(npc)
local variant = npc.Variant
local subType = npc.SubType

	if variant ~= 10 and variant ~= 12 then
		if not npc:HasEntityFlags(EntityFlag.FLAG_FRIENDLY) then
			npc:AddEntityFlags(EntityFlag.FLAG_NO_STATUS_EFFECTS)
		end
	end

	if variant == 1 then
		mod:bubbleAI(npc)
	elseif variant == 2 then
		mod.flakCannonFlyAI(npc)
	elseif variant == 3 then
		mod:nimbuscloudai(npc, subType)
	elseif variant == 4 then
		mod:corpseAI(npc)
	elseif variant == 5 then
		mod:bonerocketAI(npc)
	elseif variant == 6 then
		if subType == 1 then
			mod:homingStingerProjectileAI(npc)
		elseif subType == mod.FF.StingerProjBeebee.Sub then
			mod:beebeeStingerProjectileAI(npc)
		else
			mod:stingerProjectileAI(npc)
		end
	elseif variant == 7 then
		mod:sporeProjectileAI(npc)
	elseif variant == 8 then
		mod:dogmeatProjectileAI(npc)
	elseif variant == 9 then
		mod:flyingMaggotAI(npc, subType)
	elseif variant == 10 then
		mod:waitingSpiderAI(npc, subType)
	elseif variant == 11 then
		mod:scytheRiderScytheAI(npc, subType)
	elseif variant == 12 then
		mod:hollowKnightProjectileAI(npc, npc:GetSprite(), npc:GetData())
	elseif variant == 13 then
		if subType == 10 then
			mod:technicianProjAI(npc)
		elseif subType == 20 then
			mod:owlStarProj(npc)
		else
			mod:wardenBallAI(npc)
		end
	elseif variant == 14 then
		mod:garyAI(npc)
	elseif variant == 15 then
		mod:floatingSporeAI(npc)
	elseif variant == 16 then
		mod:waitingWormAI(npc, subType)
	elseif variant == 17 then
		mod:bigHemoProjAI(npc)
	elseif variant == 18 then
		mod:horse(npc)
	elseif variant == 19 then
		mod:drsBone(npc)
	elseif variant == 20 then
		mod:dominatorChainBall(npc)
	elseif variant == 21 then
		mod:sternumRibsAI(npc, subType)
	elseif variant == 23 then
		mod:psionEgAI(npc, subType)
	elseif variant == 24 or variant == mod.FF.Miscarriage.Var then
		mod:amnioticAI(npc, subType)
	elseif variant == 25 then
		mod:davyCrockettAI(npc, subType)
	elseif variant == 26 then
		mod:nuclearWasteBarrelAI(npc, subType)
	elseif variant == 27 then
		mod:spiderRollerMineAI(npc, subType)
	elseif variant == 28 then
		mod:quackMineAI(npc, subType)
	elseif variant == mod.FF.DangerousDisc.Var then
		mod:dangerousDiscAI(npc)
	elseif variant == mod.FF.DangerousDiscGuide.Var then
		mod:dangerousDiscGuideAI(npc)
	elseif variant == mod.FF.HitcherPitchfork.Var then
		mod:pitchforkProjAI(npc)
	elseif variant == mod.FF.Hitbox.Var then
		mod:customHitboxAI(npc)
	elseif variant == mod.FF.MemberCardRelocator.Var then
		mod:memberCardRelocatorAI(npc)
	elseif variant > 999 and variant < 1010 then
		npc:Remove()
	elseif variant == 0 then
		--Dank Slime AI is the generic one.
		mod:dankSlimeAI(npc, subType)
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkTechnical, mod.FFID.Tech)

function mod:customHitboxAI(npc)
	if npc.SubType == 0 and (not npc.SpawnerEntity or not npc.SpawnerEntity:Exists() or mod:isStatusCorpse(npc.SpawnerEntity)) then
		npc:Remove()
		return
	elseif npc.SubType == 1 and (not npc:GetData().CustomGrid or not npc:GetData().CustomGrid:Exists()) then
		npc:Remove()
		return
	end

	local data = npc:GetData()
	if not data.Init then
		npc:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
		if not data.AllowKnockback then
			npc:AddEntityFlags(EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK | EntityFlag.FLAG_NO_KNOCKBACK)
		end
		npc.Visible = false
		data.Init = true
	end

	data.Updated = true

	local width, height, rotation = data.Width or 16, data.Height or 16, data.Rotation or 0

	npc.SpriteRotation = rotation
	npc.SizeMulti = Vector(width / 16, height / 16)

	if data.FixToPosition then
		npc.Position = data.FixToPosition
		npc.Velocity = Vector.Zero
	end

	if data.FixToSpawner then
		data.SpawnerOffset = data.SpawnerOffset or Vector.Zero
		if npc.SubType == 1 then
			local customGrid = data.CustomGrid
			if customGrid.Projectile then
				npc.Position = data.CustomGrid.Projectile.Position
				npc.Velocity = data.CustomGrid.Projectile.Velocity
			elseif customGrid.GridEntity then
				npc.Position = data.CustomGrid.GridEntity.Position
				npc.Velocity = Vector.Zero
			else
				npc.Position = game:GetRoom():GetGridPosition(data.CustomGrid.GridIndex)
				npc.Velocity = Vector.Zero
			end
		else
			npc.Position = npc.SpawnerEntity.Position
			npc.Velocity = npc.SpawnerEntity.Velocity
		end

		if data.PositionOffset then
			npc.Position = npc.Position + data.PositionOffset
		end
	end
end

function mod:customHitboxFrozenChecks()
	local hitboxes = Isaac.FindByType(mod.FF.Hitbox.ID, mod.FF.Hitbox.Var)
	if #hitboxes > 0 then
		local chains = Isaac.FindByType(EntityType.ENTITY_EFFECT, EffectVariant.ANIMA_CHAIN)
		for _, hitbox in ipairs(hitboxes) do
			local data = hitbox:GetData()
			if data.Updated then
				data.Updated = false
			elseif not data.NoForceUpdate then
				mod:customHitboxAI(hitbox:ToNPC())
			end

			if data.OnAnimaSola then
				for _, chain in ipairs(chains) do
					if chain.Target and GetPtrHash(chain.Target) == GetPtrHash(hitbox) then
						data.OnAnimaSola(hitbox, chain)
					end
				end
			end
		end
	end
end

function mod:waitingWormAI(npc, subt)
	local sprite = npc:GetSprite()
	local npcdata = npc:GetData()
	local target = npc:GetPlayerTarget()

	if not npcdata.init then
		npcdata.StateFrame = 0
		npc:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
		npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
		npc:AddEntityFlags(EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK | EntityFlag.FLAG_NO_KNOCKBACK | EntityFlag.FLAG_NO_STATUS_EFFECTS)
		npc.Visible = false
		npcdata.waiting = true
		npcdata.init = true
		if npc.SubType == mod.FF.WaitingWormBunker.Sub then
			npc.PositionOffset = Vector(0,10)
		end

		mod:waitingWormSprites(npc, sprite, subt)

	else
		npcdata.StateFrame = npcdata.StateFrame + 1
	end

	if npcdata.waiting then
		if mod.CanIComeOutYet() then
			if npcdata.StateFrame > 15 then
				if mod.farFromAllPlayers(npc.Position, 60) then
					npcdata.waiting = false
					npc:ClearEntityFlags(EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK | EntityFlag.FLAG_NO_KNOCKBACK | EntityFlag.FLAG_NO_STATUS_EFFECTS)
					npc.Visible = true
					if(subt == 12) then
						--weaver
						mod:spritePlay(sprite, "Empty")
					elseif(subt == 13) then
						--weaver sr.
						mod:spritePlay(sprite, "Empty")
					elseif(subt == 10 or subt == 18) then
						--lump/bunker worm
						mod:spritePlay(sprite, "Emerge")
					elseif(subt == 11) then
						--fred
						mod:spritePlay(sprite, "DigUp")
					elseif (subt == 14 or subt == 15 or subt == 16 or subt == 17) then
						--pins
						mod:spritePlay(sprite, "HoleClose")
						npc.Visible = false
					elseif(subt == 19) then
						--drunk worm
						mod:spritePlay(sprite, "digout")
					else
						npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_ALL
						mod:spritePlay(sprite, "Appear")
					end
				end
			end
		else
			npcdata.StateFrame = 0
		end
	else
		npc.Velocity = nilvector
		npc:ClearEntityFlags(EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK | EntityFlag.FLAG_NO_KNOCKBACK | EntityFlag.FLAG_NO_STATUS_EFFECTS)
		if (subt == 14 or subt == 15 or subt == 16) then
			if sprite:IsFinished("HoleClose") then
				--pin scolex frail
				local pin = Isaac.Spawn(62, subt - 14, 0, npc.Position, nilvector, npc):ToNPC()
				pin.Visible = false
				pin:GetData().wasWaitingWorm = true
				npc:Remove()
			end
		elseif subt == 17 then
			if sprite:IsFinished("HoleClose") then
				local kingy = Isaac.Spawn(mod.FF.Kingpin.ID, mod.FF.Kingpin.Var, 0, npc.Position, nilvector, npc)
				kingy:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
				kingy:Update()
				npc:Remove()
			end
		elseif subt == 12 or subt == 13 then
			if sprite:IsFinished("Empty") then
				if(subt == 12) then
					--weaver
						local weave = Isaac.Spawn(mod.FF.Weaver.ID, 0, 0, npc.Position, nilvector, npc):ToNPC()
						weave:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
						npc:Remove()
				elseif(subt == 13) then
					--weaver sr.
					local weave = Isaac.Spawn(mod.FF.Weaver.ID, 1, 0, npc.Position, nilvector, npc):ToNPC()
					weave:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
					npc:Remove()
				end
			end
		elseif subt == 10 then
			if sprite:IsFinished("Emerge") then
				--lump
				npc:Morph(56, 0, 95, -1)
				mod:waitingWormSprites(npc, sprite, subt)
			end
		elseif subt == 11 then
			if sprite:IsFinished("DigUp") then
				--fred
				npc:Morph(59, 0, 95, -1)
				mod:waitingWormSprites(npc, sprite, subt)
			end
		elseif subt == 18 then --bunker worm
			if sprite:IsFinished("Emerge") then
				npc:Morph(mod.FF.BunkerWorm.ID, mod.FF.BunkerWorm.Var, 0, -1)
				local d = npc:GetData()
				d.shoot = 1
				d.state = "idle"
				d.init = true
				npc.TargetPosition = npc.Position
				npc.PositionOffset = Vector(0,10)
				npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_ALL
			elseif sprite:IsEventTriggered("Emerge") then
				npc:PlaySound(SoundEffect.SOUND_SHOVEL_DIG,0.6,0,false,math.random(150,170)/100)
			elseif sprite:IsEventTriggered("Shoot") then
				npc:PlaySound(SoundEffect.SOUND_MAGGOT_BURST_OUT,0.7,0,false,math.random(120,130)/100)
			end
		elseif subt == 19 and sprite:IsFinished("digout") then
			--drunk worm
			npc:Morph(mod.FF.DrunkWorm.ID, mod.FF.DrunkWorm.Var, 0, -1)
			local d = npc:GetData()
			d.state = "idle"
			d.init = true
			npc:AddEntityFlags(EntityFlag.FLAG_NO_KNOCKBACK)
			npc.TargetPosition = npc.Position
			npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_ALL
		elseif sprite:IsFinished("Appear") then
			if subt == 1 then
				--round
				npc:Morph(244, 0, 95, -1)
			elseif subt == 2 then
				--night
				npc:Morph(255, 0, 95, -1)
			elseif subt == 3 then
				--ulcer
				npc:Morph(289, 0, 95, -1)
			elseif subt == 4 then
				--roundy
				npc:Morph(276, 0, 95, -1)
			elseif subt == 5 then
				--tube
				npc:Morph(244, 1, 95, -1)
			elseif subt == 6 then
				--parabite
				npc:Morph(58, 0, 95, -1)
			elseif subt == 7 then
				--scarred parabite
				npc:Morph(58, 1, 95, -1)
			elseif subt == 8 then
				--bone
				npc:Morph(mod.FF.BoneWorm.ID, mod.FF.BoneWorm.Var, 95, -1)
			elseif subt == 9 then
				--drink
				npc:Morph(666, 100, 95, -1)
				npc:AddEntityFlags(EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK)
				npcdata.state = "idle"
				npcdata.idletimer = math.random(15, 30)
				npcdata.burrowedtimer = 0
				npcdata.init = true
				npcdata.firstdig = false
				npcdata.burrowcheck = false
				npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_ALL
			else
				--base case
				npc:Morph(244, 0, 95, -1)
			end
			mod:waitingWormSprites(npc, sprite, subt)
		end
	end
end

function mod:waitingWormSprites(npc, sprite, subt)
	local level = game:GetLevel()
	local stage = level:GetStage()
	local stageType = level:GetStageType()

	--[[if(subt == 5) then
		if ((stageType == StageType.STAGETYPE_REPENTANCE) and (stage == LevelStage.STAGE1_1 or stage == LevelStage.STAGE1_2)) or ((stageType == StageType.STAGETYPE_AFTERBIRTH) and (stage == LevelStage.STAGE2_1 or stage == LevelStage.STAGE2_2)) then
			sprite:ReplaceSpritesheet(0, "gfx/monsters/afterbirthplus/tubeworm_downpour.png")
			sprite:LoadGraphics()
		end
	end]]
	if subt == 6 and mod.roomBackdrop == 10 then
		--parabite
		mod:ReplaceEnemySpritesheet(npc, "gfx/monsters/classic/monster_199_parabite_morbus", 0)
		mod:ReplaceEnemySpritesheet(npc, "gfx/monsters/classic/monster_199_parabite_morbus", 1)
	end
end

function mod:checkTechnicalInit(npc)
	local variant = npc.Variant
	local subtype = npc.SubType

	if variant == 0 then
		mod.dankSlimeInit(npc)
	elseif variant == 1 then -- Bubble
		local target = npc:GetPlayerTarget()
		npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS
		if subtype < 4 then
			mod.BubbleTotal = mod.BubbleTotal or {}
			table.insert(mod.BubbleTotal, npc)
			if #mod.BubbleTotal > 100 then
				mod.BubbleTotal[1]:TakeDamage(1, 0, EntityRef(target), 0)
				table.remove(mod.BubbleTotal, 1)
			end
		end
	elseif variant == 2 then
		npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS
	elseif variant == 33 then --Toxic Cloud Spawner
		local cloud = Isaac.Spawn(1000,141,0,npc.Position,Vector.Zero,nil)
		if subtype == 0 then
			cloud:GetData().LeaveOnRoomClear = true
		end
		npc:Remove()
	elseif variant == 1000 then
		npc:Remove()
	end
end
mod:AddCallback(ModCallbacks.MC_POST_NPC_INIT , mod.checkTechnicalInit, mod.FFID.Tech)

--150Coll, 150 Collision
function mod:checkTechnicalCollision(npc1, npc2, first)
local var = npc1.Variant
	if var == 6 then
		if npc1.SubType == 0 then
			local effect = Isaac.Spawn(1000,7014,0,npc1.Position,nilvector,nil)
			effect.SpriteRotation = npc1.SpriteRotation
			effect:Update()
			npc1:Remove()
		--[[elseif npc1.SubType == mod.FF.StingerProjBeebee.Sub then
			local effect = Isaac.Spawn(1000,7014,1,npc1.Position,nilvector,nil)
			effect.SpriteRotation = npc1.SpriteRotation
			effect:Update()
			npc1:Remove()]]
		end
	elseif var == 13 then
		if npc1.SubType == 10 then
			mod:dieTechnicianProj(npc1)
			local randExt = math.random(45)
			for i = 45, 360, 45 do
				local laser = Isaac.Spawn(1000, 1737, 0, npc1.Position, Vector(0, 10):Rotated(i + randExt), npc1):ToEffect()
				laser:Update()
				laser.Parent = npc1.SpawnerEntity
				laser:GetData().vec = laser.Velocity:Rotated(-115)
				--laser.SpriteScale = laser.SpriteScale * 0.5
				laser:Update()
			end
			return true
		elseif npc1.SubType == 20 then
			mod:owlStarProjColl(npc1)
		else
			if npc2.Type == 1 then
				sfx:Play(mod.Sounds.WardenHit, 1, 0, false, 1)
				local effect = Isaac.Spawn(1000,1728,0,npc2.Position,nilvector,nil)
				npc1.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
				npc1:GetData().jivin = true
				npc1:Update()
			end
		end
	elseif var == 20 then
		if npc2.Type == 1 then
			npc1:GetData().state = "control"
			npc1.Parent = npc2
		end
	elseif var == 23 then
		if not (npc2.Type and npc2.Variant == 23) then
			npc1:GetData().FFPsyEgKill = true
		end
	elseif var == 1 and npc1:HasEntityFlags(EntityFlag.FLAG_FRIENDLY) then
		if npc2:IsEnemy() and not npc2:HasEntityFlags(EntityFlag.FLAG_FRIENDLY) then -- Enemies but no Friends
			npc1.State = 11
			local mult = 1
			if npc1.SubType == 0 then
				mult = 0.75
			elseif npc1.SubType <= 3 then
				mult = mult * npc1.SubType
			end

			npc2:TakeDamage(3.5 * mult, 0, EntityRef(npc1), 0)
		end
	elseif var == mod.FF.RollingHollowKnight.Var then
		local data = npc1:GetData()
		if data.brain and npc2.InitSeed == data.brain.InitSeed and npc2.Index == data.brain.Index then
			return true
		end
	elseif var == mod.FF.Hitbox.Var then
		local data = npc1:GetData()
		if data.OnCollide then
			return data.OnCollide(npc1, npc2, first)
		end
	end
end
mod:AddCallback(ModCallbacks.MC_PRE_NPC_COLLISION , mod.checkTechnicalCollision, mod.FFID.Tech)

--150Hurt
function mod:checkTechnicalHurt(npc, damage, flag, source, countdown)
	local var = npc.Variant
	if var == 22 then
		return false
	elseif var == mod.FF.SternumRib.Var then
		return false
	elseif var == mod.FF.RollingHollowKnight.Var then
		local data = npc:GetData()
		if flag == flag | DamageFlag.DAMAGE_POISON_BURN and data.brain then
			data.brain:TakeDamage(damage, flag | DamageFlag.DAMAGE_CLONES, source, 0)
		end
	elseif var == mod.FF.NuclearWaste.Var then
		return false
	elseif var == mod.FF.Hitbox.Var then
		local data = npc:GetData()
		if data.OnHurt then
			return data.OnHurt(npc, damage, flag, source, countdown)
		elseif data.Relay then
			local flags = flag
			if data.Clones then
				flags = flags | DamageFlag.DAMAGE_CLONES
			end

			if data.Relay == true then
				npc.SpawnerEntity:TakeDamage(damage, flags, source, countdown)
			else
				data.Relay:TakeDamage(damage, flags, source, countdown)
			end

			return false
		else
			return false
		end
	end
end
mod:AddCallback(ModCallbacks.MC_ENTITY_TAKE_DMG , mod.checkTechnicalHurt, mod.FFID.Tech)

--950Kill
function mod:checkTechnicalKill(npc)
	local var = npc.Variant
	if var == mod.FF.RollingHollowKnight.Var then
		local data = npc:GetData()
		if data.brain then
			--ew hacky workarounds ewwwww
			data.brain.HitPoints = 0
			data.brain:TakeDamage(0.001, 0, EntityRef(npc), 0)
		end
	end
end
mod:AddCallback(ModCallbacks.MC_POST_ENTITY_KILL, mod.checkTechnicalKill, mod.FFID.Tech)

--Run Slammer AI
function mod:checkSlammer(npc)

	mod:slammerAI(npc)
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkSlammer, mod.FF.Slammer.ID)

--[[Run Bouncer AI
function mod:checkBouncer(npc)
	mod:bouncerAI(npc)
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkSlammer, 951)]]

--Run Square Fly AI
function mod:checkSquareFly(npc)
	mod:squareFlyAI(npc)
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkSquareFly, mod.FF.SquareFly.ID)


--Run Sniffle AI
function mod:checkSniffle(npc)
	mod:sniffleAI(npc)
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkSniffle, mod.FF.Sniffle.ID)

--Run Snagger AI
function mod:checkSnagger(npc)
	mod:snaggerAI(npc)
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkSnagger, mod.FF.Snagger.ID)

local honeyIcon = Sprite()
honeyIcon:Load("gfx/ui/ff_statuseffects.anm2", true)
honeyIcon:Play("Honey", true)

function mod:renderSnagger(npc)
	local d = npc:GetData()
	if d.batteried and d.interpolationframe then
		npc:Update()
		npc:GetSprite():Update()
		d.interpolationframe = nil
	end
	if d.honeybuff and d.honeybuff > 0 then
		honeyIcon:Render(Isaac.WorldToScreen(npc.Position + Vector(0,-50)), Vector.Zero, Vector.Zero)
	end
end

mod:AddCallback(ModCallbacks.MC_POST_NPC_RENDER, mod.renderSnagger, mod.FF.Snagger.ID)

--Run Weaver AI
function mod:checkWeaver(npc)
	mod:weaverAI(npc, npc.Variant)
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkWeaver, mod.FF.Weaver.ID)

--Run Craterface, Muk and Blazer AI
function mod:checkCraterFace(npc)
local variant = npc.Variant
	if variant == mod.FF.Blazer.Var then
		mod:blazerAI(npc)
	elseif variant == mod.FF.Drooler.Var then
		mod:mukAI(npc)
	else
		mod:craterFaceAI(npc)
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkCraterFace, mod.FF.Blazer.ID)

--Run Psion AI
function mod:checkPsion(npc)
	mod:psionAI(npc)
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkPsion, mod.FF.Psion.ID)

--Run Further Erf AI
--My god it's gone
--960update, 960_update, 960ai,

function mod:checkBombmuncherCollision(npc1, npc2, mysteryBoolean)
  local d = npc1:ToNPC():GetData()
	if npc1.Variant == mod.FF.Bombmuncher.Var then
		if npc2.SpawnerEntity and npc2.SpawnerEntity.Variant == npc1.Variant then
			return true
		end
	end
end
mod:AddCallback(ModCallbacks.MC_PRE_NPC_COLLISION, mod.checkBombmuncherCollision, mod.FF.Bombmuncher.ID)

function mod:erflyProjectileCollision(proj, entity, mysteryBoolean)
	if entity.Type == mod.FF.Bola.ID and entity.Variant == mod.FF.Bola.Var then
		if proj.SpawnerEntity and proj.SpawnerEntity.Parent and proj.SpawnerEntity.Parent.InitSeed == entity.InitSeed then
			return true
		end
	elseif entity.Type == mod.FF.MrGob.ID and entity.Variant == mod.FF.MrGob.Var then
		if proj.SpawnerEntity and proj.SpawnerEntity.Parent and proj.SpawnerEntity.Parent.InitSeed == entity.InitSeed then
			return true
		elseif proj.SpawnerEntity and proj.SpawnerEntity.Child and proj.SpawnerEntity.Child.InitSeed == entity.InitSeed then
			return true
		end
	end
end
mod:AddCallback(ModCallbacks.MC_PRE_PROJECTILE_COLLISION, mod.erflyProjectileCollision)

--[[function mod:checkPlayerColl(playerEntity, npc2, mysteryBoolean)
	if npc2.Type == 960 and npc2.Variant == 451 then
		Isaac.ConsoleOutput("ya2")
		return false
	end
end
mod:AddCallback(ModCallbacks.MC_PRE_PLAYER_COLLISION, mod.checkPlayerColl)]]

--tnt, supertnt, watertnt, compost
mod:AddCallback(ModCallbacks.MC_POST_NPC_INIT, function(_, npc)
	if npc.Variant == 750 or npc.Variant == 752 then
		npc.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_WALLS
		npc:AddEntityFlags(EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK | EntityFlag.FLAG_NO_KNOCKBACK)
		npc.Velocity = nilvector
	end
end, 292)

mod:AddCallback(ModCallbacks.MC_POST_EFFECT_UPDATE, function(_, effect)
	local data = effect:GetData()
	local sprite = effect:GetSprite()

	if not data.init then
		sprite:SetFrame("Bubble", 0)
		data.init = true
	else
		for _, p in pairs(Isaac.FindByType(1, -1, -1, false, false)) do
			if p.Position:Distance(effect.Position) - effect.Size - p.Size <= 0 then
				effect:Remove()
				sfx:Play(SoundEffect.SOUND_PLOP,0.7,2,false,math.random(8,12)/10)
			end
		end
	end

	if sprite:GetFrame() == 7 and sprite:IsFinished("Bubble") then
		sprite:Play("BubbleIdle")
	end

	if sprite:IsFinished("Bubble") and effect.FrameCount > 1 and effect.FrameCount % 7 == 0 then
		sprite:SetFrame("Bubble", effect.FrameCount / 7)
	end

	if effect.FrameCount > 150 then
		effect:Remove()
		sfx:Play(SoundEffect.SOUND_PLOP,0.7,2,false,math.random(8,12)/10)
		for i = 1, 4 do
			local p = Isaac.Spawn(9, 0, 0, effect.Position, RandomVector() * (math.random(12, 50)/7.5), nil):ToProjectile()
			p.FallingSpeed = -35 + math.random(10);
			p.FallingAccel = 1.5
			p.Color = mod.ColorDankBlackReal
		end
	end

	local ents = {}
	for _, e in pairs(Isaac.GetRoomEntities()) do
		if e.Position:Distance(effect.Position) - effect.Size - e.Size <= 1 and (e.Type == 1000 and e.Variant == 26 and e:GetColor().A > 0.5) then
			ents[#ents + 1] = e
		end
	end

	if #ents == 0 then
		if sprite:IsPlaying("BubbleIdle") then
			effect:Remove()
			sfx:Play(SoundEffect.SOUND_PLOP,0.7,2,false,math.random(8,12)/10)
			for i = 1, 4 do
				local p = Isaac.Spawn(9, 0, 0, effect.Position, RandomVector() * (math.random(12, 50)/7.5), nil):ToProjectile()
				p.FallingSpeed = -35 + math.random(10);
				p.FallingAccel = 1.5
				p.Color = mod.ColorDankBlackReal
			end
		else
			effect:Remove()
			sfx:Play(SoundEffect.SOUND_PLOP,0.7,2,false,math.random(8,12)/10)
		end
	end
end, 1723)

mod:AddCallback(ModCallbacks.MC_POST_EFFECT_UPDATE, function(_, effect)
	local sprite = effect:GetSprite()
	local subt = effect.SubType

	sprite:Play("Poof")

	if sprite:IsEventTriggered("popsound") and not subt == 1 then
		sfx:Play(SoundEffect.SOUND_PLOP, 0.7, 2, false, math.random(8,12)/10)
	end
	if sprite:IsFinished("Poof") then
		effect:Remove()
	end
end, 7020)

mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, function(_, npc)
	local data = npc:GetData()
	if npc.FrameCount < 1 and npc.Variant >= 750 and npc.Variant <= 760 then
		local sprite = npc:GetSprite()
		if sprite:IsPlaying("Blown") then
			data.dontDoAnything = true
		end
	end
	if npc.Variant == 750 then -- Super TNT
		local sprite = npc:GetSprite()
		npc.Velocity = nilvector
		if not data.dontDoAnything then
			mod.QuickSetEntityGridPath(npc, 3999)
		end
		if sprite:IsPlaying("Blown") or sprite:IsFinished("Blown") then
			if data.dontDoAnything then return end
			if data.bigboy and data.offset and data.offset == npc.FrameCount then
				for i = 1, 4 do
					game:BombExplosionEffects(npc.Position + Vector(40, 0):Rotated(90*i), 2, 0, Color(0, 0, 0, 0, 0, 0, 0), npc, 0.5, false, true)
					Isaac.Spawn(1000, 1, 0, npc.Position + Vector(40, 0):Rotated(90*i), nilvector, npc)
				end
				data.offset = nil
				data.extraoffset = npc.FrameCount + 5
			end
			if data.bigboy and data.extraoffset and data.extraoffset == npc.FrameCount then
				for i = 1, 2 do
					game:BombExplosionEffects(npc.Position + Vector(80, 0):Rotated(180*i), 2, 0, Color(0, 0, 0, 0, 0, 0, 0), npc, 0.5, false, true)
					Isaac.Spawn(1000, 1, 0, npc.Position + Vector(80, 0):Rotated(180*i), nilvector, npc)
				end
				data.extraoffset = nil
				data.dontDoAnything = true
			end
		end
	elseif npc.Variant == 751 then
		if not data.dontDoAnything then
			mod.QuickSetEntityGridPath(npc, 900)
		end
	elseif npc.Variant == 752 then
		if not data.dontDoAnything then
			--[[if not data.debugprint then
				print("setgridpath")
				data.debugprint = true
			end]]
			mod.QuickSetEntityGridPath(npc, 3999)
		end
		npc.Velocity = nilvector
	end
end, 292) -- Puashable TNT type enemies

mod:AddCallback(ModCallbacks.MC_POST_EFFECT_UPDATE, function(_, effect)
	local sprite = effect:GetSprite()
	if sprite:IsFinished("Explosion") then
		effect:Remove()
	end

	if not effect:GetData().alreadyHit then
		effect:GetData().alreadyHit = true
		local extinguishedSomething
		for _, e in pairs(Isaac.FindInRadius(effect.Position, 80, 0xffffffff)) do
			if e.Type == 10 and e.Variant == 2 then -- Flaming Gaper
				e:ToNPC():Morph(10, 1, 0, e:ToNPC():GetChampionColorIdx())
				e:GetSprite():PlayOverlay("Head")
				e:TakeDamage(e.MaxHitPoints/5, 0, EntityRef(Isaac.GetPlayer(0)), 0)
				extinguishedSomething = true
			elseif e.Type == 54 and e.Variant == 0 then -- Flaming Hopper
				e:ToNPC():Morph(29, 0, 0, e:ToNPC():GetChampionColorIdx())
				e:TakeDamage(e.MaxHitPoints/5, 0, EntityRef(Isaac.GetPlayer(0)), 0)
				extinguishedSomething = true
			elseif e.Type == 208 and e.Variant == 2 then -- Flaming Fatty
				e:ToNPC():Morph(208, 0, 0, e:ToNPC():GetChampionColorIdx())
				e:TakeDamage(e.MaxHitPoints/5, 0, EntityRef(Isaac.GetPlayer(0)), 0)
				extinguishedSomething = true
			elseif e.Type == 226 and e.Variant == 2 then -- Crispy
				e:ToNPC():Morph(226, 0, 0, e:ToNPC():GetChampionColorIdx())
				local s = e:GetSprite()
				s:Load("gfx/226.002_crispy.anm2", true)
				s:ReplaceSpritesheet(3, "haha.png")
				s:LoadGraphics()
				s:PlayOverlay("Head")
				e:TakeDamage(e.MaxHitPoints/5, 0, EntityRef(Isaac.GetPlayer(0)), 0)
				extinguishedSomething = true
			elseif e.Type == 33 and e.Variant <= 1 then -- (Red) Fireplace
				e:TakeDamage(99999, 0, EntityRef(effect), 0)
			elseif e.Type == 1000 and (e.Variant == 51 or e.Variant == 52) then -- Fire/Red Flame
				e:Remove()
				extinguishedSomething = true
			elseif e.Type == 1000 and e.Variant == 26 and (e.SubType == 7000 or e.SubType == 7001) then -- Gunpowder (FiendFolio)
				e:Remove()
			elseif e.Type == 1000 and e.Variant == 7005 then -- Gunpowder fire (FiendFolio)
				e:Remove()
				extinguishedSomething = true
			elseif e.Type == 1000 and e.Variant == 7015 then -- Fiend Fire (FiendFolio)
				e:Remove()
			elseif e.Type == mod.FF.Spitroast.ID and e.Variant == mod.FF.Spitroast.Var then -- Spitroast
				--e:ToNPC():Morph(61, 0, 0, e:ToNPC():GetChampionColorIdx())
				e:TakeDamage(e.MaxHitPoints/5, 0, EntityRef(Isaac.GetPlayer(0)), 0)
				extinguishedSomething = true
			elseif e.Type == mod.FF.Spitfire.ID and e.Variant == mod.FF.Spitfire.Var then -- Spitroast
				--e:ToNPC():Morph(61, 0, 0, e:ToNPC():GetChampionColorIdx())
				e:TakeDamage(e.MaxHitPoints/5, 0, EntityRef(Isaac.GetPlayer(0)), 0)
				extinguishedSomething = true
			elseif e.Type == 208 and e.Variant == 963 then -- Big Smoke
				--e:ToNPC():Morph(208, 0, 0, e:ToNPC():GetChampionColorIdx())
				e:TakeDamage(e.MaxHitPoints/5, 0, EntityRef(Isaac.GetPlayer(0)), 0)
				extinguishedSomething = true
				--e:Kill()
			elseif e.Type == 240 and e.Variant == 700 then -- Fried
				e:GetData().unignited = true
				e:TakeDamage(e.MaxHitPoints/5, 0, EntityRef(Isaac.GetPlayer(0)), 0)
				extinguishedSomething = true
			elseif e.Type == mod.FF.Smore.ID and e.Variant == mod.FF.Smore.Var then -- S'more
				extinguishedSomething = true
				local ed = e:GetData()
				if not ed.unignited then
					ed.unignited = true
					ed.AshLeave = false
					local smoresprite = e:GetSprite()
					mod:ReplaceEnemySpritesheet(e, "gfx/enemies/slamboy/smoreextinguished", 1)
					smoresprite:ReplaceSpritesheet(0, "gfx/nothing.png")
					smoresprite:LoadGraphics()
					e:TakeDamage(e.MaxHitPoints/5, 0, EntityRef(Isaac.GetPlayer(0)), 0)
				end
			elseif e.Type == mod.FF.Flare.ID and e.Variant == mod.FF.Flare.Var then -- Mr Flare
				extinguishedSomething = true
				--e:ToNPC():Morph(12, 0, 0, e:ToNPC():GetChampionColorIdx())
				e:GetData().unignited = true
				e:TakeDamage(e.MaxHitPoints/5, 0, EntityRef(Isaac.GetPlayer(0)), 0)
			elseif e.Type == mod.FF.Woodburner.ID and e.Variant == mod.FF.Woodburner.Var then -- Woodburner
				extinguishedSomething = true
				e:GetData().unignited = true
				e:TakeDamage(e.MaxHitPoints/5, 0, EntityRef(Isaac.GetPlayer(0)), 0)
			elseif e.Type == mod.FF.Fumegeist.ID and e.Variant == mod.FF.Fumegeist.Var then -- Fumegeist
				extinguishedSomething = true
				e:GetData().state = "BecomeNormal"
				e:TakeDamage(e.MaxHitPoints/5, 0, EntityRef(Isaac.GetPlayer(0)), 0)
			elseif e.Type == mod.FF.Mote.ID and e.Variant == mod.FF.Mote.Var then -- Mote
				extinguishedSomething = true
				e:GetData().flaming = false
				e:TakeDamage(e.MaxHitPoints/5, 0, EntityRef(Isaac.GetPlayer(0)), 0)
			elseif e.Type == mod.FF.Charlie.ID and e.Variant == mod.FF.Charlie.Var then -- Charlie
				extinguishedSomething = true
				--e:ToNPC():Morph(10, 1, 0, e:ToNPC():GetChampionColorIdx())
				e:TakeDamage(e.MaxHitPoints/5, 0, EntityRef(Isaac.GetPlayer(0)), 0)
				--e:Kill()
			elseif e.Type == mod.FF.Sooty.ID and e.Variant == mod.FF.Sooty.Var then -- Sooty
				extinguishedSomething = true
				--e:ToNPC():Morph(284, 0, 0, e:ToNPC():GetChampionColorIdx())
				e:TakeDamage(e.MaxHitPoints/5, 0, EntityRef(Isaac.GetPlayer(0)), 0)
				--e:Kill()
			elseif e.Type == 750 and e.Variant == 110 then -- Wick
				extinguishedSomething = true
				e:GetData().unignited = true
				e:TakeDamage(e.MaxHitPoints/5, 0, EntityRef(Isaac.GetPlayer(0)), 0)
			elseif e.Type == 114 and e.Variant == 8 then -- Crucible
				extinguishedSomething = true
				e:GetData().ignited = false
				e:TakeDamage(e.MaxHitPoints/5, 0, EntityRef(Isaac.GetPlayer(0)), 0)
			end
		end
		if extinguishedSomething then
			sfx:Play(SoundEffect.SOUND_FIREDEATH_HISS,1,1,false,1.5)
		end
	end
end, 7019) -- Water Explosion

--watertnt,supertnt,tntbarrel,
local watertntRNG = RNG()
mod:AddCallback(ModCallbacks.MC_ENTITY_TAKE_DMG, function(_, entity, amount, flags)
	if entity:GetData().dontDoAnything then
		return
	end
	if entity.Variant == 750 then -- Super TNT
		entity:GetData().bigboy = true
		entity:GetData().offset = entity.FrameCount + 5
	elseif entity.Variant == 751 then -- Water TNT
		local amt = math.min(math.max(math.floor(amount / 15), 1), 3)
		if entity.HitPoints - amt <= 1 or flags & (DamageFlag.DAMAGE_TNT | DamageFlag.DAMAGE_EXPLOSION) ~= 0 then
			Isaac.Spawn(1000, 7019, 0, entity.Position, nilvector, nil)
			sfx:Play(mod.Sounds.Waterboom, 2, 0, false, 1)
			mod.QuickSetEntityGridPath(entity, 0)
			--[[local room = game:GetRoom()
			if room:GetBackdropType() == 6 then
				watertntRNG:SetSeed(room:GetSpawnSeed() + room:GetGridIndex(entity.Position), 0)
				if watertntRNG:RandomInt(10) < 4 then
					Isaac.Spawn(960, 150, 0, entity.Position, nilvector, nil)
				end
			end]]

			--local creep = Isaac.Spawn(1000, 37, 0, entity.Position + Vector(0,10), Vector(0,0), entity):ToEffect();
			local creep = Isaac.Spawn(1000, 32, 0, entity.Position + Vector(0,10), Vector.Zero, entity):ToEffect()
			local color = Color(1,1,1,1,0,0,0)
			color:SetColorize(160/255,190/255,230/255,1)
			creep.Color = color
			creep:SetTimeout(90)
			creep:Update() 

			for i = 22.5, 360, 22.5 do
				local tear = Isaac.Spawn(2, 0, 0, entity.Position, Vector(9,0):Rotated(i), entity)
			end

			for i = 1, 6 do
				local particle = Isaac.Spawn(1000, 27, 0, entity.Position, RandomVector()*math.random(5,30)/10, entity)
				particle:GetSprite():ReplaceSpritesheet(0, "gfx/grid/water_tnt.png")
				particle:GetSprite():LoadGraphics()
				particle:GetData().turnedIntoCoolBetterParticles = true
				particle:Update()
			end

			local t = Isaac.Spawn(entity.Type, entity.Variant, 0, entity.Position, nilvector, nil)
			t.HitPoints = 0
			t:GetData().dontDoAnything = true
			entity:Remove()
			t:Update()
		else
			entity.HitPoints = entity.HitPoints - amt
		end
		return false
	elseif entity.Variant == 752 then -- Compost Bins, CompostAI, PooBarrels, BeanTNT,
		local amt = math.min(math.max(math.floor(amount / 15), 1), 3)
		if entity.HitPoints - amt <= 1 or flags & (DamageFlag.DAMAGE_TNT | DamageFlag.DAMAGE_EXPLOSION) ~= 0 or entity:IsDead() then
			sfx:Play(SoundEffect.SOUND_MUSHROOM_POOF, 2, 0, false, 1.5);
			if entity:GetDropRNG():RandomInt(50) == 0 then
				local sd = FiendFolio.savedata.run
				sd.ComposBarrelBeanFloor = sd.ComposBarrelBeanFloor or entity:GetDropRNG():RandomInt(5)
				if sd.ComposBarrelBeanFloor == 1 and not sd.SpawnedRainbowBean then
					Isaac.Spawn(5, 350, mod.ITEM.TRINKET.RAINBOW_BEAN, entity.Position + Vector(0,10), nilvector, nil)
					sd.SpawnedRainbowBean = true
				end
			end
			if entity.SubType == 2 then
				Game():CharmFart(entity.Position, 120, entity)
			elseif entity.SubType == 1 then
				Game():Fart(entity.Position, 80, entity, 1, 0)
				mod:FakeFart(entity, entity.Position)
			else
				game:ButterBeanFart(entity.Position, 280, entity, true, false)
				for _, enemy in pairs(Isaac.FindInRadius(entity.Position, 120, 0xffffffff)) do
					if enemy:IsEnemy() or enemy.Type == 1 then
						local enemyvec = (enemy.Position - entity.Position)
						local dist = 80 - enemyvec:Length()
						if enemy:IsEnemy() and not enemy:HasEntityFlags(EntityFlag.FLAG_CONFUSION) then
							enemy:AddConfusion(EntityRef(entity), math.ceil(30 + dist), false)
						end
						if not enemy:HasEntityFlags(EntityFlag.FLAG_NO_PHYSICS_KNOCKBACK | EntityFlag.FLAG_NO_KNOCKBACK) then
							if enemy.Type == 1 then
								--enemy.Velocity = enemy.Velocity + enemyvec:Resized(2)
							else
								enemy.Velocity = enemy.Velocity + enemyvec:Resized(15)
							end
						end
					end
				end
			end

			for i = 1, 6 do
				local particle = Isaac.Spawn(1000, 27, 0, entity.Position, RandomVector()*math.random(5,30)/10, entity)
				local ps = particle:GetSprite()
				if entity.SubType == 3 then
					ps:Load("gfx/grid/composter/composter_unstable.anm2", true)
				elseif entity.SubType == 2 then
					ps:Load("gfx/grid/composter/composter_charm.anm2", true)
				elseif entity.SubType == 1 then
					ps:Load("gfx/grid/composter/composter_poison.anm2", true)
				else
					ps:Load("gfx/grid/composter/composter_knockback.anm2", true)
				end
				ps:Play("Gib" .. math.random(4), true)
				particle:GetData().turnedIntoCoolBetterParticles = true
				particle:Update()
			end

			local t = Isaac.Spawn(entity.Type, entity.Variant, entity.SubType, entity.Position, nilvector, nil)
			t.HitPoints = 0
			t:GetData().dontDoAnything = true
			entity:Remove()
			t:Update()
		else
			entity.HitPoints = entity.HitPoints - amt
		end
		return false
	end
end, 292) -- Pushable TNT type enemies


function mod:globalTakeDamage(entity, amount, flags, source, cooldown)
	if mod.eternalFlickerspiritInRoom then
		local d = entity:GetData()
		if d.eternalFlickerspirited then
			return false
		end
	end

	if source and source.Entity and source.Entity:GetData().IsPeppermint then
		if entity:IsEnemy() and (not mod:isFriend(entity)) and (not entity:HasEntityFlags(EntityFlag.FLAG_NO_STATUS_EFFECTS)) then
			entity:AddSlowing(EntityRef(source.Entity.Parent), 60, 0.5, Color(1.2,1.2,1.2,1,0,0,0.1))
			entity:AddEntityFlags(EntityFlag.FLAG_ICE)
			entity:GetData().PeppermintSlowed = true
		end
	end
end

mod:AddCallback(ModCallbacks.MC_ENTITY_TAKE_DMG, mod.globalTakeDamage)

local mimeHurts = {
	"Ouch!",
	"Oof!",
	"Ow!",
	"Merde!",
	"Sacre Bleu!",
	"Mon Dieu!",
}
local mimeHurtsFiend = {
	"F**k!",
	"S**t!",
	"D*mn!",
	"Cr*p!",
	"Gah!",
	"Grah!",
	"Bah!",
	"**** **** ***** ** *** *** !",
}

function mod:playerDamage(entity, amount, flags, source, cooldown)
	player = entity:ToPlayer()
	local ret = mod:biendHurt(entity, amount, flags, source, cooldown)
	if ret ~= nil then
		return ret
	end

	mod:erflyPlayerHurt(player, amount, flags, source, cooldown)
	if player:HasCollectible(mod.ITEM.COLLECTIBLE.MIME_DEGREE) then
		mod.scheduleForUpdate(function()
			sfx:Stop(SoundEffect.SOUND_ISAAC_HURT_GRUNT)
		end, 1)
		if player:GetPlayerType() == FiendFolio.PLAYER.FIEND then
			game:GetHUD():ShowItemText(mimeHurtsFiend[math.random(#mimeHurtsFiend)])
		else
			if math.random(1000) == 1 then
				game:GetHUD():ShowItemText("TABARNAK D'OSTI D'CALISSE", "DE SAINT SIBOUERE DE SACREMENT D'MAUDITE MARDE")
			else
				game:GetHUD():ShowItemText(mimeHurts[math.random(#mimeHurts)])
			end
		end
	else
		if player:GetPlayerType() == FiendFolio.PLAYER.FIEND then
			sfx:Play(mod.Sounds.FiendHurt, 0.8, 0, false, 1)
		elseif player:GetPlayerType() == FiendFolio.PLAYER.BIEND then
			sfx:Play(mod.Sounds.BiendHurt, 0.8, 0, false, 1)
		elseif player:GetPlayerType() == FiendFolio.PLAYER.GOLEM or player:GetPlayerType() == FiendFolio.PLAYER.BOLEM then
			sfx:Play(mod.Sounds.GolemHurt, 1, 0, false, 1)
		elseif player:GetPlayerType() == FiendFolio.PLAYER.CHINA then
			sfx:Play(mod.Sounds.FiendHurt, 0.8, 0, false, 1.5)
		elseif player:GetPlayerType() == FiendFolio.PLAYER.FIENT then
			sfx:Play(mod.Sounds.AGJump, 1, 0, false, 1)
			mod.scheduleForUpdate(function()
				sfx:Stop(SoundEffect.SOUND_ISAAC_HURT_GRUNT)
			end, 1)
		elseif player:GetPlayerType() == FiendFolio.PLAYER.FEND then
			sfx:Play(mod.Sounds.FiendHurt, 0.8, 0, false, 0.7)
		end
	end
end

mod:AddCallback(ModCallbacks.MC_ENTITY_TAKE_DMG, mod.playerDamage, 1)


--Effect related (in cases of overriding stuff)

function mod:checkDirtPile(e)
	local subt = e.SubType
	local d = e:GetData()
	if d.WeaverPile then
		mod:weaverDirtPileOpeningAI(e)
	elseif d.KingpinPile then
		mod:kingpinDirtPileAI(e)
	end
end

mod:AddCallback(ModCallbacks.MC_POST_EFFECT_UPDATE, mod.checkDirtPile, 146)

function mod:checkBlackCreep(e)
local subt = e.SubType
	if subt == 980 then
		mod:borisCreepPool(e)
	elseif subt == 7000 then
		mod:AshCreepAI(e)
	elseif subt == 7001 then
		mod:gunpowderCreepAI(e)
	elseif subt == 7002 then
		mod:weaverDirtPileAI(e)
	end

	local d = e:GetData()
	if d.DangerousToFeetsies then
		for _, player in pairs(Isaac.FindInRadius(e.Position, 40, EntityPartition.PLAYER)) do
			player = player:ToPlayer()
			if not (player:HasCollectible(CollectibleType.COLLECTIBLE_SOCKS) or player:HasCollectible(CollectibleType.COLLECTIBLE_MOMS_HEELS) or player:HasCollectible(CollectibleType.COLLECTIBLE_BEE_SKIN) or player:HasTrinket(TrinketType.TRINKET_CALLUS) or player.CanFly) then
				player:GetData().BleedyFeetsies = 50
			end
		end
	end
end
mod:AddCallback(ModCallbacks.MC_POST_EFFECT_UPDATE, mod.checkBlackCreep, 26)
mod:AddCallback(ModCallbacks.MC_POST_EFFECT_UPDATE, mod.checkBlackCreep, 45)
mod:AddCallback(ModCallbacks.MC_POST_EFFECT_UPDATE, mod.checkBlackCreep, 7000)

function mod:checkRedCandle(e)
	if e.SubType == 960 then
		local d = e:GetData()
		local fc = e.FrameCount
		local timer = d.timer or 120
		if fc < 5 then
			e.SpriteScale = Vector(fc/5, fc/5)
		elseif fc > timer then
			e.SpriteScale = e.SpriteScale * 0.9
			if e.SpriteScale.X < 0.1 then
				e:Remove()
			end
		end
	end
end
mod:AddCallback(ModCallbacks.MC_POST_EFFECT_UPDATE, mod.checkRedCandle, 51)

--Find color info
--[[function mod:checkSplatCol(npc)
	Isaac.ConsoleOutput("R" .. npc.SplatColor.R .. "\n")
	Isaac.ConsoleOutput("G" .. npc.SplatColor.G .. "\n")
	Isaac.ConsoleOutput("B" .. npc.SplatColor.B .. "\n")
	Isaac.ConsoleOutput("A" .. npc.SplatColor.A .. "\n")
	Isaac.ConsoleOutput("RO" .. npc.SplatColor.RO .. "\n")
	Isaac.ConsoleOutput("GO" .. npc.SplatColor.GO .. "\n")
	Isaac.ConsoleOutput("BO" .. npc.SplatColor.BO .. "\n")
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkSplatCol, 219)]]

function mod.GetPlayerIndex(player)
	local idx = 0
	for i = 1, game:GetNumPlayers() do
		local p = Isaac.GetPlayer(i - 1)
		if p and GetPtrHash(p) == GetPtrHash(player) then
			idx = i
			break
		end
	end
	return idx
end

function mod.AnyPlayerDo(foo)
	for i = 0, game:GetNumPlayers() - 1 do
		local player = Isaac.GetPlayer(i)
		foo(player)
	end
end

function mod.anyPlayerHas(itemid, trinket, mombox)
	for i = 1, game:GetNumPlayers() do
		local p = Isaac.GetPlayer(i - 1)
		if trinket then
			if mombox then
				if p:HasTrinket(itemid) and p:HasCollectible(CollectibleType.COLLECTIBLE_MOMS_BOX) then
					return true
				end
			else
				if p:HasTrinket(itemid) then
					return true
				end
			end
		else
			if p:HasCollectible(itemid) then
				return true
			end
		end
	end
end

function mod.phdPlayer()
	for i = 1, game:GetNumPlayers() do
		local p = Isaac.GetPlayer(i - 1)
		if p:HasCollectible(CollectibleType.COLLECTIBLE_PHD) then
			return p
		end
	end
end
function mod.goodPillPlayer()
	for i = 1, game:GetNumPlayers() do
		local p = Isaac.GetPlayer(i - 1)
		if p:HasCollectible(CollectibleType.COLLECTIBLE_LUCKY_FOOT) or p:HasCollectible(CollectibleType.COLLECTIBLE_VIRGO) then
			return p
		end
	end
end
function mod.falsephdPlayer()
	for i = 1, game:GetNumPlayers() do
		local p = Isaac.GetPlayer(i - 1)
		if p:HasCollectible(CollectibleType.COLLECTIBLE_FALSE_PHD) then
			return p
		end
	end
end

function mod.getTrinketMultiplierAcrossAllPlayers(trinketid)
	local totalMult = 0
	for i = 1, game:GetNumPlayers() do
		local p = Isaac.GetPlayer(i - 1)
		totalMult = totalMult + p:GetTrinketMultiplier(trinketid)
	end
	return totalMult
end

function mod.getTrinketMultiplierOfPlayerWithTrinket(multiId, hasId)
	local maxMulti = 0
	for i = 1, game:GetNumPlayers() do
		local p = Isaac.GetPlayer(i - 1)
		if p:HasTrinket(hasId) then
			maxMulti = math.max(maxMulti, p:GetTrinketMultiplier(multiId))
		end
	end
	return maxMulti
end

function mod.isAnyoneCharacter(characterID)
	for i = 1, game:GetNumPlayers() do
		local p = Isaac.GetPlayer(i - 1)
		if p:GetPlayerType() == characterID then
			return true
		end
	end
end

function mod.slowestPlayerSpeed(capMin, capMax)
	capMin = capMin or 0.1
	local movespeed = capMax or 2
	for i = 1, game:GetNumPlayers() do
		local p = Isaac.GetPlayer(i - 1)
		if p.MoveSpeed < movespeed then
			movespeed = p.MoveSpeed
		end
	end
	return math.max(capMin, movespeed)
end

function mod:playerIsBelialMode(player)
	if player:HasCollectible(CollectibleType.COLLECTIBLE_BIRTHRIGHT) and
	(player:GetPlayerType() == PlayerType.PLAYER_JUDAS or player:GetPlayerType() == PlayerType.PLAYER_BLACKJUDAS) then
		return true
	end
end

local cursedPennyRng = RNG()
mod:AddCallback(ModCallbacks.MC_POST_PICKUP_UPDATE, function(_, pickup)
	if pickup.SubType ~= CoinSubType.COIN_CURSEDPENNY and pickup.SubType ~= 216 then return end

	local sprite = pickup:GetSprite()
	if sprite:IsEventTriggered("DropSound") then
		if pickup.SubType == 216 then
			sfx:Play(SoundEffect.SOUND_DIMEDROP, 1, 0, false, 1)
		end
		sfx:Play(SoundEffect.SOUND_PENNYDROP, 1, 0, false, 1.0)
	end
end, PickupVariant.PICKUP_COIN)

function mod:AddCursedPennyStats(player)
	local data = player:GetData()
	data.ffsavedata.CursedPennyStats = (data.ffsavedata.CursedPennyStats or 0) + 1
	player:AddCacheFlags(CacheFlag.CACHE_ALL)
	player:EvaluateItems()
end

function mod:cursedPennyCollide(pickup, opp)
	if pickup.SubType == CoinSubType.COIN_CURSEDPENNY or pickup.SubType == 216 then
	else return end

	if opp:ToPlayer() or
	   (opp:ToFamiliar() and (opp.Variant == FamiliarVariant.BUM_FRIEND or
							  opp.Variant == FamiliarVariant.BUMBO or
							  opp.Variant == FamiliarVariant.SUPER_BUM))
	then
		local sprite = pickup:GetSprite()
		if not (sprite:WasEventTriggered("DropSound") or sprite:IsPlaying("Idle")) then
			return false
		end

		cursedPennyRng:SetSeed(pickup.DropSeed, 0)
		local odds = cursedPennyRng:RandomInt(200)

		local player = opp:ToPlayer()
		local familiar = opp:ToFamiliar()

		if player and not FiendFolio.ACHIEVEMENT.GOLDEN_CURSED_PENNY:IsUnlocked(true) and mod.CanRunUnlockAchievements() then
			mod.savedata.cursedPennyPickups = mod.savedata.cursedPennyPickups + 1
			if mod.savedata.cursedPennyPickups >= 50 then
				FiendFolio.ACHIEVEMENT.GOLDEN_CURSED_PENNY:Unlock()
			end
		end

		if odds < 60 then
			-- 30% - remove 1 coin
			if player then
				player:AddCoins(-1)
			elseif familiar then
				familiar.Coins = math.max(familiar.Coins - 1, 0)
			end
			sfx:Play(mod.Sounds.CursedPennyNegative, 1, 0, false, 1)
		elseif odds < 120 then
			-- 30% - grant 1 coin
			if player then
				player:AddCoins(1)
			elseif familiar then
				familiar.Coins = familiar.Coins + 1
			end
			sfx:Play(SoundEffect.SOUND_PENNYPICKUP, 1, 0, false, 1)
		elseif odds < 160 then
			-- 20% - grant 2 coins
			if player then
				player:AddCoins(2)
			elseif familiar then
				familiar.Coins = familiar.Coins + 2
			end
			sfx:Play(mod.Sounds.CursedPennyPositive, 1, 0, false, 1)
		elseif odds < 180 then
			-- 10% - grant 0 coins
			if player then
				player:AddCoins(-2)
			elseif familiar then
				familiar.Coins = math.max(familiar.Coins - 2, 0)
			end
			sfx:Play(mod.Sounds.CursedPennyNegativeSuper, 1, 0, false, 1)
			--sfx:Play(SoundEffect.SOUND_BROWNIE_LAUGH, 1, 0, false, 1.3)
			game:Fart(pickup.Position, 40, pickup, 1, 0)
		elseif odds < 190 then
			-- 5% - grant 1 luck and 1 coin
			if player then
				player:AddCoins(1)
				player:DonateLuck(1)
				player:AnimateHappy()
			elseif familiar then
				familiar.Coins = familiar.Coins + 1
			end
			sfx:Play(mod.Sounds.CursedPennyPositiveSuper, 1, 0, false, 1)
		elseif odds < 195 then
			-- 2.5% - explode and hurt the player and remove 1 coin
			if player then
				player:AddCoins(-1)
				player:AnimateSad()

				if not FiendFolio.ACHIEVEMENT.EVIL_STICKER:IsUnlocked(true) then
					FiendFolio.ACHIEVEMENT.EVIL_STICKER:Unlock()
				end
			elseif familiar then
				familiar.Coins = math.max(familiar.Coins - 1, 0)
			end
			Isaac.Explode(pickup.Position, nil, 40)
			sfx:Play(mod.Sounds.CursedPennyNegativeMega, 1, 0, false, 1)
		elseif odds < 198 then
			-- 2.5% - grant a very minor all stats up and 1 coin
			if player then
				player:AddCoins(1)
				mod:AddCursedPennyStats(player)
				player:AnimateHappy()
			elseif familiar then
				familiar.Coins = familiar.Coins + 1
			end
			sfx:Play(mod.Sounds.CursedPennyPositiveMega, 1, 0, false, 1)
		else
			sfx:Play(mod.Sounds.CursedPennyNeutral, 1, 0, false, 1)
		end

		if pickup.OptionsPickupIndex ~= 0 then
			local pickups = Isaac.FindByType(EntityType.ENTITY_PICKUP)
			for _, entity in ipairs(pickups) do
				if entity:ToPickup().OptionsPickupIndex == pickup.OptionsPickupIndex and
				   (entity.Index ~= pickup.Index or entity.InitSeed ~= pickup.InitSeed)
				then
					Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.POOF01, 0, entity.Position, nilvector, nil)
					entity:Remove()
				end
			end
		end

		pickup.Velocity = nilvector
		pickup.Touched = true
		pickup.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
		sprite:Play("Collect", true)
		if pickup.SubType == 216 and cursedPennyRng:RandomInt(10) < 9 then
			local gold = Isaac.Spawn(5, 20, 216, mod:FindRandomFreePos(pickup), Vector.Zero, pickup)
			gold:GetSprite():Play("Reappear", true)
		end
		pickup:Die()
		
		Game():SetStateFlag(GameStateFlag.STATE_HEART_BOMB_COIN_PICKED, true)

		return true
	elseif opp.Type == EntityType.ENTITY_ULTRA_GREED or
		   opp.Type == EntityType.ENTITY_BUMBINO
	then
		cursedPennyRng:SetSeed(pickup.DropSeed, 0)
		if pickup.SubType == 216 and cursedPennyRng:RandomInt(10) < 9 then
			local gold = Isaac.Spawn(5, 20, 216, mod:FindRandomFreePos(pickup), Vector.Zero, pickup)
			gold:GetSprite():Play("Reappear", true)
		end
		pickup.SubType = 1
		return
	end
end
mod:AddCallback(ModCallbacks.MC_PRE_PICKUP_COLLISION, mod.cursedPennyCollide, 20)

--Haunted Penny
function mod:hauntedPennyCollide(pickup, opp)
	if pickup.SubType ~= CoinSubType.COIN_HAUNTEDPENNY then return end

	if opp:ToPlayer() or
	   (opp:ToFamiliar() and (opp.Variant == FamiliarVariant.BUM_FRIEND or
							  opp.Variant == FamiliarVariant.BUMBO or
							  opp.Variant == FamiliarVariant.SUPER_BUM))
	then
		local sprite = pickup:GetSprite()
		if not (sprite:WasEventTriggered("DropSound") or sprite:IsPlaying("Idle")) then
			return false
		end

		local player = opp:ToPlayer()
		local familiar = opp:ToFamiliar()

		if player then
			player:AddCoins(1)
			player:AddWisp(0, player.Position)
		elseif familiar then
			familiar.Coins = familiar.Coins + 1
		end
		sfx:Play(SoundEffect.SOUND_CANDLE_LIGHT, 1, 0, false, 1)
		sfx:Play(SoundEffect.SOUND_SOUL_PICKUP, 1.3, 0, false, 1)

		if pickup.OptionsPickupIndex ~= 0 then
			local pickups = Isaac.FindByType(EntityType.ENTITY_PICKUP)
			for _, entity in ipairs(pickups) do
				if entity:ToPickup().OptionsPickupIndex == pickup.OptionsPickupIndex and
				   (entity.Index ~= pickup.Index or entity.InitSeed ~= pickup.InitSeed)
				then
					Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.POOF01, 0, entity.Position, nilvector, nil)
					entity:Remove()
				end
			end
		end

		pickup.Velocity = nilvector
		pickup.Touched = true
		pickup.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
		sprite:Play("Collect", true)
		pickup:Die()
		
		Game():SetStateFlag(GameStateFlag.STATE_HEART_BOMB_COIN_PICKED, true)

		return true
	elseif opp.Type == EntityType.ENTITY_ULTRA_GREED or
		   opp.Type == EntityType.ENTITY_BUMBINO
	then
		pickup.SubType = 1
		return
	end
end
mod:AddCallback(ModCallbacks.MC_PRE_PICKUP_COLLISION, mod.hauntedPennyCollide, 20)

--Honey Penny
function mod:honeyPennyCollide(pickup, opp)
	if pickup.SubType ~= 215 then return end

	if opp:ToPlayer() or
	   (opp:ToFamiliar() and (opp.Variant == FamiliarVariant.BUM_FRIEND or
							  opp.Variant == FamiliarVariant.BUMBO or
							  opp.Variant == FamiliarVariant.SUPER_BUM))
	then
		local sprite = pickup:GetSprite()
		if not (sprite:WasEventTriggered("DropSound") or sprite:IsPlaying("Idle")) then
			return false
		end

		local player = opp:ToPlayer()
		local familiar = opp:ToFamiliar()

		if player then
			player:AddCoins(1)

			local data = player:GetData()
			if data.HoneyPenny ~= true then
				local iconEnt = Isaac.Spawn(EntityType.ENTITY_EFFECT, 1748, 0, player.Position, player.Velocity, nil)
				iconEnt:AddEntityFlags(EntityFlag.FLAG_PERSISTENT)
				local icon = iconEnt:ToEffect()
				icon.Parent = player
				icon:FollowParent(player)
				icon.DepthOffset = 1
				icon:Update()
				iconEnt:GetSprite():Play("Honey")
			end

			data.HoneyPenny = true
			data.HoneyPennyTimer = 60*8
		elseif familiar then
			familiar.Coins = familiar.Coins + 1
		end
		sfx:Play(SoundEffect.SOUND_ANIMAL_SQUISH, 1.3, 0, false, 1)
		sfx:Play(SoundEffect.SOUND_PENNYPICKUP, 1, 0, false, 1)

		if pickup.OptionsPickupIndex ~= 0 then
			local pickups = Isaac.FindByType(EntityType.ENTITY_PICKUP)
			for _, entity in ipairs(pickups) do
				if entity:ToPickup().OptionsPickupIndex == pickup.OptionsPickupIndex and
				   (entity.Index ~= pickup.Index or entity.InitSeed ~= pickup.InitSeed)
				then
					Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.POOF01, 0, entity.Position, nilvector, nil)
					entity:Remove()
				end
			end
		end

		pickup.Velocity = nilvector
		pickup.Touched = true
		pickup.EntityCollisionClass = EntityCollisionClass.ENTCOLL_NONE
		sprite:Play("Collect", true)
		pickup:Die()
		
		Game():SetStateFlag(GameStateFlag.STATE_HEART_BOMB_COIN_PICKED, true)

		return true
	elseif opp.Type == EntityType.ENTITY_ULTRA_GREED or
		   opp.Type == EntityType.ENTITY_BUMBINO
	then
		pickup.SubType = 1
		return
	end
end
mod:AddCallback(ModCallbacks.MC_PRE_PICKUP_COLLISION, mod.honeyPennyCollide, 20)


mod:AddCallback(ModCallbacks.MC_POST_PICKUP_UPDATE, function(_, pickup)
	if pickup.SubType == 214 then
		if pickup:GetSprite():IsEventTriggered("DropSound") then
			sfx:Play(SoundEffect.SOUND_PENNYDROP, 1, 0, false, 1)
		end
	elseif pickup.SubType == 215 then
		if pickup:GetSprite():IsEventTriggered("DropSound") then
			sfx:Play(SoundEffect.SOUND_ANIMAL_SQUISH, 1.3, 0, false, 1)
		end
	end
end, 20)


mod:AddCallback(ModCallbacks.MC_PRE_PICKUP_COLLISION, function(_, pickup, collider)
	
	-- EPIPHANY PICKUP FIX --
	if collider -- is defined
	and collider:ToPlayer() -- is a player
	and Epiphany -- is installed
	and collider:ToPlayer():GetPlayerType() == Epiphany.table_type_id["KEEPER"] -- player is Tarnished Keeper
	and pickup.Price -- is defined
	and not (pickup.Price > 0)
	and not pickup.Touched
	then return end -- do not check the pickup
	-- END --

	if pickup.SubType == KeySubType.KEY_SPICY or pickup.SubType == KeySubType.KEY_SPICY_PERM then
		if collider.Type == 1 then
			collider = collider:ToPlayer()
			if pickup:GetSprite():WasEventTriggered("DropSound") or pickup:GetSprite():IsPlaying("Idle") then
				pickup:GetSprite():Play("Collect")
				pickup:Die()
				sfx:Play(SoundEffect.SOUND_FIREDEATH_HISS, 1, 0, false, 1)
				collider:AddKeys(2)
				collider:TakeDamage(1, DamageFlag.DAMAGE_NO_PENALTIES | DamageFlag.DAMAGE_FIRE, EntityRef(pickup), 30)

				if pickup.OptionsPickupIndex ~= 0 then
					local pickups = Isaac.FindByType(EntityType.ENTITY_PICKUP)
					for _, entity in ipairs(pickups) do
						if entity:ToPickup().OptionsPickupIndex == pickup.OptionsPickupIndex and
						   (entity.Index ~= pickup.Index or entity.InitSeed ~= pickup.InitSeed)
						then
							Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.POOF01, 0, entity.Position, nilvector, nil)
							entity:Remove()
						end
					end
				end

				pickup.EntityCollisionClass = 0
				return true
			end
		elseif collider.Type == 3 and collider.Variant == FamiliarVariant.KEY_BUM then
			collider = collider:ToFamiliar()
			if pickup:GetSprite():WasEventTriggered("DropSound") or pickup:GetSprite():IsPlaying("Idle") then
				pickup:GetSprite():Play("Collect")
				pickup:Die()
				sfx:Play(SoundEffect.SOUND_FIREDEATH_HISS, 1, 0, false, 1)
				collider.Keys = collider.Keys + 2

				if pickup.OptionsPickupIndex ~= 0 then
					local pickups = Isaac.FindByType(EntityType.ENTITY_PICKUP)
					for _, entity in ipairs(pickups) do
						if entity:ToPickup().OptionsPickupIndex == pickup.OptionsPickupIndex and
						   (entity.Index ~= pickup.Index or entity.InitSeed ~= pickup.InitSeed)
						then
							Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.POOF01, 0, entity.Position, nilvector, nil)
							entity:Remove()
						end
					end
				end

				pickup.EntityCollisionClass = 0
				return true
			end
		end
	elseif pickup.SubType == KeySubType.KEY_SUPERSPICY or pickup.SubType == KeySubType.KEY_SUPERSPICY_PERM then
		if collider.Type == 1 then
			collider = collider:ToPlayer()
			if pickup:GetSprite():WasEventTriggered("DropSound") or pickup:GetSprite():IsPlaying("Idle") then
				pickup:GetSprite():Play("Collect")
				pickup:Die()
				sfx:Play(SoundEffect.SOUND_FIREDEATH_HISS, 1, 0, false, 1)
				collider:AddKeys(3)
				collider:TakeDamage(1, DamageFlag.DAMAGE_NO_PENALTIES | DamageFlag.DAMAGE_FIRE, EntityRef(pickup), 30)

				if pickup.OptionsPickupIndex ~= 0 then
					local pickups = Isaac.FindByType(EntityType.ENTITY_PICKUP)
					for _, entity in ipairs(pickups) do
						if entity:ToPickup().OptionsPickupIndex == pickup.OptionsPickupIndex and
						   (entity.Index ~= pickup.Index or entity.InitSeed ~= pickup.InitSeed)
						then
							Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.POOF01, 0, entity.Position, nilvector, nil)
							entity:Remove()
						end
					end
				end

				pickup.EntityCollisionClass = 0
				return true
			end
		elseif collider.Type == 3 and collider.Variant == FamiliarVariant.KEY_BUM then
			collider = collider:ToFamiliar()
			if pickup:GetSprite():WasEventTriggered("DropSound") or pickup:GetSprite():IsPlaying("Idle") then
				pickup:GetSprite():Play("Collect")
				pickup:Die()
				sfx:Play(SoundEffect.SOUND_FIREDEATH_HISS, 1, 0, false, 1)
				collider.Keys = collider.Keys + 3

				if pickup.OptionsPickupIndex ~= 0 then
					local pickups = Isaac.FindByType(EntityType.ENTITY_PICKUP)
					for _, entity in ipairs(pickups) do
						if entity:ToPickup().OptionsPickupIndex == pickup.OptionsPickupIndex and
						   (entity.Index ~= pickup.Index or entity.InitSeed ~= pickup.InitSeed)
						then
							Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.POOF01, 0, entity.Position, nilvector, nil)
							entity:Remove()
						end
					end
				end

				pickup.EntityCollisionClass = 0
				return true
			end
		end
	elseif pickup.SubType == KeySubType.KEY_CHARGEDSPICY or pickup.SubType == KeySubType.KEY_CHARGEDSPICY_PERM then
		if collider.Type == 1 then
			collider = collider:ToPlayer()
			if pickup:GetSprite():WasEventTriggered("DropSound") or pickup:GetSprite():IsPlaying("Idle") then
				pickup:GetSprite():Play("Collect")
				pickup:Die()
				sfx:Play(SoundEffect.SOUND_FIREDEATH_HISS, 1, 0, false, 1)
				collider:AddKeys(2)
				collider:FullCharge()
				collider:TakeDamage(1, DamageFlag.DAMAGE_NO_PENALTIES | DamageFlag.DAMAGE_FIRE, EntityRef(pickup), 30)

				if pickup.OptionsPickupIndex ~= 0 then
					local pickups = Isaac.FindByType(EntityType.ENTITY_PICKUP)
					for _, entity in ipairs(pickups) do
						if entity:ToPickup().OptionsPickupIndex == pickup.OptionsPickupIndex and
						   (entity.Index ~= pickup.Index or entity.InitSeed ~= pickup.InitSeed)
						then
							Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.POOF01, 0, entity.Position, nilvector, nil)
							entity:Remove()
						end
					end
				end

				pickup.EntityCollisionClass = 0
				return true
			end
		elseif collider.Type == 3 and collider.Variant == FamiliarVariant.KEY_BUM then
			collider = collider:ToFamiliar()
			if pickup:GetSprite():WasEventTriggered("DropSound") or pickup:GetSprite():IsPlaying("Idle") then
				pickup:GetSprite():Play("Collect")
				pickup:Die()
				sfx:Play(SoundEffect.SOUND_FIREDEATH_HISS, 1, 0, false, 1)
				collider.Keys = collider.Keys + 2

				if pickup.OptionsPickupIndex ~= 0 then
					local pickups = Isaac.FindByType(EntityType.ENTITY_PICKUP)
					for _, entity in ipairs(pickups) do
						if entity:ToPickup().OptionsPickupIndex == pickup.OptionsPickupIndex and
						   (entity.Index ~= pickup.Index or entity.InitSeed ~= pickup.InitSeed)
						then
							Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.POOF01, 0, entity.Position, nilvector, nil)
							entity:Remove()
						end
					end
				end

				pickup.EntityCollisionClass = 0
				return true
			end
		end
	elseif pickup.SubType == KeySubType.KEY_SPICY_BOX then
		if collider.Type == 1 then
			collider = collider:ToPlayer()
			if pickup:GetSprite():WasEventTriggered("DropSound") or pickup:GetSprite():IsPlaying("Idle") then
				pickup:GetSprite():Play("Collect")
				pickup:Die()
				sfx:Play(SoundEffect.SOUND_FIREDEATH_HISS, 1, 0, false, 0.8)
				collider:AddKeys(3)
				collider:TakeDamage(2, DamageFlag.DAMAGE_NO_PENALTIES | DamageFlag.DAMAGE_FIRE, EntityRef(pickup), 30)

				if pickup.OptionsPickupIndex ~= 0 then
					local pickups = Isaac.FindByType(EntityType.ENTITY_PICKUP)
					for _, entity in ipairs(pickups) do
						if entity:ToPickup().OptionsPickupIndex == pickup.OptionsPickupIndex and
						   (entity.Index ~= pickup.Index or entity.InitSeed ~= pickup.InitSeed)
						then
							Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.POOF01, 0, entity.Position, nilvector, nil)
							entity:Remove()
						end
					end
				end

				pickup.EntityCollisionClass = 0
				return true
			end
		elseif collider.Type == 3 and collider.Variant == FamiliarVariant.KEY_BUM then
			collider = collider:ToFamiliar()
			if pickup:GetSprite():WasEventTriggered("DropSound") or pickup:GetSprite():IsPlaying("Idle") then
				pickup:GetSprite():Play("Collect")
				pickup:Die()
				sfx:Play(SoundEffect.SOUND_FIREDEATH_HISS, 1, 0, false, 1)
				collider.Keys = collider.Keys + 3

				if pickup.OptionsPickupIndex ~= 0 then
					local pickups = Isaac.FindByType(EntityType.ENTITY_PICKUP)
					for _, entity in ipairs(pickups) do
						if entity:ToPickup().OptionsPickupIndex == pickup.OptionsPickupIndex and
						   (entity.Index ~= pickup.Index or entity.InitSeed ~= pickup.InitSeed)
						then
							Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.POOF01, 0, entity.Position, nilvector, nil)
							entity:Remove()
						end
					end
				end

				pickup.EntityCollisionClass = 0
				return true
			end
		end
	elseif pickup.SubType == KeySubType.KEY_SUPERSPICY_BOX then
		if collider.Type == 1 then
			collider = collider:ToPlayer()
			if pickup:GetSprite():WasEventTriggered("DropSound") or pickup:GetSprite():IsPlaying("Idle") then
				pickup:GetSprite():Play("Collect")
				pickup:Die()
				sfx:Play(SoundEffect.SOUND_FIREDEATH_HISS, 1, 0, false, 0.8)
				collider:AddKeys(4)
				collider:TakeDamage(2, DamageFlag.DAMAGE_NO_PENALTIES | DamageFlag.DAMAGE_FIRE, EntityRef(pickup), 30)

				if pickup.OptionsPickupIndex ~= 0 then
					local pickups = Isaac.FindByType(EntityType.ENTITY_PICKUP)
					for _, entity in ipairs(pickups) do
						if entity:ToPickup().OptionsPickupIndex == pickup.OptionsPickupIndex and
						   (entity.Index ~= pickup.Index or entity.InitSeed ~= pickup.InitSeed)
						then
							Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.POOF01, 0, entity.Position, nilvector, nil)
							entity:Remove()
						end
					end
				end

				pickup.EntityCollisionClass = 0
				return true
			end
		elseif collider.Type == 3 and collider.Variant == FamiliarVariant.KEY_BUM then
			collider = collider:ToFamiliar()
			if pickup:GetSprite():WasEventTriggered("DropSound") or pickup:GetSprite():IsPlaying("Idle") then
				pickup:GetSprite():Play("Collect")
				pickup:Die()
				sfx:Play(SoundEffect.SOUND_FIREDEATH_HISS, 1, 0, false, 1)
				collider.Keys = collider.Keys + 4

				if pickup.OptionsPickupIndex ~= 0 then
					local pickups = Isaac.FindByType(EntityType.ENTITY_PICKUP)
					for _, entity in ipairs(pickups) do
						if entity:ToPickup().OptionsPickupIndex == pickup.OptionsPickupIndex and
						   (entity.Index ~= pickup.Index or entity.InitSeed ~= pickup.InitSeed)
						then
							Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.POOF01, 0, entity.Position, nilvector, nil)
							entity:Remove()
						end
					end
				end

				pickup.EntityCollisionClass = 0
				return true
			end
		end
	elseif pickup.SubType == KeySubType.KEY_CHARGEDSPICY_BOX then
		if collider.Type == 1 then
			collider = collider:ToPlayer()
			if pickup:GetSprite():WasEventTriggered("DropSound") or pickup:GetSprite():IsPlaying("Idle") then
				pickup:GetSprite():Play("Collect")
				pickup:Die()
				sfx:Play(SoundEffect.SOUND_FIREDEATH_HISS, 1, 0, false, 0.8)
				collider:AddKeys(3)
				collider:FullCharge()
				collider:TakeDamage(2, DamageFlag.DAMAGE_NO_PENALTIES | DamageFlag.DAMAGE_FIRE, EntityRef(pickup), 30)

				if pickup.OptionsPickupIndex ~= 0 then
					local pickups = Isaac.FindByType(EntityType.ENTITY_PICKUP)
					for _, entity in ipairs(pickups) do
						if entity:ToPickup().OptionsPickupIndex == pickup.OptionsPickupIndex and
						   (entity.Index ~= pickup.Index or entity.InitSeed ~= pickup.InitSeed)
						then
							Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.POOF01, 0, entity.Position, nilvector, nil)
							entity:Remove()
						end
					end
				end

				pickup.EntityCollisionClass = 0
				return true
			end
		elseif collider.Type == 3 and collider.Variant == FamiliarVariant.KEY_BUM then
			collider = collider:ToFamiliar()
			if pickup:GetSprite():WasEventTriggered("DropSound") or pickup:GetSprite():IsPlaying("Idle") then
				pickup:GetSprite():Play("Collect")
				pickup:Die()
				sfx:Play(SoundEffect.SOUND_FIREDEATH_HISS, 1, 0, false, 1)
				collider.Keys = collider.Keys + 3

				if pickup.OptionsPickupIndex ~= 0 then
					local pickups = Isaac.FindByType(EntityType.ENTITY_PICKUP)
					for _, entity in ipairs(pickups) do
						if entity:ToPickup().OptionsPickupIndex == pickup.OptionsPickupIndex and
						   (entity.Index ~= pickup.Index or entity.InitSeed ~= pickup.InitSeed)
						then
							Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.POOF01, 0, entity.Position, nilvector, nil)
							entity:Remove()
						end
					end
				end

				pickup.EntityCollisionClass = 0
				return true
			end
		end
	end
end, PickupVariant.PICKUP_KEY)

mod.WoodenBackdrops = {
	[BackdropType.CELLAR] = true,
	[BackdropType.BURNT_BASEMENT] = true,
	[BackdropType.LIBRARY] = true,
	[BackdropType.SHOP] = true,
	[BackdropType.ISAAC] = true,
	[BackdropType.BARREN] = true,
	[BackdropType.ARCADE] = true,
	[BackdropType.GREED_SHOP] = true,
	[BackdropType.DOWNPOUR] = true,
	[BackdropType.DOWNPOUR_ENTRANCE] = true,
	[BackdropType.ISAACS_BEDROOM] = true,
	[BackdropType.HALLWAY] = true,
	[BackdropType.MOMS_BEDROOM] = true,
	[BackdropType.CLOSET] = true,
	[BackdropType.CLOSET_B] = true,
	[BackdropType.DOGMA] = true,
	[BackdropType.DARK_CLOSET] = true,
}

mod.PipeBackdrops = {
	[BackdropType.DROSS] = true,
}

mod.fireTypes = {
{10, 2},		--Flaming Gaper
{15, 3},		--Grilled Clotty
{54, 0},		--Flaming Hopper
{160, 442},		--Flamin
{160, 443},		--Flamin Chain
{208, 2},		--Flaming Fatty
{226, 2},		--Crispy
{824, 1},		--Grilled Gyro
{1000, 1},		--Bomb explosion
{1000, 51, 1},	--Fatty Fire
{1000, 147},	--Fire Jet
{1000, 148},	--Fire Wave
{1000, 7005},	--Gunpowder fire
{1000, 7012},	--Evil Explosion
{1000, 7015},	--Fiend fire
}
mod.specialFireTypes = {
{mod.FF.Spark.ID, mod.FF.Spark.Var},			--Spark
{mod.FF.Fumegeist.ID, mod.FF.Fumegeist.Var},	--Fumegeist
{mod.FF.Mote.ID, mod.FF.Mote.Var},				--Mote
{mod.FF.Smokin.ID, mod.FF.Smokin.Var},			--Smokin
{mod.FF.Smogger.ID, mod.FF.Smogger.Var},		--Smogger
}
mod.playerFireTypes = {
{1000, 51},
{1000, 52},
{3, 231, mod.ITEM.COLLECTIBLE.MODERN_OUROBOROS}
}
mod.blacklistedFlickerSpirits = {
{33},			--Fires
{965},				--Minecart
{mod.FF.Flickerspirit.ID, mod.FF.Flickerspirit.Var},		--Flickerspirit
{mod.FF.EternalFlickerspirit.ID, mod.FF.EternalFlickerspirit.Var},		--Eternal Flickerspirit
{mod.FF.Viscerspirit.ID, mod.FF.Viscerspirit.Var},      --Viscerspirit
{EntityType.ENTITY_DARK_ESAU},
{EntityType.ENTITY_FROZEN_ENEMY}, --Uranus Frozen Corpses
{mod.FF.Specturn.ID, mod.FF.Specturn.Var},      --Specturn
}
mod.playerobjsFlickerSpirits = {
{35, 1},			--Maw Head
{96}			--Eternal Fly
}
mod.unaffectedFlickerSpirits = {
{35, 10},			--Maw Neck
{216, 10},			--Swinger Neck
mod.ENT("WaitingSpider"),			--Waiting Spider
mod.ENT("WaitingWorm"),			--Waiting Worm
mod.ENT("OffalWait"),		--Waiting Offal
{mod.FF.Drop.ID, mod.FF.Drop.Var},
{mod.FF.Fishface.ID, mod.FF.Fishface.Var, mod.FF.FishfaceWait.Sub},
{mod.FF.Harletwin.ID, mod.FF.Harletwin.Var, mod.FF.HarletwinCord.Sub},
{mod.FF.Effigy.ID, mod.FF.Effigy.Var, mod.FF.EffigyCord.Sub},
{mod.FF.FlaminChain.ID, mod.FF.FlaminChain.Var},
{mod.FF.Madclaw.ID, mod.FF.Madclaw.Var},
FiendFolio.ENT("BucketheadWait"),
}
mod.BlacklistedDeliriumBosses = {
mod.ENT("Gravedigger"),
mod.ENT("Psion"),
mod.ENT("SunVenus"),
mod.ENT("SunEarth"),
mod.ENT("SunNeptune"),
mod.ENT("SunMoon"),
mod.ENT("OrgChaser"),
mod.ENT("OrgBashful"),
mod.ENT("OrgSpeedy"),
mod.ENT("OrgPokey"),
--{980, 80},
mod.ENT("Luncheon"),
}

function mod.GetRoomEntities()
mod.creepSpawnerCount = {0}
mod.countFlies = {}
mod.fireEntities = {}
mod.fireEntitiesFriend = {}
mod.playerPositions = {}
mod.playerVelocities = {}

mod.RoomEntitiesCache = Isaac.GetRoomEntities()

local printStuff = false
if FiendFolio.PrintEnts then
	print("___________________________")
end
	for _,entity in ipairs(mod.RoomEntitiesCache) do
		local etype = entity.Type
		local evar = entity.Variant
		local esub = entity.SubType
		if FiendFolio.PrintEnts then
			print(etype, evar, esub)
		end
		if etype == 1 then
			table.insert(mod.playerPositions, entity)
			table.insert(mod.playerVelocities, entity.Velocity)
			if mod.FiendishEffects then
				local p = entity:ToPlayer()
				if mod.FiendishEffects.RollHealth then
					p:AddMaxHearts(math.random(3) - 2)
					if math.random(3) == 1 then
						p:AddBoneHearts(math.random(3) - 2)
					end
					p:AddHearts(math.random(3) - 2)
					p:AddRottenHearts(math.random(3) - 2)
					if math.random(2) == 1 then
						p:AddSoulHearts(math.random(3) - 2)
					end
					if math.random(2) == 1 then
						p:AddBlackHearts(math.random(3) - 2)
					end
					if math.random(5) == 1 then
						p:AddGoldenHearts(math.random(3) - 2)
					end
					if math.random(5) == 1 then
						p:AddBrokenHearts(math.random(3) - 2)
					end
				end
				if mod.FiendishEffects.RollItems and entity.FrameCount % 5 == 0 then
					player:UseActiveItem(CollectibleType.COLLECTIBLE_D4, false, false, true, false)
				end
				if mod.FiendishEffects.GetSpeedy then
					p.MoveSpeed = p.MoveSpeed + 0.01
				end
				if mod.FiendishEffects.GetShooty then
					p.MaxFireDelay = p.MaxFireDelay - 0.05
				end
				if mod.FiendishEffects.GetHurty then
					p.Damage = p.Damage + 1
				end
				if mod.FiendishEffects.LessHurty then
					p.Damage = p.Damage * 0.99
				end
				if mod.FiendishEffects.GetShootSpeedy then
					p.ShotSpeed = p.ShotSpeed + 0.05
				end
			end
		end
		if etype ~= 1 then
			if mod.FiendishEffects then
				if mod.FiendishEffects.RunRound then
					entity.Velocity = RandomVector():Resized(math.random(50) - 25)
				end
				if mod.FiendishEffects.ZipZoop then
					entity.Velocity = entity.Velocity * -1
				end
				if mod.FiendishEffects.Nyoom then
					entity.Velocity = entity.Velocity * 1.1
				end
				if mod.FiendishEffects.SlowDown then
					entity.Velocity = entity.Velocity * 0.1
				end
				if mod.FiendishEffects.Funny then
					entity.Position = entity.Position + RandomVector()*math.random(100)/10
				end
				if mod.FiendishEffects.Twirly then
					entity.SpriteRotation = entity.SpriteRotation + math.random(100)
				end
				if mod.FiendishEffects.Spunky then
					entity.HitPoints = math.random(100)
				end
				if mod.FiendishEffects.Spindigo then
					grng:SetSeed(entity.InitSeed, 0)
					local rotval = grng:RandomInt(100) - 50
					entity.Velocity = entity.Velocity:Rotated(rotval)
				end
				if mod.FiendishEffects.Homer then
					entity.Velocity = mod:Lerp(entity.Velocity, (Isaac.GetPlayer(0).Position - entity.Position), 0.001)
				end
				if mod.FiendishEffects.Scared then
					entity.Velocity = mod:Lerp(entity.Velocity, (entity.Position - Isaac.GetPlayer(0).Position), 0.001)
				end
				if mod.FiendishEffects.SPEED then
					entity:Update()
				end
				if mod.FiendishEffects.FunnyPickup then
					if etype == 5 or etype == 6 then
						mod:CatheryPathFinding(entity, Isaac.GetPlayer(0).Position, {
							Speed = 2,
							Accel = 0.3
						})
					end
				end
				if mod.FiendishEffects.FunnyProjectiles then
					if etype == 9 or etype == mod.FFID.Tech or (etype == 1000 and evar == 7005) or (etype == 1000 and evar > 21 and evar < 27)then
						mod:CatheryPathFinding(entity, Isaac.GetPlayer(0).Position, {
							Speed = 10,
							Accel = 0.3
						})
					end
				end
				if mod.FiendishEffects.SizeRandomizer then
					entity.SpriteScale = Vector(math.random(100)/50, math.random(100)/50)
				end
				if mod.FiendishEffects.Pendulum then
					grng:SetSeed(entity.InitSeed, 0)
					local rotval = grng:RandomInt(100) - 50
					entity.SpriteRotation = entity.SpriteRotation + (math.sin(entity.FrameCount / 10) * rotval)
				end
				if mod.FiendishEffects.SpeedSpinUp then
					grng:SetSeed(entity.InitSeed, 0)
					local rotval = grng:RandomInt(10) - 5
					rotval = rotval * 1 + (mod.FiendishEffects.SpeedSpinUp)
					entity.SpriteRotation = entity.SpriteRotation + rotval
				end
			end
			--entity.Friction = 1.1
		end
		if etype == 412 then
			mod.IsDeliriumRoom = true
		end
		if etype == mod.FF.Snagger.ID then
			--[[if entity:GetData().batteried then
				entity:Update()
			end]]
		end
		for _,v in ipairs(mod.creepLeavingEnemies) do
			if etype == v[1] and evar == v[2] and not entity:IsDead() then
				table.insert(mod.creepSpawnerCount, entity)
			end
		end
		for _,v in ipairs(mod.customFlies) do
			if not entity:IsDead() then
				if v[2] then
					if etype == v[1] and evar == v[2] then
						table.insert(mod.countFlies, entity)
					end
				else
					if etype == v[1] then
						table.insert(mod.countFlies, entity)
					end
				end
			end
		end
		if etype == 33 and entity.HitPoints > 1 then
			table.insert(mod.fireEntities, entity)
		end
		for _, v in ipairs(mod.fireTypes) do
			if v[3] then
				if v[1] == etype and v[2] == evar and v[3] == esub then
					table.insert(mod.fireEntities, entity)
				end
			elseif v[2] then
				if v[1] == etype and v[2] == evar then
					table.insert(mod.fireEntities, entity)
				end
			elseif v[1] == etype then
				table.insert(mod.fireEntities, entity)
			end
		end
		for _, v in ipairs(mod.specialFireTypes) do
			if v[2] then
				if v[1] == etype and v[2] == evar then
					if entity:GetData().flaming then
						table.insert(mod.fireEntities, entity)
					end
				end
			elseif v[1] == etype then
				if entity:GetData().flaming then
					table.insert(mod.fireEntities, entity)
				end
			end
		end
		for _, v in ipairs(mod.playerFireTypes) do
			if v[3] then
				if v[1] == etype and v[2] == evar and v[3] == esub then
					table.insert(mod.fireEntitiesFriend, entity)
				end
			elseif v[2] then
				if v[1] == etype and v[2] == evar then
					table.insert(mod.fireEntitiesFriend, entity)
				end
			elseif v[1] == etype then
				table.insert(mod.fireEntitiesFriend, entity)
			end
		end
		if mod.FlickerspiritInRoom then
			if entity:IsEnemy() then
				local isgood = true
				for _, v in ipairs(mod.blacklistedFlickerSpirits) do
					if v[2] then if etype == v[1] and evar == v[2] then isgood = false end
					elseif etype == v[1] then isgood = false end
				end
				if isgood then
					local unaffected = false
					for _, v in ipairs(mod.unaffectedFlickerSpirits) do
						if v[3] then if etype == v[1] and evar == v[2] and esub == v[3] then unaffected = true end
						elseif v[2] then if etype == v[1] and evar == v[2] then unaffected = true end
						elseif etype == v[1] then unaffected = true end
					end
					local fs = mod.FindClosestEntity(entity.Position, 150, mod.FF.Flickerspirit.ID, mod.FF.Flickerspirit.Var)
					if fs then
						--entity:SetColor(Color(0.7,8,10,0.05,0,0,0), 1, 1, false, true)
						entity:SetColor(Color(1,1,1,0.15,0,400 / 255,500 / 255), 1, 1, false, true)
						local origcoll
						if not entity:GetData().flickerspirited or entity.EntityCollisionClass ~= EntityCollisionClass.ENTCOLL_PLAYERONLY then
							origcoll = entity.EntityCollisionClass
						end
						if not unaffected then
							entity.EntityCollisionClass = math.min(entity.EntityCollisionClass, EntityCollisionClass.ENTCOLL_PLAYERONLY)
						end
						if origcoll then
							entity:GetData().restoreCollision = origcoll
						end
						entity:GetData().flickerspirited = true
					else
						local d = entity:GetData()
						if unaffected then
							d.flickerspirited = false
						else
							local obj = false
							for _, v in ipairs(mod.playerobjsFlickerSpirits) do
								if v[2] then if etype == v[1] and evar == v[2] then obj = true end
								elseif etype == v[1] then obj = true end
							end
							if obj then
								entity.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS
								d.flickerspirited = false
							end

							if d.flickerspirited then
								if entity:GetData().restoreCollision then
									entity.EntityCollisionClass = entity:GetData().restoreCollision
								end
								d.flickerspirited = false
							end
						end
					end
				end
			end
		end
		if Isaac.GetChallenge() == mod.challenges.dirtyBubble then
			if etype == 9 then
				local entity = entity:ToProjectile()
				local ef = entity.ProjectileFlags
				if ef == ef | ProjectileFlags.SMART then
					mod.ShootBubble(entity, 4, entity.Position, entity.Velocity * 0.4)
				elseif ef == ef | ProjectileFlags.EXPLODE then
					mod.ShootBubble(entity, 6, entity.Position, entity.Velocity * 0.4)
				else
					mod.ShootBubble(entity, nil, entity.Position, entity.Velocity * 0.4)
				end
				entity:Remove()
			elseif etype == 1000 and evar == 7005 then
				mod.ShootBubble(entity, 6, entity.Position, entity.Velocity * 0.2)
				entity:Remove()
			end
		end
	end
	if #mod.creepSpawnerCount == 0 then
		mod.creepSpawnerCount = {0}
	end
end

function mod.PlayFlySound()
	local lightning_fly_counter = 0

	if #mod.countFlies > 0 and not sfx:IsPlaying(mod.Sounds.InsectSwarmLoop) then
		sfx:Play(mod.Sounds.InsectSwarmLoop, 0.3, 0, true, 1)
	elseif #mod.countFlies == 0 then
		sfx:Stop(mod.Sounds.InsectSwarmLoop)
	end

	--[[for _,fly in pairs(mod.countFlies) do
		if fly.Type == 970 and fly.Variant == Isaac.GetEntityVariantByName("Lightning Fly") and fly:GetData().state == "charged" then
			lightning_fly_counter = lightning_fly_counter + 1
		end
	end

	if lightning_fly_counter > 0 and not sfx:IsPlaying(mod.Sounds.LightningFlyBuzzLoop) then
		sfx:Play(mod.Sounds.LightningFlyBuzzLoop, 0.5, 0, true, 1)
	elseif lightning_fly_counter == 0 then
		sfx:Stop(mod.Sounds.LightningFlyBuzzLoop)
	end]]
end

--[[function mod:OnTearUpdate(v)
--Isaac.ConsoleOutput(tear.Velocity:GetAngleDegrees() .. "\n")
print("Var:" .. v.Variant .. " ")
print("R:" .. v.Color.R .. " ")
print("G:" .. v.Color.G .. " ")
print("B:" .. v.Color.B .. " ")
print("A:" .. v.Color.A .. " ")
print("RO:" .. v.Color.RO .. " ")
print("GO:" .. v.Color.GO .. " ")
print("BO:" .. v.Color.BO .. "\n")
end
mod:AddCallback(ModCallbacks.MC_POST_PROJECTILE_UPDATE, mod.OnTearUpdate)]]

function mod.SuperEasyModeFun()
	if mod.ModeEnabled == 2 then
		local room = game:GetRoom()
		if room:GetType() == RoomType.ROOM_BOSS then
			if room:IsClear() then
				local size = room:GetGridSize()
				for i=0, size do
					local gridEntity = room:GetGridEntity(i)
					if gridEntity then
						local desc = gridEntity.Desc.Type
						if gridEntity.Desc.Type == GridEntityType.GRID_TRAPDOOR then
							local gridpos = room:GetGridPosition(i)
							Isaac.Spawn(5, 370, 0, gridpos, nilvector, nil)
							Isaac.GridSpawn(1, 0, gridpos, true)
						end
					end
				end
			end
		end
	end
end

function mod.spawnPersistents()
	local room = game:GetRoom()
	if room:IsClear() and not room:IsFirstVisit() then
		if mod.persistentTable then
			if #mod.persistentTable > 0 then
				--Isaac.ConsoleOutput(mod.persistentTable[1].Type .. mod.persistentTable[1].Variant)
				if room:IsClear() then
					--Isaac.ConsoleOutput("spawning")
					for _, entity in ipairs(mod.persistentTable) do
						local ent = Isaac.Spawn(entity.Type, entity.Variant, entity.SubType, entity.Position, nilvector, nil)
						--if entity.DontClearAppear then
							ent:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
						--end
						ent:Update()
					end
				end
			end
			mod.persistentTable = {}
		end
	else
		mod.persistentTable = {}
	end
end

function mod.challengeDadsHomePlus()
	if Isaac.GetChallenge() == mod.challenges.dadsHomePlus then
		local sd = FiendFolio.savedata.run
		local room = game:GetRoom()
		sd.challengeDadsHomePlusTable = sd.challengeDadsHomePlusTable or {}
		if #sd.challengeDadsHomePlusTable > 0 then
			for _,entity in ipairs(sd.challengeDadsHomePlusTable) do
				Isaac.Spawn(entity.Type, entity.Variant, entity.SubType, room:FindFreePickupSpawnPosition(room:GetCenterPos(), 40, true), nilvector, nil)
			end
		end
		if room:IsFirstVisit() then
			sd.challengeDadsHomePlusTable = {}
			for _,entity in ipairs(Isaac.GetRoomEntities()) do
				if entity:IsEnemy() then
					local blacklisted
					if entity.Type == 33 then
						blacklisted = true
					elseif entity.Type == 62 and entity.Parent then
						blacklisted = true
					elseif entity.Type == 13 and entity.SubType == 250 then
						blacklisted = true
					elseif entity.Type == 79 and entity.Variant == 20 then
						blacklisted = true
					elseif entity.Type == 281 and entity.Parent then
						blacklisted = true
					end
					if not blacklisted then
						table.insert(sd.challengeDadsHomePlusTable, {Type = entity.Type, Variant = entity.Variant, SubType = entity.SubType})
					end
				end
			end
		end
	end
end

function mod.challengeTheRealJon()
	if Isaac.GetChallenge() == mod.challenges.theRealJon then
		local jons = {}
		for _,entity in ipairs(Isaac.FindByType(mod.FF.LilJon.ID, mod.FF.LilJon.Var, 1, false, false)) do
			table.insert(jons, entity)
		end
		if #jons < 1 then
			local entity = Isaac.Spawn(mod.FF.LilJon.ID, mod.FF.LilJon.Var, 1, Game():GetRoom():GetCenterPos(), nilvector, nil)
		end
	end
end

--DO NOT UNCOMMENT OUT REPETE!! playtesters complained about sickness and "black spots" after playing the game. someone please test it, i'm really busy
--[[function mod.challengeRePete()
	if Isaac.GetChallenge() == mod.challenges.RePete then
		if not mod.ActivatedPete then
			--First checks player (actual) location

			local realPos = game:ScreenToRealPos(Vector(10, 0))
			local searchRadius = 250 * 10 --based on average house size
			local playerDiscovered = false
			for _, player in pairs(Isaac.GetRealPlayers(realPos, searchRadius))) do
				--on location discovery
				if player and player:Exists() then
					--Just being cheeky and using the discovered player as the bool
					playerDiscovered = player
					break
				end
			end

			if playerDiscovered then
				local moveVec = playerDiscovered.Position - game:ScreenToRealPos(room:GetCenterPos()):Resized(10)
				local pete = Isaac.Spawn(mod.FF.realPete.Type, mod.FF.realPete.Variant, playerDiscovered.SubType, playerDiscovered.Position, moveVec, nil):ToReal()
				pete:Activate()
				pete:Update()
				mod.ActivatedPete = true
			end
		end
	end
end]]

mod:AddCallback(ModCallbacks.MC_PRE_SPAWN_CLEAN_AWARD, function(_, dropRNG, spawnPos)
	local room = game:GetRoom()
	spawnPos = room:FindFreePickupSpawnPosition(spawnPos, 10, true)
	--ROOM COMPLETION ITEMS
	--Dice Bag
	for _, d in pairs(Isaac.FindByType(3, FamiliarVariant.DICE_BAG, -1, false, false)) do
		local data = d:GetData()
		if not data.rooms then data.rooms = 0 end
		data.rooms = data.rooms + 1
	end
	mod:erflyPreSpawnAward(spawnPos, dropRNG)

	--ROOM REWARDS
	--Skip Card
	if mod.SkipCardUsed then
		mod.SkipCardUsed = nil
		if room:IsCurrentRoomLastBoss() then
			Isaac.GridSpawn(GridEntityType.GRID_TRAPDOOR, 0, spawnPos, true)
		end
		return true
	end

	local roomtype = room:GetType()
	if roomtype == RoomType.ROOM_DEFAULT then
		--Balanced Fossil
		local balancedFossil = nil
		for i=1, game:GetNumPlayers() do
			local p = Isaac.GetPlayer(i - 1)

			if p:HasTrinket(FiendFolio.ITEM.ROCK.BALANCED_FOSSIL) then
				local rng = p:GetTrinketRNG(FiendFolio.ITEM.ROCK.BALANCED_FOSSIL)
				local mult = math.min(0,math.floor(mod.GetGolemTrinketPower(p, FiendFolio.ITEM.ROCK.BALANCED_FOSSIL))-1)
				if rng:RandomInt(2) == 0 then
					if p:GetNumKeys() == 0+mult then
						balancedFossil = "key"
					elseif p:GetNumBombs() == 0+mult then
						balancedFossil = "bomb"
					elseif p:GetNumCoins() < 5+mult then
						balancedFossil = "coin"
					elseif p:GetHearts() < p:GetMaxHearts()/2 then
						balancedFossil = "heart"
					end
				end
			end
		end

		if balancedFossil then
			if balancedFossil == "key" then
				Isaac.Spawn(5, 30, 0, spawnPos, nilvector, nil)
			elseif balancedFossil == "bomb" then
				Isaac.Spawn(5, 40, 0, spawnPos, nilvector, nil)
			elseif balancedFossil == "coin" then
				Isaac.Spawn(5, 20, 0, spawnPos, nilvector, nil)
			elseif balancedFossil == "heart" then
				Isaac.Spawn(5, 10, 1, spawnPos, nilvector, nil)
			end
			Isaac.Spawn(1000, 15, 0, spawnPos, nilvector, nil)
			sfx:Play(SoundEffect.SOUND_SUMMONSOUND, 0.7, 0, false, 1)
			return true
		end

		--IOU
		local spawntrinket = false
		for i = 1, game:GetNumPlayers() do
			local p = Isaac.GetPlayer(i - 1)
			if p:HasTrinket(TrinketType.TRINKET_IOU) then
				local playerChance = dropRNG:RandomInt(100)
				local startval = math.max(30, 100 - 50 * (p:GetTrinketMultiplier(TrinketType.TRINKET_IOU) - 1))
				--print(startval - playerChance)
				if startval - playerChance < math.max(math.min(15 + p.Luck * 2.5, 90), 5) then
					spawntrinket = true
				end
			end
		end

		if spawntrinket then
			local trinkydinky = Isaac.Spawn(5, 350, 0, spawnPos, nilvector, nil)
			return true
		end

		--Fool's Gold
		local spawnfool = false
		for i = 1, game:GetNumPlayers() do
			local p = Isaac.GetPlayer(i - 1)
			if p:HasTrinket(TrinketType.TRINKET_FOOLS_GOLD) then
				local startval = 15 - 5 * (p:GetTrinketMultiplier(TrinketType.TRINKET_FOOLS_GOLD) - 1)
				local randnum = math.floor(startval - p.Luck)
				local rand = dropRNG:RandomInt(math.max(randnum, 1))
				if rand == 0 then
					spawnfool = true
				end
			end
		end

		if spawnfool then
			local funnypenny = Isaac.Spawn(5, 20, CoinSubType.COIN_CURSEDPENNY, spawnPos, nilvector, nil)
			return true
		end

		if mod.anyPlayerHas(CollectibleType.COLLECTIBLE_EVIL_STICKER) then
			local rand = dropRNG:RandomInt(13)
			if rand == 0 then
				local rand2 = dropRNG:RandomInt(100)
				--1% Golden Troll Bomb
				if rand2 < 1 then
					local spawn = Isaac.Spawn(5, PickupVariant.PICKUP_DIRE_CHEST, 0, spawnPos, nilvector, nil)
					return true
				--10% Dire Chest
				elseif rand2 < 11 then
					local spawn = Isaac.Spawn(5, PickupVariant.PICKUP_DIRE_CHEST, 0, spawnPos, nilvector, nil)
					return true
				--13% Spicy Key
				elseif rand2 < 24 then
					local spawn = Isaac.Spawn(5, 30, KeySubType.KEY_SPICY_PERM, spawnPos, nilvector, nil)
					return true
				--13% Immoral Heart
				elseif rand2 < 37 then
					local spawn = Isaac.Spawn(5, PickupVariant.PICKUP_IMMORAL_HEART, 0, spawnPos, nilvector, nil)
					return true
				--13% Copper Bomb
				elseif rand2 < 50 then
					local spawn = Isaac.Spawn(5, PickupVariant.PICKUP_BOMB, FiendFolio.PICKUP.BOMB.COPPER, spawnPos, nilvector, nil)
					return true
				--50% Cursed Penny
				else
					local spawn = Isaac.Spawn(5, 20, CoinSubType.COIN_CURSEDPENNY, spawnPos, nilvector, nil)
					return true
				end
			end
		end

		local totalTrollChance = 0
		mod.AnyPlayerDo(function(player)
			if player:HasTrinket(FiendFolio.ITEM.ROCK.TROLLITE) then
				local trinketPower = FiendFolio.GetGolemTrinketPower(player, FiendFolio.ITEM.ROCK.TROLLITE)
				totalTrollChance = totalTrollChance + 10 * trinketPower
			end
		end)
		totalTrollChance = math.ceil(totalTrollChance)
		if totalTrollChance > 0 then
			if grng:RandomInt(100) < totalTrollChance then
				local rand = grng:RandomInt(20)
				if rand == 0 then
					local spawn = Isaac.Spawn(4, 18, 0, spawnPos, nilvector, nil)
					return true
				elseif rand < 5 then
					local spawn = Isaac.Spawn(4, 4, 0, spawnPos, nilvector, nil)
					return true
				else
					local spawn = Isaac.Spawn(4, 3, 0, spawnPos, nilvector, nil)
					return true
				end
			end
		end

		--Faulty Fuse
		local spawnfool = false
		local trinkyPower = mod.getTrinketMultiplierAcrossAllPlayers(FiendFolio.ITEM.TRINKET.FAULTY_FUSE)

		local chance = (0.05 * trinkyPower)
		if dropRNG:RandomFloat() < chance then
			local spawn = Isaac.Spawn(EntityType.ENTITY_PICKUP, PickupVariant.PICKUP_BOMB, FiendFolio.PICKUP.BOMB.COPPER, spawnPos, nilvector, nil)
			return true
		end

		--Energy searcher
		local spawnfool = false
		local trinkyPower = mod.getTrinketMultiplierAcrossAllPlayers(FiendFolio.ITEM.TRINKET.ENERGY_SEARCHER)

		local chance = (0.05 * trinkyPower)
		if dropRNG:RandomFloat() < chance then
			local spawn = Isaac.Spawn(5, 302, 2, spawnPos, nilvector, nil)
			return true
		end
	end
end)

local function areAllBossesGone()
	if game:GetRoom():GetAliveBossesCount() ~= 0 then
		return false
	end

	for _, entity in ipairs(Isaac.GetRoomEntities()) do
		if entity:IsBoss() then
			return false
		end
	end

	return true
end

function mod.MusicLogic()
	if StageAPI.InNewStage() then return end
	local currentRoom = StageAPI.GetCurrentRoom()
	local isFFBoss
	local bossData
	if currentRoom and currentRoom.PersistentData.BossID then
		bossData = StageAPI.GetBossData(currentRoom.PersistentData.BossID)
		if bossData and bossData.IsFFBoss then
			isFFBoss = true
		end
	end

	if isFFBoss then
		local mm = MusicManager()
		local musicId = mm:GetCurrentMusicID()
		local stageType = Game():GetLevel():GetStageType()

		local newId = nil
		local queueMaize
		if musicId == Music.MUSIC_BOSS or musicId == Music.MUSIC_BOSS2 or musicId == Music.MUSIC_BOSS3 then
			if bossData.Horseman then
				newId = FiendFolio.Music.HorsemanTheme
			elseif stageType == StageType.STAGETYPE_REPENTANCE or stageType == StageType.STAGETYPE_REPENTANCE_B then
				newId = FiendFolio.Music.AltBossTheme
			else
				newId = FiendFolio.Music.BossTheme
			end
		elseif musicId == Music.MUSIC_JINGLE_BOSS then
			if bossData.Horseman then
				newId = FiendFolio.Music.HorsemanAppear
			elseif stageType == StageType.STAGETYPE_REPENTANCE or stageType == StageType.STAGETYPE_REPENTANCE_B then
				newId = FiendFolio.Music.AltBossAppear
			else
				newId = FiendFolio.Music.BossAppear
			end
		elseif musicId == Music.MUSIC_JINGLE_BOSS_OVER or musicId == Music.MUSIC_JINGLE_BOSS_OVER2 or musicId == Music.MUSIC_JINGLE_BOSS_OVER3
		or ((musicId == FiendFolio.Music.HorsemanTheme or musicId == FiendFolio.Music.AltBossTheme or musicId == FiendFolio.Music.BossTheme) and areAllBossesGone()) then
			if bossData.Horseman then
				newId = FiendFolio.Music.HorsemanOverJingle
			elseif stageType == StageType.STAGETYPE_REPENTANCE or stageType == StageType.STAGETYPE_REPENTANCE_B then
				newId = FiendFolio.Music.AltBossOverJingle
			else
				newId = FiendFolio.Music.BossOverJingle
			end
			queueMaize = true
		elseif musicId == Music.MUSIC_BOSS_OVER then
			newId = FiendFolio.Music.BossOver
		end

		if newId then
			mm:Play(newId, 0)
			mm:UpdateVolume()
			if queueMaize then
				mm:Queue(FiendFolio.Music.BossOver)
			end
		end
	elseif (not mod.crawlspaceMoosicks) then
		local newId = nil
		local room = Game():GetRoom()
		local mm = MusicManager()
		local musicId = mm:GetCurrentMusicID()
		local backid = room:GetBackdropType()
		if backid == 29 then
			if  musicID ~= FiendFolio.Music.CrawlSpace then
				newId = FiendFolio.Music.CrawlSpace
			end
		elseif room:GetType() == RoomType.ROOM_BLACK_MARKET then
			if musicID ~= FiendFolio.Music.BlackMarket then
				newId = FiendFolio.Music.BlackMarket
			end
		end

		if newId then
			mm:Play(newId, 0)
			mm:UpdateVolume()
		end
		mod.crawlspaceMoosicks = true
	end
end

mod.fiendCheat = {
Keyboard.KEY_S, Keyboard.KEY_E, Keyboard.KEY_C, Keyboard.KEY_R, Keyboard.KEY_E, Keyboard.KEY_T,
}

function mod:cheatCodeLogic(player, ci)
	if mod.cheatModeOn then return end
	local data = player:GetData()
	local inputFrames = 7

	data.fiendCheat = data.fiendCheat or {}
	data.fiendCheat.LastKeyPressed = data.fiendCheat.LastKeyPressed or 0

	if data.fiendCheat.LastTimePressed and player.FrameCount > data.fiendCheat.LastTimePressed + inputFrames then
		data.fiendCheat.LastTimePressed = nil
		data.fiendCheat.LastKeyPressed = 0
	end

	if data.fiendCheat.LastKeyPressed > #mod.fiendCheat - 1 then data.fiendCheat.LastKeyPressed = #mod.fiendCheat - 1 end

	if mod.AnyKeyboardTriggered(mod.fiendCheat[data.fiendCheat.LastKeyPressed + 1], ci) then

		local frame = player.FrameCount
		local dropFrame = data.fiendCheat.LastTimePressed

		data.fiendCheat.LastTimePressed = frame
		data.fiendCheat.LastKeyPressed = data.fiendCheat.LastKeyPressed + 1

		if dropFrame and frame - dropFrame <= inputFrames then
			if data.fiendCheat.LastKeyPressed == #mod.fiendCheat then
				Isaac.ConsoleOutput("Fiend has found your password\n")
				sfx:Play(mod.Sounds.FiendFolioBook, 1, 0, false, 1)
				mod.Fiendish = true
				mod.cheatModeOn = true
				data.fiendCheat.LastTimePressed = nil
				data.fiendCheat.LastKeyPressed = nil
			end
		elseif dropFrame and frame - dropFrame > inputFrames then
			data.fiendCheat.LastTimePressed = nil
			data.fiendCheat.LastKeyPressed = nil
		end
	end
end

mod.ValidFunnyKeys = {
	{Keyboard.KEY_SPACE, "Space"},
	{Keyboard.KEY_TAB, "Tab"},
	{Keyboard.KEY_ENTER, "Enter"},
	{Keyboard.KEY_RIGHT, "Right Arrow"},
	{Keyboard.KEY_LEFT, "Left Arrow"},
	{Keyboard.KEY_DOWN, "Down Arrow"},
	{Keyboard.KEY_UP, "Up Arrow"},
	{Keyboard.KEY_LEFT_CONTROL, "Left Control"},
	{Keyboard.KEY_LEFT_SHIFT, "Left Shift"},
	{Keyboard.KEY_0, "0"},
	{Keyboard.KEY_1, "1"},
	{Keyboard.KEY_2, "2"},
	{Keyboard.KEY_3, "3"},
	{Keyboard.KEY_4, "4"},
	{Keyboard.KEY_5, "5"},
	{Keyboard.KEY_6, "6"},
	{Keyboard.KEY_7, "7"},
	{Keyboard.KEY_8, "8"},
	{Keyboard.KEY_9, "9"},
	{Keyboard.KEY_A, "A"},
	{Keyboard.KEY_B, "B"},
	{Keyboard.KEY_C, "C"},
	{Keyboard.KEY_D, "D"},
	{Keyboard.KEY_E, "E"},
	{Keyboard.KEY_F, "F"},
	{Keyboard.KEY_G, "G"},
	{Keyboard.KEY_H, "H"},
	{Keyboard.KEY_I, "I"},
	{Keyboard.KEY_J, "J"},
	{Keyboard.KEY_K, "K"},
	{Keyboard.KEY_L, "L"},
	{Keyboard.KEY_M, "M"},
	{Keyboard.KEY_N, "N"},
	{Keyboard.KEY_O, "O"},
	{Keyboard.KEY_Q, "Q"},
	{Keyboard.KEY_R, "R"},
	{Keyboard.KEY_S, "S"},
	{Keyboard.KEY_T, "T"},
	{Keyboard.KEY_U, "U"},
	{Keyboard.KEY_V, "V"},
	{Keyboard.KEY_W, "W"},
	{Keyboard.KEY_X, "X"},
	{Keyboard.KEY_Y, "Y"},
	{Keyboard.KEY_Z, "Z"},
}
mod.ValidFunnyActions = {
	{ButtonAction.ACTION_LEFT, "Move left"},
	{ButtonAction.ACTION_RIGHT, "Move right"},
	{ButtonAction.ACTION_UP, "Move up"},
	{ButtonAction.ACTION_DOWN, "Move down"},
	{ButtonAction.ACTION_SHOOTLEFT, "Shoot left"},
	{ButtonAction.ACTION_SHOOTRIGHT, "Shoot right"},
	{ButtonAction.ACTION_SHOOTUP, "Shoot up"},
	{ButtonAction.ACTION_SHOOTDOWN, "Shoot down"},
	{ButtonAction.ACTION_BOMB, "Place a bomb"},
	{ButtonAction.ACTION_ITEM, "Use your active item"},
	{ButtonAction.ACTION_PILLCARD, "Use your pill or card"},
}

function mod:pressKeyOrDieLogic(player, ci)
	if mod.FiendishKeyToPress then
		local key = mod.ValidFunnyKeys[mod.FiendishKeyToPress][1]
		if mod.AnyKeyboardTriggered(key, ci) then
			mod.FiendishKeyToPress = nil
			mod.FiendishKeyTimer = nil
		end
	end
end
function mod:doActionOrDieLogic(player, ci)
	if mod.FiendishActionToDo then
		local key = mod.ValidFunnyActions[mod.FiendishActionToDo][1]
		if Input.IsActionPressed(key, ci) then
			mod.FiendishActionToDo = nil
			mod.FiendishKeyTimer = nil
		end
	end
end

mod:AddCallback(ModCallbacks.MC_POST_RENDER, function()
	if mod.FiendishKeyToPress then
		local key = mod.ValidFunnyKeys[mod.FiendishKeyToPress][2]
		mod.FiendishKeyTimer = mod.FiendishKeyTimer - 1
		local secondTimer = math.ceil(mod.FiendishKeyTimer / 60)
		local secondString = "s"
		if secondTimer == 1 then
			secondString = ""
		end
		Isaac.RenderText("Press " .. key .. " key in " .. secondTimer .. " second" .. secondString .. " or die!",  100, 78, 255, 255, 255, 1)
		if mod.FiendishKeyTimer < 1 then
			Isaac.GetPlayer():Kill()
			mod.FiendishKeyToPress = nil
			mod.FiendishKeyTimer = nil
		end
	elseif mod.FiendishActionToDo then
		local key = mod.ValidFunnyActions[mod.FiendishActionToDo][2]
		mod.FiendishKeyTimer = mod.FiendishKeyTimer - 1
		local secondTimer = math.ceil(mod.FiendishKeyTimer / 60)
		local secondString = "s"
		if secondTimer == 1 then
			secondString = ""
		end
		Isaac.RenderText(key .. " in " .. secondTimer .. " second" .. secondString .. " or die!",  100, 78, 255, 255, 255, 1)
		if mod.FiendishKeyTimer < 1 then
			Isaac.GetPlayer():Kill()
			mod.FiendishActionToDo = nil
			mod.FiendishKeyTimer = nil
		end
	end
end)

function mod.PressButtonLogic()
	if game:IsPaused() then return end
	local player = Isaac.GetPlayer(0):ToPlayer()
	local ci = player.ControllerIndex
	mod:cheatCodeLogic(player, ci)
	mod:frogmodeLogic(player, ci)
	mod:pressKeyOrDieLogic(player, ci)
	mod:doActionOrDieLogic(player, ci)
	mod:erflyPressButtonLogic(player, ci)
end

function mod:OnRender()
	mod.MusicLogic()
	mod.PressButtonLogic()

	if sfx:IsPlaying(mod.Sounds.FiendHurt) or sfx:IsPlaying(mod.Sounds.BiendHurt) or sfx:IsPlaying(mod.Sounds.GolemHurt) then
		sfx:Stop(SoundEffect.SOUND_ISAAC_HURT_GRUNT)
	end
end
mod:AddCallback(ModCallbacks.MC_POST_RENDER, mod.OnRender)

function FiendFolio.GetCorrectedFiringInput(p)
	if p:HasCollectible(CollectibleType.COLLECTIBLE_ANALOG_STICK) then
		return p:GetShootingInput()
	else
		return dirToVec[p:GetFireDirection()]
	end
end

function mod.debugToolLogic()
	if mod.motherFollowing then
		if mod.GetEntityCount(mod.FF.MotherOrb.ID, mod.FF.MotherOrb.Var) < 1 then
			local room = game:GetRoom()
			local targ = room:GetCenterPos()
			local player = mod.FindClosestEntity(1, 80)
			if player and player.Distance(targ.Position) < 80 then
				targ = player.Position + Vector(0, -80)
			end
			local mother = Isaac.Spawn(mod.FF.MotherOrb.ID, mod.FF.MotherOrb.Var, 0, targ, nilvector, nil)
			mother:GetData().DingCount = 5
			mother.CollisionDamage = 100
			mother.Color = Color(0, 0, 0, 1, 0, 0, 0)
			mother:AddEntityFlags(EntityFlag.FLAG_PERSISTENT)
			mother:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
			mother:Update()
		end
	end
end

function mod:grabberChallenge()
	if Isaac.GetChallenge() == mod.challenges.handsOn and not sfx:IsPlaying(mod.Sounds.ClapSong) then
		sfx:Play(mod.Sounds.ClapSong, 2, 0, false, 1)
		MusicManager():Pause()
		MusicManager():Disable()
	end
end

mod:AddCallback(ModCallbacks.MC_PRE_GAME_EXIT, function()
	if sfx:IsPlaying(mod.Sounds.ClapSong) then
		sfx:Stop(mod.Sounds.ClapSong)
	end
end)

function mod:OnUpdate()
	mod.GetRoomEntities()
	mod.PlayFlySound()
	mod.RoomGridPath = mod:GetRoomGridPath()
	mod.smokingMulliganExplosionHandling()
	mod.graterGratesLogic()
	mod.SuperEasyModeFun()
	mod.ThousandEyesLogic()
	mod.fiendishLogic()
	mod.spookLogic()
	mod.debugToolLogic()
	mod.nukePathLogic()
	--mod.grabberChallenge()
	mod.bullMatador()
	mod.instantPickups()
	mod:erflyOnUpdate()
	mod:customHitboxFrozenChecks()

	math.randomseed(Isaac.GetTime())
end
mod:AddCallback(ModCallbacks.MC_POST_UPDATE, mod.OnUpdate)

function mod.stopLoopingSounds()
	--[[sfx:Stop(SoundEffect.SOUND_ULTRA_GREED_SPINNING)
	sfx:Stop(mod.Sounds.FriedLoop)
	sfx:Stop(mod.Sounds.CrosseyeShootLoop)
	sfx:Stop(mod.Sounds.PsionRedirectLoop)
	sfx:Stop(mod.Sounds.TapLoop)
	sfx:Stop(mod.Sounds.TapHoney02)
	sfx:Stop(mod.Sounds.SteamTrain)
	sfx:Stop(mod.Sounds.RolyPolyRoll)]]
	sfx:StopLoopingSounds() --I didn't realise this function existed my god
end

function mod.gbfLogic()
	if FiendFolio.savedata.sawGBFBefore then return end
	if mod.sawGBF then
		mod.sawGBF = mod.sawGBF + 1
		if mod.sawGBF == 15 then
			sfx:Play(mod.Sounds.gbf, 0.5, 0, false, 1)
			mod.sawGBF = false
			FiendFolio.savedata.sawGBFBefore = true
		end
	end
end

function mod:resetCertainFamiliars()
	for _, randy in pairs(Isaac.FindByType(3, FamiliarVariant.RANDY_THE_SNAIL, -1, false, false)) do
		randy:GetData().init = nil
		randy:Update()
	end
	for _, psihelper in pairs(Isaac.FindByType(mod.FF.Psihunter.ID, mod.FF.Psihunter.Var, 10, false, false)) do
		psihelper.Position = Isaac.GetPlayer(0).Position
	end
	for _, peachcreep in pairs(Isaac.FindByType(3, FamiliarVariant.PEACH_CREEP, -1, false, false)) do
		peachcreep.Position = Isaac.GetPlayer(0).Position
		peachcreep:GetData().init = nil
	end
	for _, gorgon in pairs(Isaac.FindByType(3, FamiliarVariant.GORGON, -1, false, false)) do
		gorgon:GetData().init = nil
		gorgon:Update()
	end
	for _, rock in pairs(Isaac.FindByType(3, FamiliarVariant.PETROCK, -1, false, false)) do
		rock:GetData().init = nil
		--rock:GetData().face = nil
		rock:Update()
	end
	for _, snake in pairs(Isaac.FindByType(3, FamiliarVariant.OPHIUCHUS, -1, false, false)) do
		snake.Position = mod:FindNearbyDoor(snake:ToFamiliar().Player.Position, true)
		snake:GetData().init = nil
		snake:Update()
	end
	for _, hand in pairs(Isaac.FindByType(3, mod.ITEM.FAMILIAR.REDHAND, -1, false, false)) do
		hand:GetData().init = nil
		hand:Update()
	end
	for _, peeve in pairs(Isaac.FindByType(3, mod.ITEM.FAMILIAR.PET_PEEVE, -1, false, false)) do
		peeve:GetData().init = nil
	end
	for _, ffbookhelp in pairs(Isaac.FindByType(3, FamiliarVariant.FF_BOOK_HELPER, -1, false, false)) do
		ffbookhelp:Remove()
	end
end

function mod:removeDireChests()
	for _, pickup in pairs(Isaac.FindByType(5, 712, 1, false, false)) do
		if pickup.SubType == 1 then
			pickup:Remove()
		end
	end
end

function mod:moveToCentreForCertainBosses()
	local room = game:GetRoom()
	if room:GetType() == RoomType.ROOM_BOSS
	and (
		  #Isaac.FindByType(mod.FF.SunBody.ID, mod.FF.SunBody.Var, -1, false, false)
		+ #Isaac.FindByType(mod.FF.Luncheon.ID, mod.FF.Luncheon.Var, -1, false, false)
		+ #Isaac.FindByType(mod.FF.Dusk.ID, mod.FF.Dusk.Var, -1, false, false)
		+ #Isaac.FindByType(mod.FF.WarpZone.ID, mod.FF.WarpZone.Var, -1, false, false)
		+ #Isaac.FindByType(mod.FF.Junkstrap.ID, mod.FF.Junkstrap.Var, -1, false, false)
	) > 0 then
		local room = Game():GetRoom()
		local spawnpos = room:FindFreePickupSpawnPosition(room:GetCenterPos() + Vector(0,80), 1, true)
		for _,player in ipairs(Isaac.FindByType(1, -1, -1, EntityPartition.PLAYER, true)) do
			player.Position = spawnpos
		end
	end
end

mod.ModernHorsemanFleas = {
[1] = TrinketType.TRINKET_FLEA_MELTDOWN,
[2] = TrinketType.TRINKET_FLEA_DELUGE,
[3] = TrinketType.TRINKET_FLEA_POLLUTION,
[4] = TrinketType.TRINKET_FLEA_PROPAGANDA,
}

function mod:fleaSpawnLogic()
	local room = game:GetRoom()
	if room:IsFirstVisit() and not room:IsClear() then
		for i = 1, game:GetNumPlayers() do
			local p = Isaac.GetPlayer(i - 1)
			for j = 1, 4 do
				if p:HasTrinket(mod.ModernHorsemanFleas[j]) then
					local repeatTimes = p:GetTrinketMultiplier(mod.ModernHorsemanFleas[j])
					for k = 1, repeatTimes do
						local randVec = RandomVector() * math.random(5,15)
						Isaac.Spawn(3, FamiliarVariant.ATTACK_SKUZZ, j, p.Position + randVec, nilvector, p)
					end
				end
			end
			--Just doing this in here too since it's easier
			if p:HasTrinket(TrinketType.TRINKET_CHUNK_OF_TAR) then
				local repeatTimes = 3 + 2 * (p:GetTrinketMultiplier(TrinketType.TRINKET_CHUNK_OF_TAR) - 1)
				for k = 1, repeatTimes do
					local randVec = RandomVector() * math.random(5,15)
					local blot = Isaac.Spawn(mod.FF.Blot.ID, mod.FF.Blot.Var, 0, p.Position + randVec, nilvector, p)
					blot:AddEntityFlags(EntityFlag.FLAG_CHARM)
					blot:AddEntityFlags(EntityFlag.FLAG_FRIENDLY)
					blot:AddEntityFlags(EntityFlag.FLAG_PERSISTENT)
					blot.Color = Color(1.5,1.5,1.5,1)
					blot:Update()
				end
			end
		end
	end
end

function mod:cirnoTime()
	local room = game:GetRoom()
	if not room:IsClear() then
		if mod.anyPlayerHas(CollectibleType.COLLECTIBLE_CHIRUMIRU) then
			mod.scheduleForUpdate(function()
				for _, entity in pairs(Isaac.FindInRadius(Isaac.GetPlayer(0).Position, 9999, EntityPartition.ENEMY)) do
					entity:AddFreeze(EntityRef(Isaac.GetPlayer(0)), 27)
				end
			end, 1, nil, true)
			for i = 1, game:GetNumPlayers() do
				local player = Isaac.GetPlayer(i - 1):ToPlayer()
				if player:HasCollectible(CollectibleType.COLLECTIBLE_CHIRUMIRU) then
					local pulse = Isaac.Spawn(1000, 1960, 20, player.Position, nilvector, player)
					pulse.Color = Color(1,1,1,0.1,0,0,0)
					pulse:Update()
				end
			end
		end
	end
end

function mod:instantPickups()
--Honey Penny
 for i = 1, game:GetNumPlayers() do
	local player = Isaac.GetPlayer(i - 1)
	local data = player:GetData()
	if data.HoneyPenny == true then
		if player.FrameCount % (#mod.creepSpawnerCount * 4 - 1) == 1 then
		 local honeycolor = Color(1,1,1,1,0,0,0)
		 honeycolor:SetColorize(5.5, 3.5, 1, 1)
		 local creepSlowEnt = Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.PLAYER_CREEP_BLACK, 0, player.Position, Vector(0,0), player);
		 local creepSlow = creepSlowEnt:ToEffect()
		 creepSlowEnt.Visible = false
		 creepSlow.SpriteScale = Vector(0.4, 0.4)
		 creepSlow:SetTimeout(30)
		 local creepHoneyEnt = Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.PLAYER_CREEP_RED, 0, player.Position, Vector(0,0), player);
		 local creepHoney = creepHoneyEnt:ToEffect()
		 creepHoneyEnt.CollisionDamage = 0
		 creepHoneyEnt:SetColor(honeycolor,99999, 1, false, false)
		 creepHoney.SpriteScale = Vector(0.2, 0.2)
		 creepHoney:SetTimeout(30)
		 creepHoney:Update()
		end
	 data.HoneyPennyTimer = data.HoneyPennyTimer-1
	 if data.HoneyPennyTimer <= 0 then
	  data.HoneyPenny = nil
	  data.HoneyPennyTimer = nil
	 end
	end

 end
end


mod:AddCallback(ModCallbacks.MC_POST_EFFECT_UPDATE, function(_, eff)
	if eff.SubType == 960 then
		eff.Color = Color(1,1,1,eff:GetData().opacity)
	elseif eff.SubType == 961 then
		local opacityAmount = eff:GetData().opacity
		if opacityAmount and eff.FrameCount <= 10 then
			opacityAmount = opacityAmount * (0.1 * eff.FrameCount)
		end
		eff.Velocity = mod:Lerp(eff.Velocity, eff.Velocity:Resized(1), 0.07)
		if opacityAmount and eff.FrameCount > 40 then
			opacityAmount = opacityAmount * (0.9^(eff.FrameCount - 40))
			if eff.FrameCount > 120 or opacityAmount < 0.001 then
				eff:Remove()
			end
		end
		eff.Color = Color(eff.Color.R,eff.Color.G,eff.Color.B,opacityAmount, eff.Color.RO, eff.Color.GO, eff.Color.BO)
	end
end, 138)

--Storage Battery
function mod:useStorageBattery(card, player, useFlags)
	if (useFlags & UseFlag.USE_OWNED == 0) then return end

	local playersItem = player:GetActiveItem()
	local playersPocketItem = player:GetActiveItem(2)
	local toset = ActiveSlot.SLOT_PRIMARY

	if playersItem == 0 and playersPocketItem ~= 0 then --If player has no active but has pocket active
	 toset = 2
	 playersItem = playersPocketItem
	elseif playersItem ~= 0 and playersPocketItem ~= 0 and player:GetActiveCharge(toset) == 0 then --Has Active and Pocket, but Active is not charged.
	 toset = 2
	 playersItem = playersPocketItem
	end

	local baseCharge = player:GetActiveCharge(toset)
	local overcharge = player:GetBatteryCharge(toset)
	local itemCharge = baseCharge+overcharge
	if card == Card.STORAGE_BATTERY_0 then
		if playersItem == 0 and toset == 0 then
		player:AddCard(Card.STORAGE_BATTERY_0)
		elseif Isaac.GetItemConfig():GetCollectible(playersItem).ChargeType ~= 0 then
		player:AddCard(Card.STORAGE_BATTERY_0)
		elseif itemCharge == 0 then
		player:AddCard(Card.STORAGE_BATTERY_0)
		elseif itemCharge == 1 then
		 player:AddCard(Card.STORAGE_BATTERY_1)
		 player:SetActiveCharge(itemCharge-1,toset)
		elseif itemCharge == 2 then
		 player:AddCard(Card.STORAGE_BATTERY_2)
		 player:SetActiveCharge(itemCharge-2,toset)
		elseif itemCharge >= 3 then
		 player:AddCard(Card.STORAGE_BATTERY_3)
		 player:SetActiveCharge(itemCharge-3,toset)
		end
		SFXManager():Play(SoundEffect.SOUND_BEEP,1,1,false,2)
	elseif card == Card.STORAGE_BATTERY_1 then
		--Checks Avaliable Slot
		 if playersItem == 0 and playersPocketItem ~= 0 then --If player has no active but has pocket active
			toset = 2
		elseif playersItem ~= 0 and playersPocketItem ~= 0 and player:GetActiveCharge(0) == 0 then --Has Active and Pocket, but Active is not charged.
			toset = 0
		end
		baseCharge = player:GetActiveCharge(toset)
		overcharge = player:GetBatteryCharge(toset)
		itemCharge = baseCharge+overcharge

		 player:AddCard(Card.STORAGE_BATTERY_0)
		 player:SetActiveCharge(itemCharge+1,toset)
		 SFXManager():Play(SoundEffect.SOUND_BATTERYCHARGE,1,1,false,1.5)
		 
		 --Timed Item
         if Isaac.GetItemConfig():GetCollectible(playersItem).ChargeType == 1 then
          if player:GetActiveCharge(toset) ~= Isaac.GetItemConfig():GetCollectible(playersItem).MaxCharges then
		   player:SetActiveCharge(Isaac.GetItemConfig():GetCollectible(playersItem).MaxCharges,toset)
		  else
		   player:SetActiveCharge(Isaac.GetItemConfig():GetCollectible(playersItem).MaxCharges+Isaac.GetItemConfig():GetCollectible(playersItem).MaxCharges,toset)
		  end
         end
		 
		 local e = Isaac.Spawn(1000, 48, 0, player.Position+Vector(0,-50), nilvector, nil)
	elseif card == Card.STORAGE_BATTERY_2 then
		--Checks Avaliable Slot
		 if playersItem == 0 and playersPocketItem ~= 0 then --If player has no active but has pocket active
			toset = 2
		elseif playersItem ~= 0 and playersPocketItem ~= 0 and player:GetActiveCharge(0) == 0 then --Has Active and Pocket, but Active is not charged.
			toset = 0
		end
		baseCharge = player:GetActiveCharge(toset)
		overcharge = player:GetBatteryCharge(toset)
		itemCharge = baseCharge+overcharge

		 player:AddCard(Card.STORAGE_BATTERY_0)
		 player:SetActiveCharge(itemCharge+2,toset)
		 SFXManager():Play(SoundEffect.SOUND_BATTERYCHARGE,1,1,false,1.5)
		 
		 --Timed Item
         if Isaac.GetItemConfig():GetCollectible(playersItem).ChargeType == 1 then
          if player:GetActiveCharge(toset) ~= Isaac.GetItemConfig():GetCollectible(playersItem).MaxCharges then
		   player:SetActiveCharge(Isaac.GetItemConfig():GetCollectible(playersItem).MaxCharges,toset)
		  else
		   player:SetActiveCharge(Isaac.GetItemConfig():GetCollectible(playersItem).MaxCharges+Isaac.GetItemConfig():GetCollectible(playersItem).MaxCharges,toset)
		  end
         end
		 
		 local e = Isaac.Spawn(1000, 48, 0, player.Position+Vector(0,-50), nilvector, nil)
	elseif card == Card.STORAGE_BATTERY_3 then
		--Checks Avaliable Slot
		 if playersItem == 0 and playersPocketItem ~= 0 then --If player has no active but has pocket active
			toset = 2
		elseif playersItem ~= 0 and playersPocketItem ~= 0 and player:GetActiveCharge(0) == 0 then --Has Active and Pocket, but Active is not charged.
			toset = 0
		end
		baseCharge = player:GetActiveCharge(toset)
		overcharge = player:GetBatteryCharge(toset)
		itemCharge = baseCharge+overcharge

		 player:AddCard(Card.STORAGE_BATTERY_0)
		 player:SetActiveCharge(itemCharge+3,toset)
		 SFXManager():Play(SoundEffect.SOUND_BATTERYCHARGE,1,1,false,1.5)
		 
		 --Timed Item
         if Isaac.GetItemConfig():GetCollectible(playersItem).ChargeType == 1 then
          if player:GetActiveCharge(toset) ~= Isaac.GetItemConfig():GetCollectible(playersItem).MaxCharges then
		   player:SetActiveCharge(Isaac.GetItemConfig():GetCollectible(playersItem).MaxCharges,toset)
		  else
		   player:SetActiveCharge(Isaac.GetItemConfig():GetCollectible(playersItem).MaxCharges+Isaac.GetItemConfig():GetCollectible(playersItem).MaxCharges,toset)
		  end
         end
		 
		 local e = Isaac.Spawn(1000, 48, 0, player.Position+Vector(0,-50), nilvector, nil)
	elseif card == Card.CORRODED_BATTERY_0 then
		if playersItem == 0 then
		player:AddCard(Card.CORRODED_BATTERY_0)
		elseif Isaac.GetItemConfig():GetCollectible(playersItem).ChargeType ~= 0 then
		player:AddCard(Card.CORRODED_BATTERY_0)
		elseif itemCharge == 0 then
		player:AddCard(Card.CORRODED_BATTERY_0)
		elseif itemCharge == 1 then
		 player:AddCard(Card.CORRODED_BATTERY_1)
		 player:SetActiveCharge(itemCharge-1,toset)
		elseif itemCharge == 2 then
		 player:AddCard(Card.CORRODED_BATTERY_2)
		 player:SetActiveCharge(itemCharge-2,toset)
		elseif itemCharge >= 3 then
		 player:AddCard(Card.CORRODED_BATTERY_3)
		 player:SetActiveCharge(itemCharge-3,toset)
		end
		SFXManager():Play(SoundEffect.SOUND_EDEN_GLITCH, 1, 0, false, 1)
	elseif card == Card.CORRODED_BATTERY_1 then
		--Checks Avaliable Slot
		 if playersItem == 0 and playersPocketItem ~= 0 then --If player has no active but has pocket active
			toset = 2
		elseif playersItem ~= 0 and playersPocketItem ~= 0 and player:GetActiveCharge(0) == 0 then --Has Active and Pocket, but Active is not charged.
			toset = 0
		end
		baseCharge = player:GetActiveCharge(toset)
		overcharge = player:GetBatteryCharge(toset)
		itemCharge = baseCharge+overcharge
		 
		 player:SetActiveCharge(itemCharge+1,toset)
		 SFXManager():Play(SoundEffect.SOUND_REDLIGHTNING_ZAP, 1, 0, false, 1)
		 SFXManager():Play(SoundEffect.SOUND_BATTERYCHARGE,1,1,false,1.5)
		 local e = Isaac.Spawn(6, 666, 0, player.Position+Vector(0,15), nilvector, nil)
		 local e = Isaac.Spawn(1000, 48, 0, player.Position+Vector(0,-50), nilvector, nil)
		 
		--Timed Item
         if Isaac.GetItemConfig():GetCollectible(playersItem).ChargeType == 1 then
          if player:GetActiveCharge(toset) ~= Isaac.GetItemConfig():GetCollectible(playersItem).MaxCharges then
		   player:SetActiveCharge(Isaac.GetItemConfig():GetCollectible(playersItem).MaxCharges,toset)
		  else
		   player:SetActiveCharge(Isaac.GetItemConfig():GetCollectible(playersItem).MaxCharges+Isaac.GetItemConfig():GetCollectible(playersItem).MaxCharges,toset)
		  end
         end
		 
	elseif card == Card.CORRODED_BATTERY_2 then
		--Checks Avaliable Slot
		 if playersItem == 0 and playersPocketItem ~= 0 then --If player has no active but has pocket active
			toset = 2
		elseif playersItem ~= 0 and playersPocketItem ~= 0 and player:GetActiveCharge(0) == 0 then --Has Active and Pocket, but Active is not charged.
			toset = 0
		end
		baseCharge = player:GetActiveCharge(toset)
		overcharge = player:GetBatteryCharge(toset)
		itemCharge = baseCharge+overcharge

		 player:SetActiveCharge(itemCharge+2,toset)
		 SFXManager():Play(SoundEffect.SOUND_REDLIGHTNING_ZAP, 1, 0, false, 1)
		 SFXManager():Play(SoundEffect.SOUND_BATTERYCHARGE,1,1,false,1.5)
		 local e = Isaac.Spawn(6, 666, 0, player.Position+Vector(0,15), nilvector, nil)
		 local e = Isaac.Spawn(1000, 48, 0, player.Position+Vector(0,-50), nilvector, nil)
		 
		 --Timed Item
         if Isaac.GetItemConfig():GetCollectible(playersItem).ChargeType == 1 then
          if player:GetActiveCharge(toset) ~= Isaac.GetItemConfig():GetCollectible(playersItem).MaxCharges then
		   player:SetActiveCharge(Isaac.GetItemConfig():GetCollectible(playersItem).MaxCharges,toset)
		  else
		   player:SetActiveCharge(Isaac.GetItemConfig():GetCollectible(playersItem).MaxCharges+Isaac.GetItemConfig():GetCollectible(playersItem).MaxCharges,toset)
		  end
         end
		 
	elseif card == Card.CORRODED_BATTERY_3 then
		--Checks Avaliable Slot
		 if playersItem == 0 and playersPocketItem ~= 0 then --If player has no active but has pocket active
			toset = 2
		elseif playersItem ~= 0 and playersPocketItem ~= 0 and player:GetActiveCharge(0) == 0 then --Has Active and Pocket, but Active is not charged.
			toset = 0
		end
		baseCharge = player:GetActiveCharge(toset)
		overcharge = player:GetBatteryCharge(toset)
		itemCharge = baseCharge+overcharge

		 player:SetActiveCharge(itemCharge+3,toset)
		 SFXManager():Play(SoundEffect.SOUND_REDLIGHTNING_ZAP, 1, 0, false, 1)
		 SFXManager():Play(SoundEffect.SOUND_BATTERYCHARGE,1,1,false,1.5)
		 local e = Isaac.Spawn(6, 666, 0, player.Position+Vector(0,15), nilvector, nil)
		 local e = Isaac.Spawn(1000, 48, 0, player.Position+Vector(0,-50), nilvector, nil)
		 
		 --Timed Item
         if Isaac.GetItemConfig():GetCollectible(playersItem).ChargeType == 1 then
          if player:GetActiveCharge(toset) ~= Isaac.GetItemConfig():GetCollectible(playersItem).MaxCharges then
		   player:SetActiveCharge(Isaac.GetItemConfig():GetCollectible(playersItem).MaxCharges,toset)
		  else
		   player:SetActiveCharge(Isaac.GetItemConfig():GetCollectible(playersItem).MaxCharges+Isaac.GetItemConfig():GetCollectible(playersItem).MaxCharges,toset)
		  end
         end
		 
	end

	for i = 0, 1 do
		local trinketHeld = player:GetTrinket(i)
		if trinketHeld == 79 then
			player:DropTrinket(player.Position,false)
			SFXManager():Play(SoundEffect.SOUND_THUMBS_DOWN,0.6,1,false,1.5)
		end
	end

	--[[for i = 0, 1 do
		local trinketHeld = player:GetTrinket(i)
		if trinketHeld == 79 then
			local batterytodelete = Isaac.FindByType(5,300,Card.STORAGE_BATTERY_0)
			for  _, v in pairs(batterytodelete) do
				batterytodelete[_]:Remove()
			end
		end
	end]]--

end
mod:AddCallback(ModCallbacks.MC_USE_CARD, mod.useStorageBattery, Card.STORAGE_BATTERY_0);
mod:AddCallback(ModCallbacks.MC_USE_CARD, mod.useStorageBattery, Card.STORAGE_BATTERY_1);
mod:AddCallback(ModCallbacks.MC_USE_CARD, mod.useStorageBattery, Card.STORAGE_BATTERY_2);
mod:AddCallback(ModCallbacks.MC_USE_CARD, mod.useStorageBattery, Card.STORAGE_BATTERY_3);
mod:AddCallback(ModCallbacks.MC_USE_CARD, mod.useStorageBattery, Card.CORRODED_BATTERY_0);
mod:AddCallback(ModCallbacks.MC_USE_CARD, mod.useStorageBattery, Card.CORRODED_BATTERY_1);
mod:AddCallback(ModCallbacks.MC_USE_CARD, mod.useStorageBattery, Card.CORRODED_BATTERY_2);
mod:AddCallback(ModCallbacks.MC_USE_CARD, mod.useStorageBattery, Card.CORRODED_BATTERY_3);

function mod.determineFuegoSpots()
	mod.fuegoSpawnPoints = {}
	if mod.fuegoSpawners then
		for i = 1, #mod.fuegoSpawners do
			--table.insert(mod.fuegoSpawnPoints, mod.fuegoSpawners[i])
			mod.fuegoSpawnPoints[mod.fuegoSpawners[i]] = true
		end
	end
	mod.fuegoSpawners = nil
end

function mod:OnNewRoom()
	--Clear loop sounds
	mod.stopLoopingSounds()

	--Custom drops for vanilla grids/alt rocks/pIss BUCKET
	if StageAPI then
		local room = game:GetRoom()
		local backdropType = room:GetBackdropType()
		if backdropType == 16 or backdropType == 17 or room:GetType() == RoomType.ROOM_DUNGEON then
			StageAPI.TemporarilyOverrideRockAltEffects()
		elseif mod.roomBackdrop == 9 then
			StageAPI.TemporarilyOverrideRockAltEffects()
		elseif mod.roomBackdrop == 10 then -- Morbus
			StageAPI.TemporarilyOverrideRockAltEffects()
		end
	end

	mod.RoomIndexOffsets = mod:GetRoomIndexOffsets()

	mod.FlickerspiritInRoom = false
	mod.eternalFlickerspiritInRoom = false
	mod.waitingEnemiesTriggered = false
	mod.momframes = false
	mod.secondphasestomp = false
	mod.momfleshframes = 0
	mod.momfleshbuffer = 10
	mod.comeconsecutivecheck = nil
	mod.comeconsecutivecheck2 = nil
	mod.smokingMulliganLocations = {} --Clear em all away
	mod.smokingMulliganTicks = nil
	mod.graterInRoom = false
	mod.graterCount = nil
	mod.GraterState = nil
	mod.thousandeyes = nil
	mod.ThousandEyesSpawned = nil
	mod.resetelitejon = nil
	mod.cursedGrimaceClones = 0
	mod.spookInRoom = nil
	mod.spookRecord = {}
	mod.spookrecordplayerstart = {}
	mod.spookJustKilledEnemy = nil
	mod.ghostLarriesKilled = 0
	mod.doneShowingModCompatWarning = true
	mod.crawlspaceMoosicks = false
	mod.RoomGrids = nil
	mod.downloadFailureCarded = nil
	mod.bullInRoom = nil
	mod.bullData = nil
	mod.petRocksKilled = nil
	mod.checkWeedy = false
	mod.SkipCardUsed = nil
	mod.RoomEntitiesCache = nil

	mod:FiendNewRoomStuff()
	mod:BossRoomFunTime()
	mod:backdropReplacer()
  mod:checkD12Rocks()
	--mod:gbfLogic() --Arg over
	mod:isDeliriumRoom()
	mod:spawnPersistents()
	mod:makeRamblinPoints()
	mod:resetCertainFamiliars()
	mod:removeDireChests()
	mod:moveToCentreForCertainBosses()
	mod:fleaSpawnLogic()
	mod.ExtraCrawlspaceGfx()
	mod.cirnoTime()
	mod.determineFuegoSpots()
	mod.animRespawn()
	mod:cancelScheduledFunctions()

	mod:challengeDadsHomePlus()
	mod:challengeTheRealJon()
end
mod:AddCallback(ModCallbacks.MC_POST_NEW_ROOM, mod.OnNewRoom)

mod:AddCallback(ModCallbacks.MC_POST_ENTITY_REMOVE, function(_, npc)
  if npc.Variant == 1 then
	local hosts = Isaac.FindByType(27, 0, 0, false, false)
	for _, h in ipairs(hosts) do
	  if h.FrameCount == 0 and npc.Position:Distance(h.Position) == 0 then
		local sprite = h:GetSprite()
		sprite:Load("gfx/enemies/grid hosts/host.anm2", false)
		sprite:ReplaceSpritesheet(1, "gfx/enemies/grid hosts/host_siren.png")
		sprite:LoadGraphics()
		h:GetData().ffGridHost = "siren.png"
		break
	  end
	end
  end
end, 904)

function mod.setHostGridGfx(host, backdrop)
  local hSprite
  if ((1<<7 | 1<<30) & backdrop) ~= 0 then hSprite = "depths.png"
  elseif ((1<<8) & backdrop) ~= 0 then hSprite = "necropolis.png"
  elseif ((1<<9) & backdrop) ~= 0 then hSprite = "dank.png"
  elseif ((1<<14) & backdrop) ~= 0 then hSprite = "sheol.png"
  elseif ((1<<33 | 1<<38 | 1<<40 | 1<<41 | 1<<42) & backdrop) ~= 0 then hSprite = "maus.png"
  elseif ((1<<39) & backdrop) ~= 0 then hSprite = "corpse_maus.png"
  elseif ((1<<47) & backdrop) ~= 0 then hSprite = "gehenna.png"
  end
  local sprite = host:GetSprite()
  sprite:Load("gfx/enemies/grid hosts/host.anm2", false)
  sprite:ReplaceSpritesheet(1, "gfx/enemies/grid hosts/host_" .. hSprite)
  sprite:LoadGraphics()
  host:GetData().ffGridHost = hSprite
end

mod:AddCallback(ModCallbacks.MC_POST_NPC_INIT, function(_, npc)
  if npc.Variant == 0 then
	if npc.SubType == 250 then
	  npc:GetData().ffGridHost = "hostlet.png"
	  return
	end
	local backdrop = 1<<(Game():GetRoom():GetBackdropType())
	local backdropFlags = 1<<7 | 1<<8 | 1<<9 | 1<<14 | 1<<30 | 1<<33 | 1<<38 | 1<<39 | 1<<40 | 1<<41 | 1<<42 | 1<<47
	--1<<7 depths  --1<<30 depths  --1<<8 necro  --1<<9 dank  --1<<14 sheol  --1<<33 maus  --1<<38 maus  --1<<40 maus  --1<<41 maus?  --1<<42 maus?  --1<<39 corpse  --1<<47 gehenna
	if (backdropFlags & backdrop) == 0 then return end
	local grid = Game():GetRoom():GetGridEntityFromPos(npc.Position)
	if not grid then return end
	if grid:GetType() == 6 and grid.State == 2 then
	  local pGrids = Isaac.FindByType(1000, 4, 0, false, false)
	  for _, p in ipairs(pGrids) do
		if p.FrameCount == 0 and npc.Position:Distance(p.Position) < 5 then
		  mod.setHostGridGfx(npc, backdrop)
		  break
		end
	  end
	end
  end
end, 27)

mod:AddCallback(ModCallbacks.MC_POST_ENTITY_REMOVE, function(_, tear)
  if (tear.Type == 2 and tear.Variant == 40) or (tear.Type == 9 and tear.Variant == 8) then
	local backdrop = 1<<(Game():GetRoom():GetBackdropType())
	local backdropFlags = 1<<7 | 1<<8 | 1<<9 | 1<<14 | 1<<30 | 1<<33 | 1<<38 | 1<<39 | 1<<40 | 1<<41 | 1<<42 | 1<<47
	if (backdropFlags & backdrop) == 0 then return end
	local hosts = Isaac.FindByType(27, 0, 0, false, false)
	for _, h in ipairs(hosts) do
	  if h.FrameCount == 0 and tear.Position:Distance(h.Position) == 0 then
		mod.setHostGridGfx(h, backdrop)
		break
	  end
	end
  end
end)

mod:AddCallback(ModCallbacks.MC_POST_EFFECT_UPDATE, function(_, eff)
  if eff.FrameCount == 1 and eff:GetSprite():GetFilename() == "gfx/002.040_thrown tear.anm2" then
	local hosts = Isaac.FindInRadius(eff.Position, 40, EntityPartition.ENEMY)
	local nearest
	local dist
	for _, h in pairs(hosts) do
	  if h.Type == 27 and h.Variant == 0 then
		if not nearest then
		  nearest = h
		  dist = h.Position:Distance(eff.Position)
		else
		  local distN = h.Position:Distance(eff.Position)
		  if distN < dist then
			nearest = h
			dist = distN
		  end
		end
	  end
	end
	if not nearest then return end
	local h = nearest
	if h:GetData().ffGridHost then
	  local sSprite = h:GetData().ffGridHost
	  local sprite = eff:GetSprite()
	  sprite:Load("gfx/enemies/grid hosts/thrown_specialrocks.anm2", false)
	  sprite:ReplaceSpritesheet(0, "gfx/enemies/grid hosts/thrown_specialrocks_" .. sSprite)
	  sprite:LoadGraphics()
	  sprite:Play("Rock1", true)
	  if not h:GetData().ffGridRedHost then
		h:GetData().ffGridRedHost = true
		local hSprite = h:GetSprite()
		local hAnm = hSprite:GetAnimation()
		local hNum = hSprite:GetFrame()
		local hFile = hSprite:GetFilename()
		if hFile == "gfx/enemies/jammed/hostlet.anm2" then
		  hSprite:ReplaceSpritesheet(1, "gfx/enemies/jammed/red_hostlet.png")
		  h:GetData().IsHostlet = true
		elseif hFile == "gfx/enemies/grid hosts/host.anm2" then
		  hSprite:ReplaceSpritesheet(1, "gfx/enemies/grid hosts/redhost_" .. sSprite)
		end
		hSprite:LoadGraphics()
		hSprite:Play(hAnm, true)
		for i=0, hNum do
		  hSprite:Update()
		end
		--hSprite:SetFrame(hAnm, hNum)
	  end
	end
  end
end, 136)
--[[
mod:AddCallback(ModCallbacks.MC_POST_CURSE_EVAL, function(_, mask) -- Bye-bye curse of maze
	return mask & ~ LevelCurse.CURSE_OF_MAZE
end)

mod:AddCallback(ModCallbacks.MC_GET_PILL_EFFECT, function(selectedEffect, colour)
	if selectedEffect == PillEffect.PILLEFFECT_QUESTIONMARK then
		return math.random(Isaac.GetPillEffectByName("Melatonin"), Isaac.GetPillEffectByName("Spider Unboxing"))
	end
end)
]]
-- for callbacks that need to run after everything else
local addedCallbacks = false
mod:AddCallback(ModCallbacks.MC_POST_NEW_LEVEL, function()
	if not addedCallbacks and
	   mod ~= nil and
	   mod.AddCacheCallback ~= nil and
	   mod.AddFireballGenDamageCallback ~= nil and
	   mod.AddModelRocketCallbacks ~= nil and
	   mod.AddCopperBombCallbacks ~= nil and
	   mod.AddMorbidChunkCallbacks ~= nil
	then
		mod:AddCacheCallback()
		mod:AddFireballGenDamageCallback()
		mod:AddModelRocketCallbacks()
		mod:AddCopperBombCallbacks()
		mod:AddMorbidChunkCallbacks()

		addedCallbacks = true
	end
end)
mod:AddCallback(ModCallbacks.MC_POST_RENDER, function()
	if not addedCallbacks and
	   mod ~= nil and
	   mod.AddCacheCallback ~= nil and
	   mod.AddFireballGenDamageCallback ~= nil and
	   mod.AddModelRocketCallbacks ~= nil and
	   mod.AddCopperBombCallbacks ~= nil and
	   mod.AddMorbidChunkCallbacks ~= nil
	then
		mod:AddCacheCallback()
		mod:AddFireballGenDamageCallback()
		mod:AddModelRocketCallbacks()
		mod:AddCopperBombCallbacks()
		mod:AddMorbidChunkCallbacks()

		addedCallbacks = true
	end
end)

LoadScripts({
	"ffscripts.controls",
	"ffscripts.customgrids",
	"ffscripts.puzzlelocks",
	"ffscripts.players.golem",
	"ffscripts.puzzlePiece",
	"ffscripts.extraSlots",
	"ffscripts.customhealth",
	"ffscripts.customTearVariants",
	"ffscripts.players.golem_subway",
	"ffscripts.blor.gutso",
	"ffscripts.blor.whispers",
	"ffscripts.critical_hit",
	"ffscripts.levelgen",
	"ffscripts.replacements",
	"ffscripts.alphacoin",
})

LoadScripts({
	"ffscripts.budj.main",
	"ffscripts.dead.main",
	"ffscripts.erfly.main",
	"ffscripts.ferrium.main",
	"ffscripts.taiga.main",
	"ffscripts.xalum.main",
	"ffscripts.snake.main",
	"ffscripts.statuses.main",
	"ffscripts.guwah.main",
	"ffscripts.sbody.main",
	"ffscripts.connor.main",
	"ffscripts.cake.main",
	"ffscripts.oroshibu.main",
	"ffscripts.julia.main",
	"ffscripts.jd.main"
})

--Some stuff needs to be loaded after everything else
LoadScripts({
	"ffscripts.modcompat.abl",
	"ffscripts.modcompat.enhancedbossbars",
})

FiendFolio.EnemyOnDeath.DeathAnims = {
	{ID = mod.FF.Tagbag.ID, Var = mod.FF.Tagbag.Var, CustomAnimFunc = mod.tagbagDeathAnim},
	{ID = mod.FF.FossilBoomFly.ID, Var = mod.FF.FossilBoomFly.Var, CustomAnimFunc = mod.fossilizedBoomFlyDeathAnim},
	{ID = mod.FF.Gunk.ID, Var = mod.FF.Gunk.Var, CustomAnimFunc = mod.gunkDeathAnim},
	{ID = mod.FF.Punk.ID, Var = mod.FF.Punk.Var, CustomAnimFunc = mod.gunkDeathAnim},
	{ID = mod.FF.Dogmeat.ID, Var = mod.FF.Dogmeat.Var, CustomAnimFunc = mod.erflyCustomDeathAnim},
	{ID = mod.FF.HeadHoncho.ID, Var = mod.FF.HeadHoncho.Var, CustomAnimFunc = mod.headHonchoDeathAnim},
	{ID = mod.FF.Gorger.ID, Var = mod.FF.Gorger.Var, Sub = 0, BasicAnimName = "Death"},
	{ID = mod.FF.Fishaac.ID, Var = mod.FF.Fishaac.Var, CustomAnimFunc = mod.fishaacDeathAnim},
	{ID = mod.FF.TDweller.ID, Var = mod.FF.TDweller.Var, CustomAnimFunc = mod.deepDwellerDeathAnim},
	{ID = mod.FF.Warden.ID, Var = mod.FF.Warden.Var, CustomAnimFunc = mod.erflyCustomDeathAnim},
	{ID = mod.FF.Carrier.ID, Var = mod.FF.Carrier.Var, CustomAnimFunc = mod.erflyCustomDeathAnim},
	{ID = mod.FF.MiniMinMin.ID, Var = mod.FF.MiniMinMin.Var, CustomAnimFunc = mod.miniMinDeathAnim},
	{ID = mod.FF.Tango.ID, Var = mod.FF.Tango.Var, BasicAnimName = "Death", DropsBeforeAnim = true},
	{ID = mod.FF.Blastcore.ID, Var = mod.FF.Blastcore.Var, CustomAnimFunc = mod.BlastcoreDeathAnim},
	{ID = mod.FF.Rufus.ID, Var = mod.FF.Rufus.Var, CustomAnimFunc = mod.RufusDeathAnim},
	{ID = mod.FF.Oralopede.ID, Var = mod.FF.Oralopede.Var, BasicAnimName = "Death", DropsBeforeAnim = true},
	{ID = mod.FF.Oralid.ID, Var = mod.FF.Oralid.Var, BasicAnimName = "Death", DropsBeforeAnim = true},
	{ID = mod.FF.Craterface.ID, Var = mod.FF.Craterface.Var, BasicAnimName = "Death"},
	{ID = mod.FF.Load.ID, Var = mod.FF.Load.Var, BasicAnimName = "death"},
	{ID = mod.FF.CornLoad.ID, Var = mod.FF.CornLoad.Var, BasicAnimName = "death"},
	{ID = mod.FF.Baro.ID, Var = mod.FF.Baro.Var, BasicAnimName = "Death"},
	{ID = mod.FF.Lez.ID, Var = mod.FF.Lez.Var, Sub = mod.FF.Lez.Sub, BasicAnimName = "Death", DropsBeforeAnim = true},
	{ID = mod.FF.Shi.ID, Var = mod.FF.Shi.Var, CustomAnimFunc = mod.shiDeathAnim},
	{ID = mod.FF.Nuchal.ID, Var = mod.FF.Nuchal.Var, CustomAnimFunc = mod.nuchalDeathAnim},
	{ID = mod.FF.MamaPooter.ID, Var = mod.FF.MamaPooter.Var, CustomAnimFunc = mod.mamaPooterDeathAnim},
	{ID = mod.FF.PsychoFly.ID, Var = mod.FF.PsychoFly.Var, CustomAnimFunc = mod.psychoFlyDeathAnim},
	{ID = mod.FF.ManicFly.ID, Var = mod.FF.ManicFly.Var, CustomAnimFunc = mod.manicFlyDeathAnim},
	{ID = mod.FF.Punted.ID, Var = mod.FF.Punted.Var, CustomAnimFunc = mod.puntedDeathAnim},
	{ID = mod.FF.Empath.ID, Var = mod.FF.Empath.Var, CustomAnimFunc = mod.empathDeathAnim},
	{ID = mod.FF.BubbleBat.ID, Var = mod.FF.BubbleBat.Var, CustomAnimFunc = mod.drownedFatDeathAnim},
	{ID = mod.FF.Drooler.ID, Var = mod.FF.Drooler.Var, CustomAnimFunc = mod.mukDeathAnim},
	{ID = mod.FF.Melty.ID, Var = mod.FF.Melty.Var, CustomAnimFunc = mod.meltyDeathAnim},
	{ID = mod.FF.DungeonMaster.ID, Var = mod.FF.DungeonMaster.Var, CustomAnimFunc = mod.DungeonMasterDeathAnim},
	{ID = mod.FF.Coconut.ID, Var = mod.FF.Coconut.Var, CustomAnimFunc = mod.CoconutDeathAnim},
	{ID = mod.FF.Fishy.ID, Var = mod.FF.Fishy.Var, Sub = 0, CustomAnimFunc = mod.FishyDeathAnim},
	{ID = mod.FF.Discy.ID, Var = mod.FF.Discy.Var, Sub = 0, CustomAnimFunc = mod.DiscyDeathAnim},
	{ID = mod.FF.DreadMaw.ID, Var = mod.FF.DreadMaw.Var, CustomAnimFunc = mod.dreadMawDeathAnim},
	{ID = mod.FF.Quack.ID, Var = mod.FF.Quack.Var, CustomAnimFunc = mod.QuackDeathAnim},
	{ID = mod.FF.CorruptedContusion.ID, Var = mod.FF.CorruptedContusion.Var, CustomAnimFunc = mod.corruptedContusionDeathAnim},
	{ID = mod.FF.CorruptedSuture.ID, Var = mod.FF.CorruptedSuture.Var, CustomAnimFunc = mod.corruptedSutureDeathAnim},
	{ID = mod.FF.CorruptedMonstro.ID, Var = mod.FF.CorruptedMonstro.Var, CustomAnimFunc = mod.corruptedMonstroDeathAnim},
	{ID = mod.FF.Steralis.ID, Var = mod.FF.Steralis.Var, CustomAnimFunc = mod.SteralisDeathAnim},
	{ID = mod.FF.Nematode.ID, Var = mod.FF.Nematode.Var, CustomAnimFunc = mod.nematodeDeathAnim},
	{ID = mod.FF.Chummer.ID, Var = mod.FF.Chummer.Var, Sub = 0, CustomAnimFunc = mod.chummerDeathAnim},
	{ID = mod.FF.Aleya.ID, Var = mod.FF.Aleya.Var, CustomAnimFunc = mod.AleyaDeathAnim},
	{ID = mod.FF.Whale.ID, Var = mod.FF.Whale.Var, Sub = 0, CustomAnimFunc = mod.whaleDeathAnim},
	{ID = mod.FF.Clam.ID, Var = mod.FF.Clam.Var, BasicAnimName = "Death"},
	{ID = mod.FF.Buckshot.ID, Var = mod.FF.Buckshot.Var, CustomAnimFunc = mod.BuckshotDeathAnim},
	{ID = mod.FF.Musk.ID, Var = mod.FF.Musk.Var, CustomAnimFunc = mod.mukDeathAnim},
	{ID = mod.FF.Plexus.ID, Var = mod.FF.Plexus.Var, BasicAnimName = "death"},
	{ID = mod.FF.Onlyfan.ID, Var = mod.FF.Onlyfan.Var, BasicAnimName = "Death!"},
}

FiendFolio.EnemyOnDeath.SkulltistEffects = {
	{ID = mod.FF.Tagbag.ID, Var = mod.FF.Tagbag.Var, EffectFunc = mod.tagbagDeathEffect},
	{ID = mod.FF.Gunk.ID, Var = mod.FF.Gunk.Var, EffectFunc = mod.gunkDeathEffect},
	{ID = mod.FF.Punk.ID, Var = mod.FF.Punk.Var, EffectFunc = mod.gunkDeathEffect},
	{ID = mod.FF.Dogmeat.ID, Var = mod.FF.Dogmeat.Var, EffectFunc = mod.dogmeatDeathEffect},
	{ID = mod.FF.HeadHoncho.ID, Var = mod.FF.HeadHoncho.Var, EffectFunc = mod.headHonchoDeathEffect},
	{ID = mod.FF.Carrier.ID, Var = mod.FF.Carrier.Var, EffectFunc = mod.carrierDeathEffect},
	{ID = mod.FF.MiniMinMin.ID, Var = mod.FF.MiniMinMin.Var, EffectFunc = mod.miniMinDeathEffect},
	{ID = mod.FF.MamaPooter.ID, Var = mod.FF.MamaPooter.Var, EffectFunc = mod.mamaPooterDeathEffect},
	{ID = mod.FF.Melty.ID, Var = mod.FF.Melty.Var, EffectFunc = mod.meltyDeathEffect},
	{ID = mod.FF.Empath.ID, Var = mod.FF.Empath.Var, EffectFunc = mod.empathDeathEffect},
	{ID = mod.FF.Coconut.ID, Var = mod.FF.Coconut.Var, EffectFunc = mod.CoconutDeathEffect},
	{ID = mod.FF.FossilBoomFly.ID, Var = mod.FF.FossilBoomFly.Var, EffectFunc = mod.fossilizedBoomFlyDeathEffect},
	{ID = mod.FF.DreadMaw.ID, Var = mod.FF.DreadMaw.Var, EffectFunc = mod.DreadMawDeathEffect},
	{ID = mod.FF.Blastcore.ID, Var = mod.FF.Blastcore.Var, EffectFunc = mod.BlastcoreDeathEffect},
	{ID = mod.FF.Rufus.ID, Var = mod.FF.Rufus.Var, EffectFunc = mod.RufusDeathEffect},
}
