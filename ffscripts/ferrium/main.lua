local fenemy = "ffscripts.ferrium.enemies."
local fitems = "ffscripts.ferrium.items."
local fgolem = "ffscripts.ferrium.items.golem."
FiendFolio.LoadScripts({
	--Standard enemies
	fenemy .. "benign",
	fenemy .. "dewdrop",
	fenemy .. "connipshit",
	fenemy .. "tango",
	fenemy .. "bellow",
	fenemy .. "floodface",
	fenemy .. "frowny",
	fenemy .. "psystalk",
	fenemy .. "crucible",
	fenemy .. "fount",
	fenemy .. "drillbit",
	fenemy .. "minimoon",
	fenemy .. "bladder",
	fenemy .. "heartbeat",
	fenemy .. "ignis",
	fenemy .. "globlet",
	fenemy .. "crotchety",
	fenemy .. "gabber",
	fenemy .. "stalagnaught",
	fenemy .. "antigolem",
	fenemy .. "torment",
	fenemy .. "zissuru",
	fenemy .. "wheezer",
	fenemy .. "gritty",
	fenemy .. "psyclopia",
	fenemy .. "peepisser",
	fenemy .. "brood",
	fenemy .. "alderman",
	fenemy .. "unshornz",
	fenemy .. "dreadmaw",
	--fenemy .. "bluemaw",
	fenemy .. "specturn",
	fenemy .. "quaker",
	fenemy .. "shaker",
	fenemy .. "brisket",
	fenemy .. "accursed",
	fenemy .. "shellmet",
	fenemy .. "nematode",
	fenemy .. "g_host",
	fenemy .. "skullcap",
	fenemy .. "chummer",
	fenemy .. "hangman",
	fenemy .. "slimer",
	fenemy .. "fracture",
	fenemy .. "congaskuzz",
	fenemy .. "ringskuzz",
	fenemy .. "flailer",
	fenemy .. "holywobbles",
	fenemy .. "firewhirl",
	fenemy .. "whale",
	fenemy .. "clam",
	fenemy .. "lunksack",
	fenemy .. "coloscope",
	fenemy .. "putrefatty",
	fenemy .. "musk",
	fenemy .. "spanky",
	fenemy .. "spiroll",
	fenemy .. "thwammy",
	fenemy .. "acolyte",
	fenemy .. "edema",
	
	--Vanilla variants
	fenemy .. "scowlcreep",
	fenemy .. "cellulitis",
	fenemy .. "floaty",
	fenemy .. "psychoknight",
	fenemy .. "seacucumber",
	fenemy .. "scopecreep",
	fenemy .. "grievance",
	fenemy .. "casted",
	
	--Jokes and Misc
	fenemy .. "mouse",
	fenemy .. "murasa",
	fenemy .. "k3miku",
	fenemy .. "waiting",
	fenemy .. "custommoter",
	fenemy .. "shadyhost",
	fenemy .. "mawmr",
	
	
	--Bosses
	"ffscripts.ferrium.bosses.warpzone",
	"ffscripts.ferrium.bosses.corruptedcontusion",
	"ffscripts.ferrium.bosses.corruptedsuture",
	"ffscripts.ferrium.bosses.corruptedlarry",
	"ffscripts.ferrium.bosses.corruptedmonstro",
	
	
	--Items
	fitems .. "autopsykit",
	fitems .. "fleacircus",
	fitems .. "spiregrowth",
	fitems .. "sharppenny",
	fitems .. "angryfaic",
	fitems .. "dicegoblin",
	fitems .. "pocketdice",
	fitems .. "cherrybomb",
	fitems .. "lockedshackle",
	fitems .. "astropulvis",
	
	fgolem .. "scentedrock",
	fgolem .. "arcaderock",
	fgolem .. "tintedheart",
	fgolem .. "warmgeode",
	fgolem .. "rosequartz",
	fgolem .. "hailstone",
	fgolem .. "ramblinopal",
	fgolem .. "chaingeode",
	fgolem .. "sanddollar",
	fgolem .. "fishfossil",
	fgolem .. "runicfossil",
	fgolem .. "saltlamp",
	fgolem .. "moltenslag",
	fgolem .. "cannedfossil",
	fgolem .. "sandstone",
	fgolem .. "fakerock",
	fgolem .. "citrinepulp",
	fgolem .. "bloodstone",
	fgolem .. "rustygeode",
	fgolem .. "fragmentedonyxgeode",
	fgolem .. "emeticantimony",
	fgolem .. "rockfromanabyss",
	fgolem .. "constantrockshooter",
	fgolem .. "robotrock",
	fgolem .. "rockcandy",
	fgolem .. "keystone",
	fgolem .. "meatslab",
	fgolem .. "sheeprock",
	fgolem .. "rebellionrock",
	fgolem .. "dadslegendarygoldenrock",
	fgolem .. "bedsheet",
	fgolem .. "fetalstone",
	fgolem .. "grimaces",
	fgolem .. "quantumgeode",
	fgolem .. "technologicalgeode",
	fgolem .. "buriedfossil",
	fgolem .. "focuscrystal",
	fgolem .. "trippyfossil",
	fgolem .. "maxsfossil",
	fgolem .. "bombsackfossil",
	fgolem .. "deathcapfossil",
	fgolem .. "explosivefossil",
	fgolem .. "oddlysmoothstone",
	fgolem .. "moonstone",
	fgolem .. "limestone",
	fgolem .. "carnalcarnelian",
	fgolem .. "rebarrock",
	fgolem .. "dogrockrock",
	fgolem .. "stalactite",
	fgolem .. "skuzzfossil",
	fgolem .. "shardofgolgotha",
	fgolem .. "petrifiedsock",
	fgolem .. "smokyquartz",
	fgolem .. "charcoal",
	fgolem .. "achillesrock",
	fgolem .. "rubbergeode",
	fgolem .. "valuefossil",
	fgolem .. "electrum",
	fgolem .. "purequartz",
	fgolem .. "amazonite",
	fgolem .. "starsapphire",
	fgolem .. "gravestone",
	fgolem .. "calzonegeode",
	fgolem .. "sandcastle",
	fgolem .. "guardedgarnet",
	fgolem .. "shamrock",
	fgolem .. "gaspocket",
	fgolem .. "coralfossil",
	fgolem .. "tipsygeode",
	fgolem .. "vinylgeode",
	fgolem .. "soapstone",
	fgolem .. "spiriturn",
	fgolem .. "necromanticfossil",
	fgolem .. "brainfossil",
	fgolem .. "sunshard",
	fgolem .. "steadfaststone",
	fgolem .. "insatiableapatite",
	fgolem .. "raistone",
	fgolem .. "orepenny",
	fgolem .. "prismaticgeode",
	fgolem .. "heavymetal",
	fgolem .. "grossular",
	fgolem .. "sulfurcrystal",
	fgolem .. "fractalgeode",
	fgolem .. "throwlomite",
	fgolem .. "hearthstone",
	fgolem .. "gmogeode",
	fgolem .. "magneticsand",
	fgolem .. "swallowedgeode",
	fgolem .. "leftfossil",
	fgolem .. "powerrock",
	fgolem .. "tigerseye",
	fgolem .. "smallerrock",
	fgolem .. "voodoogeode",
	fgolem .. "umbilicalgeode",
	fgolem .. "hiddenite",

	--Joke Items
	fitems .. "eternalclicker",
	fitems .. "d122",
	
	
	--Non Enemy Shenanigans
	"ffscripts.ferrium.misc.cellgame",
	"ffscripts.ferrium.misc.launchedStuff",
	"ffscripts.ferrium.misc.rockshadows"
})

local mod = FiendFolio
local game = Game()
local sfx = SFXManager()

mod.FerriumEffects = {
	[mod.FF.TangoAfterimage.Sub] = {
		Update = mod.tangoafterimageAI,
	},
	[mod.FF.TangoAfterimage2.Sub] = {
		Update = mod.tangoafterimageAI,
	},
	[mod.FF.MurasaAnchorTrail.Sub] = {
		Update = mod.anchorAfterimageAI,
	},
	[mod.FF.MurasaEffects.Sub] = {
		Update = mod.murasaEffects,
	},
	[mod.FF.PissDroplets.Sub] = {
		Update = mod.pissDropletsEffect,
	},
	[mod.FF.RoseQuartzShield.Sub] = {
		Update = mod.roseQuartzShieldEffect,
	},
	[mod.FF.SaltLampAura.Sub] = {
		Update = mod.saltLampAuraEffect,
	},
	[mod.FF.FocusCrystalRing.Sub] = {
		Update = mod.focusCrystalRingEffect,
	},
	[mod.FF.FocusCrystalPoof.Sub] = {
		Disappear = "bang"
	},
	[mod.FF.MaxFossilGhost.Sub] = {
		Update = mod.dogFossilEffect,
		--[[Disappear = mod.goAwayEffect,
		Animation = "ghosty"]]
	},
	[mod.FF.WarpZoneParticle.Sub] = {
		Update = mod.warpZoneParticleEffect,
	},
	[mod.FF.CharmHearts.Sub] = {
		Update = mod.charmHeartsEffect,
	},
	[mod.FF.GuardedGarnetShield.Sub] = {
		Update = mod.guardedGarnetShieldEffect,
	},
	[mod.FF.ShadowlessRockShadow.Sub] = {
		Update = mod.shadowlessRockShadowEffect,
	},
	[mod.FF.AstropulvisGhost.Sub] = {
		Update = mod.astropulvisGhostEffect,
		Init = mod.astropulvisGhostInit,
	},
	[mod.FF.HolyWobblesBeam.Sub] = {
		Update = mod.holyWobblesBeamEffect,
	},
	[mod.FF.LunksackNeedle.Sub] = {
		Update = mod.lunksackNeedleEffect,
	},
}

mod.FerriumEnemies = {
	[mod.FF.Benign.Var] = {
		Update = mod.benignAI,
		Hurt = mod.benignHurt,
	},
	[mod.FF.Dewdrop.Var] = {
		Update = mod.dewdropAI,
	},
	[mod.FF.Connipshit.Var] = {
		Update = mod.connipshitAI,
		Hurt = mod.connipshitHurt,
	},
	[mod.FF.Tango.Var] = {
		Update = mod.tangoAI,
		Death = mod.tangoDeath,
	},
	[mod.FF.Bellow.Var] = {
		Update = mod.bellowAI,
	},
	[mod.FF.Floodface.Var] = {
		Update = mod.floodfaceAI,
	},
	[mod.FF.Frowny.Var] = {
		Update = mod.frownyAI,
		Hurt = mod.frownyHurt,
	},
	[mod.FF.Psystalk.Var] = {
		Update = mod.psykerAI,
	},
	[mod.FF.Crucible.Var] = {
		Update = mod.crucibleAI,
		Hurt = mod.crucibleHurt,
		Coll = mod.crucibleColl,
	},
	[mod.FF.Fount.Var] = {
		--Update = mod.fountAI,
	},
	[mod.FF.Drillbit.Var] = {
		Update = mod.drillbitAI,
	},
	[mod.FF.Minimoon.Var] = {
		Update = mod.minimoonAI,
	},
	[mod.FF.Bladder.Var] = {
		Update = mod.bladderAI,
	},
	[mod.FF.Heartbeat.Var] = {
		Update = mod.heartbeatAI,
		Hurt = mod.heartbeatHurt,
	},
	[mod.FF.Ignis.Var] = {
		Update = mod.ignisAI,
	},
	[mod.FF.Globlet.Var] = {
		Update = mod.globletAI,
		Kill = mod.globletKill,
		Death = mod.globletDeath,
	},
	[mod.FF.Crotchety.Var] = {
		Update = mod.crotchetyAI,
		Hurt = mod.crotchetyHurt,
		Kill = mod.crotchetyKill,
		Death = mod.crotchetyDeath,
	},
	[mod.FF.Gabber.Var] = {
		Update = mod.gabberAI,
	},
	[mod.FF.Stalagnaught.Var] = {
		Update = mod.stalagnaughtAI,
	},
	[mod.FF.AntiGolem.Var] = {
		Update = mod.antiGolemAI,
		Hurt = mod.antiGolemHurt,
	},
	[mod.FF.Torment.Var] = {
		Update = mod.tormentAI,
	},
	[mod.FF.Zissuru.Var] = {
		Update = mod.zissuruAI,
	},
	[mod.FF.Wheezer.Var] = {
		Update = mod.wheezerAI,
		Hurt = mod.wheezerHurt,
	},
	[mod.FF.Gritty.Var] = {
		Update = mod.grittyAI,
		Hurt = mod.grittyHurt,
	},
	[mod.FF.Psyclopia.Var] = {
		Update = mod.psyclopiaAI,
	},
	[mod.FF.Peepisser.Var] = {
		Update = mod.peepisserAI,
		Hurt = mod.peepisserHurt,
	},
	[mod.FF.Brood.Var] = {
		Update = mod.broodAI,
	},
	[mod.FF.Alderman.Var] = {
		Update = mod.aldermanAI,
		Hurt = mod.aldermanHurt,
	},
	[mod.FF.Unshornz.Var] = {
		Update = mod.unshornzAI,
		Coll = mod.unshornzColl,
	},
	[mod.FF.DreadMaw.Var] = {
		Update = mod.dreadMawAI,
		Hurt = mod.dreadMawHurt,
	},
	--[[[mod.FF.BlueMaw.Var] = {
		Update = mod.blueConjoinedMawAI,
	},]]
	[mod.FF.Specturn.Var] = {
		Update = mod.specturnAI,
	},
	[mod.FF.Quaker.Var] = {
		Update = mod.quakerAI,
	},
	[mod.FF.Shaker.Var] = {
		Update = mod.shakerAI,
	},
	[mod.FF.Brisket.Var] = {
		Update = mod.brisketAI,
	},
	[mod.FF.Accursed.Var] = {
		Update = mod.accursedAI,
		Hurt = mod.accursedHurt,
	},
	[mod.FF.Murmur.Var] = {
		Update = mod.murmurAI,
		Coll = mod.murmurColl,
	},
	[mod.FF.Shellmet.Var] = {
		Update = mod.shellmetAI,
		Coll = mod.shellmetColl,
	},
	[mod.FF.Nematode.Var] = {
		Update = mod.nematodeAI,
		Hurt = mod.nematodeHurt,
	},
	[mod.FF.G_Host.Var] = {
		Update = mod.g_HostAI,
		Hurt = mod.g_HostHurt,
		Coll = mod.g_HostColl,
	},
	[mod.FF.Skullcap.Var] = {
		Update = mod.skullcapAI,
		Hurt = mod.skullcapHurt,
	},
	[mod.FF.Chummer.Var] = {
		Update = mod.chummerAI,
		Hurt = mod.chummerHurt,
	},
	[mod.FF.Hangman.Var] = {
		Update = mod.hangmanAI,
	},
	[mod.FF.Slimer.Var] = {
		Update = mod.slimerAI,
	},
	[mod.FF.Fracture.Var] = {
		Update = mod.fractureAI,
		Hurt = mod.fractureHurt,
	},
	[mod.FF.CongaSkuzz.Var] = {
		Update = mod.congaSkuzzAI,
	},
	[mod.FF.RingSkuzz.Var] = {
		Update = mod.ringSkuzzAI,
	},
	[mod.FF.FlailerBody.Var] = {
		Update = mod.flailerAI,
		Render = mod.flailerRender,
		Coll = mod.flailerColl,
	},
	[mod.FF.HolyWobbles.Var] = {
		Update = mod.holyWobblesAI,
	},
	[mod.FF.Firewhirl.Var] = {
		Update = mod.firewhirlAI,
	},
	[mod.FF.Whale.Var] = {
		Update = mod.whaleAI,
		Hurt = mod.whaleHurt,
	},
	[mod.FF.Clam.Var] = {
		Update = mod.clamAI,
		Hurt = mod.clamHurt,
	},
	[mod.FF.Lunksack.Var] = {
		Update = mod.lunksackAI,
	},
	[mod.FF.Coloscope.Var] = {
		Update = mod.coloscopeAI,
	},
	[mod.FF.Putrefatty.Var] = {
		Update = mod.putrefattyAI,
		Coll = mod.putrefattyColl,
	},
	[mod.FF.Musk.Var] = {
		Update = mod.muskAI,
	},
	[mod.FF.Spanky.Var] = {
		Update = mod.spankyAI,
		Coll = mod.spankyColl,
	},
	[mod.FF.Spiroll.Var] = {
		Update = mod.spirollAI,
		Coll = mod.spirollColl,
	},
	[mod.FF.Thwammy.Var] = {
		Update = mod.thwammyAI,
		Hurt = mod.thwammyHurt,
		Coll = mod.thwammyColl,
	},
	[mod.FF.Acolyte.Var] = {
		Update = mod.acolyteAI,
	},
	[mod.FF.Edema.Var] = {
		Update = mod.edemaAI,
	},
	[mod.FF.Redema.Var] = {
		Update = mod.edemaAI,
	},


	[mod.FF.Mouse.Var] = {
		Update = mod.mouseAI,
		Hurt = mod.mouseHurt,
	},
	[mod.FF.Murasa.Var] = {
		Update = mod.murasaAI,
		Hurt = mod.murasaHurt,
	},
	[mod.FF.MurasaAnchor.Var] = {
		Update = mod.murasaAnchorAI,
	},
	[mod.FF.K3Miku.Var] = {
		Update = mod.k3MikuAI,
	},
	[mod.FF.FerrWaiting.Var] = {
		Update = mod.ferrWaiting,
	},
	[mod.FF.PeeBucket.Var] = {
		Update = mod.peeBucketAI,
		Hurt = mod.peeBucketHurt,
		Coll = mod.peeBucketCollision,
	},
	[mod.FF.BuriedFossilCrack.Var] = {
		Update = mod.buriedFossilCrackUpdate,
	},
	[mod.FF.ChummerPathfinder.Var] = {
		Update = mod.chummerPathfinderAI,
		Hurt = mod.chummerPathfinderHurt,
	},
	[mod.FF.ShadyHost.Var] = {
		Update = mod.shadyHostAI,
		Hurt = mod.shadyHostHurt,
	},
	[mod.FF.MawMr.Var] = {
		Update = mod.mawMrUpdate,
		Render = mod.mawMrRender,
		Coll = mod.mawMrColl,
	},
	[mod.FF.MrPsychicMaw.Var] = {
		Update = mod.mrPsychicMawUpdate,
		Render = mod.mrPsychicMawRender,
		Coll = mod.mawMrColl,
	},
}

function mod.ferriumProj(v, d)
	mod.dewdropProj(v, d)
	mod.psykerProj(v, d)
	mod.scowlCreepProj(v, d)
	mod.ignisProj(v, d)
	mod.gabberProj(v, d)
	mod.murasaProj(v, d)
	mod.k3MikuProj(v, d)
	mod.psyclopiaProj(v, d)
	mod.peepisserProj(v, d)
	mod.broodProj(v, d)
	mod.dreadMawProj(v, d)
	--mod.blueMawProj(v, d)
	mod.shakerProj(v, d)
	mod.accursedProj(v, d)
	mod.warpZoneProj(v, d)
	mod.sutureShrapnelProj(v, d)
	mod.slimerProj(v, d)
	mod.ashSpawnProj(v, d)
	mod.shadyHostProj(v, d)
	mod.pointedProjectile(v, d)
	mod.coloscopeProj(v, d)
end

mod:AddCallback(ModCallbacks.MC_POST_ENTITY_REMOVE, function(_,proj1)
	local data = proj1:GetData()
	local proj = proj1:ToProjectile()
	mod.psyclopiaProjRemove(proj, data)
	mod.reheatedHostProj(proj, data)
end, 9)

function mod.ferriumProjColl(proj, npc, bool)
	local d = proj:GetData()
	mod.murasaProjColl(proj, d)
	--mod.psyclopiaProjColl(proj, d, npc)
	mod.peepisserProjColl(proj, d)
	mod.chaosCardProjColl(proj, npc)
end

function mod.ferriumTear(v, d)
	mod.fractalTear(v, d)
	mod.dontHitAbove(v, d)
end

mod.madeEternal = {}
mod.brisketPowder = {}
mod.activeZissurus = {}
mod.quantumGeodeTears = {}
mod.sutureRockSpawns = {}
mod.angryFaicedBosses = {}
mod.ringSkuzzGroups = {}
mod.astropulvisRocks = {}

--Rock breaking
mod.roomRockTable = {}
mod.roomRockPitTable = {}
mod.chainGeodeRocks = {}
mod.chainGeodeScheduled = {}
mod.fakeRockRocks = {}
mod.fakeRockRooms = {}
mod.gravestoneRocks = {}
mod.gasPocketRocks = {}
mod.powerRockRocks = {}
mod.smallerRockRocks = {}

function mod:refreshFerriumTables()
	mod.madeEternal = {}
	mod.brisketPowder = {}
	mod.activeZissurus = {}
	mod.setRockTable()
	mod.chainGeodeScheduled = {}
	mod.sutureRockSpawns = {}
	mod.angryFaicedBosses = {}
	mod.ringSkuzzGroups = {}
	mod.astropulvisRocks = {}
	mod.acolyteTelInfo = nil
end
mod:AddCallback(ModCallbacks.MC_PRE_ROOM_ENTITY_SPAWN, mod.refreshFerriumTables)

function mod:checkFerriumTables()
	for _, eternal in pairs(mod.madeEternal) do
        mod:madeEternalEnemies(eternal)
    end
	for _, brisket in pairs(mod.brisketPowder) do
		mod:spreadBrisketSeasoning(brisket)
	end
	for _, grid in pairs(mod.chainGeodeScheduled) do
		mod:chainGeodeDestroy(grid)
	end
	for _, grid in pairs(mod.sutureRockSpawns) do
		mod:sutureRockSpawn(grid)
	end
	for key, boss in pairs(mod.angryFaicedBosses) do
		mod:checkForAngryFaicDeath(boss, key)
	end
	for _, grid in pairs(mod.astropulvisRocks) do
		mod:astropulvisRockDestroy(grid)
	end
end
mod:AddCallback(ModCallbacks.MC_POST_UPDATE, mod.checkFerriumTables)

mod:AddCallback(ModCallbacks.MC_POST_PEFFECT_UPDATE, function(_, player)
	local data = player:GetData()
	
	mod:scentedRockUpdate(player)
	mod:hailstoneUpdate(player)
	mod:ramblinOpalUpdate(player, data)
	mod:warmGeodeUpdate(player, data)
	mod:chainGeodeUpdate(player)
	mod:saltLampUpdate(player, data)
	mod:moltenSlagUpdate(player)
	mod:fakeRockUpdate(player)
	mod:citrinePulpUpdate(player, data)
	mod:bloodstoneUpdate(player, data)
	mod:rustyGeodeUpdate(player, data)
	mod:emeticAntimonyUpdate(player, data)
	mod:robotRockUpdate(player, data)
	mod:rockCandyUpdate(player)
	mod:keystoneUpdate(player, data)
	mod:meatSlabUpdate(player, data)
	mod:dadsLegendaryGoldenRockSwap(player)
	mod:fetalStoneUpdate(player, data)
	mod:grimaceRockUpdate(player, data)
	mod:technologicalGeodeUpdate(player, data)
	mod:playFossilSound(player, data)
	mod:focusCrystalUpdate(player, data)
	mod:deathCapFossilReset(player)
	mod:limestoneUpdate(player)
	mod:carnalCarnelianUpdate(player)
	mod:dogrockrockUpdate(player, data)
	mod:stalactiteItemUpdate(player, data)
	mod:smokyQuartzUpdate(player, data)
	mod:achillesRockUpdate(player)
	mod:starSapphireUpdate(player, data)
	mod:gravestoneUpdate(player, data)
	mod:gasPocketUpdate(player, data)
	mod:coralFossilUpdate(player, data)
	mod:tipsyGeodeUpdate(player, data)
	mod:spiritUrnUpdate(player, data)
	mod:sunShardUpdate(player, data)
	mod:insatiableApatiteUpdate(player, data)
	mod:firewhirlPullUpdate(player, data)
	mod:prismaticGeodeUpdate(player, data)
	mod:heavyMetalUpdate(player, data)
	mod:grossularUpdate(player, data)
	mod:throwlomiteUpdate(player, data)
	mod:powerRockUpdate(player, data)
	mod:tigersEyeUpdate(player, data)
	mod:smallerRockUpdate(player, data)
	mod:thwammyPlayerUpdate(player, data)
	mod:voodooGeodeUpdate(player, data)
	mod:hiddeniteUpdate(player)

	if data.quantumTears then
		for key, tear in ipairs(data.quantumTears) do
			mod:quantumGeodeTearChecks(key, tear, player)
		end
	end
	
	mod:d122Update(player, data)
	mod:spireGrowthUpdate(player, data)
	mod:eternalClickerUpdate(player)

	--[[for _,grid in ipairs(mod.GetGridEntities()) do
		if grid:GetType() == GridEntityType.GRID_TELEPORTER then
			print(grid.State)
		end
	end]]
	
	--mod:marioMode(player)
	
	--[[local tempEffs = player:GetEffects()
	local tempEffects = player:GetEffects():GetEffectsList()
	for i=1,tempEffects.Size do
		local effect = tempEffects:Get(i-1)
		local item = effect.Item
		print(item.ID)
	end]]
end)

mod:AddCallback(ModCallbacks.MC_ENTITY_TAKE_DMG, function(_, ent, damage, flag, source)
	local player = ent:ToPlayer()
	local data = player:GetData()
	
	if mod:blockExplosiveTearDamage(player, damage, flag, source) == false then
		return false
	end
	--mod:roseQuartzDamage(player, damage, flag, source)
	mod:fishFossilDamage(player)
	mod:cannedFossilDamage(player)
	mod:tintedHeartDamage(player, damage, flag, source)
	mod:sandstoneDamage(player, damage, flag, source)
	mod:bloodstoneDamage(player)
	mod:rebellionRockDamage(player, damage, flag, source)
	mod:smokyQuartzHurt(player)
	mod:pureQuartzHurt(player, damage, flag)
	mod:gravestoneHurt(player, damage, flag)
	mod:shamrockHurt(player, flag, source)
	mod:soapStoneHurt(player)
	mod:swallowedGeodeHurt(player)
	mod:umbilicalGeodeHurt(player)
	
	if mod:heavyMetalHurt(player, flag, source) == false then
		return false
	end
	if mod:sandCastleHurt(player, flag, source) == false then
		return false
	end
	if mod:guardedGarnetHurt(player) == false then
		return false
	end
	if mod:steadfastStoneHurt(player, damage) == false then
		return false
	end
end, 1)

function mod:check114Hurt(npc, damage, flag, source)
	if mod.FerriumEnemies[npc.Variant] and mod.FerriumEnemies[npc.Variant].Hurt then
		return mod.FerriumEnemies[npc.Variant].Hurt(_,npc, damage, flag, source)
	end
end
mod:AddCallback(ModCallbacks.MC_ENTITY_TAKE_DMG, mod.check114Hurt, mod.FFID.Ferrium)

function mod:check114Kill(npc)
    if mod.FerriumEnemies[npc.Variant] and mod.FerriumEnemies[npc.Variant].Kill then
		mod.FerriumEnemies[npc.Variant].Kill(_,npc, npc.Variant)
	end
end
mod:AddCallback(ModCallbacks.MC_POST_ENTITY_KILL, mod.check114Kill, mod.FFID.Ferrium)

function mod:check114Death(npc)
	if mod.FerriumEnemies[npc.Variant] and mod.FerriumEnemies[npc.Variant].Death then
		mod.FerriumEnemies[npc.Variant].Death(_,npc, npc.Variant)
	end
end
mod:AddCallback(ModCallbacks.MC_POST_NPC_DEATH, mod.check114Death, mod.FFID.Ferrium)

function mod:check114(npc)
	if mod.FerriumEnemies[npc.Variant] and mod.FerriumEnemies[npc.Variant].Update then
		mod.FerriumEnemies[npc.Variant].Update(_, npc, npc.SubType, npc.Variant)
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.check114, mod.FFID.Ferrium)

function mod:check114Collision(npc, collider, bool)
	if mod.FerriumEnemies[npc.Variant] and mod.FerriumEnemies[npc.Variant].Coll then
		return mod.FerriumEnemies[npc.Variant].Coll(_, npc, collider, bool)
	end
end
mod:AddCallback(ModCallbacks.MC_PRE_NPC_COLLISION, mod.check114Collision, mod.FFID.Ferrium)

function mod:check114Render(npc, offset)
	if mod.FerriumEnemies[npc.Variant] and mod.FerriumEnemies[npc.Variant].Render then
		return mod.FerriumEnemies[npc.Variant].Render(_, npc, offset)
	end
end
mod:AddCallback(ModCallbacks.MC_POST_NPC_RENDER, mod.check114Render, mod.FFID.Ferrium)


function mod:checkEffect1750(npc)
	if mod.FerriumEffects[npc.SubType] and mod.FerriumEffects[npc.SubType].Update then
		mod.FerriumEffects[npc.SubType].Update(_, npc, npc.SubType, npc.Variant)
	end
	
	if mod.FerriumEffects[npc.SubType] and mod.FerriumEffects[npc.SubType].Disappear then
		mod:goAwayEffect(npc, mod.FerriumEffects[npc.SubType].Disappear)
	end
end
mod:AddCallback(ModCallbacks.MC_POST_EFFECT_UPDATE, mod.checkEffect1750, 1750)

function mod:checkEffectInit1750(effect)
	if mod.FerriumEffects[effect.SubType] and mod.FerriumEffects[effect.SubType].Init then
		mod.FerriumEffects[effect.SubType].Init(_, effect)
	end
end
mod:AddCallback(ModCallbacks.MC_POST_EFFECT_INIT, mod.checkEffectInit1750, 1750)

function mod:goAwayEffect(e, anim)
	local sprite = e:GetSprite()
	if sprite:IsFinished(anim) then
		e:Remove()
	end
end

function mod:ferriumPlayerOnNewRoom()
	for i = 1, game:GetNumPlayers() do
		local player = Isaac.GetPlayer(i-1)
		local data = player:GetData()
		
		if data.hangmanPositions then
			data.hangmanPositions = nil
		end
		if data.belialD122 then
			data.belialD122 = nil
			player:AddCacheFlags(CacheFlag.CACHE_DAMAGE)
   			player:EvaluateItems()
		end
		mod:spiritUrnNewRoom(player)
		mod:sunShardNewRoom(player, data)
		mod:sulfurCrystalNewRoom(player, data)
		mod:voodooGeodeNewRoom(player, data)
		mod:umbilicalGeodeNewRoom(player)
	end
	mod:angryFaicNewRoom()
	mod:buriedFossilNewRoom()
	mod:maxFossilNewRoom()
	mod:moonstoneNewRoom()
	mod:quantumGeodeNewRoom()
	mod:rockFromAnAbyssNewRoom()
	mod:shardOfGolgothaNewRoom()
	mod:skuzzFossilNewRoom()
end
mod:AddCallback(ModCallbacks.MC_POST_NEW_ROOM, mod.ferriumPlayerOnNewRoom)

function mod:ferriumPlayerOnNewLevel()
	for i = 1, game:GetNumPlayers() do
		local player = Isaac.GetPlayer(i - 1)
		local data = player:GetData()
		mod:diceGoblinNewLevel(player)
		mod:pocketDiceNewLevel(player)
		mod:voodooGeodeNewLevel(player, data)
	end
	mod:buriedFossilNewLevel()
	mod:amazoniteNewLevel()
	mod:bedsheetNewLevel()
	mod:fakeRockNewLevel()
	mod:keystoneNewLevel()
	mod:moonstoneNewLevel()
	mod:saltLampNewLevel()
	mod:shamrockNewLevel()
	mod:vinylGeodeNewLevel()
end
mod:AddCallback(ModCallbacks.MC_POST_NEW_LEVEL, mod.ferriumPlayerOnNewLevel)

function mod:ferriumPlayerInit(player, data, continue)
	if continue then
		mod:emeticAntimonyWispCheck(player, data)
	end
end

function mod:ferriumOnFireTear(player, tear, secondHandMultiplier, isLudo, ignorePlayerEffects)
	mod:sandstoneOnFireTear(player, tear, secondHandMultiplier)
	mod:fragmentedOnyxOnFireTear(player, tear, secondHandMultiplier)
	mod:rockCandyOnFireTear(player, tear, secondHandMultiplier)
	mod:sheepRockOnFireTear(player, tear, secondHandMultiplier)
	mod:trippyFossilOnFireTear(player, tear, secondHandMultiplier)
	mod:petrifiedSockOnFireTear(player, tear, secondHandMultiplier)
	mod:rubberGeodeOnFireTear(player, tear, secondHandMultiplier)
	mod:brainFossilOnFireTear(player, tear)
	
	mod:charcoalOnFireTear(player, tear)
	
	if player:HasTrinket(FiendFolio.ITEM.ROCK.COLOSSAL_FOSSIL) then
		if not tear:GetData().AppliedColossalFossil then
			tear.Scale = tear.Scale*2
			tear:GetData().AppliedColossalFossil = true
		end
	end

	if player:GetData().warmGeodeBonus == 2 then
		tear:AddTearFlags(TearFlags.TEAR_BURN)
		tear:Update()
	end
	
	if player:HasTrinket(FiendFolio.ITEM.ROCK.CITRINE_PULP) and
	   not ignorePlayerEffects
	then
		local dir = nil
		if isLudo and not game:GetRoom():IsClear() then
			dir = tear.Position - player.Position
		elseif not isLudo and tear.CanTriggerStreakEnd then
			dir = tear.Velocity
		end
		if dir ~= nil then mod:fireCitrine(player, dir) end
	end
	
	mod:calzoneGeodeOnFireTear(player, tear, secondHandMultiplier, isLudo, ignorePlayerEffects)
	mod:coralFossilOnFireTear(player)
	mod:fractalGeodeOnFireTear(player, tear, secondHandMultiplier, isLudo, ignorePlayerEffects)
	mod:magneticSandOnFireTear(player, tear, secondHandMultiplier, isLudo, ignorePlayerEffects)
	
	if not isLudo then
		mod:quantumGeodeOnFireTear(player, tear)
	end
	
	if player:GetData().emeticAntimonyReady then
		player:GetData().emeticAntimonyReady = false
	end
end

function mod:ferriumOnFireLaser(player, laser)
	if player:HasTrinket(FiendFolio.ITEM.ROCK.CITRINE_PULP) then
		FiendFolio.scheduleForUpdate(function()
			local vec = Vector(10, 0)
			if laser.Velocity:Length() > 0 then
				vec = laser.Velocity:Resized(10)
			end

			mod:fireCitrine(player, vec:Rotated(laser.AngleDegrees))
		end, 1)
	end
	if player:GetData().emeticAntimonyReady then
		player:GetData().emeticAntimonyReady = false
	end
	mod:calzoneGeodeOnFireLaser(player, laser)
	mod:coralFossilOnFireLaser(player, laser)
end

function mod:ferriumOnFireKnife(player, knife)
	if player:HasTrinket(FiendFolio.ITEM.ROCK.CITRINE_PULP) then
		mod:fireCitrine(player, Vector(1,0):Rotated(knife.Rotation))
	end
	mod:calzoneGeodeOnFireKnife(player, knife)
	mod:coralFossilOnFireKnife(player, knife)
end

function mod:ferriumOnFireBomb(player, bomb, secondHandMultiplier)
	if player:HasTrinket(FiendFolio.ITEM.ROCK.CITRINE_PULP) then
		mod:fireCitrine(player, bomb.Velocity)
	end
	if player:GetData().emeticAntimonyReady then
		player:GetData().emeticAntimonyReady = false
	end
	mod:calzoneGeodeOnFireBomb(player, bomb)
	mod:coralFossilOnFireBomb(player, bomb)
	mod:fractalGeodeOnFireBomb(player, bomb, secondHandMultiplier)
	mod:sandstoneOnFireBomb(player, bomb, secondHandMultiplier)
	mod:fragmentedOnyxOnFireBomb(player, bomb, secondHandMultiplier)
	mod:rockCandyOnFireBomb(player, bomb, secondHandMultiplier)
	mod:sheepRockOnFireBomb(player, bomb, secondHandMultiplier)
	mod:trippyFossilOnFireBomb(player, bomb, secondHandMultiplier)
	mod:petrifiedSockOnFireBomb(player, bomb, secondHandMultiplier)
	mod:magneticSandOnFireBomb(player, bomb, secondHandMultiplier)
end

mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, function(_,npc)
	mod:starSapphireChecks(npc)
	mod:angryFaicNPCUpdate(npc)
	mod:fakeKnockbackEffect(npc)
end)

function mod:ferriumWisps(wisp)
	if wisp.SubType == FiendFolio.ITEM.COLLECTIBLE.CHERRY_BOMB then
		mod:cherryBombWisp(wisp)
	end
end
mod:AddCallback(ModCallbacks.MC_FAMILIAR_UPDATE, mod.ferriumWisps, FamiliarVariant.WISP)

--[[function mod:printEffects(npc)
	local sprite = npc:GetSprite()
	--fuck off decoration insects
	local blacklist = {[7] = true,[66] = true,[87] = true,[12] = true,[15] = true,[21] = true, [21343] = true, [68] = true, [33] = true, [2] = true}
	if blacklist[npc.Variant] == true then
	else
		print(npc.Variant)
	end
	--mod:PrintColor(npc:GetColor())
	--print(npc:GetSprite():GetFilename())
	if npc.TargetPosition then
		--print(npc.TargetPosition.X)
	end
end
mod:AddCallback(ModCallbacks.MC_POST_EFFECT_UPDATE, mod.printEffects)]]

--[[mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, function(_,npc)
	local sprite = npc:GetSprite()
	local data = npc:GetData()

	if npc.Variant == 20 then
		print(npc.V1)

		npc.V1 = Vector(0,-40)
	end
end, 831)]]

--[[mod:AddCallback(ModCallbacks.MC_POST_PROJECTILE_UPDATE, function(_, proj)
	local sprite = proj:GetSprite()
	local data = proj:GetData()
	--mod:PrintColor(proj.Color)

	print(sprite:GetAnimation())
end)]]

--[[function mod:printTears(npc)
	local sprite = npc:GetSprite()
	--print(npc.Variant)
	--mod:PrintColor(npc:GetColor())
	--print(npc:GetSprite():GetFilename())
end
mod:AddCallback(ModCallbacks.MC_POST_TEAR_UPDATE, mod.printTears)]]

--[[function mod:forTestStuffEnemies(npc)
	local data = npc:GetData()
	local sprite = npc:GetSprite()
	--print(npc.State)
	print(npc:GetEntityFlags())
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.forTestStuffEnemies)]]

--[[mod:AddCallback(ModCallbacks.MC_POST_TEAR_UPDATE, function(_, v)
	print(v:GetSprite():GetAnimation())
end)]]

--Checks Membrain/Mama Guts alts
function mod:checkMembrain(npc)
	if npc.Variant == 114 then -- Cellulitis
		mod:cellulitisAI(npc)
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkMembrain, 57)

--Checks Attack Fly alts
function mod:checkAttackFlyEnemy(npc)
	if npc.Variant == 114 then -- Custom Moter
		mod:customMoterAI(npc)
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkAttackFlyEnemy, 18)

--Singe's Balls
function mod:checkSingeBalls(npc)
	if npc.Variant == 1 then
		mod:singeBallsAI(npc)
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkSingeBalls, 915)

--Sub Horfs
function mod:checkSubHorfs(npc)
	if npc.Variant == 0 and npc.SubType == mod.FF.Floaty.Sub then -- Floaty
		mod:floatyAI(npc)
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkSubHorfs, 812)

--Knights
function mod:checkKnights(npc)
	if npc.Variant == mod.FF.PsychoKnight.Var then -- PsychoKnight
		mod:psychoKnightAI(npc)
	end
end
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, mod.checkKnights, 41)

--Modified random valid path function to get random enemies closer to Isaac, or further away
function mod:FindClosestValidPosition(npc, target, avoidplayer, range, mode, ignorepoops)
local validPosition = nil
local pathfinder = npc.Pathfinder
local room = game:GetRoom()
local size = room:GetGridSize()
local radius = nil
range = range or 120
ignorepoops = ignorepoops or false
mode = mode or 0
if mode == 0 then
	radius = 9999
else
	radius = 0
end
local playertable = {}
	if avoidplayer then
		for _, entity in ipairs(Isaac.GetRoomEntities()) do
			if entity.Type == 1 then
				table.insert(playertable, entity)
			end
		end
	end
	for i=0, size do
		local gridpos = room:GetGridPosition(i)
		local gridEntity = room:GetGridEntity(i)
		local farfromplayer = true
		if npc.Pathfinder:HasPathToPos(gridpos, ignorepoops) and (not gridEntity or gridEntity.CollisionClass == GridCollisionClass.COLLISION_NONE) then
			if avoidplayer then
				for k = 1, #playertable do
					if gridpos:Distance(playertable[k].Position) < avoidplayer then
						farfromplayer = false
					end
				end
			end
			if farfromplayer then
				if npc.Position:Distance(gridpos) < range then
					if mode == 0 then
						if target.Position:Distance(gridpos) < radius then
							validPosition = gridpos
							radius = target.Position:Distance(gridpos)
						end
					else
						if target.Position:Distance(gridpos) > radius then
							validPosition = gridpos
							radius = target.Position:Distance(gridpos)
						end
					end
				end
			end
		end
	end
	if validPosition ~= nil then
		return validPosition
	else
		return npc.Position
	end
end

function mod:FindClosestFreePosition(npc, target, avoidplayer, range, mode, ignorepoops)
local validPosition = nil
local pathfinder = npc.Pathfinder
local room = game:GetRoom()
local size = room:GetGridSize()
local radius = nil
range = range or 120
ignorepoops = ignorepoops or false
mode = mode or 0
if mode == 0 then
	radius = 9999
else
	radius = 0
end
local playertable = {}
	if avoidplayer then
		for _, entity in ipairs(Isaac.GetRoomEntities()) do
			if entity.Type == 1 then
				table.insert(playertable, entity)
			end
		end
	end
	for i=0, size do
		local gridpos = room:GetGridPosition(i)
		local gridEntity = room:GetGridEntity(i)
		local farfromplayer = true
		if not gridEntity or gridEntity.CollisionClass == GridCollisionClass.COLLISION_NONE then
			if avoidplayer then
				for k = 1, #playertable do
					if gridpos:Distance(playertable[k].Position) < avoidplayer then
						farfromplayer = false
					end
				end
			end
			if farfromplayer then
				if npc.Position:Distance(gridpos) < range then
					if mode == 0 then
						if target.Position:Distance(gridpos) < radius then
							validPosition = gridpos
							radius = target.Position:Distance(gridpos)
						end
					else
						if target.Position:Distance(gridpos) > radius then
							validPosition = gridpos
							radius = target.Position:Distance(gridpos)
						end
					end
				end
			end
		end
	end
	if validPosition ~= nil then
		return validPosition
	else
		return npc.Position
	end
end

function mod:compoundRoll(dropTable, seed, customRNG)
	local rng = RNG()
	if customRNG == nil then
		local usedSeed = seed or game:GetRoom():GetSpawnSeed()
		rng:SetSeed(usedSeed, 0)
	else
		rng = customRNG
	end

	local outcomes = {}
	for i = 1, #dropTable do
		local specificRoll = dropTable[i]
		if (mod:getRoll(1, 100, rng) <= specificRoll[3]) then
			table.insert(outcomes, mod:getRoll(specificRoll[1], specificRoll[2], rng))
		else
			table.insert(outcomes, -1)
		end
	end

	return outcomes
end

--Note, maximum needs to be larger than 
function mod:getRoll(minimum, maximum, rng)
	if rng == nil then
		local customRNG = RNG()
		customRNG:SetSeed(game:GetRoom():GetSpawnSeed(), 0)
		rng = customRNG
	end
	if minimum > maximum then
		local newMin = maximum
		maximum = minimum
		minimum = newMin
	end
	local fixedNum = maximum-minimum
	return rng:RandomInt(fixedNum)+1+minimum
end

function mod.throwShit(pos, vel, z_init, z_vel, spawner, state, countdown, damage) -- Shamelessly stealing the throw maggot code to see if it works cause I don't understand editing basegame stuff
	local rSpider
	local forceSplat
	local bounce
	if state == "coalSpider" then
		rSpider = Isaac.Spawn(818, 2, mod:RandomInt(1,3), pos, vel, spawner):ToNPC()
		forceSplat = mod.ColorFireJuicy
		bounce = z_vel*0.3
	elseif state == "rockSpider" then
		rSpider = Isaac.Spawn(818, 0, mod:RandomInt(1,3), pos, vel, spawner):ToNPC()
		bounce = z_vel*0.3
	elseif state == "coal" then
		rSpider = Isaac.Spawn(33, 11, mod:RandomInt(1,3), pos, vel, spawner):ToNPC()
		rSpider.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_WALLS
		forceSplat = mod.ColorFireJuicy
		bounce = z_vel*0.3
	elseif state == "redBomb" then
		rSpider = Isaac.Spawn(4, 13, 114, pos, vel, spawner):ToBomb()
		rSpider.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS
		rSpider.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_WALLS
		if countdown then
			rSpider:SetExplosionCountdown(countdown)
		end
		if damage then
			rSpider.ExplosionDamage = damage
		end
		rSpider.PositionOffset = Vector(0,z_init)
		rSpider.Parent = spawner
		rSpider:GetData().playerGrab = true
	elseif state == "rottenGaper" then
		local sType = countdown or 0
		rSpider = Isaac.Spawn(10, 3, sType, pos, vel, spawner):ToNPC()
	end
	
	if state ~= "redBomb" and state ~= "rottenGaper" then
		rSpider.State = 16
		rSpider:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
	elseif state == "rottenGaper" then
		rSpider:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
	end
	--rSpider.PositionOffset = Vector(0, z_init)

	local data = rSpider:GetData()
	--leaving this bit here since don't want to mess with the red bomb stuff
	data.isthrown = true
	data.z_vel = z_vel
	data.forcevel = vel
	if forceSplat then
		data.forceSplatColor = forceSplat
	end
	data.launchedEnemyInfo = {zVel = z_vel, height = z_init, collision = -30}
	data.launchedEnemyInfo.vel = vel
	if bounce then 
		data.launchedEnemyInfo.landFunc = function(npc, tab)
			data.launchedEnemyInfo = {zVel = bounce, vel = vel, landFunc = function() data.launchedEnemyInfo = {zVel = bounce*0.5, vel = vel*0.5} end}
		end
	end
	--data.launchedEnemyInfo.pos = true

	return rSpider
end

mod:AddCallback(ModCallbacks.MC_POST_BOMB_UPDATE, function(_, npc)
	local data = npc:GetData()
	if data.playerGrab then
		if data.isthrown and not data.pickedUp then
			if data.z_vel < 0 then
				npc.PositionOffset = Vector(0, npc.PositionOffset.Y + data.z_vel)
				data.z_vel = data.z_vel + 1
			end
		end
		if npc.PositionOffset.Y < 0 then
			npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS
			npc.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_WALLS
		else	
			data.pickedUp = nil
			npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS
			npc.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_GROUND
		end
	elseif data.antiGolem then
		if npc.Parent and not mod:isStatusCorpse(npc.Parent) then
			if npc.PositionOffset.Y > -30 and not data.up then
				npc.PositionOffset = mod:Lerp(npc.PositionOffset, Vector(0, -35), 0.6)
			else
				data.up = true
				npc.PositionOffset = Vector(0, -33)
			end
			
			npc.Position = npc.Parent.Position
			npc.Velocity = npc.Parent.Velocity
		end
	end
	if npc.SubType == 114 or data.antiGolem then
		data.timer = data.timer or 0
		data.timer = data.timer+1
		local player = Isaac.GetPlayer(0)
		if player:GetEffects():HasCollectibleEffect(CollectibleType.COLLECTIBLE_REMOTE_DETONATOR) then
			if data.antiGolem then
				npc.Parent:GetData().state = "Idle"
				npc.Parent:ToNPC().StateFrame = 0
			end
			npc:SetExplosionCountdown(0)
		elseif player:HasCollectible(CollectibleType.COLLECTIBLE_REMOTE_DETONATOR) then
			if data.timer > 10 then
				npc:SetExplosionCountdown(48)
				data.timer = 0
			end
		end
	end
end, 13)

--[[mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, function(_, npc)
	local data = npc:GetData()
	if data.isthrown then
		if data.z_vel < 0 then
			npc.PositionOffset = Vector(0, npc.PositionOffset.Y + data.z_vel)
			data.z_vel = data.z_vel + 1
			npc.Position = npc.Position + data.forcevel
		end
	end
end, 818)
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, function(_, npc)
	local data = npc:GetData()
	if data.isthrown then
		if data.z_vel < 0 then
			npc.PositionOffset = Vector(0, npc.PositionOffset.Y + data.z_vel)
			data.z_vel = data.z_vel + 1
			npc.Position = npc.Position + data.forcevel
		end
	end
end, 33)
mod:AddCallback(ModCallbacks.MC_NPC_UPDATE, function(_, npc)
	local data = npc:GetData()
	if data.isthrown then
		if npc.PositionOffset.Y < 0 or data.z_vel < 0 then
			npc.PositionOffset = Vector(0, npc.PositionOffset.Y + data.z_vel)
			data.z_vel = data.z_vel + 1
			npc.Position = npc.Position + data.forcevel
		end
	end
end, 10)]]

function mod:recalculateSpecturnOrbits(npcTable) --look, I'm just not even going to bother changing the names or anything
	local wires = {}

	local initialoffset
	for _, wire in pairs(npcTable) do
		if wire:Exists() and not (wire:IsDead() or mod:isStatusCorpse(wire) or mod:isLeavingStatusCorpse(wire)) then
			local wireD = wire:GetData()
			if wireD.Parent ~= nil then
				if #wires < 1 then
					table.insert(wires, wire)
				else
					for i = 1, #wires do
						if wireD.madeEternalOffset < wires[i]:GetData().madeEternalOffset then
							table.insert(wires, i, wire)
							break
						end
					end
					if wireD.madeEternalOffset > wires[#wires]:GetData().madeEternalOffset then
						table.insert(wires, wire)
					end
				end
			end
		end
	end

	if #wires > 0 then
		local initialoffset = wires[1]:GetData().madeEternalOffset
		local divnum = #wires

		for i = 1, divnum do
			wires[i]:GetData().madeEternalChangePlaces = initialoffset + (100/divnum) * (i - 1)
		end
	end
end

function mod:madeEternalEnemies(entry)
	local npc = entry.npc
	local d = npc:GetData()
	if npc.Parent and not mod:isStatusCorpse(npc.Parent) then
		local childReal = true
		local checkChildren
		if npc.Parent:GetData().specturnChildren == nil then
			childReal = false
		else
			checkChildren = npc.Parent:GetData().specturnChildren[d.specturnRing]
		end
		--[[local realLength = 0 --Okay, for some reason the length of the table is ignoring some when it's nil.
		for i = 1,#checkChildren do
			if checkChildren[i] ~= nil then
				realLength = realLength+1
			end
		end]]
		
		--[[if realLength ~= d.specturnCount then
			if realLength > 1 then
				for i=1,realLength do
					if i < d.specturnCount then
						if checkChildren[i] == nil then
							print(i .. " " .. d.specturnPosition)
							checkChildren[i] = npc
							checkChildren[d.specturnPosition] = nil
							d.specturnPosition = i
						end
					end
				end
				d.madeEternalChangePlaces = d.madeEternalOffset+(100/realLength)*d.specturnPosition
				--d.madeEternalOffset = (100/realLength)*d.specturnPosition
			end
			d.specturnCount = realLength
		end]]
		
		--npc:SetColor(Color(1-(1/d.specturnCount)*d.specturnPosition, 1-(1/d.specturnCount)*d.specturnPosition, 1-(1/d.specturnCount)*d.specturnPosition,1,50 / 255,50 / 255,50 / 255),15,1,true,false)
	
		npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS
		npc.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_NONE
		
		if d.madeEternalInvuln == true then
			npc:SetColor(Color(1.5,1.5,1.5,1,50 / 255,50 / 255,50 / 255),5,1,false,false)
			if mod.CanIComeOutYet() then
				d.isSpecturnInvuln = false
				npc.Color:Reset()
				d.madeEternalInvuln = false
			end
		end
		local target = npc.Parent.Position
		local frame = d.madeEternalOffset+(npc.FrameCount-2*npc.FrameCount*d.madeEternalDirection)
		
		if d.madeEternalChangePlaces ~= nil then
			d.madeEternalOffset = mod:Lerp(d.madeEternalOffset, d.madeEternalChangePlaces, 0.1)
			if math.abs(d.madeEternalOffset-d.madeEternalChangePlaces) < 1 then
				d.madeEternalOffset = d.madeEternalChangePlaces
				d.madeEternalChangePlaces = nil
			end
		end
		
		local distance = math.min(d.madeEternalInitialOffset+(npc.FrameCount)/3, d.madeEternalDistance)

		local xvel = math.cos((frame / 16) + math.pi) * (distance) * (d.madeEternalSpeed)
		local yvel = math.sin((frame / 16) + math.pi) * (distance) * (d.madeEternalSpeed)
		
		local pos = Vector(target.X - xvel, target.Y - yvel)

		local direction = Vector(target.X - xvel, target.Y - yvel) - npc.Position

		if direction:Length() > 50 then
			direction:Resize(50)
		end
		
		npc.Position = mod:Lerp(npc.Position, pos, 0.6)
		--npc.Velocity = direction
		npc.Velocity = mod:Lerp(npc.Velocity, direction, 0.6)
		
		if not d.madeEternalAppear and npc.FrameCount > 1 then
			local poof = Isaac.Spawn(1000, 15, 0, npc.Position, Vector.Zero, npc):ToEffect()
			poof:FollowParent(npc)
			poof.DepthOffset = npc.DepthOffset+1
			npc.Visible = true
			d.madeEternalAppear = true
		end
		
		if npc:IsDead() or mod:isLeavingStatusCorpse(npc) then
			if childReal == true then
				mod:recalculateSpecturnOrbits(checkChildren)
			end
			--checkChildren[d.specturnPosition] = nil
			npc.Parent = nil
		end
	else
		if d.madeEternalSpawn == true then
			npc.Color:Reset()
			npc.Parent = nil
			npc:ClearEntityFlags(EntityFlag.FLAG_NO_STATUS_EFFECTS | EntityFlag.FLAG_NO_TARGET)
			npc.EntityCollisionClass = d.madeEternalEntColl
			npc.GridCollisionClass = d.madeEternalGridColl
		else
			npc:Kill()
		end
		d.isSpecturnInvuln = false
		d.imEternal = false
		entry = nil
	end
end

function mod:makeEnemyEternal(npc, target, rotation, distance, makeInvuln, deathSpawn, initialOffset, speed, direction)
	local rand = npc:GetDropRNG()
	local data = npc:GetData()
	if makeInvuln == nil or makeInvuln == true then
		npc:AddEntityFlags(EntityFlag.FLAG_NO_STATUS_EFFECTS | EntityFlag.FLAG_NO_TARGET)
		makeInvuln = true
		data.isSpecturnInvuln = true
	end
	if deathSpawn == nil then
		deathSpawn = true
	end
	if initialOffset == nil then
		initialOffset = 0
	end
	data.madeEternalEntColl = npc.EntityCollisionClass
	data.madeEternalGridColl = npc.GridCollisionClass
	npc.EntityCollisionClass = EntityCollisionClass.ENTCOLL_PLAYEROBJECTS
	npc.GridCollisionClass = EntityGridCollisionClass.GRIDCOLL_NONE
	--npc:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
	npc.Parent = target
	data.madeEternalRotation = rotation or rand:RandomInt(75)
	data.madeEternalDistance = distance or 50
	data.madeEternalInitialOffset = initialOffset or 0
	data.madeEternalOffset = data.madeEternalRotation
	data.madeEternalDirection = direction or 0
	data.madeEternalSpeed = speed or 1
	data.madeEternalInvuln = makeInvuln
	data.madeEternalSpawn = deathSpawn
	data.imEternal = false
	data.removePoof = true
	npc.Visible = false
	
	--[[for _, poof in ipairs(Isaac.FindByType(1000, 15, -1, false, false)) do
		if poof.SpawnerType == npc.Type and poof.SpawnerVariant == npc.Variant and poof.Position:Distance(npc.Position) < 20 and poof.FrameCount < 2 then
			poof:Remove()
		end
	end]]
	
	table.insert(mod.madeEternal, {["npc"] = npc, ["target"] = target})
end

function mod:destroyTheDangPoof(effect)
	if effect.SpawnerEntity and effect.SpawnerEntity:GetData().removePoof == true then
		effect.Visible = false
		effect:Update()
		effect:Remove()
		effect.SpawnerEntity:GetData().removePoof = nil
	end
end
mod:AddCallback(ModCallbacks.MC_POST_EFFECT_INIT, mod.destroyTheDangPoof, 15)

function mod.setRockTable()
	mod.roomRockTable = {}
	mod.roomRockPitTable = {}
	mod.smallerRockRocks = {}
	local validTypes = {2, 4, 5, 6, 22, 25, 26, 27}
	for _,grid in ipairs(mod.GetGridEntities()) do
		if grid.CollisionClass == GridCollisionClass.COLLISION_SOLID then
			for i=1,#validTypes do
				if grid:GetType() == validTypes[i] then
					mod.roomRockTable[grid:GetGridIndex()] = validTypes[i]
					mod.roomRockPitTable[grid:GetGridIndex()] = validTypes[i]
				end
			end
			if grid:GetType() == GridEntityType.GRID_ROCKT then
				mod.smallerRockRocks[grid:GetGridIndex()] = 4
			end
		end
		if grid:GetType() == 7 and grid.State == 0 then
			mod.roomRockPitTable[grid:GetGridIndex()] = 7
		end
	end
	
	mod.chainGeodeRocks = mod.roomRockPitTable
	mod.fakeRockRocks = mod.roomRockTable
	mod.gravestoneRocks = mod.roomRockTable
	mod.gasPocketRocks = mod.roomRockTable
	mod.powerRockRocks = mod.roomRockTable
	return mod.roomRockTable
end

function mod:getSeveralDifferentNumbers(needed, totalAmount, customRNG, blacklist)
	local numTable = {}
	local results = {}
	for i=1,totalAmount do
		table.insert(numTable, i)
	end
	local rng = RNG()
	if customRNG == nil then
		rng:SetSeed(game:GetRoom():GetSpawnSeed(), 0)
	else
		rng = customRNG
	end
	
	if blacklist then
		for _,num in blacklist do
			table.remove(numTable, num)
		end
	end

	for i=1,needed do
		local roll = rng:RandomInt(#numTable)+1
		results[i] = numTable[roll]
		table.remove(numTable, roll)
	end
	return results
end

--[[mod:AddCallback(ModCallbacks.MC_INPUT_ACTION, function(_, entity, hook, buttonAction)
    local game = Game()
	if buttonAction ~= ButtonAction.ACTION_DROP then return end

    if hook ~= InputHook.IS_ACTION_TRIGGERED or game:IsPaused() then return end

    local player = entity and entity:ToPlayer()
    if not player then return end
	
	local controllerIndex = player.ControllerIndex
    local isDropping = Input.IsActionTriggered(buttonAction, controllerIndex)

    if not isDropping then return end
	
	local data = player:GetData()
	if not data.animatedTimes then
		data.animatedTimes = 0
	end
	data.animatedTimes = data.animatedTimes+1
	if data.animatedTimes > 10 then
		player:SetColor(Color(1,1,1,0,0,0,0), 999, 999, false, false)
		Isaac.Explode(player.Position, player, 0)
		for i=1,20 do
			Isaac.Spawn(1000, 5, 0, player.Position, RandomVector()*math.random(1,15), nil)
		end
		for i=1,5 do
			local smoke = Isaac.Spawn(EntityType.ENTITY_EFFECT, EffectVariant.DUST_CLOUD, 0, player.Position, RandomVector()*math.random(1,5), nil):ToEffect()
			smoke.Color = Color(158/255, 11/255, 15/255, 67/255, 0, 0, 0)
			smoke:SetTimeout(50 + math.random(15))
			smoke:Update()
		end
		player:Kill()
	end
	player:AnimateHappy()
end)]]

mod:AddCallback(ModCallbacks.MC_POST_PROJECTILE_UPDATE, function(_, proj)
	local sprite = proj:GetSprite()
	local data = proj:GetData()
	
	if data.projAnim then
		mod:spritePlay(sprite, data.projAnim)
	end
	
	if data.gridProjectile then
		if data.leaveCustomGrid then
			data.leaveCustomGrid.PersistentData.Destroyed = true
		end
		
		if proj:IsDead() then
			local game = Game()
			local room = game:GetRoom()
			local index = room:GetGridIndex(proj.Position)
			local sprite = proj:GetSprite()
			local anim = sprite:GetAnimation()
			local frame = sprite:GetFrame()
			local flipX = sprite.FlipX
			local dontSpawn = false
			if room:GetGridEntityFromPos(proj.Position) then
				local gridEnt = room:GetGridEntityFromPos(proj.Position)
				if gridEnt:GetType() == GridEntityType.GRID_SPIKES or gridEnt:GetType() == GridEntityType.GRID_PRESSURE_PLATE or gridEnt:GetType() == GridEntityType.GRID_TELEPORTER then
					dontSpawn = true
				end
			end

			if room:GetGridCollisionAtPos(proj.Position) == GridCollisionClass.COLLISION_NONE and data.leaveGrid ~= nil and not dontSpawn then
				proj.SubType = 0
				data.leavingGrid = true
				if data.leaveCustomGrid then
					--data.leaveCustomGrid.GridConfig:Spawn(index, false, false, data.leaveCustomGrid.PersistentData)
					if data.leaveCustomGrid.Data.Effect then
						if data.leaveCustomGrid.Data.Effect:Exists() then
							data.leaveCustomGrid.Data.Effect:Remove()
						end
				
						data.leaveCustomGrid.Data.Effect = nil
					end
					local newGrid = data.leaveCustomGrid.GridConfig:Spawn(index, false, false, nil)
					local gridEnt = room:GetGridEntity(index)
					if gridEnt then
						gridEnt:GetSprite():SetFrame(anim, frame)
						gridEnt:GetSprite().FlipX = flipX
						gridEnt.State = data.gridState
					end
					data.leaveCustomGrid:Remove(true)
				else
					Isaac.GridSpawn(data.leaveGrid[1], data.leaveGrid[2], proj.Position, true)
					local gridEnt = room:GetGridEntity(index)
					if gridEnt then
						gridEnt:GetSprite():SetFrame(anim, frame)
						gridEnt:GetSprite().FlipX = flipX
						gridEnt.State = data.gridState

						local gridType = gridEnt:GetType()
						if gridType < 7 or gridType == 22 or gridType == 25 or gridType == 26 or gridType == 27 then
							local roomgfx = mod:getCurrentRoomGfx()
							local backdropType = room:GetBackdropType()
							local rSprite = gridEnt:GetSprite()

							if data.d12 then
								if data.d12 == 1 then
									rSprite:ReplaceSpritesheet(0, "gfx/grid/rocks_d12.png")
								elseif data.d12 == 2 then
									rSprite:ReplaceSpritesheet(0, "gfx/grid/rocks_ed12.png")
								end
								rSprite:LoadGraphics()
							elseif roomgfx and roomgfx.Grids and roomgfx.Grids.Rocks then
								rSprite:ReplaceSpritesheet(0, roomgfx.Grids.Rocks)
								rSprite:LoadGraphics()
							elseif mod.backdropRockSpritesheets[backdropType] then
								rSprite:ReplaceSpritesheet(0, mod.backdropRockSpritesheets[backdropType])
								rSprite:LoadGraphics()
							end
						end
					end
				end
			elseif data.leaveCustomGrid then
				local Callbacks = require("scripts.stageapi.enums.Callbacks")
				data.leaveCustomGrid:CallCallbacks(Callbacks.POST_CUSTOM_GRID_DESTROY, proj)
			elseif data.specialGridDeath then
				data.specialGridDeath(proj)
			end
		end
	elseif data.enemyTurnedProjectile then
		if proj:IsDead() then
			local game = Game()
			local room = game:GetRoom()
			local index = room:GetGridIndex(proj.Position)
			
			if room:GetGridCollisionAtPos(proj.Position) == GridCollisionClass.COLLISION_NONE and data.leaveEnemy then
				local spawn = Isaac.Spawn(data.leaveEnemy.Type, data.leaveEnemy.Variant, data.leaveEnemy.SubType, room:GetGridPosition(room:GetGridIndex(proj.Position)), Vector.Zero, proj)
				spawn:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
				--spawn.State = data.enemyState
				spawn.HitPoints = data.hitPoints
				spawn:Update()
			elseif data.enemyProjDeath then
				data.enemyProjDeath(data.enemyProjEnt, proj)
			end
		end
	end
end, 8)

mod:AddCallback(ModCallbacks.MC_PRE_PROJECTILE_COLLISION, function(_, proj)
	local data = proj:GetData()
	if data.gridProjectile then
		if data.leaveCustomGrid then
			local Callbacks = require("scripts.stageapi.enums.Callbacks")
			data.leaveCustomGrid:CallCallbacks(Callbacks.POST_CUSTOM_GRID_DESTROY, proj)
		elseif data.specialGridDeath then
			data.specialGridDeath(proj)
		end
	elseif data.enemyTurnedProjectile then
		if data.enemyProjDeath then
			data.enemyProjDeath(data.enemyProjEnt, proj)
		end
	end
end, 8)

mod:AddCallback(ModCallbacks.MC_POST_TEAR_UPDATE, function(_, proj)
	local sprite = proj:GetSprite()
	local data = proj:GetData()
	
	if data.projAnim then
		mod:spritePlay(sprite, data.projAnim)
		if data.projAnimOverlay then
			mod:spriteOverlayPlay(sprite, data.projAnimOverlay)
		end
	end
	
	if data.gridProjectile then
		if data.leaveCustomGrid then
			data.leaveCustomGrid.PersistentData.Destroyed = true
		end
		
		if proj:IsDead() then
			local game = Game()
			local room = game:GetRoom()
			local index = room:GetGridIndex(proj.Position)
			local sprite = proj:GetSprite()
			local anim = sprite:GetAnimation()
			local frame = sprite:GetFrame()
			local flipX = sprite.FlipX
			local dontSpawn = false
			if room:GetGridEntityFromPos(proj.Position) then
				local gridEnt = room:GetGridEntityFromPos(proj.Position)
				if gridEnt:GetType() == GridEntityType.GRID_SPIKES or gridEnt:GetType() == GridEntityType.GRID_PRESSURE_PLATE or gridEnt:GetType() == GridEntityType.GRID_TELEPORTER then
					dontSpawn = true
				end
			end
			
			if room:GetGridCollisionAtPos(proj.Position) == GridCollisionClass.COLLISION_NONE and data.leaveGrid ~= nil and not dontSpawn then
				proj.SubType = 0
				data.leavingGrid = true
				if data.leaveCustomGrid then
					--data.leaveCustomGrid.GridConfig:Spawn(index, false, false, data.leaveCustomGrid.PersistentData)
					if data.leaveCustomGrid.Data.Effect then
						if data.leaveCustomGrid.Data.Effect:Exists() then
							data.leaveCustomGrid.Data.Effect:Remove()
						end
				
						data.leaveCustomGrid.Data.Effect = nil
					end
					local newGrid = data.leaveCustomGrid.GridConfig:Spawn(index, false, false, nil)
					local gridEnt = room:GetGridEntity(index)
					if gridEnt then
						gridEnt:GetSprite():SetFrame(anim, frame)
						gridEnt:GetSprite().FlipX = flipX
						gridEnt.State = data.gridState
					end
					data.leaveCustomGrid:Remove(true)
				else
					Isaac.GridSpawn(data.leaveGrid[1], data.leaveGrid[2], proj.Position, true)
					local gridEnt = room:GetGridEntity(index)
					if gridEnt then
						gridEnt:GetSprite():SetFrame(anim, frame)
						gridEnt:GetSprite().FlipX = flipX
						gridEnt.State = data.gridState

						local gridType = gridEnt:GetType()
						if gridType < 7 or gridType == 22 or gridType == 25 or gridType == 26 or gridType == 27 then
							local roomgfx = mod:getCurrentRoomGfx()
							local backdropType = room:GetBackdropType()
							local rSprite = gridEnt:GetSprite()

							if data.d12 then
								if data.d12 == 1 then
									rSprite:ReplaceSpritesheet(0, "gfx/grid/rocks_d12.png")
								elseif data.d12 == 2 then
									rSprite:ReplaceSpritesheet(0, "gfx/grid/rocks_ed12.png")
								end
								rSprite:LoadGraphics()
							elseif roomgfx and roomgfx.Grids and roomgfx.Grids.Rocks then
								rSprite:ReplaceSpritesheet(0, roomgfx.Grids.Rocks)
								rSprite:LoadGraphics()
							elseif mod.backdropRockSpritesheets[backdropType] then
								rSprite:ReplaceSpritesheet(0, mod.backdropRockSpritesheets[backdropType])
								rSprite:LoadGraphics()
							end
						end
					end
				end
			elseif data.leaveCustomGrid then
				local Callbacks = require("scripts.stageapi.enums.Callbacks")
				data.leaveCustomGrid:CallCallbacks(Callbacks.POST_CUSTOM_GRID_DESTROY, proj)
				--[[if data.d122Wisp then
					local wisp = Isaac.Spawn(3, FamiliarVariant.WISP, CollectibleType.COLLECTIBLE_D12_2, proj.Position, Vector.Zero, proj):ToFamiliar()
					wisp.Player = data.d122WispSpawner
				end]]
			elseif data.specialGridDeath then
				data.specialGridDeath(proj)
				--[[if data.d122Wisp then
					local wisp = Isaac.Spawn(3, FamiliarVariant.WISP, CollectibleType.COLLECTIBLE_D12_2, proj.Position, Vector.Zero, proj):ToFamiliar()
					wisp.Player = data.d122WispSpawner
				end]]
			end
		end
	elseif data.enemyTurnedProjectile then
		if proj:IsDead() then
			local game = Game()
			local room = game:GetRoom()
			local index = room:GetGridIndex(proj.Position)
			
			if room:GetGridCollisionAtPos(proj.Position) == GridCollisionClass.COLLISION_NONE and data.leaveEnemy then
				local spawn = Isaac.Spawn(data.leaveEnemy.Type, data.leaveEnemy.Variant, data.leaveEnemy.SubType, room:GetGridPosition(room:GetGridIndex(proj.Position)), Vector.Zero, proj)
				spawn:ClearEntityFlags(EntityFlag.FLAG_APPEAR)
				--spawn.State = data.enemyState
				spawn.HitPoints = data.hitPoints
				spawn:Update()
			elseif data.enemyProjDeath then
				data.enemyProjDeath(data.enemyProjEnt, proj)
			end
		end
	end
end, 40)

mod:AddCallback(ModCallbacks.MC_PRE_TEAR_COLLISION, function(_, proj)
	local data = proj:GetData()
	if data.gridProjectile then
		if data.leaveCustomGrid then
			local Callbacks = require("scripts.stageapi.enums.Callbacks")
			data.leaveCustomGrid:CallCallbacks(Callbacks.POST_CUSTOM_GRID_DESTROY, proj)
		elseif data.specialGridDeath then
			data.specialGridDeath(proj)
		end
	elseif data.enemyTurnedProjectile then
		if data.enemyProjDeath then
			data.enemyProjDeath(data.enemyProjEnt, proj)
		end
	end
end, 40)


--Decoration remover for removed grids
function mod:makeDecorInvisible(index)
	local data = FiendFolio.savedata.run
	local game = Game()
	local level = game:GetLevel()
	local currentRoom = level:GetCurrentRoomDesc().ListIndex
	
	if not data.invisibleDecor then
		data.invisibleDecor = {}
	end
	if data.invisibleDecor[currentRoom] == nil then
		data.invisibleDecor[currentRoom] = {}
	end
	table.insert(data.invisibleDecor[currentRoom], index)
end

function mod:makeRockForRoomOnly(index)
	local data = FiendFolio.savedata.run
	local game = Game()
	local level = game:GetLevel()
	local currentRoom = level:GetCurrentRoomDesc().ListIndex
	
	if not data.currentRoomTempRock then
		data.currentRoomTempRock = {}
	end
	if data.currentRoomTempRock[currentRoom] == nil then
		data.currentRoomTempRock[currentRoom] = {}
	end
	table.insert(data.currentRoomTempRock[currentRoom], index)
end

mod:AddCallback(ModCallbacks.MC_POST_NEW_LEVEL, function()
	local data = FiendFolio.savedata.run
	data.invisibleDecor = {}
	data.currentRoomTempRock = {}
end)

mod:AddCallback(ModCallbacks.MC_POST_NEW_ROOM, function()
	local data = FiendFolio.savedata.run
	local game = Game()
	local level = game:GetLevel()
	local room = game:GetRoom()
	if data.invisibleDecor then
		for list,rooms in pairs(data.invisibleDecor) do
			if level:GetCurrentRoomDesc().ListIndex == list then
				for key,index in pairs(rooms) do
					local deco = room:GetGridEntity(index)
					if deco and deco:GetType() == 1 then
						local sprite = deco:GetSprite()
						sprite:ReplaceSpritesheet(0, "gfx/nothing.png")
						sprite:LoadGraphics()
					else
						rooms[key] = nil
					end
				end
			end
		end
	end
	if data.currentRoomTempRock then
		for list,rooms in pairs(data.currentRoomTempRock) do
			if level:GetCurrentRoomDesc().ListIndex == list then
				for key,index in pairs(rooms) do
					local grid = room:GetGridEntity(index)
					if grid and grid.CollisionClass ~= GridCollisionClass.COLLISION_NONE then
						room:RemoveGridEntity(index, 0, false)
						FiendFolio.scheduleForUpdate(function()
							room:SpawnGridEntity(index, 1, 0, 0, 0)
							local newRock = room:GetGridEntity(index)
							local temp = newRock:GetSprite()
							temp:ReplaceSpritesheet(0, "gfx/nothing.png")
							temp:LoadGraphics()
							mod:makeDecorInvisible(index)
						end, 2)
					else
						rooms[key] = nil
					end
				end
			end
		end
	end
end)

--[[mod:AddCallback(ModCallbacks.MC_ENTITY_TAKE_DMG, function(_, ent, damage, flag, source)
	local player
	if source.Entity then
		player = source.Entity:ToPlayer()
	end
	if player then
		if player:HasCollectible(CollectibleType.COLLECTIBLE_MARS) then
			local tempEffects = player:GetEffects()
			if tempEffects:HasCollectibleEffect(CollectibleType.COLLECTIBLE_MARS) then
				local dir = (player.Velocity*0.6):Rotated(math.random(-20,20))
				local proj = mod:turnEntitytoProjectile(player, ent, dir, false, nil, nil, nil, nil, nil, function(e,p) local spawn = Isaac.Spawn(e.Type, e.Variant, e.SubType, room:GetGridPosition(room:GetGridIndex(p.Position)), Vector.Zero, p) spawn:AddEntityFlags(EntityFlag.FLAG_FRIENDLY | EntityFlag.FLAG_CHARM) spawn:Kill() end)
				if proj then
					proj.FallingSpeed = -math.random(5,10)
					proj.FallingAcceleration = 0.95
					SFXManager():Play(SoundEffect.SOUND_FORESTBOSS_STOMPS, 0.4, 0, false, 1.7)
				end
			end
		end
	end
end)]]

function mod:shuntedPosition(int, rng)
	local result
	if rng then
		result = Vector(mod:getRoll(-int, int, rng), mod:getRoll(-int, int, rng))
	else
		result = Vector(math.random(-int,int), math.random(-int,int))
	end
	return result
end

function mod:makeCopiedTable(original)
	local tab = {}
	for key,entry in pairs(original) do
		tab[key] = entry
	end
	return tab
end

function mod:adjustChildrenData(ent, tag, result)
	if ent.Child then
		local child = ent.Child
		while child do
			local data = child:GetData()
			data[tag] = result
			
			if child.Child and child.Child:Exists() then
				child = child.Child
			else
				child = nil
			end
		end
	end
end

function mod:updateToNPCPosition(npc, held, override, noUpdate)
	held.Position = (override or npc.Position)
	if npc.Index > held.Index and not noUpdate then
		held:Update()
	end
	held.Velocity = npc.Velocity
end